<div class="mb2 gray5">1 min read</div><img class="mr2" src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1kNmxuKi9KEGqihLmmWMLD/afc4ae72f1fc8469d2173ffb4b45951b/Feature_Image.png" alt="">
<div class="post-content lh-copy gray1">
	<p>Connecting to an application should be as simple as knowing its name. Yet, many security models still force us to rely on brittle, ever-changing IP addresses. And we heard from many of you that managing those ever-changing IP lists was a constant struggle.&nbsp;</p>
	<p>Today, we’re taking a major step toward making that a relic of the past.</p>
	<p>We're excited to announce that you can now route traffic to <a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-networks"><u>Cloudflare Tunnel</u></a> based on a hostname or a domain. This allows you to use Cloudflare Tunnel to build simple zero-trust and egress policies for your private and public web applications without ever needing to know their underlying IP. This is one more step on our <a href="https://blog.cloudflare.com/egress-policies-by-hostname"><u>mission</u></a> to strengthen platform-wide support for hostname- and domain-based policies in the <a href="https://developers.cloudflare.com/cloudflare-one"><u>Cloudflare One</u></a> SASE platform, simplifying complexity and improving security for our customers and end users.&nbsp;</p>
	<div class="flex anchor relative">
		<h2 id="grant-access-to-applications-not-networks">Grant access to applications, not networks</h2>
		<a href="https://blog.cloudflare.com/#grant-access-to-applications-not-networks" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>In August 2020, the National Institute of Standards (NIST) published <a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-207.pdf"><u>Special Publication 800-207</u></a>, encouraging organizations to abandon the "castle-and-moat" model of security (where trust is established on the basis of network location) and move to a Zero Trust model (where we “<a href="https://www.whitehouse.gov/wp-content/uploads/2022/01/M-22-09.pdf"><u>verify anything and everything attempting to establish access</u></a>").</p>
	<p>Now, instead of granting broad network permissions, you grant specific access to individual resources. This concept, known as per-resource authorization, is a cornerstone of the Zero Trust framework, and it presents a huge change to how organizations have traditionally run networks. Per-resource authorization requires that access policies be configured on a per-resource basis. By applying the principle of least privilege, you give users access only to the resources they absolutely need to do their job. This tightens security and shrinks the potential attack surface for any given resource.</p>
	<p>Instead of allowing your users to access an entire network segment, like <code><b>10.131.0.0/24</b></code>, your security policies become much more precise. For example:</p>
	<ul>
		<li>
			<p>Only employees in the "SRE" group running a managed device can access <code><b>admin.core-router3-sjc.acme.local</b></code>.</p>
		</li>
		<li>
			<p>Only employees in the "finance" group located in Canada can access <code><b>canada-payroll-server.acme.local</b></code>.</p>
		</li>
		<li>
			<p>All employees located in New York can access<b> </b><code><b>printer1.nyc.acme.local</b></code>.</p>
		</li>
	</ul>
	<p>Notice what these powerful, granular rules have in common? They’re all based on the resource’s private <b>hostname</b>, not its IP address. That’s exactly what our new hostname routing enables. We’ve made it dramatically easier to write effective zero trust policies using stable hostnames, without ever needing to know the underlying IP address.</p>
	<div class="flex anchor relative">
		<h2 id="why-ip-based-rules-break">Why IP-based rules break</h2>
		<a href="https://blog.cloudflare.com/#why-ip-based-rules-break" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Let's imagine you need to secure an internal server, <code><b>canada-payroll-server.acme.local</b></code>. It’s hosted on internal IP <code><b>10.4.4.4</b></code> and its hostname is available in internal private DNS, but not in public DNS. In a modern cloud environment, its IP address is often the least stable thing about it. If your security policy is tied to that IP, it's built on a shaky foundation.</p>
	<p>This happens for a few common reasons:</p>
	<ul>
		<li>
			<p><b>Cloud instances</b>: When you launch a compute instance in a cloud environment like AWS, you're responsible for its <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hostname-types.html"><u>hostname</u></a>, but not always its IP address. As a result, you might only be tracking the hostname and may not even know the server's IP.</p>
		</li>
		<li>
			<p><b>Load Balancers</b>: If the server is behind a load balancer in a cloud environment (like AWS ELB), its IP address could be changing dynamically in response to <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/application-load-balancers.html"><u>changes in traffic</u></a>.</p>
		</li>
		<li>
			<p><b>Ephemeral infrastructure</b>: This is the "<a href="https://cloudscaling.com/blog/cloud-computing/the-history-of-pets-vs-cattle"><u>cattle, not pets</u></a>" world of modern infrastructure. Resources like servers in an autoscaling group, containers in a Kubernetes cluster, or applications that spin down overnight are created and destroyed as needed. They keep a persistent hostname so users can find them, but their IP is ephemeral and changes every time they spin up.</p>
		</li>
	</ul>
	<p>To cope with this, we've seen customers build complex scripts to maintain dynamic "IP Lists" — mappings from a hostname to its IPs that are updated every time the address changes. While this approach is clever, maintaining IP Lists is a chore. They are brittle, and a single error could cause employees to lose access to vital resources.</p>
	<p>Fortunately, hostname-based routing makes this IP List workaround obsolete.</p>
	<div class="flex anchor relative">
		<h2 id="how-it-works-secure-a-private-server-by-hostname-using-cloudflare-one-sase-platform">How it works: secure a private server by hostname using Cloudflare One SASE platform</h2>
		<a href="https://blog.cloudflare.com/#how-it-works-secure-a-private-server-by-hostname-using-cloudflare-one-sase-platform" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>To see this in action, let's create a policy from our earlier example: we want to grant employees in the "finance" group located in Canada access to <code><b>canada-payroll-server.acme.local</b></code>. Here’s how you do it, without ever touching an IP address.</p>
	<p><b>Step 1: Connect your private network</b></p>
	<p>First, the server's network needs a secure connection to Cloudflare's global network. You do this by installing our lightweight agent, <a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-networks"><u>cloudflared</u></a>, in the same local area network as the server, which creates a secure Cloudflare Tunnel. You can create a new tunnel directly from cloudflared by running <code><b>cloudflared tunnel create &lt;TUNNEL-NAME&gt;</b></code> or using your Zero Trust dashboard.</p>
	<div style="position: relative; padding-top: 56.25%;">
		<iframe src="https://customer-1mwganm1ma0xgnmj.cloudflarestream.com/0410c73fe3fdd36142ec08bac77e8f97/iframe?preload=true&amp;letterboxColor=transparent&amp;poster=https%3A%2F%2Fpub-d9bf66e086fb4b639107aa52105b49dd.r2.dev%2FVideo-2-Stop-hosting-your-own-VPN-service.jpg" loading="lazy" style="border: none; position: absolute; top: 0; left: 0; height: 100%; width: 100%;" allow="accelerometer; gyroscope; autoplay; encrypted-media; picture-in-picture;" allowfullscreen="true"></iframe>
	</div>
	<p>
		<b>Step 2: Route the hostname to the tunnel</b>
	</p>
	<p>This is where the new capability comes into play. In your Zero Trust dashboard, you now establish a route that binds the <i>hostname</i> <code>canada-payroll-server.acme.local</code> directly to that tunnel. In the past, you could only route an IP address (<code>10.4.4.4)</code> or its subnet (<code>10.4.4.0/24</code>). That old method required you to create and manage those brittle IP Lists we talked about. Now, you can even route entire domains, like <code>*.acme.local</code>, directly to the tunnel, simply by creating a hostname route to <code>acme.local</code>.</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3mcoBAILYENIP6kGW4tw96/bb7ec6571ae7b4f04b5dc0456f694d59/1.png" alt="" class="kg-image" width="1990" height="530" loading="lazy">
	</figure>
	<p>For this to work, you must delete your private network’s subnet (in this case <code>10.0.0.0/8</code>) and <code>100.64.0.0/10</code> from the <a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/warp/configure-warp/route-traffic/split-tunnels"><u>Split Tunnels Exclude</u></a> list. You also need to remove <code>.local</code> from the <a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/warp/configure-warp/route-traffic/local-domains"><u>Local Domain Fallback</u></a>.</p>
	<p>(As an aside, we note that this feature also works with domains. For example, you could bind <code>*.acme.local</code> to a single tunnel, if desired.)</p>
	<p><b>Step 3: Write your zero trust policy</b></p>
	<p>Now that Cloudflare knows <i>how</i> to reach your server by its name, you can write a policy to control <i>who</i> can access it. You have a couple of options:</p>
	<ul>
		<li>
			<p><b>In Cloudflare Access (for HTTPS applications):</b> Write an <a href="https://developers.cloudflare.com/cloudflare-one/applications/non-http/self-hosted-private-app"><u>Access policy</u></a> that grants employees in the “finance” group access to the private hostname <code>canada-payroll-server.acme.local</code>. This is ideal for applications accessible over HTTPS on port 443.
			</p>
			<figure class="kg-card kg-image-card">
				<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/7lIZI9ThsAWtxFZZis3HtZ/08451586dbe373ff137bd9e91d23dea6/2.png" alt="" class="kg-image" width="1970" height="1204" loading="lazy">
			</figure>
			<p></p>
		</li>
		<li>
			<p><b>In Cloudflare Gateway (for HTTPS applications):</b> Alternatively, write a <a href="https://developers.cloudflare.com/cloudflare-one/policies/gateway"><u>Gateway policy</u></a> that grants employees in the “finance” group access to the <a href="https://developers.cloudflare.com/cloudflare-one/policies/gateway/network-policies/#sni"><u>SNI</u></a> <code>canada-payroll-server.acme.local</code>. This <a href="https://developers.cloudflare.com/cloudflare-one/policies/gateway/network-policies/protocol-detection"><u>works</u></a> for services accessible over HTTPS on any port.
			</p>
			<figure class="kg-card kg-image-card">
				<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5GpwDZNmdzapOyjOgFFlKD/50e2d0df64d2230479ad8d0a013de24b/3.png" alt="" class="kg-image" width="1978" height="1030" loading="lazy">
			</figure>
			<p></p>
		</li>
		<li>
			<p><b>In Cloudflare Gateway (for non-HTTP applications):</b> You can also write a <a href="https://developers.cloudflare.com/cloudflare-one/policies/gateway"><u>Gateway policy</u></a> that blocks DNS resolution <code>canada-payroll-server.acme.local</code> for all employees except the “finance” group.</p>
		</li>
	</ul>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3na5Mf6UMpBcKYm6JWmnzd/5791054c944300e667c3829e9bd8c6ec/4.png" alt="" class="kg-image" width="1984" height="1386" loading="lazy">
	</figure>
	<p>The principle of "trust nothing" means your security posture should start by denying traffic by default. For this setup to work in a true Zero Trust model, it should be paired with a default Gateway policy that blocks all access to your internal IP ranges. Think of this as ensuring all doors to your private network are locked by default. The specific <code>allow</code> policies you create for hostnames then act as the keycard, unlocking one specific door only for authorized users.</p>
	<p>Without that foundational "deny" policy, creating a route to a private resource would make it accessible to everyone in your organization, defeating the purpose of a least-privilege model and creating significant security risks. This step ensures that only the traffic you explicitly permit can ever reach your corporate resources.</p>
	<p>And there you have it. We’ve walked through the entire process of writing a per-resource policy using only the server’s private hostname. No IP Lists to be seen anywhere, simplifying life for your administrators.</p>
	<div class="flex anchor relative">
		<h2 id="secure-egress-traffic-to-third-party-applications">Secure egress traffic to third-party applications</h2>
		<a href="https://blog.cloudflare.com/#secure-egress-traffic-to-third-party-applications" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Here's another powerful use case for hostname routing: controlling outbound connections from your users to the public Internet. Some third-party services, such as banking portals or partner APIs, use an IP allowlist for security. They will only accept connections that originate from a specific, dedicated public source IP address that belongs to your company.</p>
	<p>This common practice creates a challenge. Let's say your banking portal at <code>bank.example.com</code> requires all traffic to come from a dedicated source IP <code>203.0.113.9</code> owned by your company. At the same time, you want to enforce a zero trust policy that <i>only</i> allows your finance team to access that portal. You can't build your policy based on the bank's destination IP — you don't control it, and it could change at any moment. You have to use its hostname.</p>
	<p>There are two ways to solve this problem. First, if your dedicated source IP is purchased from Cloudflare, you can use the <a href="https://blog.cloudflare.com/egress-policies-by-hostname"><u>“egress policy by hostname” feature</u></a> that we announced previously. By contrast, if your dedicated source IP belongs to your organization, or is leased from cloud provider, then we can solve this problem with hostname-based routing, as shown in the figure below:</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6wXu6FMiiVz4lXsESFrBTg/e1bb13e8eef0653ab311d0800d95f391/5.png" alt="" class="kg-image" width="1742" height="987" loading="lazy">
	</figure>
	<p>Here’s how this works:</p>
	<ol>
		<li>
			<p><b>Force traffic through your dedicated IP.</b> First, you deploy a <a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-networks"><u>Cloudflare Tunnel</u></a> in the network that owns your dedicated IP (for example, your primary VPC in a cloud provider). All traffic you send through this tunnel will exit to the Internet with <code>203.0.113.9</code> as its source IP.</p>
		</li>
		<li>
			<p><b>Route the banking app to that tunnel.</b> Next, you create a hostname route in your Zero Trust dashboard. This rule tells Cloudflare: "Any traffic destined for <code>bank.example.com</code> must be sent through this specific tunnel."</p>
		</li>
		<li>
			<p><b>Apply your user policies.</b> Finally, in Cloudflare Gateway, you create your granular access rules. A low-priority <a href="https://developers.cloudflare.com/cloudflare-one/policies/gateway/network-policies"><u>network policy</u></a> blocks access to the <a href="https://developers.cloudflare.com/cloudflare-one/policies/gateway/network-policies/#sni"><u>SNI</u></a> <code>bank.example.com</code> for everyone. Then, a second, higher-priority policy explicitly allows users in the "finance" group to access the <a href="https://developers.cloudflare.com/cloudflare-one/policies/gateway/network-policies/#sni"><u>SNI</u></a> <code>bank.example.com</code>.</p>
		</li>
	</ol>
	<p>Now, when a finance team member accesses the portal, their traffic is correctly routed through the tunnel and arrives with the source IP the bank expects. An employee from any other department is blocked by Gateway before their traffic even enters the tunnel. You've enforced a precise, user-based zero trust policy for a third-party service, all by using its public hostname.</p>
	<div class="flex anchor relative">
		<h2 id="under-the-hood-how-hostname-routing-works">Under the hood: how hostname routing works</h2>
		<a href="https://blog.cloudflare.com/#under-the-hood-how-hostname-routing-works" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>To build this feature, we needed to solve a classic networking challenge. The routing mechanism for Cloudflare Tunnel is a core part of Cloudflare Gateway, which operates at both Layer 4 (TCP/UDP) and Layer 7 (HTTP/S) of the network stack.</p>
	<p>Cloudflare Gateway must make a decision about which Cloudflare Tunnel to send traffic upon receipt of the very first IP packet in the connection. This means the decision must necessarily be made at Layer 4, where Gateway only sees the IP and TCP/UDP headers of a packet. IP and TCP/UDP headers contain the destination IP address, but do not contain destination <i>hostname</i>. The hostname is only found in Layer 7 data (like a TLS SNI field or an HTTP Host header), which isn't even available until after the Layer 4 connection is already established.</p>
	<p>This creates a dilemma: how can we route traffic based on a hostname before we've even seen the hostname?&nbsp;</p>
	<div class="flex anchor relative">
		<h3 id="synthetic-ips-to-the-rescue">Synthetic IPs to the rescue</h3>
		<a href="https://blog.cloudflare.com/#synthetic-ips-to-the-rescue" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>The solution lies in the fact that Cloudflare Gateway also acts as a DNS resolver. This means we see the user's <i>intent </i>— the DNS query for a hostname — <i>before</i> we see the actual application traffic. We use this foresight to "tag" the traffic using a <a href="https://blog.cloudflare.com/egress-policies-by-hostname"><u>synthetic IP address</u></a>.</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/7Kd3x5SppGp8G4KZeO34n/67b338ca8e81db63e110dc89c7596bf6/6.png" alt="" class="kg-image" width="1999" height="906" loading="lazy">
	</figure>
	<p>Let’s walk through the flow:</p>
	<ol>
		<li>
			<p><b>DNS Query</b>. A user's device sends a DNS query for
				<code>canada-payroll-server.acme.local </code>to the Gateway resolver.
			</p>
		</li>
		<li>
			<p><b>Private Resolution</b>. Gateway asks the <code>cloudflared </code>agent running in your private network to resolve the real IP for that hostname. Since <code>cloudflared</code> has access to your internal DNS, it finds the real private IP <code>10.4.4.4</code>, and sends it back to the Gateway resolver.</p>
		</li>
		<li>
			<p><b>Synthetic Response</b>. Here's the key step. Gateway resolver <b>does not</b> send the real IP (<code>10.4.4.4</code>) back to the user. Instead, it temporarily assigns an <i>initial resolved IP</i> from a reserved Carrier-Grade NAT (CGNAT) address space (e.g., <code>100.80.10.10</code>) and sends the initial resolved IP back to the user's device. The initial resolved IP acts as a tag that allows Gateway to identify network traffic destined to <code>canada-payroll-server.acme.local</code>. The initial resolved IP is randomly selected and temporarily assigned from one of the two IP address ranges:</p>
			<ul>
				<li>
					<p>IPv4: <code>100.80.0.0/16</code></p>
				</li>
				<li>
					<p>IPv6: <code>2606:4700:0cf1:4000::/64</code>&nbsp;</p>
				</li>
			</ul>
		</li>
		<li>
			<p><b>Traffic Arrives</b>. The user's device sends its application traffic (e.g., an HTTPS request) to the destination IP it received from Gateway resolver: the initial resolved IP <code>100.80.10.10</code>.</p>
		</li>
		<li>
			<p><b>Routing and Rewriting</b>. When Gateway sees an incoming packet destined for <code>100.80.10.10</code>, it knows this traffic is for <code>canada-payroll-server.acme.local</code> and must be sent through a specific Cloudflare Tunnel. It then rewrites the destination IP on the packet back to the <i>real</i> private destination IP (<code>10.4.4.4</code>) and sends it down the correct tunnel.</p>
		</li>
	</ol>
	<p>The traffic goes down the tunnel and arrives at <code>canada-payroll-server.acme.local</code> at IP (<code>10.4.4.4)</code> and the user is connected to the server without noticing any of these mechanisms. By intercepting the DNS query, we effectively tag the network traffic stream, allowing our Layer 4 router to make the right decision without needing to see Layer 7 data.</p>
	<div class="flex anchor relative">
		<h2 id="using-gateway-resolver-policies-for-fine-grained-control">Using Gateway Resolver Policies for fine grained control</h2>
		<a href="https://blog.cloudflare.com/#using-gateway-resolver-policies-for-fine-grained-control" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>The routing capabilities we've discussed provide simple, powerful ways to connect to private resources. But what happens when your network architecture is more complex? For example, what if your private DNS servers are in one part of your network, but the application itself is in another?</p>
	<p>With Cloudflare One, you can solve this by creating policies that separate the path for DNS resolution from the path for application traffic for the very same hostname using <a href="https://developers.cloudflare.com/cloudflare-one/policies/gateway/resolver-policies"><u>Gateway Resolver Policies</u></a>. This gives you fine-grained control to match complex network topologies.</p>
	<p>Let's walk through a scenario:</p>
	<ul>
		<li>
			<p>Your private DNS resolvers, which can resolve <code><b>acme.local</b></code>, are located in your core datacenter, accessible only via <code><b>tunnel-1</b></code>.</p>
		</li>
		<li>
			<p>The webserver for <code><b>canada-payroll-server.acme.local</b></code><b> </b>is hosted in a specific cloud VPC, accessible only via <code><b>tunnel-2</b></code>.</p>
		</li>
	</ul>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2sVMsS4DhuN2yoTlGWTK5X/e5a66330c951e7b65428f5c76b5c7b0a/7.png" alt="" class="kg-image" width="1980" height="544" loading="lazy">
	</figure>
	<p>Here’s how to configure this split-path routing.</p>
	<p><b>Step 1: Route DNS Queries via </b><code><b>tunnel-1</b></code></p>
	<p>First, we need to tell Cloudflare Gateway how to reach your private DNS server</p>
	<ol>
		<li>
			<p><b>Create an IP Route:</b> In the Networks &gt; Tunnels area of your Zero Trust dashboard, create a route for the IP address of your private DNS server (e.g., <code><b>10.131.0.5/32</b></code>) and point it to <code><b>tunnel-1</b></code><code>.</code> This ensures any traffic destined for that specific IP goes through the correct tunnel to your datacenter.</p>
			<figure class="kg-card kg-image-card">
				<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/32JcjFZXGuhDEHHlWJoF1C/4223a6f2e5b7b49015abfbfd9b4fd20f/8.png" alt="" class="kg-image" width="1999" height="643" loading="lazy">
			</figure>
			<p></p>
		</li>
		<li>
			<p><b>Create a Resolver Policy:</b> Go to <b>Gateway -&gt; Resolver Policies</b> and create a new policy with the following logic:</p>
			<ul>
				<li>
					<p><b>If</b> the query is for the domain <code><b>acme.local</b></code> …</p>
				</li>
				<li>
					<p><b>Then</b>... resolve it using a designated DNS server with the IP <code><b>10.131.0.5</b></code>.
					</p>
					<figure class="kg-card kg-image-card">
						<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2j8kYsD692tCRYcDKoDXvb/7dbb20f426ba47350fb0b2906046d5f0/9.png" alt="" class="kg-image" width="1980" height="1296" loading="lazy">
					</figure>
					<p></p>
				</li>
			</ul>
		</li>
	</ol>
	<p>With these two rules, any DNS lookup for <code><b>acme.local</b></code> from a user's device will be sent through <code>tunnel-1</code> to your private DNS server for resolution.</p>
	<p><b>Step 2: Route Application Traffic via </b><code><b>tunnel-2</b></code></p>
	<p>Next, we'll tell Gateway where to send the actual traffic (for example, HTTP/S) for the application.</p>
	<p><b>Create a Hostname Route:</b> In your Zero Trust dashboard, create a <b>hostname route</b> that binds <code><b>canada-payroll-server.acme.local </b></code>to <code><b>tunnel-2</b></code>.</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3Ufzpsb1FUYrM39gMiyovs/c5d10828f58b0e7c854ff9fa721e1757/10.png" alt="" class="kg-image" width="1980" height="550" loading="lazy">
	</figure>
	<p>This rule instructs Gateway that any application traffic (like HTTP, SSH, or any TCP/UDP traffic) for <code><b>canada-payroll-server.acme.local</b></code> must be sent through <code><b>tunnel-2</b></code><b> </b>leading to your cloud VPC.</p>
	<p>Similarly to a setup without Gateway Resolver Policy, for this to work, you must delete your private network’s subnet (in this case <code>10.0.0.0/8</code>) and <code>100.64.0.0/10</code> from the <a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/warp/configure-warp/route-traffic/split-tunnels"><u>Split Tunnels Exclude</u></a> list. You also need to remove <code>.local</code> from the <a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/warp/configure-warp/route-traffic/local-domains"><u>Local Domain Fallback</u></a>.</p>
	<p><b>Putting It All Together</b></p>
	<p>With these two sets of policies, the "synthetic IP" mechanism handles the complex flow:</p>
	<ol>
		<li>
			<p>A user tries to access <code>canada-payroll-server.acme.local</code>. Their device sends a DNS query to Cloudflare Gateway Resolver.</p>
		</li>
		<li>
			<p>This DNS query matches a Gateway Resolver Policy, causing Gateway Resolver to forward the DNS query through <code>tunnel-1</code> to your private DNS server (<code>10.131.0.5</code>).</p>
		</li>
		<li>
			<p>Your DNS server responds with the server’s actual private destination IP (<code>10.4.4.4</code>).</p>
		</li>
		<li>
			<p>Gateway receives this IP and generates a “synthetic” initial resolved IP (<code>100.80.10.10</code>) which it sends back to the user's device.</p>
		</li>
		<li>
			<p>The user's device now sends the HTTP/S request to the initial resolved IP (<code>100.80.10.10</code>).</p>
		</li>
		<li>
			<p>Gateway sees the network traffic destined for the initial resolved IP (<code>100.80.10.10</code>) and, using the mapping, knows it's for <code>canada-payroll-server.acme.local</code>.</p>
		</li>
		<li>
			<p>The Hostname Route now matches. Gateway sends the application traffic through tunnel-2 and rewrites its destination IP to the webserver’s actual private IP (<code>10.4.4.4</code>).</p>
		</li>
		<li>
			<p>The <code>cloudflared</code> agent at the end of tunnel-2 forwards the traffic to the application's destination IP (<code>10.4.4.4</code>), which is on the same local network.</p>
		</li>
	</ol>
	<p>The user is connected, without noticing that DNS and application traffic have been routed over totally separate private network paths. This approach allows you to support sophisticated split-horizon DNS environments and other advanced network architectures with simple, declarative policies.</p>
	<div class="flex anchor relative">
		<h2 id="what-onramps-does-this-support">What onramps does this support?</h2>
		<a href="https://blog.cloudflare.com/#what-onramps-does-this-support" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Our hostname routing capability is built on the "synthetic IP" (also known as <i>initially resolved IP</i>) mechanism detailed earlier, which requires specific Cloudflare One products to correctly handle both the DNS resolution and the subsequent application traffic. Here’s a breakdown of what’s currently supported for connecting your users (on-ramps) and your private applications (off-ramps).</p>
	<div class="flex anchor relative">
		<h4 id="connecting-your-users-on-ramps"><b>Connecting Your Users (On-Ramps)</b></h4>
		<a href="https://blog.cloudflare.com/#connecting-your-users-on-ramps" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>For end-users to connect to private hostnames, the feature currently works with <a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/warp"><b><u>WARP Client</u></b></a>, agentless <a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/pac-files"><b><u>PAC files</u></b></a> and <a href="https://developers.cloudflare.com/cloudflare-one/policies/browser-isolation"><b><u>Browser Isolation</u></b></a>.</p>
	<p>Connectivity is also possible when users are behind <a href="https://developers.cloudflare.com/magic-wan"><b><u>Magic WAN</u></b></a> (in active-passive mode) or <a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/private-net/warp-connector"><b><u>WARP Connector</u></b></a>, but it requires some additional configuration. To ensure traffic is routed correctly, you must update the routing table on your device or router to send traffic for the following destinations through Gateway:</p>
	<ul>
		<li>
			<p>The initially resolved IP ranges: <code>100.80.0.0/16</code> (IPv4) and <code>2606:4700:0cf1:4000::/64</code> (IPv6).</p>
		</li>
		<li>
			<p>The private network CIDR where your application is located (e.g., <code>10.0.0.0/8)</code>.</p>
		</li>
		<li>
			<p>The IP address of your internal DNS resolver.</p>
		</li>
		<li>
			<p>The Gateway DNS resolver IPs: <code>172.64.36.1</code> and <code>172.64.36.2</code>.</p>
		</li>
	</ul>
	<p>Magic WAN customers will also need to point their DNS resolver to these Gateway resolver IPs and ensure they are running Magic WAN tunnels in active-passive mode: for hostname routing to work, DNS queries and the resulting network traffic must reach Cloudflare over the same Magic WAN tunnel. Currently, hostname routing will not work if your end users are at a site that has more than one Magic WAN tunnel actively transiting traffic at the same time.</p>
	<div class="flex anchor relative">
		<h4 id="connecting-your-private-network-off-ramps"><b>Connecting Your Private Network (Off-Ramps)</b></h4>
		<a href="https://blog.cloudflare.com/#connecting-your-private-network-off-ramps" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>On the other side of the connection, hostname-based routing is designed specifically for applications connected via <a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-networks"><b><u>Cloudflare Tunnel</u></b></a> (<code>cloudflared</code>). This is currently the only supported off-ramp for routing by hostname.</p>
	<p>Other traffic off-ramps, while fully supported for IP-based routing, are not yet compatible with this specific hostname-based feature. This includes using Magic WAN, WARP Connector, or WARP-to-WARP connections as the off-ramp to your private network. We are actively working to expand support for more on-ramps and off-ramps in the future, so stay tuned for more updates.</p>
	<div class="flex anchor relative">
		<h2 id="conclusion">Conclusion</h2>
		<a href="https://blog.cloudflare.com/#conclusion" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>By enabling routing by hostname directly within Cloudflare Tunnel, we’re making security policies simpler, more resilient, and more aligned with how modern applications are built. You no longer need to track ever-changing IP addresses. You can now build precise, per-resource authorization policies for HTTPS applications based on the one thing that should matter: the name of the service you want to connect to. This is a fundamental step in making a zero trust architecture intuitive and achievable for everyone.</p>
	<p>This powerful capability is available today, built directly into Cloudflare Tunnel and free for all Cloudflare One customers.</p>
	<p>Ready to leave IP Lists behind for good? Get started by exploring our <a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/private-net/cloudflared/connect-private-hostname"><u>developer documentation</u></a> to configure your first hostname route. If you're new to <a href="https://developers.cloudflare.com/cloudflare-one"><u>Cloudflare One</u></a>, you can sign up today and begin securing your applications and networks in minutes.</p>
</div>