{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "5",
	"locale": "en-us",
	"localesAvailable": [
		"zh-cn",
		"fr-fr",
		"de-de",
		"es-es"
	],
	"post": {
		"authors": [
			{
				"name": "Marek Majkowski",
				"slug": "marek-majkowski",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1JuU5qavgwVeqR8BAUrd6U/3a0d0445d41c9a3c42011046efe9c37b/marek-majkowski.jpeg",
				"location": null,
				"website": null,
				"twitter": "@majek04",
				"facebook": null,
				"publiclyIndex": true
			}
		],
		"excerpt": "I was particularly interested in one of the consequences of how dynamic RAM works. You see, each bit of data is stored by the charge (or lack of it) on a tiny capacitor within the RAM chip. But these capacitors gradually lose their charge over time.",
		"feature_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/791063MiEVgyr0YOABGN7W/8b88ff9f9aedf985d6f240c7c1588c68/every-7-8us-your-computers-memory-has-a-hiccup.jpg",
		"featured": false,
		"html": "\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6FFnrM6hAzOXdmSL2qSL4H/4892b30f659e3a257edbe81321742562/640px-2013_Transcend_TS512MLK72V6N--straightened-.jpg\" alt=\"640px-2013_Transcend_TS512MLK72V6N--straightened-\" class=\"kg-image\" width=\"640\" height=\"152\" loading=\"lazy\"/>\n            \n            </figure><p>Modern DDR3 SDRAM. Source: <a href=\"https://en.wikipedia.org/wiki/DDR3_SDRAM#/media/File:2013_Transcend_TS512MLK72V6N-(straightened).jpg\">BY-SA/4.0 by Kjerish</a></p><p>During my recent visit to <a href=\"http://www.computerhistory.org/\">the Computer History Museum</a> in Mountain View, I found myself staring at some ancient <a href=\"https://en.wikipedia.org/wiki/Magnetic-core_memory\">magnetic core memory</a>.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5hsvsgHolMQyvCWSIDzdNw/a1c5ba4bf5c4781ddfce24e468d40ee2/240px-KL_CoreMemory.jpg\" alt=\"240px-KL_CoreMemory\" class=\"kg-image\" width=\"240\" height=\"240\" loading=\"lazy\"/>\n            \n            </figure><p>Source: <a href=\"https://en.wikipedia.org/wiki/File:KL_CoreMemory.jpg\">BY-SA/3.0 by Konstantin Lanzet</a></p><p>I promptly concluded I had absolutely no idea on how these things could ever work. I wondered if the rings rotate (they don&#39;t), and why each ring has three wires woven through it (and I still don’t understand exactly how these work). More importantly, I realized I have very little understanding on how the modern computer memory - dynamic RAM - works!</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3dVCvpQMSH4SxxcOltfABE/4e7e4aa9b619a4f8f7516336f14692b8/cpumemory.8.png\" alt=\"cpumemory.8\" class=\"kg-image\" width=\"115\" height=\"77\" loading=\"lazy\"/>\n            \n            </figure><p>Source: <a href=\"https://lwn.net/Articles/250967/\">Ulrich Drepper&#39;s series about memory</a></p><p>I was particularly interested in one of the consequences of how dynamic RAM works. You see, each bit of data is stored by the charge (or lack of it) on a tiny capacitor within the RAM chip. But these capacitors gradually lose their charge over time. To avoid losing the stored data, they must regularly get refreshed to restore the charge (if present) to its original level. This <a href=\"https://en.wikipedia.org/wiki/Memory_refresh\">refresh process</a> involves reading the value of every bit and then writing it back. During this &quot;refresh&quot; time, the memory is busy and it can&#39;t perform normal operations like loading or storing bits.</p><p>This has bothered me for quite some time and I wondered... is it possible to notice the refresh delay in software?</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"dynamic-ram-refresh-primer\">Dynamic RAM refresh primer</h2>\n            <a href=\"#dynamic-ram-refresh-primer\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Each DIMM module is composed of &quot;cells&quot; and &quot;rows&quot;, &quot;columns&quot;, &quot;sides&quot; and/or &quot;ranks&quot;. This presentation from <a href=\"https://pubweb.eng.utah.edu/~cs7810/pres/11-7810-12.pdf\">the University of Utah explains the nomenclature</a>. You can check the configuration of memory in your computer with <code>decode-dimms</code> command. Here&#39;s an example:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ decode-dimms\nSize                                       4096 MB\nBanks x Rows x Columns x Bits              8 x 15 x 10 x 64\nRanks                                      2</pre></code>\n            <p>For today we don&#39;t need to get into the whole DDR DIMM layout, we just need to understand a single memory cell, storing one bit of information. Specifically we are only interested in how the refresh process is performed.</p><p>Let&#39;s review two sources:</p><ul><li><p><a href=\"http://utaharch.blogspot.com/2013/11/a-dram-refresh-tutorial.html\">A DRAM Refresh Tutorial, from the University of Utah</a></p></li><li><p>And an awesome documentation of 1 gigabit cell from micron: <a href=\"https://www.micron.com/~/media/documents/products/technical-note/dram/tn4609.pdf\">TN-46-09 Designing for 1Gb DDR SDRAM</a></p></li></ul><p>Each bit stored in dynamic memory must be refreshed, typically every 64ms (called Static Refresh). This is a rather costly operation. To avoid one major stall every 64ms, this process is divided into 8192 smaller refresh operations. In each operation, the computer’s memory controller sends refresh commands to the DRAM chips. After receiving the instruction a chip will refresh 1/8192 of its cells. Doing the math - 64ms / 8192 = 7812.5 ns or 7.81 μs. This means:</p><ul><li><p>A refresh command is issued every 7812.5 ns. This is called tREFI.</p></li><li><p>It takes some time for the chip to perform the refresh and recover so it can perform normal read and write operations again. This time, called tRFC is either 75ns or 120ns (as per the mentioned Micron datasheet).</p></li></ul><p>When the memory is hot (&gt;85C) the memory retention time drops and the static refresh time halves to 32ms, and tREFI falls to 3906.25 ns.</p><p>A typical memory chip is busy with refreshes for a significant fraction of its running time - between 0.4% to 5%. Furthermore, memory chips are responsible for a nontrivial share of typical computer&#39;s power draw, and large chunk of that power is spent on performing the refreshes.</p><p>For the duration of the refresh action, the whole memory chip is blocked. This means each and every bit in memory is blocked for more than 75ns every 7812ns. Let&#39;s measure this.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"preparing-an-experiment\">Preparing an experiment</h2>\n            <a href=\"#preparing-an-experiment\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>To measure operations with nanosecond granularity we must write a tight loop, perhaps in C. It looks like this:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">    for (i = 0; i &lt; ...; i++) {\n\t\t// Perform memory load. Any load instruction will do\n\t\t*(volatile int *) one_global_var;\n\n\t\t// Flush CPU cache. This is relatively slow\n\t\t_mm_clflush(one_global_var);\n\n\t\t// mfence is needed, otherwise sometimes the loop\n\t\t// takes very short time (25ns instead of like 160). I\n\t\t// blame reordering.\n\t\tasm volatile(&quot;mfence&quot;);\n\n\t\t// Measure and record time\n\t\tclock_gettime(CLOCK_MONOTONIC, &amp;ts);\n    }</pre></code>\n            <p><a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2018-11-memory-refresh/measure-dram.c\">Full code is available on Github</a>.</p><p>The code is really straightforward. Perform a memory read. Flush data from CPU caches. Measure time.</p><p>(Note: in <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2018-11-memory-refresh/measure-dram-movntdqa.c#L113-L119\">second experiment I attempted to use MOVNTDQA</a> to perform the data load, but this requires special uncacheable memory page, which needs root access.)</p><p>On my computer it generates data like this:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\"># timestamp, loop duration\n3101895733,     134\n3101895865,     132\n3101896002,     137\n3101896134,     132\n3101896268,     134\n3101896403,     135\n3101896762,     359\n3101896901,     139\n3101897038,     137</pre></code>\n            <p>Typically I get ~140ns per loop, periodically the loop duration jumps to ~360ns. Sometimes I get odd readings longer than 3200ns.</p><p>Unfortunately, the data turns out to be very noisy. It&#39;s very hard to see if there is a noticeable delay related to the refresh cycles.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"fast-fourier-transform\">Fast Fourier Transform</h2>\n            <a href=\"#fast-fourier-transform\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>At some point it clicked. Since we want to find a fixed-interval event, we can feed the data into the FFT (fast fourier transform) algorithm, which deciphers the underlying frequencies.</p><p>I&#39;m not the first one to think about this - Mark Seaborn of Rowhammer fame <a href=\"https://github.com/google/rowhammer-test/blob/master/refresh_timing/refresh_timing.cc\">implemented this very technique</a> back in 2015. Even after peeking at Mark&#39;s code, getting FFT to work turned out to be harder than I anticipated. But finally I got all the pieces together.</p><p>First we need to prepare the data. FFT requires input data to be sampled with a constant sampling interval. We also want to crop the data to reduce noise. By trial and error I found the best results are when data is preprocessed:</p><ul><li><p>Small (smaller than average * 1.8) values of loop iterations are cut out, ignored, and replaced with readings of &quot;0&quot;. We really don&#39;t want to feed the noise into the algorithm.</p></li><li><p>All the remaining readings are replaced with &quot;1&quot;, since we really don&#39;t care about the amplitude of the delay caused by some noise.</p></li><li><p>I settled on sampling interval of 100ns, but any number up to <a href=\"https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem\">a Nyquist value (double expected frequency) also work fine</a>.</p></li><li><p>The data needs to be sampled with fixed timings before feeding to FFT. All reasonable sampling methods work ok, I ended up doing basic linear interpolation.</p></li></ul><p>The algorithm is roughly:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">UNIT=100ns\nA = [(timestamp, loop_duration),...] \np = 1\nfor curr_ts in frange(fist_ts, last_ts, UNIT):\n    while not(A[p-1].timestamp &lt;= curr_ts &lt; A[p].timestamp):\n        p += 1\n    v1 = 1 if avg*1.8 &lt;= A[p-1].duration &lt;= avg*4 else 0\n    v2 = 1 if avg*1.8 &lt;= A[p].duration &lt;= avg*4 else 0\n    v = estimate_linear(v1, v2, A[p-1].timestamp, curr_ts, A[p].timestamp)\n    B.append( v )</pre></code>\n            <p>Which on my data produces fairly boring vector like this:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,\n 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...]</pre></code>\n            <p>The vector is pretty long though, typically about ~200k data points. With data prepared like this, we are ready to feed it into FFT!</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">C = numpy.fft.fft(B)\nC = numpy.abs(C)\nF = numpy.fft.fftfreq(len(B)) * (1000000000/UNIT)</pre></code>\n            <p>Pretty simple, right? This produces two vectors:</p><ul><li><p>C contains complex numbers of the frequency components. We are not interested in complex numbers and we can flatten them out by calling <code>abs()</code>.</p></li><li><p>F contains labels to what frequency bin lies in which place in vector C. We need to normalize it to Hz - by multiplying it by the input vector sampling frequency.</p></li></ul><p>The result can be charted:</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/7GN44y65zWWJhSV8uNzqnu/cd9ff00a109e3eac49d858948edfbbf0/fft1a.png\" alt=\"fft1a\" class=\"kg-image\" width=\"1893\" height=\"824\" loading=\"lazy\"/>\n            \n            </figure><p>Y axis is unit-less since we normalized the delay times. Even though, it clearly shows spikes at some fixed frequency intervals. Let&#39;s zoom in:</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5xnQR5GYgpUVqOqH4Lvbry/35d7dab15d7515d3101d341cd882abdf/fft2a.png\" alt=\"fft2a\" class=\"kg-image\" width=\"1893\" height=\"824\" loading=\"lazy\"/>\n            \n            </figure><p>We can clearly see first three spikes. After a bit of wishy-washy arithmetic, involving filtering the reading at least 10 times the size of average, we can extract the underlying frequencies:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">127850.0\n127900.0\n127950.0\n255700.0\n255750.0\n255800.0\n255850.0\n255900.0\n255950.0\n383600.0\n383650.0</pre></code>\n            <p>Doing the math: 1000000000 (ns/s) / 127900 (Hz) = 7818.6 ns</p><p>Hurray! The first frequency spike is indeed what we were looking for, and indeed does correlate with the refresh times.</p><p>The other spikes at 256kHz, 384kHz, 512kHz and so on, are multiplies of our base frequency of 128kHz called harmonics. These are a side effect of <a href=\"https://en.wikipedia.org/wiki/Square_wave\">performing FFT on something like a square wave</a> and totally expected.</p><p>For easier experimentation, we <a href=\"https://github.com/cloudflare/cloudflare-blog/tree/master/2018-11-memory-refresh\">prepared a command line version of this tool</a>. You can run the code yourself. Here is a sample run on my server:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">~/2018-11-memory-refresh$ make\ngcc -msse4.1 -ggdb -O3 -Wall -Wextra measure-dram.c -o measure-dram\n./measure-dram | python3 ./analyze-dram.py\n[*] Verifying ASLR: main=0x555555554890 stack=0x7fffffefe2ec\n[ ] Fun fact. I did 40663553 clock_gettime()&#039;s per second\n[*] Measuring MOVQ + CLFLUSH time. Running 131072 iterations.\n[*] Writing out data\n[*] Input data: min=117 avg=176 med=167 max=8172 items=131072\n[*] Cutoff range 212-inf\n[ ] 127849 items below cutoff, 0 items above cutoff, 3223 items non-zero\n[*] Running FFT\n[*] Top frequency above 2kHz below 250kHz has magnitude of 7716\n[+] Top frequency spikes above 2kHZ are at:\n127906Hz    7716\n255813Hz    7947\n383720Hz    7460\n511626Hz    7141</pre></code>\n            <p>I must admit the code is not perfectly stable. In case of trouble, consider disabling Turbo Boost, CPU frequency scaling and tuning for performance.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"finale\">Finale</h2>\n            <a href=\"#finale\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>There are two major takeaways from this work.</p><p>We&#39;ve seen that the low level data is pretty hard to analyze and seem to be pretty noisy. Instead of trying to figure something out with naked eye, we can always employ good old FFT. Some wishful thinking is needed when preparing the data.</p><p>Most importantly, we showed it&#39;s often possible to measure subtle hardware behaviours from a simple userspace process. This kind of thinking led to the discovery of <a href=\"https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html\">the original Rowhammer</a> vulnerability, was used in Meltdown/Spectre attacks and showed again in <a href=\"https://arstechnica.com/information-technology/2018/11/potentially-disastrous-rowhammer-bitflips-can-bypass-ecc-protections/\">recent ECC-defeating reincarnation of Rowhammer</a>.</p><p>There is so much more to be said. We barely scratched the surface of the inner workings of the memory subsystem. I recommend further reading:</p><ul><li><p><a href=\"http://lackingrhoticity.blogspot.com/2015/04/l3-cache-mapping-on-sandy-bridge-cpus.html\">L3 cache mapping on Sandy Bridge CPUs</a></p></li><li><p><a href=\"http://lackingrhoticity.blogspot.com/2015/05/how-physical-addresses-map-to-rows-and-banks.html\">How physical address maps to rows and banks in DRAM</a></p></li><li><p><a href=\"https://hannuhartikainen.fi/blog/hacking-ddr3-spd/\">Hannu Hartikainen hacking DDR3 SO-DIMM to work... slower</a></p></li></ul><p>Finally, here is a good reading about the old magnetic core memory:</p><ul><li><p><a href=\"http://www.psych.usyd.edu.au/pdp-11/core.html\">PDP-11 core memory explained by University of Sydney</a></p></li></ul>",
		"id": "6Q0l4fzl9jSiRzJu7HjcgB",
		"localeList": {
			"name": "Every 7.8μs your computer’s memory has a hiccup Config",
			"enUS": "English for Locale",
			"zhCN": "Translated for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "Translated for Locale",
			"deDE": "Translated for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "Translated for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": null,
		"metadata": {
			"imgPreview": ""
		},
		"primary_author": {},
		"publicly_index": true,
		"published_at": "2018-11-23T15:49:00.000+00:00",
		"slug": "every-7-8us-your-computers-memory-has-a-hiccup",
		"tags": [
			{
				"id": "4HIPcb68qM0e26fIxyfzwQ",
				"name": "Developers",
				"slug": "developers"
			},
			{
				"id": "6lhzEBz2B56RKa4nUEAGYJ",
				"name": "Programming",
				"slug": "programming"
			}
		],
		"title": "Every 7.8μs your computer’s memory has a hiccup",
		"updated_at": "2024-10-10T00:43:08.352Z",
		"url": "https://blog.cloudflare.com/every-7-8us-your-computers-memory-has-a-hiccup"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.icon_aria_label": "Search",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"search.result_stat_empty": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong>",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"search.autocomplete_title": "Insert a query. Press enter to send",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}