<div class="mb2 gray5">5 min read</div>
<div class="mt4">This post is also available in <a href="https://blog.cloudflare.com/ja-jp/async-quic-and-http-3-made-easy-tokio-quiche-is-now-open-source">日本語</a> and <a href="https://blog.cloudflare.com/ko-kr/async-quic-and-http-3-made-easy-tokio-quiche-is-now-open-source">한국어</a>.</div><img class="mr2" src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6no55dm8tLkgA5eWcZIDIn/9a1d32be20b783a421b23ea382a096b1/image3.png" alt="">
<div class="post-content lh-copy gray1">
	<p>A little over 6 years ago, we presented <a href="https://blog.cloudflare.com/enjoy-a-slice-of-quic-and-rust"><u>quiche</u></a>, our open source QUIC implementation written in Rust. Today we’re announcing the open sourcing of <a href="https://crates.io/crates/tokio-quiche"><b><u>tokio-quiche</u></b></a>, our battle-tested, asynchronous QUIC library combining both <b>quiche</b> and the Rust <b>Tokio</b> async runtime. Powering Cloudflare’s Proxy B in Apple iCloud Private Relay and our next-generation <a href="https://blog.cloudflare.com/introducing-oxy"><u>Oxy-based</u></a> proxies, <b>tokio-quiche</b> handles millions of HTTP/3 requests per second with low latency and high throughput. tokio-quiche also powers <a href="https://blog.cloudflare.com/zero-trust-warp-with-a-masque"><u>Cloudflare Warp’s MASQUE</u></a> client, replacing our WireGuard tunnels with QUIC-based tunnels, and the async version of <a href="https://blog.cloudflare.com/h3i"><u>h3i</u></a>.</p>
	<p>quiche was developed as a <a href="https://sans-io.readthedocs.io/how-to-sans-io.html"><u>sans-io</u></a> library, meaning that it implements the state machine required to handle the QUIC transport protocol while not making any assumptions about how its user intends to perform IO. This means that, with enough elbow grease, anyone can write an IO integration with quiche! This entails <code>connect</code>ing or <code>listen</code>ing on a UDP socket, managing sending and receiving UDP datagrams on that socket while feeding all network information to quiche. Given we need this integration to be async, we’d have to do all this while integrating with an async Rust runtime. tokio-quiche does all of that for you, no grease required.</p>
	<div class="flex anchor relative">
		<h3 id="lowering-the-barrier-to-entry">Lowering the barrier to entry</h3>
		<a href="https://blog.cloudflare.com/#lowering-the-barrier-to-entry" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Originally, tokio-quiche was only used as the core of <a href="https://blog.cloudflare.com/introducing-oxy"><u>Oxy’s</u></a> HTTP/3 <i>server</i>. But the spark to create tokio-quiche as a standalone library was our need for a MASQUE-capable HTTP/3 <i>client</i>. Our Zero Trust and Privacy Teams need MASQUE clients to tunnel data through WARP and our Privacy Proxies respectively, and we wanted to use the same technology to build both the client and server.</p>
	<p>We initially open-sourced quiche to share our memory-safe QUIC and HTTP/3 implementation with as many stakeholders as possible. Our focus at the time was a low-level, sans-io design that could integrate into many types of software and be deployed widely. We achieved this goal, with quiche deployed in many different clients and servers. However, integrating sans-io libraries into applications is an error-prone and time-consuming process. Our aim with tokio-quiche is to lower the barrier of entry by providing much of the needed code ourselves.</p>
	<p>Cloudflare alone embracing HTTP/3 is not of much use if others wanting to interact with our products and systems don't also adopt it. Open sourcing tokio-quiche makes integration with our systems more straightforward, and helps propel the industry into the new standard of HTTP. By contributing tokio-quiche back to the Rust ecosystem, we hope to promote the development and usage of HTTP/3, QUIC and new privacy preserving technologies.</p>
	<p>tokio-quiche has been used internally for some years now. This gave us time to refine and battle-test it, demonstrating that it can handle millions of RPS. tokio-quiche is <b>not intended</b> to be a standalone HTTP/3 client or server, but implements low-level protocols and allows for higher-level projects in the future. The README contains examples of <a href="https://github.com/cloudflare/quiche/tree/master/tokio-quiche#starting-an-http3-server"><u>server</u></a> and <a href="https://github.com/cloudflare/quiche/tree/master/tokio-quiche#sending-an-http3-request"><u>client</u></a> event loops.</p>
	<div class="flex anchor relative">
		<h3 id="its-actors-all-the-way-down">It’s actors all the way down</h3>
		<a href="https://blog.cloudflare.com/#its-actors-all-the-way-down" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p><a href="https://tokio.rs"><u>Tokio</u></a> is a wildly popular asynchronous Rust runtime. It efficiently manages, schedules and executes the billions of asynchronous tasks which run on our edge. We use Tokio <a href="https://blog.cloudflare.com/introducing-oxy"><u>extensively</u></a> <a href="https://blog.cloudflare.com/pingora-open-source"><u>at</u></a> <a href="https://blog.cloudflare.com/20-percent-internet-upgrade"><u>Cloudflare</u></a>, so we decided to tightly integrate quiche with it – thus the name, tokio-quiche. Under the hood, tokio-quiche uses <i>actors</i> to drive different parts of the QUIC and HTTP/3 state machine. Actors are small tasks with internal state that usually use message passing over channels to communicate with the outside world.</p>
	<p>The actor model is a great abstraction to use for async-ifying sans-io libraries due to the conceptual similarities between the two. Both actors and sans-io libraries have some kind of internal state which they want exclusive access to. They both usually interact with the outside world by sending and receiving&nbsp; “messages”. quiche’s “messages” are really raw byte buffers which represent incoming and outgoing network data. One of tokio-quiche’s “messages” is the <code>Incoming</code> struct which describes incoming UDP packets. Due to these similarities, async-ifying a sans-io library means: awaiting new messages or IO, translating the messages or IO into something the sans-io library understands, advancing the internal state machine, translating the state machine’s output to a message or IO, and finally sending the message or IO. (For more discussion on actors with Tokio, make sure to take a look at Alice Rhyl’s <a href="https://ryhl.io/blog/actors-with-tokio"><u>excellent blog post</u></a> on the topic.)</p>
	<p>The primary actor in tokio-quiche is the IO loop actor, which moves packets between quiche and the socket. Since QUIC is a transport protocol, it can carry any application protocol you want. <a href="https://datatracker.ietf.org/doc/rfc9114"><u>HTTP/3</u></a> is quite common, but <a href="https://datatracker.ietf.org/doc/rfc9250"><u>DNS over QUIC</u></a> and the upcoming <a href="https://blog.cloudflare.com/moq"><u>Media over QUIC</u></a> are other examples. There's even <a href="https://www.rfc-editor.org/rfc/rfc9308.html"><u>an RFC</u></a> to help you create your own QUIC application! tokio-quiche exposes the <code>ApplicationOverQuic </code>trait to abstract over application protocols. The trait abstracts over quiche’s methods and the underlying I/O, allowing you to focus on your application logic. For example, our HTTP/3 debug and test client, <a href="https://blog.cloudflare.com/h3i"><u>h3i</u></a>, is powered by a client-focused, non-HTTP/3 <code>ApplicationOverQuic</code> implementation.</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6AOaumZTjtZkzdY1iJLVTZ/c958b6937c2e4a455f3b98b0389388fd/image2.png" alt="" class="kg-image" width="1590" height="1540" loading="lazy">
	</figure>
	<p><sup>Server Architecture Diagram</sup></p>
	<p>tokio-quiche ships with an HTTP/3-focused <code>ApplicationOverQuic</code> called <code>H3Driver</code>. <code>H3Driver</code> hooks up quiche’s HTTP/3 module to this IO loop to provide the building blocks for an async HTTP/3 client or server. The driver turns quiche’s raw HTTP/3 events into higher-level events and asynchronous body data streams, allowing you to respond to them in kind. <code>H3Driver</code> is itself generic, exposing <code>ServerH3Driver</code> and <code>ClientH3Driver</code> variants that each stack additional behavior on top of the core driver’s events.</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2zxI09AhiqrBSyk8fhcSnr/b78917274391ec855370e565985c7bfc/image4.png" alt="" class="kg-image" width="1880" height="1002" loading="lazy">
	</figure>
	<p><sup>Internal Data Flow</sup></p>
	<p>Inside tokio-quiche, we spawn two important tasks that facilitate data movement from a socket to quiche. The first is the <code>InboundPacketRouter</code>, which owns the receiving half of the socket and routes inbound datagrams by their <a href="https://datatracker.ietf.org/doc/html/rfc9000#name-connection-id"><u>connection ID</u></a> (DCID) to a per-connection channel. The second task, the <code>IoWorker</code> actor, is the aforementioned IO loop and drives a single quiche <code>Connection</code>. It intersperses quiche calls with <code>ApplicationOverQuic</code> methods, ensuring you can inspect the connection before and after any IO interaction.</p>
	<p>More blog posts on the creation of tokio-quiche are coming soon. We’ll discuss actor models and mutexes, UDP GRO and GSO, tokio task coop budgeting, and more.</p>
	<div class="flex anchor relative">
		<h3 id="next-up-more-on-quic-and-beyond">Next up: more on QUIC and beyond!</h3>
		<a href="https://blog.cloudflare.com/#next-up-more-on-quic-and-beyond" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>tokio-quiche is an important foundation for Cloudflare’s investment into the QUIC and HTTP/3 ecosystem for Tokio – but it is still only a building block with its own complexity. In the future, we plan to release the same easy-to-use HTTP client and server abstractions that power our Oxy proxies and WARP clients today. Stay tuned for more blog posts on QUIC and HTTP/3 at Cloudflare, including an open-source client for customers of our <a href="https://blog.cloudflare.com/privacy-edge-making-building-privacy-first-apps-easier/#privacy-preserving-proxying-built-into-applications"><u>Privacy Proxies</u></a> and a completely new service that’s handling millions of RPS with tokio-quiche!</p>
	<p>For now, check out the <a href="https://crates.io/crates/tokio-quiche"><u>tokio-quiche crate</u></a> on crates.io and its <a href="https://github.com/cloudflare/quiche/tree/master/tokio-quiche"><u>source code</u></a> on GitHub to build your very own QUIC application. Could be a simple echo server, a DNS-over-QUIC client, a custom VPN, or even a fully-fledged HTTP server. Maybe you will beat us to the punch?</p>
</div>