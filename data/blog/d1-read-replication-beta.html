<div class="mb2 gray5">14 min read</div><img class="mr2" src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2SWdpbhtoHkEeBL0KLzmWn/d1e067d4eef463a5ecf3eb5daf8cbe02/image2.png" alt="">
<div class="post-content lh-copy gray1">
	<p>Read replication of <a href="https://developers.cloudflare.com/d1"><u>D1</u></a> databases is in public beta!</p>
	<p>D1 read replication makes read-only copies of your database available in multiple regions across Cloudflare’s network.&nbsp; For busy, read-heavy applications like e-commerce websites, content management tools, and mobile apps:</p>
	<ul>
		<li>
			<p>D1 read replication lowers average latency by routing user requests to read replicas in nearby regions.</p>
		</li>
		<li>
			<p>D1 read replication increases overall throughput by offloading read queries to read replicas, allowing the primary database to handle more write queries.</p>
		</li>
	</ul>
	<p>The main copy of your database is called the primary database and the read-only copies are called read replicas.&nbsp; When you enable replication for a D1 database, the D1 service automatically creates and maintains read replicas of your primary database.&nbsp; As your users make requests, D1 routes those requests to an appropriate copy of the database (either the primary or a replica) based on performance heuristics, the type of queries made in those requests, and the query consistency needs as expressed by your application.</p>
	<p>All of this global replica creation and request routing is handled by Cloudflare at no additional cost.</p>
	<p>To take advantage of read replication, your Worker needs to use the new D1 <a href="https://developers.cloudflare.com/d1/best-practices/read-replication"><u>Sessions API</u></a>. Click the button below to run a Worker using D1 read replication with this <a href="https://github.com/cloudflare/templates/tree/main/d1-starter-sessions-api-template"><u>code example</u></a> to see for yourself!</p><a href="https://deploy.workers.cloudflare.com/?url=https%3A%2F%2Fgithub.com%2Fcloudflare%2Ftemplates%2Ftree%2Fmain%2Fd1-starter-sessions-api-template"><img src="https://deploy.workers.cloudflare.com/button" alt="Deploy to Cloudflare"></a>
	<p></p>
	<div class="flex anchor relative">
		<h2 id="d1-sessions-api">D1 Sessions API</h2>
		<a href="https://blog.cloudflare.com/#d1-sessions-api" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>D1’s read replication feature is built around the concept of database <i>sessions</i>.&nbsp; A session encapsulates all the queries representing one logical session for your application. For example, a session might represent all requests coming from a particular web browser or all requests coming from a mobile app used by one of your users. If you use sessions, your queries will use the appropriate copy of the D1 database that makes the most sense for your request, be that the primary database or a nearby replica.</p>
	<p>The sessions implementation ensures <a href="https://jepsen.io/consistency/models/sequential"><u>sequential consistency</u></a> for all queries in the session, no matter what copy of the database each query is routed to.&nbsp; The sequential consistency model has important properties like "<a href="https://jepsen.io/consistency/models/read-your-writes"><u>read my own writes</u></a>" and "<a href="https://jepsen.io/consistency/models/writes-follow-reads"><u>writes follow reads</u></a>," as well as a total ordering of writes. The total ordering of writes means that every replica will see transactions committed in the same order, which is exactly the behavior we want in a transactional system.&nbsp; Said another way, sequential consistency guarantees that the reads and writes are executed in the order in which you write them in your code.</p>
	<p>Some examples of consistency implications in real-world applications:</p>
	<ul>
		<li>
			<p>You are using an online store and just placed an order (write query), followed by a visit to the account page to list all your orders (read query handled by a replica). You want the newly placed order to be listed there as well.</p>
		</li>
		<li>
			<p>You are using your bank’s web application and make a transfer to your electricity provider (write query), and then immediately navigate to the account balance page (read query handled by a replica) to check the latest balance of your account, including that last payment.</p>
		</li>
	</ul>
	<p>Why do we need the Sessions API? Why can we not just query replicas directly?</p>
	<p>Applications using D1 read replication need the Sessions API because D1 runs on Cloudflare’s global network and there’s no way to ensure that requests from the same client get routed to the same replica for every request. For example, the client may switch from WiFi to a mobile network in a way that changes how their requests are routed to Cloudflare. Or the data center that handled previous requests could be down because of an outage or maintenance.</p>
	<p>D1’s read replication is asynchronous, so it’s possible that when you switch between replicas, the replica you switch to lags behind the replica you were using. This could mean that, for example, the new replica hasn’t learned of the writes you just completed.&nbsp; We could no longer guarantee useful properties like “read your own writes”.&nbsp; In fact, in the presence of shifty routing, the only consistency property we could guarantee is that what you read had been committed at some point in the past (<a href="https://jepsen.io/consistency/models/read-committed"><u>read committed</u></a> consistency), which isn’t very useful at all!</p>
	<p>Since we can’t guarantee routing to the same replica, we flip the script and use the information we get from the Sessions API to make sure whatever replica we land on can handle the request in a sequentially-consistent manner.</p>
	<p>Here’s what the Sessions API looks like in a Worker:</p>
	<pre class="language-JavaScript"><code class="language-JavaScript">export default {
  async fetch(request: Request, env: Env) {
    // A. Create the session.
    // When we create a D1 session, we can continue where we left off from a previous    
    // session if we have that session's last bookmark or use a constraint.
    const bookmark = request.headers.get('x-d1-bookmark') ?? 'first-unconstrained'
    const session = env.DB.withSession(bookmark)

    // Use this session for all our Workers' routes.
    const response = await handleRequest(request, session)

    // B. Return the bookmark so we can continue the session in another request.
    response.headers.set('x-d1-bookmark', session.getBookmark())

    return response
  }
}

async function handleRequest(request: Request, session: D1DatabaseSession) {
  const { pathname } = new URL(request.url)

  if (request.method === "GET" &amp;&amp; pathname === '/api/orders') {
    // C. Session read query.
    const { results } = await session.prepare('SELECT * FROM Orders').all()
    return Response.json(results)

  } else if (request.method === "POST" &amp;&amp; pathname === '/api/orders') {
    const order = await request.json&lt;Order&gt;()

    // D. Session write query.
    // Since this is a write query, D1 will transparently forward it to the primary.
    await session
      .prepare('INSERT INTO Orders VALUES (?, ?, ?)')
      .bind(order.orderId, order.customerId, order.quantity)
      .run()

    // E. Session read-after-write query.
    // In order for the application to be correct, this SELECT statement must see
    // the results of the INSERT statement above.
    const { results } = await session
      .prepare('SELECT * FROM Orders')
      .all()

    return Response.json(results)
  }

  return new Response('Not found', { status: 404 })
}</code></pre>
	<p>To use the Session API, you first need to create a session using the <code>withSession</code> method (<b><i>step A</i></b>).&nbsp; The <code>withSession</code> method takes a bookmark as a parameter, or a constraint.&nbsp; The provided constraint instructs D1 where to forward the first query of the session. Using <code>first-unconstrained</code> allows the first query to be processed by any replica without any restriction on how up-to-date it is. Using <code>first-primary</code> ensures that the first query of the session will be forwarded to the primary.</p>
	<pre class="language-JavaScript"><code class="language-JavaScript">// A. Create the session.
const bookmark = request.headers.get('x-d1-bookmark') ?? 'first-unconstrained'
const session = env.DB.withSession(bookmark)</code></pre>
	<p>Providing an explicit bookmark instructs D1 that whichever database instance processes the query has to be at least as up-to-date as the provided bookmark (in case of a replica; the primary database is always up-to-date by definition).&nbsp; Explicit bookmarks are how we can continue from previously-created sessions and maintain sequential consistency across user requests.</p>
	<p>Once you’ve created the session, make queries like you normally would with D1.&nbsp; The session object ensures that the queries you make are sequentially consistent with regards to each other.</p>
	<pre class="language-JavaScript"><code class="language-JavaScript">// C. Session read query.
const { results } = await session.prepare('SELECT * FROM Orders').all()</code></pre>
	<p>For example, in the code example above, the session read query for listing the orders (<b><i>step C</i></b>) will return results that are at least as up-to-date as the bookmark used to create the session (<b><i>step A</i></b><i>)</i>.</p>
	<p>More interesting is the write query to add a new order (<b><i>step D</i></b>) followed by the read query to list all orders (<b><i>step E</i></b>). Because both queries are executed on the same session, it is guaranteed that the read query will observe a database copy that includes the write query, thus maintaining sequential consistency.</p>
	<pre class="language-JavaScript"><code class="language-JavaScript">// D. Session write query.
await session
  .prepare('INSERT INTO Orders VALUES (?, ?, ?)')
  .bind(order.orderId, order.customerId, order.quantity)
  .run()

// E. Session read-after-write query.
const { results } = await session
  .prepare('SELECT * FROM Orders')
  .all()</code></pre>
	<p>Note that we could make a single batch query to the primary including both the write and the list, but the benefit of using the new Sessions API is that you can use the extra read replica databases for your read queries and allow the primary database to handle more write queries.</p>
	<p>The session object does the necessary bookkeeping to maintain the latest bookmark observed across all queries executed using that specific session, and always includes that latest bookmark in requests to D1. Note that any query executed without using the session object is not guaranteed to be sequentially consistent with the queries executed in the session.</p>
	<p>When possible, we suggest continuing sessions across requests by including bookmarks in your responses to clients (<b><i>step B</i></b>), and having clients passing previously received bookmarks in their future requests.</p>
	<pre class="language-JavaScript"><code class="language-JavaScript">// B. Return the bookmark so we can continue the session in another request.
response.headers.set('x-d1-bookmark', session.getBookmark())</code></pre>
	<p>This allows <i>all</i> of a client’s requests to be in the same session. You can do this by grabbing the session’s current bookmark at the end of the request (<code>session.getBookmark()</code>) and sending the bookmark in the response back to the client in HTTP headers, in HTTP cookies, or in the response body itself.</p>
	<div class="flex anchor relative">
		<h3 id="consistency-with-and-without-sessions-api">Consistency with and without Sessions API</h3>
		<a href="https://blog.cloudflare.com/#consistency-with-and-without-sessions-api" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>In this section, we will explore the classic scenario of a read-after-write query to showcase how using the new D1 Sessions API ensures that we get sequential consistency and avoid any issues with inconsistent results in our application.</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1zIBf3V1YIogYJKeWm1kDn/f484faf38cc0f8d7227f9db1fa386354/1.png" alt="" class="kg-image" width="1999" height="1323" loading="lazy">
	</figure>
	<p>The Client, a user Worker, sends a D1 write query that gets processed by the database primary and gets the results back. However, the subsequent read query ends up being processed by a database replica. If the database replica is lagging far enough behind the database primary, such that it does not yet include the first write query, then the returned results will be inconsistent, and probably incorrect for your application business logic.</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1w81ec5tNGWJ7sQyFBZQ6l/d487ccf225a097a0e48054d88df0ba1f/2.png" alt="" class="kg-image" width="1999" height="1323" loading="lazy">
	</figure>
	<p>Using the Sessions API fixes the inconsistency issue. The first write query is again processed by the database primary, and this time the response includes “<b>Bookmark 100</b>”. The session object will store this bookmark for you transparently.</p>
	<p>The subsequent read query is processed by database replica as before, but now since the query includes the previously received “<b>Bookmark 100</b>”, the database replica will wait until its database copy is at least up-to-date as “<b>Bookmark 100</b>”. Only once it’s up-to-date, the read query will be processed and the results returned, including the replica’s latest bookmark “<b>Bookmark 104</b>”.</p>
	<p>Notice that the returned bookmark for the read query is “<b>Bookmark 104</b>”, which is different from the one passed in the query request. This can happen if there were other writes from other client requests that also got replicated to the database replica in-between the two queries our own client executed.</p>
	<div class="flex anchor relative">
		<h2 id="enabling-read-replication">Enabling read replication</h2>
		<a href="https://blog.cloudflare.com/#enabling-read-replication" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>To start using D1 read replication:</p>
	<ol>
		<li>
			<p>Update your Worker to use the D1 Sessions API to tell D1 what queries are part of the same database session. The Sessions API works with databases that do not have read replication enabled as well, so it’s safe to ship this code even before you enable replicas. Here’s <a href="https://developers.cloudflare.com/d1/best-practices/read-replication"><u>an example</u></a>.</p>
		</li>
		<li>
			<p><a href="https://developers.cloudflare.com/d1/best-practices/read-replication/#enable-read-replication"><u>Enable replicas</u></a> for your database via <a href="https://dash.cloudflare.com/?to=%2F%3Aaccount%2Fworkers%2Fd1"><u>Cloudflare dashboard</u></a> &gt; Select D1 database &gt; Settings.</p>
		</li>
	</ol>
	<p>D1 read replication is built into D1, and you don’t pay extra storage or compute costs for replicas. You incur the exact same D1 usage with or without replicas, based on <code>rows_read</code> and <code>rows_written</code> by your queries. Unlike other traditional database systems with replication, you don’t have to manually create replicas, including where they run, or decide how to route requests between the primary database and read replicas. Cloudflare handles this when using the Sessions API while ensuring sequential consistency.</p>
	<p>Since D1 read replication is in beta, we recommend trying D1 read replication on a non-production database first, and migrate to your production workloads after validating read replication works for your use case.</p>
	<p>If you don’t have a D1 database and want to try out D1 read replication, <a href="https://dash.cloudflare.com/?to=%2F%3Aaccount%2Fworkers%2Fd1%2Fcreate"><u>create a test database</u></a> in the Cloudflare dashboard.</p>
	<div class="flex anchor relative">
		<h3 id="observing-your-replicas">Observing your replicas</h3>
		<a href="https://blog.cloudflare.com/#observing-your-replicas" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Once you’ve enabled D1 read replication, read queries will start to be processed by replica database instances. The response of each query includes information in the nested <code>meta</code> object relevant to read replication, like <code>served_by_region</code> and <code>served_by_primary</code>. The first denotes the region of the database instance that processed the query, and the latter will be <code>true</code> if-and-only-if your query was processed by the primary database instance.</p>
	<p>In addition, the <a href="https://dash.cloudflare.com/?to=%2F%3Aaccount%2Fworkers%2Fd1%2F"><u>D1 dashboard overview</u></a> for a database now includes information about the database instances handling your queries. You can see how many queries are handled by the primary instance or by a replica, and a breakdown of the queries processed by region. The example screenshots below show graphs displaying the number of queries executed and number of rows read by each region.</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1ChIlqQ5xgJfiftOHw9Egg/b583d00d22dcea60e7439dfbfa1761df/image10.png" alt="" class="kg-image" width="1999" height="859" loading="lazy">
	</figure>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4Zze5y22759fOIYPOqrK1Y/6cd3c684006ca8234db20924cae8b960/image1.png" alt="" class="kg-image" width="1999" height="857" loading="lazy">
	</figure>
	<div class="flex anchor relative">
		<h2 id="under-the-hood-how-d1-read-replication-is-implemented">Under the hood: how D1 read replication is implemented</h2>
		<a href="https://blog.cloudflare.com/#under-the-hood-how-d1-read-replication-is-implemented" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>D1 is implemented on top of SQLite-backed Durable Objects running on top of Cloudflare’s <a href="https://blog.cloudflare.com/sqlite-in-durable-objects/#under-the-hood-storage-relay-service"><u>Storage Relay Service</u></a>.</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3GWWL8goIzrGTmkH54O416/aabd47fcd94bfc73492556b19ac6069f/5.png" alt="" class="kg-image" width="1999" height="741" loading="lazy">
	</figure>
	<p>D1 is structured with a 3-layer architecture.&nbsp; First is the binding API layer that runs in the customer’s Worker.&nbsp; Next is a stateless Worker layer that routes requests based on database ID to a layer of Durable Objects that handle the actual SQL operations behind D1.&nbsp; This is similar to how <a href="https://developers.cloudflare.com/durable-objects/what-are-durable-objects/#durable-objects-in-cloudflare"><u>most applications using Cloudflare Workers and Durable Objects are structured</u></a>.</p>
	<p>For a non-replicated database, there is exactly one Durable Object per database.&nbsp; When a user’s Worker makes a request with the D1 binding for the database, that request is first routed to a D1 Worker running in the same location as the user’s Worker.&nbsp; The D1 Worker figures out which D1 Durable Object backs the user’s D1 database and fetches an RPC stub to that Durable Object.&nbsp; The Durable Objects routing layer figures out where the Durable Object is located, and opens an RPC connection to it.&nbsp; Finally, the D1 Durable Object then handles the query on behalf of the user’s Worker using the Durable Objects SQL API.</p>
	<p>In the Durable Objects SQL API, all queries go to a SQLite database on the local disk of the server where the Durable Object is running.&nbsp; Durable Objects run <a href="https://www.sqlite.org/wal.html"><u>SQLite in WAL mode</u></a>.&nbsp; In WAL mode, every write query appends to a write-ahead log (the WAL).&nbsp; As SQLite appends entries to the end of the WAL file, a database-specific component called the Storage Relay Service <i>leader</i> synchronously replicates the entries to 5 <i>durability followers</i> on servers in different datacenters.&nbsp; When a quorum (at least 3 out of 5) of the durability followers acknowledge that they have safely stored the data, the leader allows SQLite’s write queries to commit and opens the Durable Object’s output gate, so that the Durable Object can respond to requests.</p>
	<p>Our implementation of WAL mode allows us to have a complete log of all of the committed changes to the database. This enables a couple of important features in SQLite-backed Durable Objects and D1:</p>
	<ul>
		<li>
			<p>We identify each write with a <a href="https://en.wikipedia.org/wiki/Lamport_timestamp"><u>Lamport timestamp</u></a> we call a <a href="https://developers.cloudflare.com/d1/reference/time-travel/#bookmarks"><u>bookmark</u></a>.</p>
		</li>
		<li>
			<p>We construct databases anywhere in the world by downloading all of the WAL entries from cold storage and replaying each WAL entry in order.</p>
		</li>
		<li>
			<p>We implement <a href="https://developers.cloudflare.com/d1/reference/time-travel"><u>Point-in-time recovery (PITR)</u></a> by replaying WAL entries up to a specific bookmark rather than to the end of the log.</p>
		</li>
	</ul>
	<p>Unfortunately, having the main data structure of the database be a log is not ideal.&nbsp; WAL entries are in write order, which is often neither convenient nor fast.&nbsp; In order to cut down on the overheads of the log, SQLite <i>checkpoints</i> the log by copying the WAL entries back into the main database file.&nbsp; Read queries are serviced directly by SQLite using files on disk — either the main database file for checkpointed queries, or the WAL file for writes more recent than the last checkpoint.&nbsp; Similarly, the Storage Relay Service snapshots the database to cold storage so that we can replay a database by downloading the most recent snapshot and replaying the WAL from there, rather than having to download an enormous number of individual WAL entries.</p>
	<p>WAL mode is the foundation for implementing read replication, since we can stream writes to locations other than cold storage in real time.</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/ezp8gcf3gXqkvumzufGfP/1a54fc6f434290968c7e695c2e5bb0c9/6.png" alt="" class="kg-image" width="1999" height="1280" loading="lazy">
	</figure>
	<p>We implemented read replication in 5 major steps.</p>
	<p>First, we made it possible to make replica Durable Objects with a read-only copy of the database.&nbsp; These replica objects boot by fetching the latest snapshot and replaying the log from cold storage to whatever bookmark primary database’s leader last committed. This basically gave us point-in-time replicas, since without continuous updates, the replicas never updated until the Durable Object restarted.</p>
	<p>Second, we registered the replica leader with the primary’s leader so that the primary leader sends the replicas every entry written to the WAL at the same time that it sends the WAL entries to the durability followers.&nbsp; Each of the WAL entries is marked with a bookmark that uniquely identifies the WAL entry in the sequence of WAL entries.&nbsp; We’ll use the bookmark later.</p>
	<p>Note that since these writes are sent to the replicas <i>before</i> a quorum of durability followers have confirmed them, the writes are actually unconfirmed writes, and the replica leader must be careful to keep the writes hidden from the replica Durable Object until they are confirmed.&nbsp; The replica leader in the Storage Relay Service does this by implementing enough of SQLite’s <a href="https://www.sqlite.org/walformat.html#the_wal_index_file_format"><u>WAL-index protocol</u></a>, so that the unconfirmed writes coming from the primary leader look to SQLite as though it’s just another SQLite client doing unconfirmed writes.&nbsp; SQLite knows to ignore the writes until they are confirmed in the log.&nbsp; The upshot of this is that the replica leader can write WAL entries to the SQLite WAL <i>immediately,</i> and then “commit” them when the primary leader tells the replica that the entries have been confirmed by durability followers.</p>
	<p>One neat thing about this approach is that writes are sent from the primary to the replica as quickly as they are generated by the primary, helping to minimize lag between replicas.&nbsp; In theory, if the write query was proxied through a replica to the primary, the response back to the replica will arrive at almost the same time as the message that updates the replica.&nbsp; In such a case, it looks like there’s no replica lag at all!</p>
	<p>In practice, we find that replication is really fast.&nbsp; Internally, we measure <i>confirm lag</i>, defined as the time from when a primary confirms a change to when the replica confirms a change.&nbsp; The table below shows the confirm lag for two D1 databases whose primaries are in different regions.</p>
	<div style="margin-left:0pt;" dir="ltr" align="center">
		<figure class="table">
			<table class="ck-table-resized" style="border-collapse:collapse;border-style:none;">
				<colgroup>
					<col style="width:33.33%;" width="233">
					<col style="width:33.33%;" width="233">
					<col style="width:33.34%;" width="233">
				</colgroup>
				<tbody>
					<tr style="height:0pt;">
						<td style="border-bottom:2.25pt solid #000000;overflow-wrap:break-word;overflow:hidden;padding:5pt;vertical-align:top;">
							<p style="line-height:1.2;margin-bottom:0pt;margin-top:0pt;" dir="ltr"><br><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">Replica Region</span></span></p>
						</td>
						<td style="border-bottom:2.25pt solid #000000;overflow-wrap:break-word;overflow:hidden;padding:5pt;vertical-align:top;">
							<p style="line-height:1.2;margin-bottom:0pt;margin-top:0pt;text-align:right;" dir="ltr"><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">Database A</span></span></p>
							<p style="line-height:1.2;margin-bottom:0pt;margin-top:0pt;text-align:right;" dir="ltr"><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">(Primary region: ENAM)</span></span></p>
						</td>
						<td style="border-bottom:2.25pt solid #000000;overflow-wrap:break-word;overflow:hidden;padding:5pt;vertical-align:top;">
							<p style="line-height:1.2;margin-bottom:0pt;margin-top:0pt;text-align:right;" dir="ltr"><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">Database B</span></span><br><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">(Primary region: WNAM)</span></span></p>
						</td>
					</tr>
					<tr style="height:0pt;">
						<td style="border-bottom:0.5pt solid #000000;border-top:2.25pt solid #000000;overflow-wrap:break-word;overflow:hidden;padding:5pt;vertical-align:top;">
							<p style="line-height:1.2;margin-bottom:0pt;margin-top:0pt;" dir="ltr"><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">ENAM</span></span></p>
						</td>
						<td style="border-bottom:0.5pt solid #000000;border-top:2.25pt solid #000000;overflow-wrap:break-word;overflow:hidden;padding:5pt;vertical-align:top;">
							<p style="line-height:1.2;margin-bottom:0pt;margin-top:0pt;text-align:right;" dir="ltr"><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">N/A</span></span></p>
						</td>
						<td style="border-bottom:0.5pt solid #000000;border-top:2.25pt solid #000000;overflow-wrap:break-word;overflow:hidden;padding:5pt;vertical-align:top;">
							<p style="line-height:1.2;margin-bottom:0pt;margin-top:0pt;text-align:right;" dir="ltr"><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">30 ms</span></span></p>
						</td>
					</tr>
					<tr style="height:0pt;">
						<td style="border-bottom:0.5pt solid #000000;border-top:0.5pt solid #000000;overflow-wrap:break-word;overflow:hidden;padding:5pt;vertical-align:top;">
							<p style="line-height:1.2;margin-bottom:0pt;margin-top:0pt;" dir="ltr"><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">WNAM</span></span></p>
						</td>
						<td style="border-bottom:0.5pt solid #000000;border-top:0.5pt solid #000000;overflow-wrap:break-word;overflow:hidden;padding:5pt;vertical-align:top;">
							<p style="line-height:1.2;margin-bottom:0pt;margin-top:0pt;text-align:right;" dir="ltr"><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">45 ms</span></span></p>
						</td>
						<td style="border-bottom:0.5pt solid #000000;border-top:0.5pt solid #000000;overflow-wrap:break-word;overflow:hidden;padding:5pt;vertical-align:top;">
							<p style="line-height:1.2;margin-bottom:0pt;margin-top:0pt;text-align:right;" dir="ltr"><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">N/A</span></span></p>
						</td>
					</tr>
					<tr style="height:0pt;">
						<td style="border-bottom:0.5pt solid #000000;border-top:0.5pt solid #000000;overflow-wrap:break-word;overflow:hidden;padding:5pt;vertical-align:top;">
							<p style="line-height:1.2;margin-bottom:0pt;margin-top:0pt;" dir="ltr"><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">WEUR</span></span></p>
						</td>
						<td style="border-bottom:0.5pt solid #000000;border-top:0.5pt solid #000000;overflow-wrap:break-word;overflow:hidden;padding:5pt;vertical-align:top;">
							<p style="line-height:1.2;margin-bottom:0pt;margin-top:0pt;text-align:right;" dir="ltr"><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">55 ms</span></span></p>
						</td>
						<td style="border-bottom:0.5pt solid #000000;border-top:0.5pt solid #000000;overflow-wrap:break-word;overflow:hidden;padding:5pt;vertical-align:top;">
							<p style="line-height:1.2;margin-bottom:0pt;margin-top:0pt;text-align:right;" dir="ltr"><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">75 ms</span></span></p>
						</td>
					</tr>
					<tr style="height:0pt;">
						<td style="border-bottom:2.25pt solid #000000;border-top:0.5pt solid #000000;overflow-wrap:break-word;overflow:hidden;padding:5pt;vertical-align:top;">
							<p style="line-height:1.2;margin-bottom:0pt;margin-top:0pt;" dir="ltr"><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">EEUR</span></span></p>
						</td>
						<td style="border-bottom:2.25pt solid #000000;border-top:0.5pt solid #000000;overflow-wrap:break-word;overflow:hidden;padding:5pt;vertical-align:top;">
							<p style="line-height:1.2;margin-bottom:0pt;margin-top:0pt;text-align:right;" dir="ltr"><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">67 ms</span></span></p>
						</td>
						<td style="border-bottom:2.25pt solid #000000;border-top:0.5pt solid #000000;overflow-wrap:break-word;overflow:hidden;padding:5pt;vertical-align:top;">
							<p style="line-height:1.2;margin-bottom:0pt;margin-top:0pt;text-align:right;" dir="ltr"><span style="background-color:transparent;color:#000000;font-family:Arial,sans-serif;"><span style="font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">75 ms</span></span></p>
						</td>
					</tr>
				</tbody>
			</table>
		</figure>
	</div>
	<p><sup><i>Confirm lag for 2 replicated databases.&nbsp; N/A means that we have no data for this combination.&nbsp; The region abbreviations are the same ones used for </i></sup><a href="https://developers.cloudflare.com/durable-objects/reference/data-location/#supported-locations-1"><sup><i><u>Durable Object location hints</u></i></sup></a><sup><i>.</i></sup></p>
	<p>The table shows that confirm lag is correlated with the network round-trip time between the data centers hosting the primary databases and their replicas.&nbsp; This is clearly visible in the difference between the confirm lag for the European replicas of the two databases.&nbsp; As airline route planners know, EEUR is <a href="http://www.gcmap.com/mapui?P=ewr-lhr%2C+ewr-waw"><u>appreciably further away</u></a> from ENAM than WEUR is, but from WNAM, both European regions (WEUR and EEUR) are <a href="http://www.gcmap.com/mapui?P=sjc-lhr%2C+sjc-waw"><u>about equally as far away</u></a>.&nbsp; We see that in our replication numbers.</p>
	<p>The exact placement of the D1 database in the region matters too.&nbsp; Regions like ENAM and WNAM are quite large in themselves.&nbsp; Database A’s placement in ENAM happens to be further away from most data centers in WNAM compared to database B’s placement in WNAM relative to the ENAM data centers.&nbsp; As such, database B sees slightly lower confirm lag.</p>
	<p>Try as we might, we can’t beat the speed of light!</p>
	<p>Third, we updated the Durable Object routing system to be aware of Durable Object replicas.&nbsp; When read replication is enabled on a Durable Object, two things happen.&nbsp; First, we create a set of replicas according to a replication policy.&nbsp; The current replication policy that D1 uses is simple: a static set of replicas in <a href="https://developers.cloudflare.com/d1/configuration/data-location/#available-location-hints"><u>every region that D1 supports</u></a>.&nbsp; Second, we turn on a routing policy for the Durable Object.&nbsp; The current policy that D1 uses is also simple: route to the Durable Object replica in the region close to where the user request is.&nbsp; With this step, we have updateable read-only replicas, and can route requests to them!</p>
	<p>Fourth, we updated D1’s Durable Object code to handle write queries on replicas. D1 uses SQLite to figure out whether a request is a write query or a read query.&nbsp; This means that the determination of whether something is a read or write query happens <i>after</i> the request is routed.&nbsp; Read replicas will have to handle write requests!&nbsp; We solve this by instantiating each replica D1 Durable Object with a reference to its primary.&nbsp; If the D1 Durable Object determines that the query is a write query, it forwards the request to the primary for the primary to handle. This happens transparently, keeping the user code simple.</p>
	<p>As of this fourth step, we can handle read and write queries at every copy of the D1 Durable Object, whether it's a primary or not.&nbsp; Unfortunately, as outlined above, if a user's requests get routed to different read replicas, they may see different views of the database, leading to a very weak consistency model.&nbsp; So the last step is to implement the Sessions API across the D1 Worker and D1 Durable Object.&nbsp; Recall that every WAL entry is marked with a bookmark.&nbsp; These bookmarks uniquely identify a point in (logical) time in the database.&nbsp; Our bookmarks are strictly monotonically increasing; every write to a database makes a new bookmark with a value greater than any other bookmark for that database.</p>
	<p>Using bookmarks, we implement the Sessions API with the following algorithm split across the D1 binding implementation, the D1 Worker, and D1 Durable Object.</p>
	<p>First up in the D1 binding, we have code that creates the <code>D1DatabaseSession</code> object and code within the <code>D1DatabaseSession</code> object to keep track of the latest bookmark.</p>
	<pre class="language-JavaScript"><code class="language-JavaScript">// D1Binding is the binding code running within the user's Worker
// that provides the existing D1 Workers API and the new withSession method.
class D1Binding {
  // Injected by the runtime to the D1 Binding.
  d1Service: D1ServiceBinding

  function withSession(initialBookmark) {
    return D1DatabaseSession(this.d1Service, this.databaseId, initialBookmark);
  }
}

// D1DatabaseSession holds metadata about the session, most importantly the
// latest bookmark we know about for this session.
class D1DatabaseSession {
  constructor(d1Service, databaseId, initialBookmark) {
    this.d1Service = d1Service;
    this.databaseId = databaseId;
    this.bookmark = initialBookmark;
  }

  async exec(query) {
    // The exec method in the binding sends the query to the D1 Worker
    // and waits for the the response, updating the bookmark as
    // necessary so that future calls to exec use the updated bookmark.
    var resp = await this.d1Service.handleUserQuery(databaseId, query, bookmark);
    if (isNewerBookmark(this.bookmark, resp.bookmark)) {
      this.bookmark = resp.bookmark;
    }
    return resp;
  }

  // batch and other SQL APIs are implemented similarly.
}</code></pre>
	<p>The binding code calls into the D1 stateless Worker (<code>d1Service</code> in the snippet above), which figures out which Durable Object to use, and proxies the request to the Durable Object.</p>
	<pre class="language-JavaScript"><code class="language-JavaScript">class D1Worker {
  async handleUserQuery(databaseId, query) {
    var doId = /* look up Durable Object for databaseId */;
    return await this.D1_DO.get(doId).handleWorkerQuery(query, bookmark)
  }
}</code></pre>
	<p>Finally, we reach the Durable Objects layer, which figures out how to actually handle the request.</p>
	<pre class="language-JavaScript"><code class="language-JavaScript">class D1DurableObject {
  async handleWorkerQuery(queries, bookmark) {
    var bookmark = bookmark ?? "first-primary";
    var results = {};

    if (this.isPrimaryDatabase()) {
      // The primary always has the latest data so we can run the
      // query without checking the bookmark.
      var result = /* execute query directly */;
      bookmark = getCurrentBookmark();
      results = result;
    } else {
      // This is running on a replica.
      if (bookmark === "first-primary" || isWriteQuery(query)) {
        // The primary must handle this request, so we'll proxy the
        // request to the primary.
        var resp = await this.primary.handleWorkerQuery(query, bookmark);
        bookmark = resp.bookmark;
        results = resp.results;
      } else {
        // The replica can handle this request, but only after the
        // database is up-to-date with the bookmark.
        if (bookmark !== "first-unconstrained") {
          await waitForBookmark(bookmark);
        }
        var result = /* execute query locally */;
        bookmark = getCurrentBookmark();
        results = result;
      }
    }
    return { results: results, bookmark: bookmark };
  }
}</code></pre>
	<p>The D1 Durable Object first figures out if this instance can handle the query, or if the query needs to be sent to the primary.&nbsp; If the Durable Object can execute the query, it ensures that we execute the query with a bookmark at least as up-to-date as the bookmark requested by the binding.</p>
	<p>The upshot is that the three pieces of code work together to ensure that all of the queries in the session see the database in a sequentially consistent order, because each new query will be blocked until it has seen the results of previous queries within the same session.</p>
	<div class="flex anchor relative">
		<h2 id="conclusion">Conclusion</h2>
		<a href="https://blog.cloudflare.com/#conclusion" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>D1’s new read replication feature is a significant step towards making globally distributed databases easier to use without sacrificing consistency. With automatically provisioned replicas in every region, your applications can now serve read queries faster while maintaining strong sequential consistency across requests, and keeping your application Worker code simple.</p>
	<p>We’re excited for developers to explore this feature and see how it improves the performance of your applications. The public beta is just the beginning—we’re actively refining and expanding D1’s capabilities, including evolving replica placement policies, and your feedback will help shape what’s next.</p>
	<p>Note that the Sessions API is only available through the <a href="https://developers.cloudflare.com/d1/worker-api"><u>D1 Worker Binding</u></a> for now, and support for the HTTP REST API will follow soon.</p>
	<p>Try out D1 read replication today by clicking the “Deploy to Cloudflare" button, check out <a href="https://developers.cloudflare.com/d1/best-practices/read-replication"><u>documentation and examples</u></a>, and let us know what you build in the <a href="https://discord.com/channels/595317990191398933/992060581832032316"><u>D1 Discord channel</u></a>!</p><a href="https://deploy.workers.cloudflare.com/?url=https%3A%2F%2Fgithub.com%2Fcloudflare%2Ftemplates%2Ftree%2Fmain%2Fd1-starter-sessions-api-template"><img src="https://deploy.workers.cloudflare.com/button" alt="Deploy to Cloudflare"></a>
	<p></p>
	<p></p>
</div>