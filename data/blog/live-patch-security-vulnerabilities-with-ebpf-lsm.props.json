{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "5",
	"locale": "en-us",
	"localesAvailable": [
		"zh-cn",
		"zh-tw"
	],
	"post": {
		"authors": [
			{
				"name": "Frederick Lawler",
				"slug": "frederick",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/69T4vzED8P3z82sjq20ktB/3602d21ed4cd710e4d34e5e99a61245d/frederick.jpg",
				"location": null,
				"website": null,
				"twitter": null,
				"facebook": null,
				"publiclyIndex": true
			}
		],
		"excerpt": "Learn how to patch Linux security vulnerabilities without rebooting the hardware and how to tighten the security of your Linux operating system with eBPF Linux Security Module",
		"feature_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1AScqEBDJJJSB1rEYb3VYV/23bb407471fa3e38579f90fbbf9430f9/live-patch-security-vulnerabilities-with-ebpf-lsm.png",
		"featured": false,
		"html": "\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/41kYAOy7BtoTL9KLr7sANN/921c5eba31c107c5d59bf57264fb7851/image1-57.png\" alt=\"Live-patching security vulnerabilities inside the Linux kernel with eBPF Linux Security Module\" class=\"kg-image\" width=\"1894\" height=\"947\" loading=\"lazy\"/>\n            \n            </figure><p><a href=\"https://www.kernel.org/doc/html/latest/admin-guide/LSM/index.html\">Linux Security Modules</a> (LSM) is a hook-based framework for implementing security policies and Mandatory Access Control in the Linux kernel. Until recently users looking to implement a security policy had just two options. Configure an existing LSM module such as AppArmor or SELinux, or write a custom kernel module.</p><p><a href=\"https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.7\">Linux 5.7</a> introduced a third way: <a href=\"https://docs.kernel.org/bpf/prog_lsm.html\">LSM extended Berkeley Packet Filters (eBPF)</a> (LSM BPF for short). LSM BPF allows developers to write granular policies without configuration or loading a kernel module. LSM BPF programs are verified on load, and then executed when an LSM hook is reached in a call path.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"lets-solve-a-real-world-problem\">Let’s solve a real-world problem</h2>\n            <a href=\"#lets-solve-a-real-world-problem\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Modern operating systems provide facilities allowing &quot;partitioning&quot; of kernel resources. For example FreeBSD has &quot;jails&quot;, Solaris has &quot;zones&quot;. Linux is different - it provides a set of seemingly independent facilities each allowing isolation of a specific resource. These are called &quot;namespaces&quot; and have been growing in the kernel for years. They are the base of popular tools like Docker, lxc or firejail. Many of the namespaces are uncontroversial, like the UTS namespace which allows the host system to hide its hostname and time. Others are complex but straightforward - NET and NS (mount) namespaces are known to be hard to wrap your head around. Finally, there is this very special very curious USER namespace.</p><p>USER namespace is special, since it allows the owner to operate as &quot;root&quot; inside it. How it works is beyond the scope of this blog post, however, suffice to say it&#39;s a foundation to having tools like Docker to not operate as true root, and things like rootless containers.</p><p>Due to its nature, allowing unpriviledged users access to USER namespace always carried a great security risk.  One such risk is privilege escalation.</p><p>Privilege escalation is a <a href=\"https://www.cloudflare.com/learning/security/what-is-an-attack-surface/\">common attack surface</a> for operating systems. One way users may gain privilege is by mapping their namespace to the root namespace via the unshare <a href=\"https://en.wikipedia.org/wiki/System_call\">syscall</a> and specifying the <i>CLONE_NEWUSER</i> flag. This tells unshare to create a new user namespace with full permissions, and maps the new user and group ID to the previous namespace. You can use the <a href=\"https://man7.org/linux/man-pages/man1/unshare.1.html\">unshare(1)</a> program to map root to our original namespace:</p>\n            <pre class=\"language-sh\"><code class=\"language-sh\">$ id\nuid=1000(fred) gid=1000(fred) groups=1000(fred) …\n$ unshare -rU\n# id\nuid=0(root) gid=0(root) groups=0(root),65534(nogroup)\n# cat /proc/self/uid_map\n         0       1000          1</pre></code>\n            <p>In most cases using unshare is harmless, and is intended to run with lower privileges. However, this syscall has been known to be used to <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-0492\">escalate privileges</a>.</p><p>Syscalls <i>clone</i> and <i>clone3</i> are worth looking into as they also have the ability to <i>CLONE_NEWUSER</i>. However, for this post we’re going to focus on unshare.</p><p>Debian solved this problem with this <a href=\"https://sources.debian.org/patches/linux/3.16.56-1+deb8u1/debian/add-sysctl-to-disallow-unprivileged-CLONE_NEWUSER-by-default.patch/\">&quot;add sysctl to disallow unprivileged CLONE_NEWUSER by default&quot;</a> patch, but it was not mainlined. Another similar patch <a href=\"https://lore.kernel.org/all/1453502345-30416-3-git-send-email-keescook@chromium.org/\">&quot;sysctl: allow CLONE_NEWUSER to be disabled&quot;</a> attempted to mainline, and was met with push back. A critique is the <a href=\"https://lore.kernel.org/all/87poq5y0jw.fsf@x220.int.ebiederm.org/\">inability to toggle this feature</a> for specific applications. In the article “<a href=\"https://lwn.net/Articles/673597/\">Controlling access to user namespaces</a>” the author wrote: “... the current patches do not appear to have an easy path into the mainline.” And as we can see, the patches were ultimately not included in the vanilla kernel.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"our-solution-lsm-bpf\">Our solution - LSM BPF</h2>\n            <a href=\"#our-solution-lsm-bpf\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Since upstreaming code that restricts USER namespace seem to not be an option, we decided to use LSM BPF to circumvent these issues. This requires no modifications to the kernel and allows us to express complex rules guarding the access.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"track-down-an-appropriate-hook-candidate\">Track down an appropriate hook candidate</h3>\n            <a href=\"#track-down-an-appropriate-hook-candidate\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>First, let us track down the syscall we’re targeting. We can find the prototype in the <a href=\"https://elixir.bootlin.com/linux/v5.18/source/include/linux/syscalls.h#L608\"><i>include/linux/syscalls.h</i></a> file. From there, it’s not as obvious to track down, but the line:</p>\n            <pre class=\"language-c\"><code class=\"language-c\">/* kernel/fork.c */</pre></code>\n            <p>Gives us a clue of where to look next in <a href=\"https://elixir.bootlin.com/linux/v5.18/source/kernel/fork.c#L3201\"><i>kernel/fork.c</i></a>. There a call to <a href=\"https://elixir.bootlin.com/linux/v5.18/source/kernel/fork.c#L3082\"><i>ksys_unshare()</i></a> is made. Digging through that function, we find a call to <a href=\"https://elixir.bootlin.com/linux/v5.18/source/kernel/fork.c#L3129\"><i>unshare_userns()</i></a>. This looks promising.</p><p>Up to this point, we’ve identified the syscall implementation, but the next question to ask is what hooks are available for us to use? Because we know from the <a href=\"https://man7.org/linux/man-pages/man2/unshare.2.html\">man-pages</a> that unshare is used to mutate tasks, we look at the task-based hooks in <a href=\"https://elixir.bootlin.com/linux/v5.18/source/include/linux/lsm_hooks.h#L605\"><i>include/linux/lsm_hooks.h</i></a>. Back in the function <a href=\"https://elixir.bootlin.com/linux/v5.18/source/kernel/user_namespace.c#L171\"><i>unshare_userns()</i></a> we saw a call to <a href=\"https://elixir.bootlin.com/linux/v5.18/source/kernel/cred.c#L252\"><i>prepare_creds()</i></a>. This looks very familiar to the <a href=\"https://elixir.bootlin.com/linux/v5.18/source/include/linux/lsm_hooks.h#L624\"><i>cred_prepare</i></a> hook. To verify we have our match via <a href=\"https://elixir.bootlin.com/linux/v5.18/source/kernel/cred.c#L291\"><i>prepare_creds()</i></a>, we see a call to the security hook <a href=\"https://elixir.bootlin.com/linux/v5.18/source/security/security.c#L1706\"><i>security_prepare_creds()</i></a> which ultimately calls the hook:</p>\n            <pre class=\"language-c\"><code class=\"language-c\">…\nrc = call_int_hook(cred_prepare, 0, new, old, gfp);\n…</pre></code>\n            <p>Without going much further down this rabbithole, we know this is a good hook to use because <i>prepare_creds()</i> is called right before <i>create_user_ns()</i> in <a href=\"https://elixir.bootlin.com/linux/v5.18/source/kernel/user_namespace.c#L181\"><i>unshare_userns()</i></a> which is the operation we’re trying to block.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"lsm-bpf-solution\">LSM BPF solution</h3>\n            <a href=\"#lsm-bpf-solution\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>We’re going to compile with the <a href=\"https://nakryiko.com/posts/bpf-core-reference-guide/#defining-own-co-re-relocatable-type-definitions\">eBPF compile once-run everywhere (CO-RE)</a> approach. This allows us to compile on one architecture and load on another. But we’re going to target x86_64 specifically. LSM BPF for ARM64 is still in development, and the following code will not run on that architecture. Watch the <a href=\"https://lore.kernel.org/bpf/\">BPF mailing list</a> to follow the progress.</p><p>This solution was tested on kernel versions &gt;= 5.15 configured with the following:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">BPF_EVENTS\nBPF_JIT\nBPF_JIT_ALWAYS_ON\nBPF_LSM\nBPF_SYSCALL\nBPF_UNPRIV_DEFAULT_OFF\nDEBUG_INFO_BTF\nDEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT\nDYNAMIC_FTRACE\nFUNCTION_TRACER\nHAVE_DYNAMIC_FTRACE</pre></code>\n            <p>A boot option <code>lsm=bpf</code> may be necessary if <code>CONFIG_LSM</code> does not contain “bpf” in the list.</p><p>Let’s start with our preamble:</p><p><i>deny_unshare.bpf.c</i>:</p>\n            <pre class=\"language-c\"><code class=\"language-c\">#include &lt;linux/bpf.h&gt;\n#include &lt;linux/capability.h&gt;\n#include &lt;linux/errno.h&gt;\n#include &lt;linux/sched.h&gt;\n#include &lt;linux/types.h&gt;\n\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n\n#define X86_64_UNSHARE_SYSCALL 272\n#define UNSHARE_SYSCALL X86_64_UNSHARE_SYSCALL</pre></code>\n            <p>Next we set up our necessary structures for CO-RE relocation in the following way:</p><p><i>deny_unshare.bpf.c</i>:</p>\n            <pre class=\"language-c\"><code class=\"language-c\">…\n\ntypedef unsigned int gfp_t;\n\nstruct pt_regs {\n\tlong unsigned int di;\n\tlong unsigned int orig_ax;\n} __attribute__((preserve_access_index));\n\ntypedef struct kernel_cap_struct {\n\t__u32 cap[_LINUX_CAPABILITY_U32S_3];\n} __attribute__((preserve_access_index)) kernel_cap_t;\n\nstruct cred {\n\tkernel_cap_t cap_effective;\n} __attribute__((preserve_access_index));\n\nstruct task_struct {\n    unsigned int flags;\n    const struct cred *cred;\n} __attribute__((preserve_access_index));\n\nchar LICENSE[] SEC(&quot;license&quot;) = &quot;GPL&quot;;\n\n…</pre></code>\n            <p>We don’t need to fully-flesh out the structs; we just need the absolute minimum information a program needs to function. CO-RE will do whatever is necessary to perform the relocations for your kernel. This makes writing the LSM BPF programs easy!</p><p><i>deny_unshare.bpf.c</i>:</p>\n            <pre class=\"language-c\"><code class=\"language-c\">SEC(&quot;lsm/cred_prepare&quot;)\nint BPF_PROG(handle_cred_prepare, struct cred *new, const struct cred *old,\n             gfp_t gfp, int ret)\n{\n    struct pt_regs *regs;\n    struct task_struct *task;\n    kernel_cap_t caps;\n    int syscall;\n    unsigned long flags;\n\n    // If previous hooks already denied, go ahead and deny this one\n    if (ret) {\n        return ret;\n    }\n\n    task = bpf_get_current_task_btf();\n    regs = (struct pt_regs *) bpf_task_pt_regs(task);\n    // In x86_64 orig_ax has the syscall interrupt stored here\n    syscall = regs-&gt;orig_ax;\n    caps = task-&gt;cred-&gt;cap_effective;\n\n    // Only process UNSHARE syscall, ignore all others\n    if (syscall != UNSHARE_SYSCALL) {\n        return 0;\n    }\n\n    // PT_REGS_PARM1_CORE pulls the first parameter passed into the unshare syscall\n    flags = PT_REGS_PARM1_CORE(regs);\n\n    // Ignore any unshare that does not have CLONE_NEWUSER\n    if (!(flags &amp; CLONE_NEWUSER)) {\n        return 0;\n    }\n\n    // Allow tasks with CAP_SYS_ADMIN to unshare (already root)\n    if (caps.cap[CAP_TO_INDEX(CAP_SYS_ADMIN)] &amp; CAP_TO_MASK(CAP_SYS_ADMIN)) {\n        return 0;\n    }\n\n    return -EPERM;\n}</pre></code>\n            <p>Creating the program is the first step, the second is loading and attaching the program to our desired hook. There are several ways to do this: <a href=\"https://github.com/cilium/ebpf\">Cilium ebpf</a> project, <a href=\"https://github.com/libbpf/libbpf-rs\">Rust bindings</a>, and several others on the <a href=\"https://ebpf.io/projects/\">ebpf.io</a> project landscape page. We’re going to use native libbpf.</p><p><i>deny_unshare.c</i>:</p>\n            <pre class=\"language-c\"><code class=\"language-c\">#include &lt;bpf/libbpf.h&gt;\n#include &lt;unistd.h&gt;\n#include &quot;deny_unshare.skel.h&quot;\n\nstatic int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args)\n{\n    return vfprintf(stderr, format, args);\n}\n\nint main(int argc, char *argv[])\n{\n    struct deny_unshare_bpf *skel;\n    int err;\n\n    libbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n    libbpf_set_print(libbpf_print_fn);\n\n    // Loads and verifies the BPF program\n    skel = deny_unshare_bpf__open_and_load();\n    if (!skel) {\n        fprintf(stderr, &quot;failed to load and verify BPF skeleton\\n&quot;);\n        goto cleanup;\n    }\n\n    // Attaches the loaded BPF program to the LSM hook\n    err = deny_unshare_bpf__attach(skel);\n    if (err) {\n        fprintf(stderr, &quot;failed to attach BPF skeleton\\n&quot;);\n        goto cleanup;\n    }\n\n    printf(&quot;LSM loaded! ctrl+c to exit.\\n&quot;);\n\n    // The BPF link is not pinned, therefore exiting will remove program\n    for (;;) {\n        fprintf(stderr, &quot;.&quot;);\n        sleep(1);\n    }\n\ncleanup:\n    deny_unshare_bpf__destroy(skel);\n    return err;\n}</pre></code>\n            <p>Lastly, to compile, we use the following Makefile:</p><p><i>Makefile</i>:</p>\n            <pre class=\"language-makefile\"><code class=\"language-makefile\">CLANG ?= clang-13\nLLVM_STRIP ?= llvm-strip-13\nARCH := x86\nINCLUDES := -I/usr/include -I/usr/include/x86_64-linux-gnu\nLIBS_DIR := -L/usr/lib/lib64 -L/usr/lib/x86_64-linux-gnu\nLIBS := -lbpf -lelf\n\n.PHONY: all clean run\n\nall: deny_unshare.skel.h deny_unshare.bpf.o deny_unshare\n\nrun: all\n\tsudo ./deny_unshare\n\nclean:\n\trm -f *.o\n\trm -f deny_unshare.skel.h\n\n#\n# BPF is kernel code. We need to pass -D__KERNEL__ to refer to fields present\n# in the kernel version of pt_regs struct. uAPI version of pt_regs (from ptrace)\n# has different field naming.\n# See: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=fd56e0058412fb542db0e9556f425747cf3f8366\n#\ndeny_unshare.bpf.o: deny_unshare.bpf.c\n\t$(CLANG) -g -O2 -Wall -target bpf -D__KERNEL__ -D__TARGET_ARCH_$(ARCH) $(INCLUDES) -c $&lt; -o $@\n\t$(LLVM_STRIP) -g $@ # Removes debug information\n\ndeny_unshare.skel.h: deny_unshare.bpf.o\n\tsudo bpftool gen skeleton $&lt; &gt; $@\n\ndeny_unshare: deny_unshare.c deny_unshare.skel.h\n\t$(CC) -g -Wall -c $&lt; -o $@.o\n\t$(CC) -g -o $@ $(LIBS_DIR) $@.o $(LIBS)\n\n.DELETE_ON_ERROR:</pre></code>\n            \n          <div class=\"flex anchor relative\">\n            <h3 id=\"result\">Result</h3>\n            <a href=\"#result\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>In a new terminal window run:</p>\n            <pre class=\"language-sh\"><code class=\"language-sh\">$ make run\n…\nLSM loaded! ctrl+c to exit.</pre></code>\n            <p>In another terminal window, we’re successfully blocked!</p>\n            <pre class=\"language-sh\"><code class=\"language-sh\">$ unshare -rU\nunshare: unshare failed: Cannot allocate memory\n$ id\nuid=1000(fred) gid=1000(fred) groups=1000(fred) …</pre></code>\n            <p>The policy has an additional feature to always allow privilege pass through:</p>\n            <pre class=\"language-sh\"><code class=\"language-sh\">$ sudo unshare -rU\n# id\nuid=0(root) gid=0(root) groups=0(root)</pre></code>\n            <p>In the unprivileged case the syscall early aborts. What is the performance impact in the privileged case?</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"measure-performance\">Measure performance</h3>\n            <a href=\"#measure-performance\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>We’re going to use a one-line unshare that’ll map the user namespace, and execute a command within for the measurements:</p>\n            <pre class=\"language-sh\"><code class=\"language-sh\">$ unshare -frU --kill-child -- bash -c &quot;exit 0&quot;</pre></code>\n            <p>With a resolution of CPU cycles for syscall unshare enter/exit, we’ll measure the following as root user:</p><ol><li><p>Command ran without the policy</p></li><li><p>Command run with the policy</p></li></ol><p>We’ll record the measurements with <a href=\"https://docs.kernel.org/trace/ftrace.html\">ftrace</a>:</p>\n            <pre class=\"language-sh\"><code class=\"language-sh\">$ sudo su\n# cd /sys/kernel/debug/tracing\n# echo 1 &gt; events/syscalls/sys_enter_unshare/enable ; echo 1 &gt; events/syscalls/sys_exit_unshare/enable</pre></code>\n            <p>At this point, we’re enabling tracing for the syscall enter and exit for unshare specifically. Now we set the time-resolution of our enter/exit calls to count CPU cycles:</p>\n            <pre class=\"language-sh\"><code class=\"language-sh\"># echo &#039;x86-tsc&#039; &gt; trace_clock </pre></code>\n            <p>Next we begin our measurements:</p>\n            <pre class=\"language-sh\"><code class=\"language-sh\"># unshare -frU --kill-child -- bash -c &quot;exit 0&quot; &amp;\n[1] 92014</pre></code>\n            <p>Run the policy in a new terminal window, and then run our next syscall:</p>\n            <pre class=\"language-sh\"><code class=\"language-sh\"># unshare -frU --kill-child -- bash -c &quot;exit 0&quot; &amp;\n[2] 92019</pre></code>\n            <p>Now we have our two calls for comparison:</p>\n            <pre class=\"language-sh\"><code class=\"language-sh\"># cat trace\n# tracer: nop\n#\n# entries-in-buffer/entries-written: 4/4   #P:8\n#\n#                                _-----=&gt; irqs-off\n#                               / _----=&gt; need-resched\n#                              | / _---=&gt; hardirq/softirq\n#                              || / _--=&gt; preempt-depth\n#                              ||| / _-=&gt; migrate-disable\n#                              |||| /     delay\n#           TASK-PID     CPU#  |||||  TIMESTAMP  FUNCTION\n#              | |         |   |||||     |         |\n         unshare-92014   [002] ..... 762950852559027: sys_unshare(unshare_flags: 10000000)\n         unshare-92014   [002] ..... 762950852622321: sys_unshare -&gt; 0x0\n         unshare-92019   [007] ..... 762975980681895: sys_unshare(unshare_flags: 10000000)\n         unshare-92019   [007] ..... 762975980752033: sys_unshare -&gt; 0x0\n</pre></code>\n            <p>unshare-92014 used 63294 cycles.unshare-92019 used 70138 cycles.</p><p>We have a 6,844 (~10%) cycle penalty between the two measurements. Not bad!</p><p>These numbers are for a single syscall, and add up the more frequently the code is called. Unshare is typically called at task creation, and not repeatedly during normal execution of a program. Careful consideration and measurement is needed for your use case.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"outro\">Outro</h2>\n            <a href=\"#outro\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>We learned a bit about what LSM BPF is, how unshare is used to map a user to root, and how to solve a real-world problem by implementing a solution in eBPF. Tracking down the appropriate hook is not an easy task, and requires a bit of playing and a lot of kernel code. Fortunately, that’s the hard part. Because a policy is written in C, we can granularly tweak the policy to our problem. This means one may extend this policy with an allow-list to allow certain programs or users to continue to use an unprivileged unshare. Finally, we looked at the performance impact of this program, and saw the overhead is worth blocking the attack vector.</p><p>“Cannot allocate memory” is not a clear error message for denying permissions. We proposed a <a href=\"https://lore.kernel.org/all/20220608150942.776446-1-fred@cloudflare.com/\">patch</a> to propagate error codes from the <i>cred_prepare</i> hook up the call stack. Ultimately we came to the conclusion that a new hook is better suited to this problem. Stay tuned!</p>",
		"id": "2AGA68zpZ0kGK4kfyvQ5Fa",
		"localeList": {
			"name": "Live-patching security vulnerabilities inside the Linux kernel with eBPF Linux Security Module Config",
			"enUS": "English for Locale",
			"zhCN": "Translated for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "Translated for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "Learn how to patch Linux security vulnerabilities without rebooting the hardware and how to tighten the security of your Linux operating system with eBPF Linux Security Module.",
		"metadata": {
			"title": "Live-patching security vulnerabilities inside the Linux kernel with eBPF Linux Security Module",
			"description": "Learn how to patch Linux security vulnerabilities without rebooting the hardware and how to tighten the security of your Linux operating system with eBPF Linux Security Module.",
			"imgPreview": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1T1WbFDlQxnohg7e9qiK4s/727f5c10f363e77cbbb6c4c29ba495c8/live-patch-security-vulnerabilities-with-ebpf-lsm-0JAtqD.png"
		},
		"primary_author": {},
		"publicly_index": true,
		"published_at": "2022-06-29T12:45:00.000+01:00",
		"slug": "live-patch-security-vulnerabilities-with-ebpf-lsm",
		"tags": [
			{
				"id": "383iv0UQ6Lp0GZwOAxGq2p",
				"name": "Linux",
				"slug": "linux"
			},
			{
				"id": "6Mp7ouACN2rT3YjL1xaXJx",
				"name": "Security",
				"slug": "security"
			},
			{
				"id": "2UVIYusJwlvsmPYl2AvSuR",
				"name": "Deep Dive",
				"slug": "deep-dive"
			},
			{
				"id": "6lhzEBz2B56RKa4nUEAGYJ",
				"name": "Programming",
				"slug": "programming"
			}
		],
		"title": "Live-patching security vulnerabilities inside the Linux kernel with eBPF Linux Security Module",
		"updated_at": "2024-10-09T23:19:25.801Z",
		"url": "https://blog.cloudflare.com/live-patch-security-vulnerabilities-with-ebpf-lsm"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.icon_aria_label": "Search",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"search.result_stat_empty": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong>",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"search.autocomplete_title": "Insert a query. Press enter to send",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}