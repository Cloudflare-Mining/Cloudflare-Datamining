{
	"initialReadingTime": "16",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Brendan Irvine-Broque",
				"slug": "brendan-irvine-broque",
				"bio": "Product Manager, Cloudflare Stream",
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/lTJBFKfbqthKbJKPvulre/95c7595893b1ac001941ddddeafadeac/brendan-irvine-broque.JPG",
				"location": "Oakland, CA",
				"website": "https://www.cloudflare.com/products/cloudflare-stream/",
				"twitter": "@irvinebroque",
				"facebook": null
			},
			{
				"name": "Thomas Lefebvre",
				"slug": "thomas",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/6olw7cJNP8SN0qnNsDbwOf/630e6539be032aded6cf0c0d3025dbec/thomas.jpg",
				"location": null,
				"website": null,
				"twitter": null,
				"facebook": null
			},
			{
				"name": "Mike Nomitch",
				"slug": "mike-nomitch",
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/3Ub221L51x1p3FZJbnblyn/6bf736c1c4f9abcdf38924bf7feb6011/_tmp_mini_magick20240415-2-6izqhi.jpg"
			}
		],
		"excerpt": "We’ve been working on something new — a platform for running containers across Cloudflare’s network. We already use it in production, for AI inference and more. Today we want to share an early look at how it’s built, why we built it, and how we use it ourselves.\n",
		"feature_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/6uXyuXT5ofnG9x4JGrR7jv/75c65f8e5c12f0913c0bed09416f2c1b/BLOG-2573_1.png",
		"featured": false,
		"html": "<p>We’ve been working on something new — a platform for running containers across Cloudflare’s network. We already use it in production for <a href=\"https://developers.cloudflare.com/workers-ai/\"><u>Workers AI</u></a>, <a href=\"https://developers.cloudflare.com/workers/ci-cd/\"><u>Workers Builds</u></a>, <a href=\"https://www.cloudflare.com/zero-trust/products/browser-isolation/\"><u>Remote Browsing Isolation</u></a>, and the <a href=\"https://developers.cloudflare.com/browser-rendering/\"><u>Browser Rendering API</u></a>. Today, we want to share an early look at how it’s built, why we built it, and how we use it ourselves.</p><p>In 2024, Cloudflare Workers celebrates its 7th birthday. <a href=\"https://blog.cloudflare.com/introducing-cloudflare-workers/\"><u>When we first announced Workers</u></a>, it was a completely new model for running compute in a multi-tenant way — on isolates, as opposed to containers. While, at the time, Workers was a pretty bare-bones functions-as-a-service product, we took a big bet that this was going to become the way software was going to be written going forward. Since introducing Workers, in addition to expanding our developer products in general to include storage and AI, we have been steadily adding more compute capabilities to Workers:</p><table><tr><td><p><b>2020</b></p></td><td><p><a href=\"https://blog.cloudflare.com/introducing-cron-triggers-for-cloudflare-workers/\"><u>Cron Triggers</u></a></p></td></tr><tr><td><p><b>2021</b></p></td><td><p><a href=\"https://blog.cloudflare.com/durable-objects-easy-fast-correct-choose-three/\"><u>Durable Objects</u></a></p><p><a href=\"https://blog.cloudflare.com/workers-rust-sdk/\"><u>Write Workers in Rust</u></a></p><p><a href=\"https://blog.cloudflare.com/introducing-worker-services/\"><u>Service Bindings</u></a></p></td></tr><tr><td><p><b>2022</b></p></td><td><p><a href=\"https://blog.cloudflare.com/introducing-cloudflare-queues/\"><u>Queues</u></a></p><p><a href=\"https://blog.cloudflare.com/announcing-route-to-workers/\"><u>Email Workers</u></a></p><p><a href=\"https://blog.cloudflare.com/durable-objects-alarms/\"><u>Durable Objects Alarms</u></a></p></td></tr><tr><td><p><b>2023</b></p></td><td><p><a href=\"https://blog.cloudflare.com/workers-tcp-socket-api-connect-databases/\"><u>Workers TCP Socket API</u></a> </p><p><a href=\"https://blog.cloudflare.com/hyperdrive-making-regional-databases-feel-distributed/\"><u>Hyperdrive</u></a></p><p><a href=\"https://blog.cloudflare.com/announcing-workers-smart-placement/\"><u>Smart Placement</u></a></p><p><a href=\"https://blog.cloudflare.com/best-place-region-earth-inference/\"><u>Workers AI</u></a></p></td></tr><tr><td><p><b>2024</b></p></td><td><p><a href=\"https://blog.cloudflare.com/python-workers/\"><u>Python Workers</u></a></p><p><a href=\"https://blog.cloudflare.com/javascript-native-rpc/\"><u>JavaScript-native RPC</u></a></p><p><a href=\"https://blog.cloudflare.com/more-npm-packages-on-cloudflare-workers-combining-polyfills-and-native-code/\"><u>Node.js compatibility</u></a></p><p><a href=\"https://blog.cloudflare.com/sqlite-in-durable-objects\"><u>SQLite in Durable Objects</u></a></p></td></tr></table><p>With each of these, we’ve faced a question — can we build this natively into the platform, in a way that removes, rather than adds complexity? Can we build it in a way that lets developers focus on building and shipping, rather than managing infrastructure, so that they don’t have to be a distributed systems engineer to build distributed systems?</p><p>In each instance, the answer has been YES. We try to solve problems in a way that simplifies things for developers in the long run, even if that is the harder path for us to take ourselves. If we didn’t, you’d be right to ask — why not self-host and manage all of this myself? What’s the point of the cloud if I’m still provisioning and managing infrastructure? These are the questions many are asking today about the earlier generation of cloud providers.</p><p>Pushing ourselves to build platform-native products and features helped us answer this question. Particularly because some of these actually use containers behind the scenes, even though as a developer you never interact with or think about containers yourself.</p><p>If you’ve used AI inference on GPUs with <a href=\"https://developers.cloudflare.com/workers-ai/\"><u>Workers AI</u></a>, spun up headless browsers with <a href=\"https://developers.cloudflare.com/browser-rendering/\"><u>Browser Rendering</u></a>, or enqueued build jobs with the new <a href=\"https://developers.cloudflare.com/workers/ci-cd/\"><u>Workers Builds</u></a>, you’ve run containers on our network, without even knowing it. But to do so, we needed to be able to run untrusted code across Cloudflare’s network, outside a <a href=\"https://developers.cloudflare.com/workers/reference/how-workers-works/#isolates\"><u>v8 isolate</u></a>, in a way that fits what we promise:</p><ol><li><p>You shouldn’t have to think about regions or data centers. Routing, scaling, load balancing, scheduling, and capacity are our problem to solve, not yours, with tools like <a href=\"https://blog.cloudflare.com/announcing-workers-smart-placement/\"><u>Smart Placement</u></a>.</p></li><li><p>You should be able to build distributed systems without being a distributed systems engineer.</p></li><li><p>Every millisecond matters — Cloudflare has to be fast.</p></li></ol><p>There wasn’t an off-the-shelf container platform that solved for what we needed, so we built it ourselves — from scheduling to IP address management, pulling and caching images, to improving startup times and more. Our container platform powers many of our newest products, so we wanted to share how we built it, optimized it, and well, you can probably guess what’s next.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"global-scheduling-the-network-is-the-computer\">Global scheduling — “The Network is the Computer”</h2>\n            <a href=\"#global-scheduling-the-network-is-the-computer\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Cloudflare serves the entire world — region: earth. Rather than asking developers to provision resources in specific regions, data centers and availability zones, we think <a href=\"https://blog.cloudflare.com/the-network-is-the-computer/\"><u>“The Network is the Computer”</u></a>. When you build on Cloudflare, you build software that runs on the Internet, not just in a data center.</p><p>When we started working on this, Cloudflare’s architecture was to just run every service via <a href=\"https://systemd.io/\"><u>systemd</u></a> on every server (we call them “metals” — we <a href=\"https://blog.cloudflare.com/gen-12-servers\"><u>run our own hardware</u></a>), allowing all services to take advantage of new capacity we add to our network. That fits running <a href=\"https://blog.cloudflare.com/upgrading-one-of-the-oldest-components-in-cloudflare-software-stack/\"><u>NGINX</u></a> and a few dozen other services, but cannot fit a world where we need to run <i>many thousands</i> of different compute heavy, resource hungry workloads. We’d <a href=\"https://blog.cloudflare.com/its-crowded-in-here/\"><u>run out of space</u></a> just trying to load all of them! Consider a canonical AI workload — deploying <a href=\"https://blog.cloudflare.com/meta-llama-3-1-available-on-workers-ai/\"><u>Llama 3.1 8B</u></a> to an inference server. If we simply ran a Llama 3.1 8B service on every Cloudflare metal, we’d have no flexibility to use GPUs for the <a href=\"https://developers.cloudflare.com/workers-ai/models/\"><u>many other models</u></a> that Workers AI supports.</p><p>We needed something that would allow us to still take advantage of the full capacity of Cloudflare’s entire network, not just the capacity of individual machines. And ideally not put that burden on the developer.</p><p>The answer: we built a control plane on our own Developer Platform that lets us schedule a container anywhere on <a href=\"https://www.cloudflare.com/en-gb/network/\"><u>Cloudflare’s Network</u></a>:</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/63nPDnWzVLvx2OB9ZPZXM5/3c0b8d46258be3bc3263db271a3dc73a/BLOG-2573_2.png\" alt=\"BLOG-2573 2\" class=\"kg-image\" width=\"1999\" height=\"1277\" loading=\"lazy\"/>\n          </figure><p>The global scheduler is built on Cloudflare <a href=\"https://developers.cloudflare.com/workers/\"><u>Workers</u></a>, <a href=\"https://developers.cloudflare.com/durable-objects/\"><u>Durable Objects</u></a>, and <a href=\"https://developers.cloudflare.com/kv/\"><u>KV</u></a>, and decides which Cloudflare location to schedule the container to run in. Each location then runs <i>its own</i> scheduler, which decides which metals within that location to schedule the container to run on. Location schedulers monitor compute capacity, and expose this to the global scheduler. This allows Cloudflare to dynamically place workloads based on capacity and hardware availability (e.g. multiple types of GPUs) across our network.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"why-does-global-scheduling-matter\">Why does global scheduling matter?</h2>\n            <a href=\"#why-does-global-scheduling-matter\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>When you run compute on a first generation cloud, the “contract” between the developer and the platform is that the developer must specify what runs where. This is regional scheduling, the status quo.</p><p>Let’s imagine for a second if we applied regional scheduling to running compute on Cloudflare’s network, with locations in <a href=\"https://www.cloudflare.com/en-gb/network/\"><u>330+ cities, across 120+ countries</u></a>. One of the obvious reasons people tell us they want to run on Cloudflare is because we have compute in places where others don’t, within 50ms of 95% of the world’s Internet-connected population. In South America, other clouds have one region in one city. Cloudflare has 19:</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/53Ba51lqKDRNQPbEBselC3/541a92d1e2702cc61d3e6c2f97d48c4d/BLOG-2573_3.png\" alt=\"BLOG-2573 3\" class=\"kg-image\" width=\"1044\" height=\"492\" loading=\"lazy\"/>\n          </figure><p>Running anywhere means you can be faster, highly available, and have more control over data location. But with regional scheduling, the more locations you run in, the more work you have to do. You configure and manage load balancing, routing, auto-scaling policies and more. Balancing performance and cost in a multi-region setup is literally a full-time job (or more) at most companies who have reached meaningful scale on traditional clouds.</p><p>But most importantly, no matter what tools you bring, you were the one who told the cloud provider, “run this container over here”. The cloud platform can’t move it for you, even if moving it would make your workload faster. This prevents the platform from adding locations, because for each location, it has to convince developers to take action themselves to move their compute workloads to the new location. Each new location carries a risk that developers won’t migrate workloads to it, or migrate too slowly, delaying the return on investment.</p><p>Global scheduling means Cloudflare can add capacity and use it immediately, letting you benefit from it. The “contract” between us and our customers isn’t tied to a specific datacenter or region, so we have permission to move workloads around to benefit customers. This flexibility plays an essential role in all of our own uses of our container platform, starting with GPUs and AI.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"gpus-everywhere-scheduling-large-images-with-workers-ai\">GPUs everywhere: Scheduling large images with Workers AI</h2>\n            <a href=\"#gpus-everywhere-scheduling-large-images-with-workers-ai\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>In late 2023, <a href=\"https://blog.cloudflare.com/workers-ai/\"><u>we launched Workers AI</u></a>, which provides fast, easy to use, and affordable GPU-backed AI inference.</p><p>The more efficiently we can use our capacity, the better pricing we can offer. And the faster we can make changes to which models run in which Cloudflare locations, the closer we can move AI inference to the application, <a href=\"https://blog.cloudflare.com/making-workers-ai-more-efficient-with-kv-cache-compression\"><u>lowering Time to First Token (TTFT)</u></a>. This also allows us to be more resilient to spikes in inference requests.</p><p>AI models that rely on GPUs present three challenges though:</p><ol><li><p>Models have different GPU memory needs. GPU memory is the most scarce resource, and different GPUs have different amounts of memory.</p></li><li><p>Not all container runtimes, such as <a href=\"https://github.com/firecracker-microvm/firecracker/issues/1179\"><u>Firecracker</u></a>, support GPU drivers and other dependencies.</p></li><li><p>AI models, particularly LLMs, are very large. Even a smaller parameter model, like <a href=\"https://developers.cloudflare.com/workers-ai/models/llama-3.1-8b-instruct/\"><u>@cf/meta/llama-3.1-8b-instruct</u></a>, is at least 5 GB. The larger the model, the more bytes we need to pull across the network when scheduling a model to run in a new location.</p></li></ol><p>Let’s dive into how we solved each of these…</p><p>First, GPU memory needs. The global scheduler knows which Cloudflare locations have blocks of GPU memory available, and then delegates scheduling the workload on a specific metal to the local scheduler. This allows us to prioritize placement of AI models that use a large amount of GPU memory, and then move smaller models to other machines in the same location. By doing this, we maximize the overall number of locations that we run AI models in, and maximize our efficiency.</p><p>Second, container runtimes and GPU support. Thankfully, from day one we built our container platform to be <i>runtime agnostic</i>. Using <a href=\"https://blog.cloudflare.com/how-we-use-hashicorp-nomad/\"><u>a runtime agnostic scheduler</u></a>, we’re able to support <a href=\"https://gvisor.dev/\"><u>gVisor</u></a>, <a href=\"https://firecracker-microvm.github.io/\"><u>Firecracker</u></a> microVMs, and traditional VMs with <a href=\"https://www.qemu.org/\"><u>QEMU</u></a>. We are also evaluating adding support for another one: <a href=\"https://github.com/cloud-hypervisor/cloud-hypervisor\"><u>cloud-hypervisor</u></a> which is based on <a href=\"https://github.com/rust-vmm\"><u>rust-vmm</u></a> and has a few compelling advantages for our use case:</p><ol><li><p>GPU passthrough <a href=\"https://github.com/cloud-hypervisor/cloud-hypervisor/blob/main/docs/vfio.md\"><u>support</u></a> using VFIO</p></li><li><p><a href=\"https://github.com/cloud-hypervisor/cloud-hypervisor/blob/main/docs/device_model.md#vhost-user-net\"><u>vhost-user-net</u></a> support, enabling high throughput between the host network interface and the VM</p></li><li><p><a href=\"https://github.com/cloud-hypervisor/cloud-hypervisor/blob/main/docs/device_model.md#vhost-user-net\"><u>vhost-user-blk</u></a> support, adding flexibility to introduce novel network-based storage backed by other Cloudflare Workers products</p></li><li><p>all the while being a smaller codebase than QEMU and written in a memory-safe language</p></li></ol><p>Our goal isn’t to build a platform that makes you as the developer choose between runtimes, and ask, “should I use Firecracker or gVisor”. We needed this flexibility in order to be able to run workloads with different needs efficiently, including workloads that depend on GPUs. gVisor has <a href=\"https://gvisor.dev/docs/user_guide/gpu/\"><u>GPU support</u></a>, while Firecracker microVMs currently <a href=\"https://github.com/firecracker-microvm/firecracker/issues/1179\"><u>does not</u></a>.</p><p>gVisor’s main component is an application kernel (called Sentry) that implements a Linux-like interface but is written in a memory-safe language (Go) and runs in userspace. It works by intercepting application system calls and acting as the guest kernel, without the need for translation through virtualized hardware.</p><p>The resource footprint of a containerized application running on gVisor is lower than a VM because it does not require managing virtualized hardware and booting up a kernel instance. However, this comes at the price of reduced application compatibility and higher per-system call overhead.</p><p>To add GPU support, the Google team introduced <a href=\"https://gvisor.dev/docs/user_guide/gpu/\"><u>nvproxy</u></a> which works using the same principles as described above for syscalls: it intercepts <a href=\"https://en.wikipedia.org/wiki/Ioctl\"><u>ioctls</u></a> destined to the GPU and proxies a subset to the GPU kernel module.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/1jqt4l5joKUkPNek1xACaM/0eb2e4546ac21b2d6da502919cd759a1/image__19_.png\" alt=\"BLOG-2573 4\" class=\"kg-image\" width=\"1256\" height=\"1428\" loading=\"lazy\"/>\n          </figure><p>To solve the third challenge, and make scheduling fast with large models, we weren’t satisfied with the status quo. So we did something about it.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"docker-pull-was-too-slow-so-we-fixed-it-and-cut-the-time-in-half\">Docker pull was too slow, so we fixed it (and cut the time in half)</h2>\n            <a href=\"#docker-pull-was-too-slow-so-we-fixed-it-and-cut-the-time-in-half\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Many of the images we need to run for AI inference are over 15 GB. Specialized inference libraries and GPU drivers add up fast. For example, when we make a scheduling decision to run a fresh container in Tokyo, naively running docker pull to fetch the image from a storage bucket in Los Angeles would be unacceptably slow. And scheduling speed is critical to being able to scale up and down in new locations in response to changes in traffic.</p><p>We had 3 essential requirements:</p><ul><li><p>Pulling and pushing very large images should be fast</p></li><li><p>We should not rely on a single point of failure</p></li><li><p>Our teams shouldn’t waste time managing image registries</p></li></ul><p>We needed globally distributed storage, so we used <a href=\"https://developers.cloudflare.com/r2/\"><u>R2</u></a>. We needed the highest cache hit rate possible, so we used Cloudflare’s <a href=\"https://developers.cloudflare.com/cache/\"><u>Cache</u></a>, and will soon use <a href=\"https://developers.cloudflare.com/cache/how-to/tiered-cache/\"><u>Tiered Cache</u></a>. And we needed a fast container image registry that we could run everywhere, in every Cloudflare location, so we built and open-sourced <a href=\"https://github.com/cloudflare/serverless-registry\"><u>serverless-registry</u></a>, which is built on <a href=\"https://developers.cloudflare.com/workers/\"><u>Workers</u></a>. You can deploy serverless-registry to your own Cloudflare account in about 5 minutes. We rely on it in production.</p><p>This is fast, but we can be faster. Our performance bottleneck was, somewhat surprisingly, <a href=\"https://docs.docker.com/reference/cli/docker/image/push/\"><u>docker push</u></a>. Docker uses <a href=\"https://www.gzip.org/\"><u>gzip</u></a> to compress and decompress layers of images while pushing and pulling. So we started using <a href=\"https://github.com/facebook/zstd\"><u>Zstandard</u></a> (zstd) instead, which compresses and decompresses faster, and results in smaller compressed files.</p><p>In order to build, chunk, and push these images to the R2 registry, we built a custom CLI tool that we use internally in lieu of running docker build and docker push. This makes it easy to use zstd and split layers into 500 MB chunks, which allows uploads to be processed by Workers while staying under <a href=\"https://developers.cloudflare.com/workers/platform/limits/#request-limits\"><u>body size limits</u></a>.</p><p>Using our custom build and push tool doubled the speed of image pulls. Our 30 GB GPU images now pull in 4 minutes instead of 8. We plan on open sourcing this tool in the near future.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"anycast-is-the-gift-that-keeps-on-simplifying-virtual-ips-and-the-global-state-router\">Anycast is the gift that keeps on simplifying — Virtual IPs and the Global State Router</h2>\n            <a href=\"#anycast-is-the-gift-that-keeps-on-simplifying-virtual-ips-and-the-global-state-router\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>We still had another challenge to solve. And yes, we solved it with anycast. We’re Cloudflare, did you expect anything else?</p><p>First, a refresher — Cloudflare operates <a href=\"https://blog.cloudflare.com/unimog-cloudflares-edge-load-balancer/\"><u>Unimog</u></a>, a Layer 4 load balancer that handles all incoming Cloudflare traffic. Cloudflare’s network uses <a href=\"https://www.cloudflare.com/learning/cdn/glossary/anycast-network\"><u>anycast</u></a>, which allows a single IP address to route requests to a variety of different locations. For most Cloudflare services with anycast, the given IP address will route to the nearest Cloudflare data center, reducing latency. Since Cloudflare runs almost every service in every data center, Unimog can simply route traffic to any Cloudflare metal that is online and has capacity, without needing to map traffic to a specific service that runs on specific metals, only in some locations.</p><p>The new compute-heavy, GPU-backed workloads we were taking on forced us to confront this fundamental “everything runs everywhere” assumption. If we run a containerized workflow in 20 Cloudflare locations, how does Unimog know which locations, and which metals, it runs in? You might say “just bring your own <a href=\"https://developers.cloudflare.com/reference-architecture/architectures/load-balancing/\"><u>load balancer</u></a>” — but then what happens when you make scheduling decisions to migrate a workload between locations, scale up, or scale down?</p><p>Anycast is foundational to how we build fast and simple products on our network, and we needed a way to keep building new types of products this way — where a team can deploy an application, get back a single IP address, and rely on the platform to balance traffic, taking load, container health, and latency into account, without extra configuration. We started letting teams use the container platform without solving this, and it was painfully clear that we needed to do something about it.</p><p>So we started integrating directly into our networking stack, building a sidecar service to Unimog. We’ll call this the Global State Router. Here’s how it works:</p><ul><li><p>An eyeball makes a request to a virtual IP address issued by Cloudflare</p></li><li><p>Request sent to the best location as determined by BGP routing. This is anycast routing.</p></li><li><p>A small <a href=\"https://ebpf.io/what-is-ebpf/\"><u>eBPF</u></a> program sits on the main networking interface and ensures packets bound to a virtual IP address are handled by the Global State Router.</p></li><li><p>The main Global State Router program contains a mapping of all anycast IPs addresses to potential end destination container IP addresses. It updates this mapping based on container health, readiness, distance, and latency. Using this information, it picks a best-fit container.</p></li><li><p>Packets are forwarded at the L4 layer.</p></li><li><p>When a target container’s server receives a packet, its own Global State Router program intercepts the packet and routes it to the local container.</p></li></ul>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/8ZICyfggbTEpkxki0OnYd/a35b43368b4db49699c0ee3a576619f2/BLOG-2573_5.png\" alt=\"BLOG-2573 5\" class=\"kg-image\" width=\"1970\" height=\"1286\" loading=\"lazy\"/>\n          </figure><p>This might sound like just a lower level networking detail, disconnected from developer experience. But by integrating directly with Unimog, we can let developers:</p><ol><li><p>Push a containerized application to Cloudflare.</p></li><li><p>Provide constraints, health checks, and load metrics that describe what the application needs.</p></li><li><p>Delegate scheduling and scaling many containers across Cloudflare’s network.</p></li><li><p>Get back a single IP address that can be used everywhere.</p></li></ol><p>We’re actively working on this, and are excited to continue building on Cloudflare’s anycast capabilities, and pushing to keep the simplicity of running “everywhere” with new categories of workloads.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"low-latency-global-remote-browser-isolation-browser-rendering\">Low latency & global — Remote Browser Isolation & Browser Rendering</h2>\n            <a href=\"#low-latency-global-remote-browser-isolation-browser-rendering\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Our container platform actually started because of a very specific challenge, running <a href=\"https://www.cloudflare.com/zero-trust/products/browser-isolation/\"><u>Remote Browser Isolation</u></a> across our network. Remote Browser Isolation provides Chromium browsers that run on Cloudflare, in containers, rather than on the end user’s own computer. Only the rendered output is sent to the end user. This provides a layer of protection against zero-day browser vulnerabilities, phishing attacks, and ransomware.</p><p>Location is critical — people expect their interactions with a remote browser to feel just as fast as if it ran locally. If the server is thousands of miles away, the remote browser will feel slow. Running across <a href=\"https://www.cloudflare.com/network/\"><u>Cloudflare’s network of over 330 locations</u></a> means the browser is nearly always as close to you as possible.</p><p>Imagine a user in Santiago, Chile, if they were to access a browser running in the same city, each interaction would incur negligible additional latency. Whereas a browser in Buenos Aires might add 21 ms, São Paulo might add 48 ms, Bogota might add 67 ms, and Raleigh, NC might add 128 ms. Where the container runs significantly impacts the latency of every user interaction with the browser, and therefore the experience as a whole.</p><p>It’s not just browser isolation that benefits from running near the user: WebRTC servers stream video better, multiplayer games have less lag, online advertisements can be served faster, financial transactions can be processed faster. Our container platform lets us run anything we need to near the user, no matter where they are in the world.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"using-spare-compute-off-peak-jobs-for-workers-ci-cd-builds\">Using spare compute — “off-peak” jobs for Workers CI/CD builds</h2>\n            <a href=\"#using-spare-compute-off-peak-jobs-for-workers-ci-cd-builds\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>At any hour of the day, Cloudflare has many CPU cores that sit idle. This is compute power that could be used for something else.</p><p>Via anycast, most of Cloudflare’s traffic is handled as close as possible to the eyeball (person) that requested it. Most of our traffic originates from eyeballs. And the eyeballs of (most) people are closed and asleep between midnight and 5:00 AM local time. While we use our compute capacity very efficiently during the daytime in any part of the world, overnight we have spare cycles. Consider what a map of the world looks like at nighttime in Europe and Africa:</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/CtkNFxhvusjLx1khXh9gs/e79ee41386f2ac057888d2293b06bb59/BLOG-2573_6.png\" alt=\"BLOG-2573 6\" class=\"kg-image\" width=\"1044\" height=\"492\" loading=\"lazy\"/>\n          </figure><p>As shown above, we can run containers during “off-peak” in Cloudflare locations receiving low traffic at night. During this time, the CPU utilization of a typical Cloudflare metal looks something like this:</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/6sXsQ3p19bFecokbR0X1yj/417881810f5de4e88fa9a9af8496f83c/Screenshot_2024-09-27_at_2.20.50_PM.png\" alt=\"BLOG-2573 7\" class=\"kg-image\" width=\"2040\" height=\"1128\" loading=\"lazy\"/>\n          </figure><p>We have many “background” compute workloads at Cloudflare. These are workloads that don’t actually need to run close to the eyeball because there is no eyeball waiting on the request. The challenge is that many of these workloads require running untrusted code — either a dependency on open-source code that we don’t trust enough to run outside of a sandboxed environment, or untrusted code that customers deploy themselves. And unlike <a href=\"https://developers.cloudflare.com/workers/configuration/cron-triggers/\"><u>Cron Triggers</u></a>, which already make a best-effort attempt to use off-peak compute, these other workloads can’t run in <a href=\"https://developers.cloudflare.com/workers/reference/how-workers-works/#isolates\"><u>v8 isolates</u></a>.</p><p>On Builder Day 2024, we <a href=\"https://blog.cloudflare.com/builder-day-2024-announcements\"><u>announced Workers Builds in open beta</u></a>. You connect your Worker to a git repository, and Cloudflare builds and deploys your Worker each time you merge a pull request. Workers Builds run on our containers platform, using otherwise idle “off-peak” compute, allowing us to offer lower pricing, and hold more capacity for unexpected spikes in traffic in Cloudflare locations during daytime hours when load is highest. We preserve our ability to serve requests as close to the eyeball as possible where it matters, while using the full compute capacity of our network.</p><p>We developed a purpose-built API for these types of jobs. The Workers Builds service has zero knowledge of where Cloudflare has spare compute capacity on its network — it simply schedules an “off-peak” job to run on the containers platform, by defining a scheduling policy:</p><p><code>scheduling_policy: &quot;off-peak&quot;</code></p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"making-off-peak-jobs-faster-with-prewarmed-images\">Making off-peak jobs faster with prewarmed images</h2>\n            <a href=\"#making-off-peak-jobs-faster-with-prewarmed-images\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Just because a workload isn’t “eyeball-facing” doesn’t mean speed isn’t relevant. When a build job starts, you still want it to start as soon as possible.</p><p>Each new build requires a fresh container though, and we must avoid reusing containers to provide strong isolation between customers. How can we keep build job start times low, while using a new container for each job without over-provisioning? </p><p>We prewarm servers with the proper image. </p><p>Before a server becomes eligible to receive an “off peak” job, the container platform instructs it to download the correct image. Once the image is downloaded and cached locally, new containers can start quickly in a Firecracker VM after receiving a request for a new build. When a build completes, we throw away the container, and start the next build using a fresh container based on the prewarmed image.</p><p>Without prewarming, pulling and unpacking our Workers Build images would take roughly 75 seconds. With prewarming, we’re able to spin up a new container in under 10 seconds. We expect this to get even faster as we introduce optimizations like pre-booting images before new runs, or <a href=\"https://github.com/firecracker-microvm/firecracker/blob/main/docs/snapshotting/snapshot-support.md\"><u>Firecracker snapshotting</u></a>, which can restore a VM in under 200ms.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"workers-and-containers-better-together\">Workers and containers, better together</h2>\n            <a href=\"#workers-and-containers-better-together\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>As more of our own engineering teams rely on our containers platform in production, we’ve noticed a pattern: they want a deeper integration with Workers.</p><p>We plan to give it to them. </p><p>Let’s take a look at a project deployed on our container platform already, <a href=\"https://blog.cloudflare.com/key-transparency/\"><u>Key Transparency</u></a>. If the container platform were highly integrated with Workers, what would this team’s experience look like?</p><p>Cloudflare regularly audits changes to public keys used by WhatsApp for encrypting messages between users. Much of the architecture is built on Workers, but there are long-running compute-intensive tasks that are better suited for containers.</p><p>We don’t want our teams to have to jump through hoops to deploy a container and integrate with Workers. They shouldn’t have to pick specific regions to run in, figure out scaling, expose IPs and handle IP updates, or set up Worker-to-container auth.</p><p>We’re still exploring many different ideas and API designs, and we want your feedback. But let’s imagine what it might look like to use Workers, Durable Objects and Containers together.</p><p>In this case, an outer layer of Workers handles most business logic and ingress, a specialized Durable Object is configured to run alongside our new container, and the platform ensures the image is loaded on the right metals and can scale to meet demand.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/5GsXRuYvVELJY1syOmfq3z/c451ea0686d2d44e4460ec97dbaf2cfe/BLOG-2573_8.png\" alt=\"BLOG-2573 8\" class=\"kg-image\" width=\"1162\" height=\"550\" loading=\"lazy\"/>\n          </figure><p>I add a containerized app to the <a href=\"https://developers.cloudflare.com/workers/wrangler/configuration/\"><code><u>wrangler.toml </u></code><u>configuration file</u></a> of my Worker (or <a href=\"https://blog.cloudflare.com/automatically-generating-cloudflares-terraform-provider\"><u>Terraform</u></a>):</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">[[container-app]]\nimage = &quot;./key-transparency/verifier/Dockerfile&quot;\nname = &quot;verifier&quot;\n\n[durable_objects]\nbindings = { name = &quot;VERIFIER&quot;, class_name = &quot;Verifier&quot;, container = &quot;verifier&quot; } }\n</pre></code>\n            <p>Then, in my Worker, I call the runVerification <a href=\"https://developers.cloudflare.com/workers/runtime-apis/rpc/\"><u>RPC method</u></a> of my Durable Object:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">fetch(request, env, ctx) {\n  const id = new URL(request.url).searchParams.get(&#039;id&#039;)\n  const durableObjectId = env.VERIFIER.idFromName(request.params.id);\n  await env.VERIFIER.get(durableObjectId).runVerification()\n  //...\n}\n</pre></code>\n            <p>From my Durable Object I can boot, configure, mount storage buckets as directories, and make HTTP requests to the container:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">class Verifier extends DurableObject {\n  constructor(state, env) {\n    this.ctx.blockConcurrency(async () =&gt; {\n\n      // starts the container\n      await this.ctx.container.start();\n\n      // configures the container before accepting traffic\n      const config = await this.state.storage.get(&quot;verifierConfig&quot;);\n      await this.ctx.container.fetch(&quot;/set-config&quot;, { method: &quot;PUT&quot;, body: config});\n    })\n  }\n\n  async runVerification(updateId) {\n    // downloads &amp; mounts latest updates from R2\n    const latestPublicKeyUpdates = await this.env.R2.get(`public-key-updates/${updateId}`);\n    await this.ctx.container.mount(`/updates/${updateId}`, latestPublicKeyUpdates);\n\n    // starts verification via HTTP call \n    return await this.ctx.container.fetch(`/verifier/${updateId}`);\n  }\n}\n</pre></code>\n            <p>And… that’s it.</p><p>I didn’t have to worry about placement, scaling, service discovery authorization, and I was able to leverage integrations into other services like KV and R2 with just a few lines of code. The container platform took care of routing, placement, and auth. If I needed more instances, I could call the binding with a new ID, and the platform would scale up containers for me.</p><p>We are still in the early stages of building these integrations, but we’re excited about everything that containers will bring to Workers and vice versa.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"so-what-do-you-want-to-build\">So, what do you want to build?</h2>\n            <a href=\"#so-what-do-you-want-to-build\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>If you’ve read this far, there’s a non-zero chance you were hoping to get to run a container yourself on our network. While we’re not ready (quite yet) to open up the platform to everyone, now that we’ve built a few GA products on our container platform, we’re looking for a handful of engineering teams to start building, in advance of wider availability in 2025. And we’re <a href=\"https://job-boards.greenhouse.io/cloudflare/jobs/5547603\"><u>continuing to hire engineers</u></a> to work on this.</p><p>We’ve told you about our use cases for containers, and now it’s your turn. If you’re interested, <a href=\"https://forms.gle/msrkBLBYNFFYRaqY8\"><u>tell us here</u></a> what you want to build, and why it goes beyond what’s possible today in <a href=\"https://developers.cloudflare.com/workers/\"><u>Workers</u></a> and on our <a href=\"https://developers.cloudflare.com/products/?product-group=Developer+platform\"><u>Developer Platform</u></a>. What do you wish you could build on Cloudflare, but can’t yet today?</p>",
		"id": "5KJejYd85inMDIZUZ6z17D",
		"localeList": {
			"name": "blog-english-only",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "We’ve been working on something new — a platform for running containers across Cloudflare’s network. We already use it in production, for AI inference and more. Today we want to share an early look at how it’s built, why we built it, and how we use it ourselves.\n",
		"metadata": {
			"title": "Our container platform is in production. It has GPUs. Here’s an early look",
			"description": "We’ve been working on something new — a platform for running containers across Cloudflare’s network. We already use it in production, for AI inference and more. Today we want to share an early look at how it’s built, why we built it, and how we use it ourselves.\n",
			"imgPreview": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/1RolWb3TF9PRzx075YgVxq/d61dbaebc5e3a45ac7c1b8d68c8110d6/BLOG-2573_OG.png"
		},
		"primary_author": {},
		"published_at": "2024-09-27T14:00+01:00",
		"slug": "container-platform-preview",
		"tags": [
			{
				"id": "1Efeqd1oZ7vy3xls0fdjHF",
				"name": "Agile Developer Services",
				"slug": "agile-developer-services"
			},
			{
				"id": "4HIPcb68qM0e26fIxyfzwQ",
				"name": "Developers",
				"slug": "developers"
			},
			{
				"id": "3JAY3z7p7An94s6ScuSQPf",
				"name": "Developer Platform",
				"slug": "developer-platform"
			},
			{
				"id": "6Foe3R8of95cWVnQwe5Toi",
				"name": "AI",
				"slug": "ai"
			},
			{
				"id": "5v2UZdTRX1Rw9akmhexnxs",
				"name": "Durable Objects",
				"slug": "durable-objects"
			}
		],
		"title": "Our container platform is in production. It has GPUs. Here’s an early look",
		"updated_at": "2024-09-29T09:28:03.488Z",
		"url": "https://blog.cloudflare.com/container-platform-preview"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.blurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}