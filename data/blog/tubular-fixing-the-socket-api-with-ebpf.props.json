{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "9",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Lorenz Bauer",
				"slug": "lorenz-bauer",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/60RQfI3asKZHVkSBiYKTKU/18eae73eed0afc63a94ad108eb4bb183/lorenz-bauer.jpeg",
				"location": null,
				"website": null,
				"twitter": null,
				"facebook": null,
				"publiclyIndex": true
			}
		],
		"excerpt": "We are open sourcing the production tooling we’ve built for the sk_lookup hook we contributed to the Linux kernel, called tubular",
		"feature_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6ZX25bMVOncyXZbjvB2aYP/75f2f69362766f723be038c44cbdff7e/tubular-fixing-the-socket-api-with-ebpf.png",
		"featured": false,
		"html": "\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3qt80mUTCxJp6nLkenADAL/29eb329be3097752997f3ac4b9a00f25/tubular-1.png\" alt=\"\" class=\"kg-image\" width=\"1200\" height=\"675\" loading=\"lazy\"/>\n            \n            </figure><p>As we develop new products, we often push our operating system - Linux - beyond what is commonly possible. A common theme has been relying on <a href=\"https://ebpf.io/what-is-ebpf/\">eBPF</a> to build technology that would otherwise have required modifying the kernel. For example, we’ve built <a href=\"/l4drop-xdp-ebpf-based-ddos-mitigations/\">DDoS mitigation</a> and a <a href=\"/unimog-cloudflares-edge-load-balancer/\">load balancer</a> and use it to <a href=\"/introducing-ebpf_exporter/\">monitor our fleet of servers</a>.</p><p>This software usually consists of a small-ish eBPF program written in C, executed in the context of the kernel, and a larger user space component that loads the eBPF into the kernel and manages its lifecycle. We’ve found that the ratio of eBPF code to userspace code differs by an order of magnitude or more. We want to shed some light on the issues that a developer has to tackle when dealing with eBPF and present our solutions for building rock-solid production ready applications which contain eBPF.</p><p>For this purpose we are open sourcing the production tooling we’ve built for the <a href=\"https://www.kernel.org/doc/html/latest/bpf/prog_sk_lookup.html\">sk_lookup hook</a> we contributed to the Linux kernel, called <b>tubular</b>. It exists because <a href=\"/its-crowded-in-here/\">we’ve outgrown the BSD sockets API</a>. To deliver some products we need features that are just not possible using the standard API.</p><ul><li><p>Our services are available on millions of IPs.</p></li><li><p>Multiple services using the same port on different addresses have to coexist, e.g. <a href=\"https://1.1.1.1/\">1.1.1.1</a> resolver and our authoritative DNS.</p></li><li><p>Our Spectrum product <a href=\"/how-we-built-spectrum/\">needs to listen on all 2^16 ports</a>.</p></li></ul><p>The source code for tubular is at <a href=\"https://github.com/cloudflare/tubular\">https://github.com/cloudflare/tubular</a>, and it allows you to do all the things mentioned above. Maybe the most interesting feature is that you can change the addresses of a service on the fly:</p><!--kg-card-begin: html--><div style=\"position: relative; padding-top: 60%;\"><iframe src=\"https://iframe.videodelivery.net/0c8aa9ba9144bbbb313fb9c865376e4e?preload=true&poster=https%3A%2F%2Fvideodelivery.net%2F0c8aa9ba9144bbbb313fb9c865376e4e%2Fthumbnails%2Fthumbnail.jpg%3Ftime%3D48s%26height%3D600&primaryColor=%23f7b018\" style=\"border: none; position: absolute; top: 0; left: 0; height: 100%; width: 100%;\" allow=\"accelerometer; gyroscope; autoplay; encrypted-media; picture-in-picture;\" allowfullscreen=\"true\"></iframe></div>\n<p></p><!--kg-card-end: html-->\n    <div class=\"flex anchor relative\">\n      <h2 id=\"how-tubular-works\">How tubular works</h2>\n      <a href=\"#how-tubular-works\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p><code>tubular</code> sits at a critical point in the Cloudflare stack, since it has to inspect every connection terminated by a server and decide which application should receive it.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6ZFfhU9ui5dR4KpbOcofqr/c61fde7a87d189167a3b72ca90b61e20/unnamed.png\" alt=\"\" class=\"kg-image\" width=\"1600\" height=\"382\" loading=\"lazy\"/>\n            \n            </figure><p>Failure to do so will drop or misdirect connections hundreds of times per second. So it has to be incredibly robust during day to day operations. We had the following goals for tubular:</p><ul><li><p><b>Releases must be unattended and happen online.</b> tubular runs on thousands of machines, so we can’t babysit the process or take servers out of production.</p></li><li><p><b>Releases must fail safely.</b> A failure in the process must leave the previous version of tubular running, otherwise we may drop connections.</p></li><li><p><b>Reduce the impact of (userspace) crashes.</b> When the inevitable bug comes along we want to minimise the blast radius.</p></li></ul><p>In the past we had built a proof-of-concept control plane for sk_lookup called <a href=\"https://github.com/majek/inet-tool\">inet-tool</a>, which proved that we could get away without a persistent service managing the eBPF. Similarly, tubular has <code>tubectl</code>: short-lived invocations make the necessary changes and persisting state is handled by the kernel in the form of <a href=\"https://www.kernel.org/doc/html/latest/bpf/maps.html\">eBPF maps</a>. Following this design gave us crash resiliency by default, but left us with the task of mapping the user interface we wanted to the tools available in the eBPF ecosystem.</p>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"the-tubular-user-interface\">The tubular user interface</h2>\n      <a href=\"#the-tubular-user-interface\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>tubular consists of a BPF program that attaches to the sk_lookup hook in the kernel and userspace Go code which manages the BPF program. The <code>tubectl</code> command wraps both in a way that is easy to distribute.</p><p><code>tubectl</code> manages two kinds of objects: bindings and sockets. A binding encodes a rule against which an incoming packet is matched. A socket is a reference to a TCP or UDP socket that can accept new connections or packets.</p><p>Bindings and sockets are &quot;glued&quot; together via arbitrary strings called labels. Conceptually, a binding assigns a label to some traffic. The label is then used to find the correct socket.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3G1ZM7iKvkGurKMBYqonW5/f6612068b8fb404a8cc0af1d02108c43/unnamed--2-.png\" alt=\"\" class=\"kg-image\" width=\"1130\" height=\"185\" loading=\"lazy\"/>\n            \n            </figure>\n    <div class=\"flex anchor relative\">\n      <h3 id=\"adding-bindings\">Adding bindings</h3>\n      <a href=\"#adding-bindings\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>To create a binding that steers port 80 (aka HTTP) traffic destined for 127.0.0.1 to the label “foo” we use <code>tubectl bind</code>:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ sudo tubectl bind &quot;foo&quot; tcp 127.0.0.1 80</pre></code>\n            <p>Due to the power of sk_lookup we can have much more powerful constructs than the BSD API. For example, we can redirect connections to all IPs in 127.0.0.0/24 to a single socket:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ sudo tubectl bind &quot;bar&quot; tcp 127.0.0.0/24 80</pre></code>\n            <p>A side effect of this power is that it&#39;s possible to create bindings that &quot;overlap&quot;:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">1: tcp 127.0.0.1/32 80 -&gt; &quot;foo&quot;\n2: tcp 127.0.0.0/24 80 -&gt; &quot;bar&quot;</pre></code>\n            <p>The first binding says that HTTP traffic to localhost should go to “foo”, while the second asserts that HTTP traffic in the localhost subnet should go to “bar”. This creates a contradiction, which binding should we choose? tubular resolves this by defining precedence rules for bindings:</p><ol><li><p>A prefix with a longer mask is more specific, e.g. 127.0.0.1/32 wins over 127.0.0.0/24.</p></li><li><p>A port is more specific than the port wildcard, e.g. port 80 wins over &quot;all ports&quot; (0).</p></li></ol><p>Applying this to our example, HTTP traffic to all IPs in 127.0.0.0/24 will be directed to bar, except for 127.0.0.1 which goes to foo.</p>\n    <div class=\"flex anchor relative\">\n      <h3 id=\"getting-ahold-of-sockets\">Getting ahold of sockets</h3>\n      <a href=\"#getting-ahold-of-sockets\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p><code>sk_lookup</code> needs a reference to a TCP or a UDP socket to redirect traffic to it. However, a socket is usually accessible only by the process which created it with the socket syscall. For example, an HTTP server creates a TCP listening socket bound to port 80. How can we gain access to the listening socket?</p><p>A fairly well known solution is to make processes cooperate by passing socket file descriptors via <a href=\"/know-your-scm_rights/\">SCM_RIGHTS</a> messages to a tubular daemon. That daemon can then take the necessary steps to hook up the socket with <code>sk_lookup</code>. This approach has several drawbacks:</p><ol><li><p>Requires modifying processes to send SCM_RIGHTS</p></li><li><p>Requires a tubular daemon, which may crash</p></li></ol><p>There is another way of getting at sockets by using systemd, provided <a href=\"https://www.freedesktop.org/software/systemd/man/systemd.socket.html\">socket activation</a> is used. It works by creating an additional service unit with the correct <a href=\"https://www.freedesktop.org/software/systemd/man/systemd.service.html#Sockets=\">Sockets</a> setting. In other words: we can leverage systemd oneshot action executed on creation of a systemd socket service, registering the socket into tubular. For example:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">[Unit]\nRequisite=foo.socket\n\n[Service]\nType=oneshot\nSockets=foo.socket\nExecStart=tubectl register &quot;foo&quot;</pre></code>\n            <p>Since we can rely on systemd to execute <code>tubectl</code> at the correct times we don&#39;t need a daemon of any kind. However, the reality is that a lot of popular software doesn&#39;t use systemd socket activation. Dealing with systemd sockets is complicated and doesn&#39;t invite experimentation. Which brings us to the final trick: <a href=\"https://www.man7.org/linux/man-pages/man2/pidfd_getfd.2.html\">pidfd_getfd</a>:</p><blockquote><p>The <code>pidfd_getfd()</code> system call allocates a new file descriptor in the calling process. This new file descriptor is a duplicate of an existing file descriptor, targetfd, in the process referred to by the PID file descriptor pidfd.</p></blockquote><p>We can use it to iterate all file descriptors of a foreign process, and pick the socket we are interested in. To return to our example, we can use the following command to find the TCP socket bound to 127.0.0.1 port 8080 in the httpd process and register it under the &quot;foo&quot; label:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ sudo tubectl register-pid &quot;foo&quot; $(pidof httpd) tcp 127.0.0.1 8080</pre></code>\n            <p>It&#39;s easy to wire this up using systemd&#39;s <a href=\"https://www.freedesktop.org/software/systemd/man/systemd.service.html#ExecStartPre=\">ExecStartPost</a> if the need arises.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">[Service]\nType=forking # or notify\nExecStart=/path/to/some/command\nExecStartPost=tubectl register-pid $MAINPID foo tcp 127.0.0.1 8080</pre></code>\n            \n    <div class=\"flex anchor relative\">\n      <h2 id=\"storing-state-in-ebpf-maps\">Storing state in eBPF maps</h2>\n      <a href=\"#storing-state-in-ebpf-maps\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>As mentioned previously, tubular relies on the kernel to store state, using <a href=\"https://prototype-kernel.readthedocs.io/en/latest/bpf/ebpf_maps.html\">BPF key / value data structures also known as maps</a>. Using the <a href=\"https://www.kernel.org/doc/html/latest/userspace-api/ebpf/syscall.html\">BPF_OBJ_PIN syscall</a> we can persist them in /sys/fs/bpf:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">/sys/fs/bpf/4026532024_dispatcher\n├── bindings\n├── destination_metrics\n├── destinations\n├── sockets\n└── ...</pre></code>\n            <p>The way the state is structured differs from how the command line interface presents it to users. Labels like “foo” are convenient for humans, but they are of variable length. Dealing with variable length data in BPF is cumbersome and slow, so the BPF program never references labels at all. Instead, the user space code allocates numeric IDs, which are then used in the BPF. Each ID represents a (<code>label</code>, <code>domain</code>, <code>protocol</code>) tuple, internally called <code>destination</code>.</p><p>For example, adding a binding for &quot;foo&quot; <code>tcp 127.0.0.1</code> ... allocates an ID for (&quot;<code>foo</code>&quot;, <code>AF_INET</code>, <code>TCP</code>). Including domain and protocol in the destination allows simpler data structures in the BPF. Each allocation also tracks how many bindings reference a destination so that we can recycle unused IDs. This data is persisted into the destinations hash table, which is keyed by (Label, Domain, Protocol) and contains (ID, Count). Metrics for each destination are tracked in destination_metrics in the form of per-CPU counters.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5JI7BzZmFdOS5DO6n2cpjh/3bf1a320954e9de2e4b60e64e0a3b375/unnamed--1--5.png\" alt=\"\" class=\"kg-image\" width=\"892\" height=\"297\" loading=\"lazy\"/>\n            \n            </figure><p><code>bindings</code> is a <a href=\"https://en.wikipedia.org/wiki/Trie\">longest prefix match (LPM) trie</a> which stores a mapping from (<code>protocol</code>, <code>port</code>, <code>prefix</code>) to (<code>ID</code>, <code>prefix length</code>). The ID is used as a key to the sockets map which contains pointers to kernel socket structures. IDs are allocated in a way that makes them suitable as an array index, which allows using the simpler BPF sockmap (an array) instead of a socket hash table. The prefix length is duplicated in the value to work around shortcomings in the BPF API.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4FJXwiooeaLRbRriCrETia/656cc5c0f78ca393627335cec1064755/unnamed--3-.png\" alt=\"\" class=\"kg-image\" width=\"1119\" height=\"662\" loading=\"lazy\"/>\n            \n            </figure>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"encoding-the-precedence-of-bindings\">Encoding the precedence of bindings</h2>\n      <a href=\"#encoding-the-precedence-of-bindings\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>As discussed, bindings have a precedence associated with them. To repeat the earlier example:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">1: tcp 127.0.0.1/32 80 -&gt; &quot;foo&quot;\n2: tcp 127.0.0.0/24 80 -&gt; &quot;bar&quot;</pre></code>\n            <p>The first binding should be matched before the second one. We need to encode this in the BPF somehow. One idea is to generate some code that executes the bindings in order of specificity, a technique we’ve used to great effect in <a href=\"/l4drop-xdp-ebpf-based-ddos-mitigations/\">l4drop</a>:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">1: if (mask(ip, 32) == 127.0.0.1) return &quot;foo&quot;\n2: if (mask(ip, 24) == 127.0.0.0) return &quot;bar&quot;\n...</pre></code>\n            <p>This has the downside that the program gets longer the more bindings are added, which slows down execution. It&#39;s also difficult to introspect and debug such long programs. Instead, we use a specialised BPF longest prefix match (LPM) map to do the hard work. This allows inspecting the contents from user space to figure out which bindings are active, which is very difficult if we had compiled bindings into BPF. The LPM map uses a trie behind the scenes, so <a href=\"https://en.wikipedia.org/wiki/Trie#Searching\">lookup has complexity proportional to the length of the key</a> instead of linear complexity for the “naive” solution.</p><p>However, using a map requires a trick for encoding the precedence of bindings into a key that we can look up. Here is a simplified version of this encoding, which ignores IPv6 and uses labels instead of IDs. To insert the binding <code>tcp 127.0.0.0/24 80</code> into a trie we first convert the IP address into a number.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">127.0.0.0    = 0x7f 00 00 00</pre></code>\n            <p>Since we&#39;re only interested in the first 24 bits of the address we, can write the whole prefix as</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">127.0.0.0/24 = 0x7f 00 00 ??</pre></code>\n            <p>where “?” means that the value is not specified. We choose the number 0x01 to represent TCP and prepend it and the port number (80 decimal is 0x50 hex) to create the full key:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">tcp 127.0.0.0/24 80 = 0x01 50 7f 00 00 ??</pre></code>\n            <p>Converting <code>tcp 127.0.0.1/32 80</code> happens in exactly the same way. Once the converted values are inserted into the trie, the LPM trie conceptually contains the following keys and values.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">LPM trie:\n        0x01 50 7f 00 00 ?? = &quot;bar&quot;\n        0x01 50 7f 00 00 01 = &quot;foo&quot;</pre></code>\n            <p>To find the binding for a TCP packet destined for 127.0.0.1:80, we again encode a key and perform a lookup.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">input:  0x01 50 7f 00 00 01   TCP packet to 127.0.0.1:80\n---------------------------\nLPM trie:\n        0x01 50 7f 00 00 ?? = &quot;bar&quot;\n           y  y  y  y  y\n        0x01 50 7f 00 00 01 = &quot;foo&quot;\n           y  y  y  y  y  y\n---------------------------\nresult: &quot;foo&quot;\n\ny = byte matches</pre></code>\n            <p>The trie returns “foo” since its key shares the longest prefix with the input. Note that we stop comparing keys once we reach unspecified “?” bytes, but conceptually “bar” is still a valid result. The distinction becomes clear when looking up the binding for a TCP packet to 127.0.0.255:80.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">input:  0x01 50 7f 00 00 ff   TCP packet to 127.0.0.255:80\n---------------------------\nLPM trie:\n        0x01 50 7f 00 00 ?? = &quot;bar&quot;\n           y  y  y  y  y\n        0x01 50 7f 00 00 01 = &quot;foo&quot;\n           y  y  y  y  y  n\n---------------------------\nresult: &quot;bar&quot;\n\nn = byte doesn&#039;t match</pre></code>\n            <p>In this case &quot;foo&quot; is discarded since the last byte doesn&#39;t match the input. However, &quot;bar&quot; is returned since its last byte is unspecified and therefore considered to be a valid match.</p>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"observability-with-minimal-privileges\">Observability with minimal privileges</h2>\n      <a href=\"#observability-with-minimal-privileges\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>Linux has the powerful ss tool (part of iproute2) available to inspect socket state:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ ss -tl src 127.0.0.1\nState      Recv-Q      Send-Q           Local Address:Port           Peer Address:Port\nLISTEN     0           128                  127.0.0.1:ipp                 0.0.0.0:*</pre></code>\n            <p>With tubular in the picture this output is not accurate anymore. <code>tubectl</code> bindings makes up for this shortcoming:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ sudo tubectl bindings tcp 127.0.0.1\nBindings:\n protocol       prefix port label\n      tcp 127.0.0.1/32   80   foo</pre></code>\n            <p>Running this command requires super-user privileges, despite in theory being safe for any user to run. While this is acceptable for casual inspection by a human operator, it&#39;s a dealbreaker for observability via pull-based monitoring systems like Prometheus. The usual approach is to expose metrics via an HTTP server, which would have to run with elevated privileges and be accessible to the Prometheus server somehow. Instead, BPF gives us the tools to enable read-only access to tubular state with minimal privileges.</p><p>The key is to carefully set file ownership and mode for state in /sys/fs/bpf. Creating and opening files in /sys/fs/bpf uses <a href=\"https://www.kernel.org/doc/html/latest/userspace-api/ebpf/syscall.html#bpf-subcommand-reference\">BPF_OBJ_PIN and BPF_OBJ_GET</a>. Calling BPF_OBJ_GET with BPF_F_RDONLY is roughly equivalent to open(O_RDONLY) and allows accessing state in a read-only fashion, provided the file permissions are correct. tubular gives the owner full access but restricts read-only access to the group:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ sudo ls -l /sys/fs/bpf/4026532024_dispatcher | head -n 3\ntotal 0\n-rw-r----- 1 root root 0 Feb  2 13:19 bindings\n-rw-r----- 1 root root 0 Feb  2 13:19 destination_metrics</pre></code>\n            <p>It&#39;s easy to choose which user and group should own state when loading tubular:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ sudo -u root -g tubular tubectl load\ncreated dispatcher in /sys/fs/bpf/4026532024_dispatcher\nloaded dispatcher into /proc/self/ns/net\n$ sudo ls -l /sys/fs/bpf/4026532024_dispatcher | head -n 3\ntotal 0\n-rw-r----- 1 root tubular 0 Feb  2 13:42 bindings\n-rw-r----- 1 root tubular 0 Feb  2 13:42 destination_metrics</pre></code>\n            <p>There is one more obstacle, <a href=\"https://github.com/systemd/systemd/blob/b049b48c4b6e60c3cbec9d2884f90fd4e7013219/src/shared/mount-setup.c#L111-L112\">systemd mounts /sys/fs/bpf</a> in a way that makes it inaccessible to anyone but root. Adding the executable bit to the directory fixes this.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ sudo chmod -v o+x /sys/fs/bpf\nmode of &#039;/sys/fs/bpf&#039; changed from 0700 (rwx------) to 0701 (rwx-----x)</pre></code>\n            <p>Finally, we can export metrics without privileges:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ sudo -u nobody -g tubular tubectl metrics 127.0.0.1 8080\nListening on 127.0.0.1:8080\n^C</pre></code>\n            <p>There is a caveat, unfortunately: truly unprivileged access requires unprivileged BPF to be enabled. Many distros have taken to disabling it via the unprivileged_bpf_disabled sysctl, in which case scraping metrics does require CAP_BPF.</p>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"safe-releases\">Safe releases</h2>\n      <a href=\"#safe-releases\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>tubular is distributed as a single binary, but really consists of two pieces of code with widely differing lifetimes. The BPF program is loaded into the kernel once and then may be active for weeks or months, until it is explicitly replaced. In fact, a reference to the program (and link, see below) is persisted into /sys/fs/bpf:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">/sys/fs/bpf/4026532024_dispatcher\n├── link\n├── program\n└── ...</pre></code>\n            <p>The user space code is executed for seconds at a time and is replaced whenever the binary on disk changes. This means that user space has to be able to deal with an &quot;old&quot; BPF program in the kernel somehow. The simplest way to achieve this is to compare what is loaded into the kernel with the BPF shipped as part of tubectl. If the two don&#39;t match we return an error:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ sudo tubectl bind foo tcp 127.0.0.1 80\nError: bind: can&#039;t open dispatcher: loaded program #158 has differing tag: &quot;938c70b5a8956ff2&quot; doesn&#039;t match &quot;e007bfbbf37171f0&quot;</pre></code>\n            <p><code>tag</code> is the truncated hash of the instructions making up a BPF program, which the kernel makes available for every loaded program:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ sudo bpftool prog list id 158\n158: sk_lookup  name dispatcher  tag 938c70b5a8956ff2\n...</pre></code>\n            <p>By comparing the tag tubular asserts that it is dealing with a supported version of the BPF program. Of course, just returning an error isn&#39;t enough. There needs to be a way to update the kernel program so that it&#39;s once again safe to make changes. This is where the persisted link in /sys/fs/bpf comes into play. <code>bpf_links</code> are used to attach programs to various BPF hooks. &quot;Enabling&quot; a BPF program is a two-step process: first, load the BPF program, next attach it to a hook using a bpf_link. Afterwards the program will execute the next time the hook is executed. By updating the link we can change the program on the fly, in an atomic manner.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ sudo tubectl upgrade\nUpgraded dispatcher to 2022.1.0-dev, program ID #159\n$ sudo bpftool prog list id 159\n159: sk_lookup  name dispatcher  tag e007bfbbf37171f0\n…\n$ sudo tubectl bind foo tcp 127.0.0.1 80\nbound foo#tcp:[127.0.0.1/32]:80</pre></code>\n            <p>Behind the scenes the upgrade procedure is slightly more complicated, since we have to update the pinned program reference in addition to the link. We pin the new program into /sys/fs/bpf:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">/sys/fs/bpf/4026532024_dispatcher\n├── link\n├── program\n├── program-upgrade\n└── ...</pre></code>\n            <p>Once the link is updated we <a href=\"https://www.man7.org/linux/man-pages/man2/rename.2.html\">atomically rename</a> program-upgrade to replace program. In the future we may be able to <a href=\"https://lkml.kernel.org/netdev/20211028094724.59043-5-lmb@cloudflare.com/t/\">use RENAME_EXCHANGE</a> to make upgrades even safer.</p>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"preventing-state-corruption\">Preventing state corruption</h2>\n      <a href=\"#preventing-state-corruption\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>So far we’ve completely neglected the fact that multiple invocations of <code>tubectl</code> could modify the state in /sys/fs/bpf at the same time. It’s very hard to reason about what would happen in this case, so in general it’s best to prevent this from ever occurring. A common solution to this is <a href=\"https://gavv.github.io/articles/file-locks/#differing-features\">advisory file locks</a>. Unfortunately it seems like BPF maps don&#39;t support locking.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ sudo flock /sys/fs/bpf/4026532024_dispatcher/bindings echo works!\nflock: cannot open lock file /sys/fs/bpf/4026532024_dispatcher/bindings: Input/output error</pre></code>\n            <p>This led to a bit of head scratching on our part. Luckily it is possible to flock the directory instead of individual maps:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ sudo flock --exclusive /sys/fs/bpf/foo echo works!\nworks!</pre></code>\n            <p>Each <code>tubectl</code> invocation likewise invokes <a href=\"https://www.man7.org/linux/man-pages//man2/flock.2.html\"><code>flock()</code></a>, thereby guaranteeing that only ever a single process is making changes.</p>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"conclusion\">Conclusion</h2>\n      <a href=\"#conclusion\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>tubular is in production at Cloudflare today and has simplified the deployment of <a href=\"https://www.cloudflare.com/products/cloudflare-spectrum/\">Spectrum</a> and our <a href=\"https://www.cloudflare.com/dns/\">authoritative DNS</a>. It allowed us to leave behind limitations of the BSD socket API. However, its most powerful feature is that <a href=\"https://research.cloudflare.com/publications/Fayed2021/\">the addresses a service is available on can be changed on the fly</a>. In fact, we have built tooling that automates this process across our global network. Need to listen on another million IPs on thousands of machines? No problem, it’s just an HTTP POST away.</p><p><i>Interested in working on tubular and our L4 load balancer</i> <a href=\"/unimog-cloudflares-edge-load-balancer/\"><i>unimog</i></a><i>? We are</i> <a href=\"https://boards.greenhouse.io/cloudflare/jobs/3232234?gh_jid=3232234\"><i>hiring in our European offices</i></a><i>.</i></p>",
		"id": "7ofIShaWHxqlp4ZmHyNRs",
		"localeList": {
			"name": "Production ready eBPF, or how we fixed the BSD socket API Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "We are open sourcing the production tooling we’ve built for the sk_lookup hook we contributed to the Linux kernel, called tubular",
		"metadata": {
			"title": "Production ready eBPF, or how we fixed the BSD socket API",
			"description": "We are open sourcing the production tooling we’ve built for the sk_lookup hook we contributed to the Linux kernel, called tubular",
			"imgPreview": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2nGy20SNvv60eBlyM5fvYl/fea04b0b89fbe8297fed6fb7c6f8e7cf/tubular-fixing-the-socket-api-with-ebpf-BVc6Nd.png"
		},
		"primary_author": {},
		"publicly_index": true,
		"published_at": "2022-02-17T17:02:54.000+00:00",
		"slug": "tubular-fixing-the-socket-api-with-ebpf",
		"tags": [
			{
				"id": "44lQSGkjHLg5W8THkxpMnh",
				"name": "eBPF",
				"slug": "ebpf"
			},
			{
				"id": "383iv0UQ6Lp0GZwOAxGq2p",
				"name": "Linux",
				"slug": "linux"
			},
			{
				"id": "KDI5hQcs301H8vxpGKXO0",
				"name": "Go",
				"slug": "go"
			}
		],
		"title": "Production ready eBPF, or how we fixed the BSD socket API",
		"updated_at": "2025-10-03T19:23:13.761Z",
		"url": "https://blog.cloudflare.com/tubular-fixing-the-socket-api-with-ebpf"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.icon_aria_label": "Search",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"search.result_stat_empty": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong>",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"search.autocomplete_title": "Insert a query. Press enter to send",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}