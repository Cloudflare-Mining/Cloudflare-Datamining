<div class="post-content lh-copy gray1">
	<p>当社は、社員をランダムなグループ（各4人）に分け、ビデオハングアウトをセットアップする実験を行ってきました。コーヒーマシンの周り、ランチでの順場待ち、またはプリンターを待っている間に時々起こるセレンディピタス（偶然）の出会いに代わるものとしてこれを行っています。また、単純に社員にお互いのことを知ってもらいたいのです。</p>
	<p>そのために、私はコードを書くことになりました。コアになるのは、<em>n個の要素を複数のグループに分け、少なくともサイズgにして各グループの人数を最小限に抑えることでした。</em>例えば、オフィスに15名の従業員がいる場合、５、5、5の3つのグループに分けられ、16名の場合は4、4、4、4、17名の場合は、4、４、4、５になります。</p>
	<p>私は最初に次のようなコードを書きました（Python）：</p>
	<!--kg-card-begin: markdown-->
	<pre><code class="language-python">    groups = [g] * (n//g)

    for e in range(0, n % g):
        groups[e % len(groups)] += 1
</code></pre>
	<!--kg-card-end: markdown-->
	<p>1行目は <code>n//g</code> （<code>//</code> は整数の除算）サイズ <code>g</code> の行列を算出します（たとえば、 <code>g == 4</code> 、 <code>n == 17</code> は、 <code>groups == [4, 4, 4, 4]</code>になります）。 「<code>for</code> ループ」は、「余り」でグループのサイズ gで割り切れなかったものを扱います。たとえば、<code>g == 4</code>、<code>n == 17</code> の場合は <code>[4、4、4、 4]</code> のどこかに「余り1」を加える必要があり、最終的にグループは [5, 4, 4, 4]になります。</p>
	<p>「 <code>e % len(groups)</code>」が必要なのは、等しい数でグループに分けた時に、余りの方が、算出されたgroupsエントリーよりも大きい場合があるからです。たとえば、 <code>g == 4</code>、 <code>n == 11</code> の場合は、groups は最初は <code>[4, 4]</code> になりますが、余りが「 <code>3</code>」になってしまい、それをたった2つの <code>groups</code>エントリーに分けなければなりません。</p>
	<p>それで、上記のコードが機能し、以下に示すのが様々なサイズの &nbsp;<code>n</code> (そして &nbsp;<code>g == 4</code>)のアウトプットです。</p>
	<!--kg-card-begin: markdown-->
	<pre><code>    4 [4]
    5 [5]
    6 [6]
    7 [7]
    8 [4, 4]
    9 [5, 4]
    10 [5, 5]
    11 [6, 5]
    12 [4, 4, 4]
    13 [5, 4, 4]
    14 [5, 5, 4]
    15 [5, 5, 5]
    16 [4, 4, 4, 4]
    17 [5, 4, 4, 4]
</code></pre>
	<!--kg-card-end: markdown-->
	<p>しかし、このコードには苛立ちを感じました。なぜなら、私は各グループにいくつの要素（elements）があるべきかを理解するための簡単な式が必要だと感じたからです。この問題についてしばらく頭を悩ませた後、よく役立つ解決方法をここでも使ってみることにしました。問題をシンプルで単純なものにする、もしくは、少なくともソリューションをシンプルで単純なものにすることです。そこで、以下のようなコードを書きました。</p>
	<!--kg-card-begin: markdown-->
	<pre><code>    groups = [0] * (n//g)

    for i in range(n):
        groups[i % len(groups)] += 1
</code></pre>
	<!--kg-card-end: markdown-->
	<p>これは本当に簡単な実装です。私はこれがn 回ループするため好きではないのですが、視覚化するのを助けてくれます。たとえば、 <code>g == 4</code>と <code>n == 17</code>を考えてみます。このループは、グループの各エントリーを次のように埋めていきます（四角はグループの中のエントリーを表し、四角の中にある数字は、ループによって増加するi値を表します）。</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2021/06/2.png" class="kg-image"></figure>
	<p>そして、グループは最終的に <code>[5, 4, 4, 4]</code>になります。これで視覚化されたのは、 <code>groups[i]</code>が何回増加したかは、i番目の要素で何回forループが、「ループ」しなければならなかったかによるということです。これは、ループを使用しなくても簡単に計算することができます。</p>
	<p>というわけで、コードは以下のようなシンプルなものになりました。</p>
	<!--kg-card-begin: markdown-->
	<pre><code>    groups = [1+max(0,n-(i+1))//(n//g) for i in range(n//g)]
</code></pre>
	<!--kg-card-end: markdown-->
	<p>私にとっては、この方がもっと満足するものでした。 <code>n//g</code>はグループのサイズで、これがループがグループの各エントリーをアップデートする回数を決めます。各エントリーは1 <code>+ max(0, n-(i+1))//(n//g)</code>.のようにセットされます。これを次のように考えることができます：</p>
	<p>1. &nbsp; 1は、グループのエントリーに最初に置く要素です。</p>
	<p>2. <code>max(0, n-(i+1))</code>は、iに達するまでグループの各要素に1つずつ置いていって、残った数です。これを、 <code>n//g</code>で割ると、要素が均等に分けられるまで（上記の簡潔なループを参照）、何回ループする必要があるかがわかります。</p>
	<p>2番目に書かれていることが不明瞭な場合は上記の図を考え、 <code>groups[0]</code>（ <code>n == 17</code>と <code>g == 4</code>）で具体的に考えてみてください。まず、 <code>1</code>を <code>groups[0]</code> に配置し、16を均等に分けることにします。単純に分けると、4回ループするので、16÷4で算出された要素をgroups[0]に加える必要があるため、5になります。</p>
	<p>次に、 <code>groups[1]</code>に移動し、1を置きます。15の要素が残っていて、これを均等に分けます。15÷4（整数除算では3）になるので、 <code>groups[1]</code>は4になります。という風に続けていきます。</p>
	<p>そして、そのソリューションは満足のいくものでした。端的に グループをワンショットで算出できました。もちろん、考えすぎかもしれませんし、他の人はこれよりも他のソリューションの方が明確で管理しやすいと考えるかもしれません。</p>
</div>