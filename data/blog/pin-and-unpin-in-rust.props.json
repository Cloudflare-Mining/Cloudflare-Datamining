{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "7",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Adam Chalmers",
				"slug": "adam-chalmers",
				"bio": "Australian, static typing enthusiast, ",
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1aqSM1mcj1n6KrFDvYWXTv/b061e85f395e09c2c094ded305087a63/adam-chalmers.png",
				"location": "Austin TX",
				"website": null,
				"twitter": "@adam_chal",
				"facebook": null,
				"publiclyIndex": true
			}
		],
		"excerpt": "Using async Rust libraries is usually easy. It's just like using normal Rust code, with a little async or .await here and there. But writing your own async libraries can be hard. ",
		"feature_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6MS1FJyHeF1ZHRn406L9Ff/7da2582030aad8f6581dda3bc11e07b0/pin-and-unpin-in-rust.png",
		"featured": false,
		"html": "\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2Qc7EGaZtlXsYT0s2mE4G/831cb4d71ac1fd19be9b56872e0fda78/Screen-Shot-2021-08-25-at-11.43.24-PM.png\" alt=\"\" class=\"kg-image\" width=\"1209\" height=\"761\" loading=\"lazy\"/>\n            \n            </figure><p></p><p>Using async Rust libraries is usually easy. It&#39;s just like using normal Rust code, with a little <code>async</code> or <code>.await</code> here and there. But writing your own async libraries can be hard. The first time I tried this, I got really confused by arcane, esoteric syntax like <code>T: ?Unpin</code> and <code>Pin&lt;&amp;mut Self&gt;</code>. I had never seen these types before, and I didn&#39;t understand what they were doing. Now that I understand them, I&#39;ve written the explainer I wish I could have read back then. In this post, we&#39;re gonna learn</p><ul><li><p>What Futures are</p></li><li><p>What self-referential types are</p></li><li><p>Why they were unsafe</p></li><li><p>How Pin/Unpin made them safe</p></li><li><p>Using Pin/Unpin to write tricky nested futures</p></li></ul>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"what-are-futures\">What are Futures?</h3>\n            <a href=\"#what-are-futures\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>A few years ago, I needed to write some code which would take some async function, run it and collect some metrics about it, e.g. how long it took to resolve. I wanted to write a type <code>TimedWrapper</code> that would work like this:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">// Some async function, e.g. polling a URL with [https://docs.rs/reqwest]\n// Remember, Rust functions do nothing until you .await them, so this isn&#039;t\n// actually making a HTTP request yet.\nlet async_fn = reqwest::get(&quot;http://adamchalmers.com&quot;);\n\n// Wrap the async function in my hypothetical wrapper.\nlet timed_async_fn = TimedWrapper::new(async_fn);\n\n// Call the async function, which will send a HTTP request and time it.\nlet (resp, time) = timed_async_fn.await;\nprintln!(&quot;Got a HTTP {} in {}ms&quot;, resp.unwrap().status(), time.as_millis())</pre></code>\n            <p></p><p>I like this interface, it&#39;s simple and should be easy for the other programmers on my team to use. OK, let&#39;s implement it! I know that, under the hood, Rust&#39;s async functions are just regular functions that return a <a href=\"https://doc.rust-lang.org/stable/std/future/trait.Future.html\"><code>Future</code></a>. The Future trait is pretty simple. It just means a type which:</p><ul><li><p>Can be polled</p></li><li><p>When it&#39;s polled, it might return &quot;Pending&quot; or &quot;Ready&quot;</p></li><li><p>If it&#39;s pending, you should poll it again later</p></li><li><p>If it&#39;s ready, it responds with a value. We call this &quot;resolving&quot;.</p></li></ul><p>Here&#39;s a really easy example of implementing a Future. Let&#39;s make a Future that returns a random <code>u16</code>.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">use std::{future::Future, pin::Pin, task::Context}\n\n/// A future which returns a random number when it resolves.\n#[derive(Default)]\nstruct RandFuture;\n\nimpl Future for RandFuture {\n\t// Every future has to specify what type of value it returns when it resolves.\n\t// This particular future will return a u16.\n\ttype Output = u16;\n\n\t// The `Future` trait has only one method, named &amp;quot;poll&amp;quot;.\nfn poll(self: Pin&amp;lt;&amp;amp;mut Self&amp;gt;, _cx: &amp;amp;mut Context) -&amp;gt; Poll&amp;lt;Self::Output  {\n\t\tPoll::ready(rand::random())\n\t}\n}</pre></code>\n            <p></p><p>Not too hard! I think we&#39;re ready to implement <code>TimedWrapper</code>.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"trying-and-failing-to-use-nested-futures\">Trying and failing to use nested Futures</h3>\n            <a href=\"#trying-and-failing-to-use-nested-futures\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>Let&#39;s start by defining the type.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">pub struct TimedWrapper&lt;Fut: Future&gt; {\n\tstart: Option&lt;Instant&gt;,\n\tfuture: Fut,\n}</pre></code>\n            <p></p><p>OK, so a <code>TimedWrapper</code> is generic over a type <code>Fut</code>, which must be a <code>Future</code>. And it will store a future of that type as a field. It&#39;ll also have a <code>start</code> field which will record when it first was first polled. Let&#39;s write a constructor:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">impl&lt;Fut: Future&gt; TimedWrapper&lt;Fut&gt; {\n\tpub fn new(future: Fut) -&gt; Self {\n\t\tSelf { future, start: None }\n\t}\n}</pre></code>\n            <p></p><p>Nothing too complicated here. The <code>new</code> function takes a future and wraps it in the <code>TimedWrapper</code>. Of course, we have to set start to None, because it hasn&#39;t been polled yet. So, let&#39;s implement the <code>poll</code> method, which is the only thing we need to implement <code>Future</code> and make it <code>.await</code>able.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">impl&lt;Fut: Future&gt; Future for TimedWrapper&lt;Fut&gt; {\n\t// This future will output a pair of values:\n\t// 1. The value from the inner future\n\t// 2. How long it took for the inner future to resolve\n\ttype Output = (Fut::Output, Duration);\n\n\tfn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;Self::Output&gt; {\n\t\t// Call the inner poll, measuring how long it took.\n\t\tlet start = self.start.get_or_insert_with(Instant::now);\n\t\tlet inner_poll = self.future.poll(cx);\n\t\tlet elapsed = self.elapsed();\n\n\t\tmatch inner_poll {\n\t\t\t// The inner future needs more time, so this future needs more time too\n\t\t\tPoll::Pending =&gt; Poll::Pending,\n\t\t\t// Success!\n\t\t\tPoll::Ready(output) =&gt; Poll::Ready((output, elapsed)),\n\t\t}\n\t}\n}</pre></code>\n            <p></p><p>OK, that wasn&#39;t too hard. There&#39;s just one problem: this doesn&#39;t work.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5vQYwC1N4iXqv6DzpxWJDq/ce5125480ef4ad35b8eb0d4882a408bf/Screen-Shot-2021-08-25-at-11.15.17-PM.png\" alt=\"\" class=\"kg-image\" width=\"2000\" height=\"509\" loading=\"lazy\"/>\n            \n            </figure><p></p><p>So, the Rust compiler reports an error on <code>self.future.poll(cx)</code>, which is &quot;no method named <code>poll</code> found for type parameter <code>Fut</code> in the current scope&quot;. This is confusing, because we know <code>Fut</code> is a <code>Future</code>, so surely it has a poll method? OK, but Rust continues: <code>Fut</code> doesn&#39;t have a poll method, but <code>Pin&lt;&amp;mut Fut&gt;</code> has one. What is this weird type?</p><p>Well, we know that methods have a &quot;receiver&quot;, which is some way it can access <code>self</code>. The receiver might be <code>self, &amp;self or &amp;mut self</code>, which mean &quot;take ownership of self,&quot; &quot;borrow self,&quot; and &quot;mutably borrow self&quot; respectively. So this is just a new, unfamiliar kind of receiver. Rust is complaining because we have Fut and we really need a <code>Pin&lt;&amp;mut Fut&gt;</code>. At this point I have two questions:</p><ol><li><p>What is <code>Pin</code>?</p></li><li><p>If I have a T value, how do I get a <code>Pin&lt;&amp;mut T&gt;</code>?</p></li></ol><p>The rest of this post is going to be answering those questions. I&#39;ll explain some problems in Rust that could lead to unsafe code, and why Pin safely solves them.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"self-reference-is-unsafe\">Self-reference is unsafe</h3>\n            <a href=\"#self-reference-is-unsafe\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>Pin exists to solve a very specific problem: self-referential datatypes, i.e. data structures which have pointers into themselves. For example, a binary search tree might have self-referential pointers, which point to other nodes in the same struct.</p><p>Self-referential types can be really useful, but they&#39;re also hard to make memory-safe. To see why, let&#39;s use this example type with two fields, an i32 called <code>val</code> and a pointer to an i32 called <code>pointer</code>.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6DejT3ngy1ze7AWuwy37Zq/6b9d388bb27d37a9d06f1e8ef2898615/memory_before.png\" alt=\"\" class=\"kg-image\" width=\"256\" height=\"110\" loading=\"lazy\"/>\n            \n            </figure><p></p><p>So far, everything is OK. The <code>pointer</code> field points to the val field in memory address A, which contains a valid i32. All the pointers are <i>valid</i>, i.e. they point to memory that does indeed encode a value of the right type (in this case, an i32). But the Rust compiler often moves values around in memory. For example, if we pass this struct into another function, it might get moved to a different memory address. Or we might Box it and put it on the heap. Or if this struct was in a <code>Vec&lt;MyStruct&gt;</code>, and we pushed more values in, the Vec might outgrow its capacity and need to move its elements into a new, larger buffer.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6WF4QNkOCFQiAIsmpbUaQK/fb8d03bc290071fb69a6d35399bec85f/memory_after.png\" alt=\"\" class=\"kg-image\" width=\"577\" height=\"134\" loading=\"lazy\"/>\n            \n            </figure><p></p><p>When we move it, the struct&#39;s fields change their address, but not their value. So the <code>pointer</code> field is still pointing at address A, but address A now doesn&#39;t have a valid i32. The data that was there was moved to address B, and some other value might have been written there instead! So now the pointer is invalid. This is bad -- at best, invalid pointers cause crashes, at worst they cause hackable vulnerabilities. We only want to allow memory-unsafe behaviour in unsafe blocks, and we should be very careful to document this type and tell users to update the pointers after moves.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"unpin-and-unpin\">Unpin and !Unpin</h3>\n            <a href=\"#unpin-and-unpin\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>To recap, all Rust types fall into two categories.</p><ol><li><p>Types that are safe to move around in memory. This is the default, the norm. For example, this includes primitives like numbers, strings, bools, as well as structs or enums entirely made of them. Most types fall into this category!</p></li><li><p>Self-referential types, which are <i>not</i> safe to move around in memory. These are pretty rare. An example is the <a href=\"https://docs.rs/tokio/1.10.0/src/tokio/util/linked_list.rs.html\">intrusive linked list inside some Tokio internals</a>. Another example is most types which implement Future and also borrow data, for reasons <a href=\"https://rust-lang.github.io/async-book/04_pinning/01_chapter.html\">explained in the Rust async book</a>.</p></li></ol><p>Types in category (1) are totally safe to move around in memory. You won&#39;t invalidate any pointers by moving them around. But if you move a type in (2), then you invalidate pointers and can get undefined behaviour, as we saw before. In earlier versions of Rust, you had to be really careful using these types to not move them, or if you moved them, to use unsafe and update all the pointers. But since Rust 1.33, the compiler can automatically figure out which category any type is in, and make sure you only use it safely.</p><p>Any type in (1) implements a special auto trait called <a href=\"https://doc.rust-lang.org/stable/std/marker/trait.Unpin.html\"><code>Unpin</code></a>. Weird name, but its meaning will become clear soon. Again, most &quot;normal&quot; types implement Unpin, and because it&#39;s an auto trait (like Send or Sync or <code>Sized</code><a href=\"https://blog.adamchalmers.com/pin-unpin/#1\">1</a>), so you don&#39;t have to worry about implementing it yourself. If you&#39;re unsure if a type can be safely moved, just check it on <a href=\"https://docs.rs\">docs.rs</a> and see if it impls <code>Unpin</code>!</p><p>Types in (2) are creatively named <code>!Unpin</code> (the <code>!</code> in a trait means &quot;does not implement&quot;). To use these types safely, we can&#39;t use regular pointers for self-reference. Instead, we use special pointers that &quot;pin&quot; their values into place, ensuring they can&#39;t be moved. This is exactly what the <a href=\"https://doc.rust-lang.org/stable/std/pin/struct.Pin.html\"><code>Pin</code></a> type does.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/19Usw25JStox7edODSK287/8d0f6e45aa88340d6f34bcde72b31980/pin_diagram.png\" alt=\"\" class=\"kg-image\" width=\"1172\" height=\"162\" loading=\"lazy\"/>\n            \n            </figure><p></p><p>Pin wraps a pointer and stops its value from moving. The only exception is if the value impls <code>Unpin</code> -- then we know it&#39;s safe to move. Voila! Now we can write self-referential structs safely! This is really important, because as discussed above, many Futures are self-referential, and we need them for async/await.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"using-pin\">Using Pin</h3>\n            <a href=\"#using-pin\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>So now we understand why Pin exists, and why our Future poll method has a pinned <code>&amp;mut self</code> to self instead of a regular <code>&amp;mut self</code>. So let&#39;s get back to the problem we had before: I need a pinned reference to the inner future. More generally: given a pinned struct, how do we access its fields?</p><p>The solution is to write helper functions which give you references to the fields. These references might be normal Rust references like &amp;mut, or they might <i>also</i> be pinned. You can choose whichever one you need. This is called <i>projection</i>: if you have a pinned struct, you can write a projection method that gives you access to all its fields.</p><p>Projecting is really just getting data into and out of Pins. For example, we get the <code>start: Option&lt;Duration&gt;</code> field from the <code>Pin&lt;&amp;mut self&gt;</code>, and we need to put the <code>future: Fut</code> into a Pin so we can call its <code>poll</code> method). If you read the <a href=\"https://doc.rust-lang.org/stable/std/pin/struct.Pin.html\"><code>Pin</code> methods</a> you&#39;ll see this is always safe if it points to an <code>Unpin</code> value, but requires unsafe otherwise.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">// Putting data into Pin\npub        fn new          &lt;P: Deref&lt;Target:Unpin&gt;&gt;(pointer: P) -&gt; Pin&lt;P&gt;;\npub unsafe fn new_unchecked&lt;P&gt;                     (pointer: P) -&gt; Pin&lt;P&gt;;\n\n// Getting data from Pin\npub        fn into_inner          &lt;P: Deref&lt;Target: Unpin&gt;&gt;(pin: Pin&lt;P&gt;) -&gt; P;\npub unsafe fn into_inner_unchecked&lt;P&gt;                      (pin: Pin&lt;P&gt;) -&gt; P;</pre></code>\n            <p></p><p>I know <code>unsafe</code> can be a bit scary, but it&#39;s OK to write unsafe code! I think of unsafe as the compiler saying &quot;hey, I can&#39;t tell if this code follows the rules here, so I&#39;m going to rely on you to check for me.&quot; The Rust compiler does so much work for us, it&#39;s only fair that we do some of the work every now and then. If you want to learn how to write your own projection methods, I can highly recommend <a href=\"https://fasterthanli.me/articles/pin-and-suffering\">this fasterthanli.me blog post</a> on the topic. But we&#39;re going to take a little shortcut.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"using-pin-project-instead\">Using pin-project instead</h3>\n            <a href=\"#using-pin-project-instead\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>So, OK, look, it&#39;s time for a confession: I don&#39;t like using <code>unsafe</code>. I know I just explained why it&#39;s OK, but still, given the option, I would rather not.</p><p>I didn&#39;t start writing Rust because I wanted to carefully think about the consequences of my actions, damnit, I just want to go fast and not break things. Luckily, someone sympathized with me and made a crate which generates totally safe projections! It&#39;s called <a href=\"https://docs.rs/pin-project\">pin-project</a> and it&#39;s <i>awesome</i>. All we need to do is change our definition:</p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">#[pin_project::pin_project] // This generates a `project` method\npub struct TimedWrapper&lt;Fut: Future&gt; {\n\t// For each field, we need to choose whether `project` returns an\n\t// unpinned (&amp;mut T) or pinned (Pin&lt;&amp;mut T&gt;) reference to the field.\n\t// By default, it assumes unpinned:\n\tstart: Option&lt;Instant&gt;,\n\t// Opt into pinned references with this attribute:\n\t#[pin]\n\tfuture: Fut,\n}</pre></code>\n            <p></p><p>For each field, you have to choose whether its projection should be pinned or not. By default, you should use a normal reference, just because they&#39;re easier and simpler. But if you know you need a pinned reference -- for example, because you want to call <code>.poll()</code>, whose receiver is <code>Pin&lt;&amp;mut Self&gt;</code> -- then you can do that with <code>#[pin]</code>.</p><p>Now we can finally poll the inner future!</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;Self::Output&gt; {\n\t// This returns a type with all the same fields, with all the same types,\n\t// except that the fields defined with #[pin] will be pinned.\n\tlet mut this = self.project();\n\t\n    // Call the inner poll, measuring how long it took.\n\tlet start = this.start.get_or_insert_with(Instant::now);\n\tlet inner_poll = this.future.as_mut().poll(cx);\n\tlet elapsed = start.elapsed();\n\n\tmatch inner_poll {\n\t\t// The inner future needs more time, so this future needs more time too\n\t\tPoll::Pending =&gt; Poll::Pending,\n\t\t// Success!\n\t\tPoll::Ready(output) =&gt; Poll::Ready((output, elapsed)),\n\t}\n}</pre></code>\n            <p></p><p>Finally, our goal is complete -- and we did it all without any unsafe code.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"summary\">Summary</h3>\n            <a href=\"#summary\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>If a Rust type has self-referential pointers, it can&#39;t be moved safely. After all, moving doesn&#39;t update the pointers, so they&#39;ll still be pointing at the old memory address, so they&#39;re now invalid. Rust can automatically tell which types are safe to move (and will auto impl the <code>Unpin</code> trait for them). If you have a <code>Pin</code>-ned pointer to some data, Rust can guarantee that nothing unsafe will happen (if it&#39;s safe to move, you can move it, if it&#39;s unsafe to move, then you can&#39;t). This is important because many Future types are self-referential, so we need <code>Pin</code> to safely poll a Future. You probably won&#39;t have to poll a future yourself (just use async/await instead), but if you do, use the <a href=\"https://docs.rs/pin-project\">pin-project</a> crate to simplify things.</p><p>I hope this helped -- if you have any questions, please <a href=\"https://twitter.com/adam_chal\">ask me on Twitter</a>. And if you want to get paid to talk to me about Rust and networking protocols, my team at Cloudflare is hiring, so be sure to visit <a href=\"https://www.cloudflare.com/careers/\">careers.cloudflare.com</a>.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"references\">References</h3>\n            <a href=\"#references\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <ul><li><p>Complete TimedWrapper example code on <a href=\"https://github.com/adamchalmers/nested-future-example/blob/master/src/main.rs\">GitHub</a></p></li><li><p>This post is based on a <a href=\"https://cloudflare.tv/event/2F1zRnM58eBCSHP2VEd74x\">presentation</a> I gave at a Rust Bay Area meetup a few weeks ago. My talk starts around 40 minutes in.</p></li><li><p>The <a href=\"https://doc.rust-lang.org/stable/std/pin/index.html\">std::pin docs</a> have a pretty good explanation of Pin&#39;s details.</p></li><li><p>The <a href=\"https://rust-lang.github.io/async-book/04_pinning/01_chapter.html\">Rust async book</a> explains why Futures often need self-referential pointers.</p></li><li><p>Comprehensive article on <a href=\"https://fasterthanli.me/articles/pin-and-suffering\">how pin projection actually works</a> by <a href=\"https://twitter.com/fasterthanlime/\">@fasterthanlime</a></p></li><li><p>Great article explaining when and how Rust <a href=\"https://hashrust.com/blog/moves-copies-and-clones-in-rust/\">moves values to different memory addresses</a>, by <a href=\"https://twitter.com/hashrust\">@HashRust</a><i>Thanks to Nick Vollmar for feedback and to</i> <a href=\"https://stackoverflow.com/users/155423/shepmaster\"><i>Shepmaster</i></a> <i>for helping me use pin-project when I first needed to write a nested Future</i></p></li></ul><p></p>",
		"id": "10AlR3uJVQ5N1QSlisjauG",
		"localeList": {
			"name": "Pin, Unpin, and why Rust needs them Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": null,
		"metadata": {
			"imgPreview": ""
		},
		"primary_author": {},
		"publicly_index": true,
		"published_at": "2021-08-26T16:04:04.000+01:00",
		"slug": "pin-and-unpin-in-rust",
		"tags": [
			{
				"id": "w4e8pkoz9c8xNDVhy9eNe",
				"name": "Rust",
				"slug": "rust"
			},
			{
				"id": "4HIPcb68qM0e26fIxyfzwQ",
				"name": "Developers",
				"slug": "developers"
			},
			{
				"id": "78aSAeMjGNmCuetQ7B4OgU",
				"name": "JavaScript",
				"slug": "javascript"
			},
			{
				"id": "2UVIYusJwlvsmPYl2AvSuR",
				"name": "Deep Dive",
				"slug": "deep-dive"
			}
		],
		"title": "Pin, Unpin, and why Rust needs them",
		"updated_at": "2024-10-10T00:44:22.555Z",
		"url": "https://blog.cloudflare.com/pin-and-unpin-in-rust"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.icon_aria_label": "Search",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"search.result_stat_empty": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong>",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"search.autocomplete_title": "Insert a query. Press enter to send",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}