{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "8",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Ignat Korchagin",
				"slug": "ignat",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/6l12U0uchJemRRwVMR9hDn/3c2bc0d267507f4f246623756909aca5/ignat.jpg",
				"location": null,
				"website": null,
				"twitter": "@ignatkn",
				"facebook": null
			}
		],
		"excerpt": "Continue learning how to import and execute code from an object file. This time we will investigate ELF relocations.",
		"feature_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/5oTbNBbKeXEuW6SrSE4SUz/a81677c8b215301fa4ebeb5ea422ba2f/how-to-execute-an-object-file-part-2.png",
		"featured": false,
		"html": "\n          <div class=\"flex anchor relative\">\n            <h2 id=\"handling-relocations\">Handling relocations</h2>\n            <a href=\"#handling-relocations\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>In the <a href=\"https://blog.cloudflare.com/how-to-execute-an-object-file-part-1/\">previous post</a>, we learned how to parse an object file and import and execute some functions from it. However, the functions in our toy object file were simple and self-contained: they computed their output solely based on their inputs and didn&#39;t have any external code or data dependencies. In this post we will build upon <a href=\"https://github.com/cloudflare/cloudflare-blog/tree/master/2021-03-obj-file/1\">the code from part 1</a>, exploring additional steps needed to handle code with some dependencies.</p><p>As an example, we may notice that we can actually rewrite our <code>add10</code> function using our <code>add5</code> function:</p><p><i>obj.c</i>:</p>\n            <pre class=\"language-cpp\"><code class=\"language-cpp\">int add5(int num)\n{\n    return num + 5;\n}\n \nint add10(int num)\n{\n    num = add5(num);\n    return add5(num);\n}</pre></code>\n            <p>Let&#39;s recompile the object file and try to use it as a library with our <code>loader</code> program:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ gcc -c obj.c\n$ ./loader\nExecuting add5...\nadd5(42) = 47\nExecuting add10...\nadd10(42) = 42</pre></code>\n            <p>Whoa! Something is not right here. <code>add5</code> still produces the correct result, but <code>add10</code> does not . Depending on your environment and code composition, you may even see the <code>loader</code> program crashing instead of outputting incorrect results. To understand what happened, let&#39;s investigate the machine code generated by the compiler. We can do that by asking the <a href=\"https://man7.org/linux/man-pages/man1/objdump.1.html\">objdump tool</a> to disassemble the <code>.text</code> section from our <code>obj.o</code>:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ objdump --disassemble --section=.text obj.o\n \nobj.o:     file format elf64-x86-64\n \n \nDisassembly of section .text:\n \n0000000000000000 &lt;add5&gt;:\n   0:\t55                   \tpush   %rbp\n   1:\t48 89 e5             \tmov    %rsp,%rbp\n   4:\t89 7d fc             \tmov    %edi,-0x4(%rbp)\n   7:\t8b 45 fc             \tmov    -0x4(%rbp),%eax\n   a:\t83 c0 05             \tadd    $0x5,%eax\n   d:\t5d                   \tpop    %rbp\n   e:\tc3                   \tretq\n \n000000000000000f &lt;add10&gt;:\n   f:\t55                   \tpush   %rbp\n  10:\t48 89 e5             \tmov    %rsp,%rbp\n  13:\t48 83 ec 08          \tsub    $0x8,%rsp\n  17:\t89 7d fc             \tmov    %edi,-0x4(%rbp)\n  1a:\t8b 45 fc             \tmov    -0x4(%rbp),%eax\n  1d:\t89 c7                \tmov    %eax,%edi\n  1f:\te8 00 00 00 00       \tcallq  24 &lt;add10+0x15&gt;\n  24:\t89 45 fc             \tmov    %eax,-0x4(%rbp)\n  27:\t8b 45 fc             \tmov    -0x4(%rbp),%eax\n  2a:\t89 c7                \tmov    %eax,%edi\n  2c:\te8 00 00 00 00       \tcallq  31 &lt;add10+0x22&gt;\n  31:\tc9                   \tleaveq\n  32:\tc3                   \tretq</pre></code>\n            <p>You don&#39;t have to understand the full output above. There are only two relevant lines here: <code>1f: e8 00 00 00 00</code> and <code>2c: e8 00 00 00 00</code>. These correspond to the two <code>add5</code> function invocations we have in the source code and <a href=\"https://man7.org/linux/man-pages/man1/objdump.1.html\">objdump</a> even conveniently decodes the instruction for us as <code>callq</code>. By looking at descriptions of the <code>callq</code> instruction online (like <a href=\"https://www.felixcloutier.com/x86/call\">this one</a>), we can further see we&#39;re dealing with a &quot;near, relative call&quot;, because of the <code>0xe8</code> prefix:</p><blockquote><p>Call near, relative, displacement relative to next instruction.</p></blockquote><p>According to the <a href=\"https://www.felixcloutier.com/x86/call\">description</a>, this variant of the <code>callq</code> instruction consists of 5 bytes: the <code>0xe8</code> prefix and a 4-byte (32 bit) argument. This is where &quot;relative&quot; comes from: the argument should contain the “distance” between the function we want to call and the current position — because the way how x86 works this distance is calculated from the next instruction and not our current <code>callq</code> instruction. <a href=\"https://man7.org/linux/man-pages/man1/objdump.1.html\">objdump</a> conveniently outputs each machine instruction&#39;s offset in the output above, so we can easily calculate the needed argument. For example, for the first <code>callq</code> instruction (<code>1f: e8 00 00 00 00</code>) the next instruction is at offset <code>0x24</code>. We know we should be calling the <code>add5</code> function, which starts at offset <code>0x0</code> (beginning of our <code>.text</code> section). So the relative offset is <code>0x0 - 0x24 = -0x24</code>. Notice, we have a negative argument, because the <code>add5</code> function is located before our calling instruction, so we would be instructing the CPU to &quot;jump backwards&quot; from its current position. Lastly, we have to remember that negative numbers — at least on x86 systems — are presented by their <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\">two&#39;s complements</a>, so a 4-byte (32 bit) representation of <code>-0x24</code> would be <code>0xffffffdc</code>. In the same way we can calculate the <code>callq</code> argument for the second <code>add5</code> call: <code>0x0 - 0x31 = -0x31</code>, two&#39;s complement - <code>0xffffffcf</code>:</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/7hr8krlEJ3GlvbDl2xV3Ww/399083ccb10913e9e708469bbce146c7/relative-calls.png\" alt=\"relative-calls\" class=\"kg-image\" width=\"499\" height=\"583\" loading=\"lazy\"/>\n            \n            </figure><p>It seems the compiler does not generate the right <code>callq</code> arguments for us. We&#39;ve calculated the expected arguments to be <code>0xffffffdc</code> and <code>0xffffffcf</code>, but the compiler has just left <code>0x00000000</code> in both places. Let&#39;s check first if our expectations are correct by patching our loaded <code>.text</code> copy before trying to execute it:</p><p><i>loader.c</i>:</p>\n            <pre class=\"language-cpp\"><code class=\"language-cpp\">...\n \nstatic void parse_obj(void)\n{\n...\n    /* copy the contents of `.text` section from the ELF file */\n    memcpy(text_runtime_base, obj.base + text_hdr-&gt;sh_offset, text_hdr-&gt;sh_size);\n \n    /* the first add5 callq argument is located at offset 0x20 and should be 0xffffffdc:\n     * 0x1f is the instruction offset + 1 byte instruction prefix\n     */\n    *((uint32_t *)(text_runtime_base + 0x1f + 1)) = 0xffffffdc;\n \n    /* the second add5 callq argument is located at offset 0x2d and should be 0xffffffcf */\n    *((uint32_t *)(text_runtime_base + 0x2c + 1)) = 0xffffffcf;\n \n    /* make the `.text` copy readonly and executable */\n    if (mprotect(text_runtime_base, page_align(text_hdr-&gt;sh_size), PROT_READ | PROT_EXEC)) {\n...</pre></code>\n            <p>And now let&#39;s test it out:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ gcc -o loader loader.c \n$ ./loader \nExecuting add5...\nadd5(42) = 47\nExecuting add10...\nadd10(42) = 52</pre></code>\n            <p>Clearly our monkey-patching helped: <code>add10</code> executes fine now and produces the correct output. This means our expected <code>callq</code> arguments, which we calculated, are correct. So why did the compiler emit wrong <code>callq</code> arguments?</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"relocations\">Relocations</h3>\n            <a href=\"#relocations\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>The problem with our toy object file is that both functions are declared with external linkage — the default setting for all functions and global variables in C. And, although both functions are declared in the same file, the compiler is not sure where the <code>add5</code> code will end up in the target binary. So the compiler avoids making any assumptions and doesn’t calculate the relative offset argument of the <code>callq</code> instructions. Let&#39;s verify this by removing our monkey patching and declaring the <code>add5</code> function as <code>static</code>:</p><p><i>loader.c</i>:</p>\n            <pre class=\"language-cpp\"><code class=\"language-cpp\">...\n \n    /* the first add5 callq argument is located at offset 0x20 and should be 0xffffffdc:\n     * 0x1f is the instruction offset + 1 byte instruction prefix\n     */\n    /* *((uint32_t *)(text_runtime_base + 0x1f + 1)) = 0xffffffdc; */\n \n    /* the second add5 callq argument is located at offset 0x2d and should be 0xffffffcf */\n    /* *((uint32_t *)(text_runtime_base + 0x2c + 1)) = 0xffffffcf; */\n \n...</pre></code>\n            <p><i>obj.c</i>:</p>\n            <pre class=\"language-cpp\"><code class=\"language-cpp\">/* int add5(int num) */\nstatic int add5(int num)\n...</pre></code>\n            <p>Recompiling and disassembling <code>obj.o</code> gives us the following:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ gcc -c obj.c\n$ objdump --disassemble --section=.text obj.o\n \nobj.o:     file format elf64-x86-64\n \n \nDisassembly of section .text:\n \n0000000000000000 &lt;add5&gt;:\n   0:\t55                   \tpush   %rbp\n   1:\t48 89 e5             \tmov    %rsp,%rbp\n   4:\t89 7d fc             \tmov    %edi,-0x4(%rbp)\n   7:\t8b 45 fc             \tmov    -0x4(%rbp),%eax\n   a:\t83 c0 05             \tadd    $0x5,%eax\n   d:\t5d                   \tpop    %rbp\n   e:\tc3                   \tretq\n \n000000000000000f &lt;add10&gt;:\n   f:\t55                   \tpush   %rbp\n  10:\t48 89 e5             \tmov    %rsp,%rbp\n  13:\t48 83 ec 08          \tsub    $0x8,%rsp\n  17:\t89 7d fc             \tmov    %edi,-0x4(%rbp)\n  1a:\t8b 45 fc             \tmov    -0x4(%rbp),%eax\n  1d:\t89 c7                \tmov    %eax,%edi\n  1f:\te8 dc ff ff ff       \tcallq  0 &lt;add5&gt;\n  24:\t89 45 fc             \tmov    %eax,-0x4(%rbp)\n  27:\t8b 45 fc             \tmov    -0x4(%rbp),%eax\n  2a:\t89 c7                \tmov    %eax,%edi\n  2c:\te8 cf ff ff ff       \tcallq  0 &lt;add5&gt;\n  31:\tc9                   \tleaveq\n  32:\tc3                   \tretq</pre></code>\n            <p>Because we re-declared the <code>add5</code> function with internal linkage, the compiler is more confident now and calculates <code>callq</code> arguments correctly (note that x86 systems are <a href=\"https://en.wikipedia.org/wiki/Endianness\">little-endian</a>, so multibyte numbers like <code>0xffffffdc</code> will be represented with least significant byte first). We can double check this by recompiling and running our <code>loader</code> test tool:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ gcc -o loader loader.c\n$ ./loader\nExecuting add5...\nadd5(42) = 47\nExecuting add10...\nadd10(42) = 52</pre></code>\n            <p>Even though the <code>add5</code> function is declared as <code>static</code>, we can still call it from the <code>loader</code> tool, basically ignoring the fact that it is an &quot;internal&quot; function now. Because of this, the <code>static</code> keyword should not be used as a security feature to hide APIs from potential malicious users.</p><p>But let&#39;s step back and revert our <code>add5</code> function in <code>obj.c</code> to the one with external linkage:</p><p><i>obj.c</i>:</p>\n            <pre class=\"language-cpp\"><code class=\"language-cpp\">int add5(int num)\n...</pre></code>\n            \n            <pre class=\"language-bash\"><code class=\"language-bash\">$ gcc -c obj.c\n$ ./loader\nExecuting add5...\nadd5(42) = 47\nExecuting add10...\nadd10(42) = 42</pre></code>\n            <p>As we have established above, the compiler did not compute proper <code>callq</code> arguments for us because it didn&#39;t have enough information. But later stages (namely the linker) will have that information, so instead the compiler leaves some clues on how to fix those arguments. These clues — or instructions for the later stages — are called <b>relocations</b>. We can inspect them with our friend, the <a href=\"https://man7.org/linux/man-pages/man1/readelf.1.html\">readelf</a> utility. Let&#39;s examine <code>obj.o</code> sections table again:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ readelf --sections obj.o\nThere are 12 section headers, starting at offset 0x2b0:\n \nSection Headers:\n  [Nr] Name              Type             Address           Offset\n       Size              EntSize          Flags  Link  Info  Align\n  [ 0]                   NULL             0000000000000000  00000000\n       0000000000000000  0000000000000000           0     0     0\n  [ 1] .text             PROGBITS         0000000000000000  00000040\n       0000000000000033  0000000000000000  AX       0     0     1\n  [ 2] .rela.text        RELA             0000000000000000  000001f0\n       0000000000000030  0000000000000018   I       9     1     8\n  [ 3] .data             PROGBITS         0000000000000000  00000073\n       0000000000000000  0000000000000000  WA       0     0     1\n  [ 4] .bss              NOBITS           0000000000000000  00000073\n       0000000000000000  0000000000000000  WA       0     0     1\n  [ 5] .comment          PROGBITS         0000000000000000  00000073\n       000000000000001d  0000000000000001  MS       0     0     1\n  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  00000090\n       0000000000000000  0000000000000000           0     0     1\n  [ 7] .eh_frame         PROGBITS         0000000000000000  00000090\n       0000000000000058  0000000000000000   A       0     0     8\n  [ 8] .rela.eh_frame    RELA             0000000000000000  00000220\n       0000000000000030  0000000000000018   I       9     7     8\n  [ 9] .symtab           SYMTAB           0000000000000000  000000e8\n       00000000000000f0  0000000000000018          10     8     8\n  [10] .strtab           STRTAB           0000000000000000  000001d8\n       0000000000000012  0000000000000000           0     0     1\n  [11] .shstrtab         STRTAB           0000000000000000  00000250\n       0000000000000059  0000000000000000           0     0     1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  l (large), p (processor specific)</pre></code>\n            <p>We see that the compiler created a new section called <code>.rela.text</code>. By convention, a section with relocations for a section named <code>.foo</code> will be called <code>.rela.foo</code>, so we can see that the compiler created a section with relocations for the <code>.text</code> section. We can examine the relocations further:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ readelf --relocs obj.o\n \nRelocation section &#039;.rela.text&#039; at offset 0x1f0 contains 2 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000000020  000800000004 R_X86_64_PLT32    0000000000000000 add5 - 4\n00000000002d  000800000004 R_X86_64_PLT32    0000000000000000 add5 - 4\n \nRelocation section &#039;.rela.eh_frame&#039; at offset 0x220 contains 2 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0\n000000000040  000200000002 R_X86_64_PC32     0000000000000000 .text + f</pre></code>\n            <p>Let&#39;s ignore the relocations from the <code>.rela.eh_frame</code> section because they are out of scope of this post. Instead, let’s try to understand the relocations from the <code>.rela.text</code>:</p><ul><li><p><code>Offset</code> column tells us exactly where in the target section (<code>.text</code> in this case) the fix/adjustment is needed. Note that these offsets are exactly the same as in our self-calculated monkey-patching above.</p></li><li><p><code>Info</code> is a combined value: the upper 32 bits — only 16 bits are shown in the output above — represent the index of the symbol in the symbol table, with respect to which the relocation is performed. In our example it is <code>8</code> and if we run <code>readelf --symbols obj.o</code> we will see that it points to an entry corresponding to the <code>add5</code> function. The lower 32 bits (<code>4</code> in our case) is a relocation type (see <code>Type</code> below).</p></li><li><p><code>Type</code> describes the relocation type. This is a pseudo-column: <code>readelf</code> actually generates it from the lower 32 bits of the <code>Info</code> field. Different relocation types have different formulas we need to apply to perform the relocation.</p></li><li><p><code>Sym. Value</code> may mean different things depending on the relocation type, but most of the time it is the symbol offset with respect to which we perform the relocation. The offset is calculated from the beginning of that symbol’s section.</p></li><li><p><code>Addend</code> is a constant we may need to use in the relocation formula. Depending on the relocation type, <a href=\"https://man7.org/linux/man-pages/man1/readelf.1.html\">readelf</a> actually adds the decoded symbol name to the output, so the column name is <code>Sym. Name + Addend</code> above but the actual field stores the addend only.</p></li></ul><p>In a nutshell, these entries tell us that we need to patch the <code>.text</code> section at offsets <code>0x20</code> and <code>0x2d</code>. To calculate what to put there, we need to apply the formula for the <code>R_X86_64_PLT32</code> relocation type. Searching online, we can find different ELF specifications — like <a href=\"https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.95.pdf\">this one</a> — which will tell us how to implement the <code>R_X86_64_PLT32</code> relocation. The specification mentions that the result of this relocation is <code>word32</code> — which is what we expect because <code>callq</code> arguments are 32 bit in our case — and the formula we need to apply is <code>L + A - P</code>, where:</p><ul><li><p><code>L</code> is the address of the symbol, with respect to which the relocation is performed (<code>add5</code> in our case)</p></li><li><p><code>A</code> is the constant addend (<code>4</code> in our case)</p></li><li><p><code>P</code> is the address/offset, where we store the result of the relocation</p></li></ul><p>When the relocation formula references some symbol addresses or offsets, we should use the actual — runtime in our case — addresses in the calculations. For example, we will be using <code>text_runtime_base + 0x2d</code> as <code>P</code> for the second relocation and not just <code>0x2d</code>. So let&#39;s try to implement this relocation logic in our object loader:</p><p><i>loader.c</i>:</p>\n            <pre class=\"language-cpp\"><code class=\"language-cpp\">...\n \n/* from https://elixir.bootlin.com/linux/v5.11.6/source/arch/x86/include/asm/elf.h#L51 */\n#define R_X86_64_PLT32 4\n \n...\n \nstatic uint8_t *section_runtime_base(const Elf64_Shdr *section)\n{\n    const char *section_name = shstrtab + section-&gt;sh_name;\n    size_t section_name_len = strlen(section_name);\n \n    /* we only mmap .text section so far */\n    if (strlen(&quot;.text&quot;) == section_name_len &amp;&amp; !strcmp(&quot;.text&quot;, section_name))\n        return text_runtime_base;\n \n    fprintf(stderr, &quot;No runtime base address for section %s\\n&quot;, section_name);\n    exit(ENOENT);\n}\n \nstatic void do_text_relocations(void)\n{\n    /* we actually cheat here - the name .rela.text is a convention, but not a\n     * rule: to figure out which section should be patched by these relocations\n     * we would need to examine the rela_text_hdr, but we skip it for simplicity\n     */\n    const Elf64_Shdr *rela_text_hdr = lookup_section(&quot;.rela.text&quot;);\n    if (!rela_text_hdr) {\n        fputs(&quot;Failed to find .rela.text\\n&quot;, stderr);\n        exit(ENOEXEC);\n    }\n \n    int num_relocations = rela_text_hdr-&gt;sh_size / rela_text_hdr-&gt;sh_entsize;\n    const Elf64_Rela *relocations = (Elf64_Rela *)(obj.base + rela_text_hdr-&gt;sh_offset);\n \n    for (int i = 0; i &lt; num_relocations; i++) {\n        int symbol_idx = ELF64_R_SYM(relocations[i].r_info);\n        int type = ELF64_R_TYPE(relocations[i].r_info);\n \n        /* where to patch .text */\n        uint8_t *patch_offset = text_runtime_base + relocations[i].r_offset;\n        /* symbol, with respect to which the relocation is performed */\n        uint8_t *symbol_address = section_runtime_base(&amp;sections[symbols[symbol_idx].st_shndx]) + symbols[symbol_idx].st_value;\n \n        switch (type)\n        {\n        case R_X86_64_PLT32:\n            /* L + A - P, 32 bit output */\n            *((uint32_t *)patch_offset) = symbol_address + relocations[i].r_addend - patch_offset;\n            printf(&quot;Calculated relocation: 0x%08x\\n&quot;, *((uint32_t *)patch_offset));\n            break;\n        }\n    }\n}\n \nstatic void parse_obj(void)\n{\n...\n \n    /* copy the contents of `.text` section from the ELF file */\n    memcpy(text_runtime_base, obj.base + text_hdr-&gt;sh_offset, text_hdr-&gt;sh_size);\n \n    do_text_relocations();\n \n    /* make the `.text` copy readonly and executable */\n    if (mprotect(text_runtime_base, page_align(text_hdr-&gt;sh_size), PROT_READ | PROT_EXEC)) {\n \n...\n}\n \n...</pre></code>\n            <p>We are now calling the <code>do_text_relocations</code> function before marking our <code>.text</code> copy executable. We have also added some debugging output to inspect the result of the relocation calculations. Let&#39;s try it out:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ gcc -o loader loader.c \n$ ./loader \nCalculated relocation: 0xffffffdc\nCalculated relocation: 0xffffffcf\nExecuting add5...\nadd5(42) = 47\nExecuting add10...\nadd10(42) = 52</pre></code>\n            <p>Great! Our imported code works as expected now. By following the relocation hints left for us by the compiler, we&#39;ve got the same results as in our monkey-patching calculations in the beginning of this post. Our relocation calculations also involved <code>text_runtime_base</code> address, which is not available at compile time. That&#39;s why the compiler could not calculate the <code>callq</code> arguments in the first place and had to emit the relocations instead.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"handling-constant-data-and-global-variables\">Handling constant data and global variables</h3>\n            <a href=\"#handling-constant-data-and-global-variables\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>So far, we have been dealing with object files containing only executable code with no state. That is, the imported functions could compute their output solely based on the inputs. Let&#39;s see what happens if we add some constant data and global variables dependencies to our imported code. First, we add some more functions to our <code>obj.o</code>:</p><p><i>obj.c</i>:</p>\n            <pre class=\"language-cpp\"><code class=\"language-cpp\">...\n \nconst char *get_hello(void)\n{\n    return &quot;Hello, world!&quot;;\n}\n \nstatic int var = 5;\n \nint get_var(void)\n{\n    return var;\n}\n \nvoid set_var(int num)\n{\n    var = num;\n}</pre></code>\n            <p><code>get_hello</code> returns a constant string and <code>get_var</code>/<code>set_var</code> get and set a global variable respectively. Next, let&#39;s recompile the <code>obj.o</code> and run our loader:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ gcc -c obj.c\n$ ./loader \nCalculated relocation: 0xffffffdc\nCalculated relocation: 0xffffffcf\nNo runtime base address for section .rodata</pre></code>\n            <p>Looks like our loader tried to process more relocations but could not find the runtime address for <code>.rodata</code> section. Previously, we didn&#39;t even have a <code>.rodata</code> section, but it was added now because our <code>obj.o</code> needs somewhere to store the constant string <code>Hello, world!:</code></p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ readelf --sections obj.o\nThere are 13 section headers, starting at offset 0x478:\n \nSection Headers:\n  [Nr] Name              Type             Address           Offset\n       Size              EntSize          Flags  Link  Info  Align\n  [ 0]                   NULL             0000000000000000  00000000\n       0000000000000000  0000000000000000           0     0     0\n  [ 1] .text             PROGBITS         0000000000000000  00000040\n       000000000000005f  0000000000000000  AX       0     0     1\n  [ 2] .rela.text        RELA             0000000000000000  00000320\n       0000000000000078  0000000000000018   I      10     1     8\n  [ 3] .data             PROGBITS         0000000000000000  000000a0\n       0000000000000004  0000000000000000  WA       0     0     4\n  [ 4] .bss              NOBITS           0000000000000000  000000a4\n       0000000000000000  0000000000000000  WA       0     0     1\n  [ 5] .rodata           PROGBITS         0000000000000000  000000a4\n       000000000000000d  0000000000000000   A       0     0     1\n  [ 6] .comment          PROGBITS         0000000000000000  000000b1\n       000000000000001d  0000000000000001  MS       0     0     1\n  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000ce\n       0000000000000000  0000000000000000           0     0     1\n  [ 8] .eh_frame         PROGBITS         0000000000000000  000000d0\n       00000000000000b8  0000000000000000   A       0     0     8\n  [ 9] .rela.eh_frame    RELA             0000000000000000  00000398\n       0000000000000078  0000000000000018   I      10     8     8\n  [10] .symtab           SYMTAB           0000000000000000  00000188\n       0000000000000168  0000000000000018          11    10     8\n  [11] .strtab           STRTAB           0000000000000000  000002f0\n       000000000000002c  0000000000000000           0     0     1\n  [12] .shstrtab         STRTAB           0000000000000000  00000410\n       0000000000000061  0000000000000000           0     0     1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  l (large), p (processor specific)</pre></code>\n            <p>We also have more <code>.text</code> relocations:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ readelf --relocs obj.o\n \nRelocation section &#039;.rela.text&#039; at offset 0x320 contains 5 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000000020  000a00000004 R_X86_64_PLT32    0000000000000000 add5 - 4\n00000000002d  000a00000004 R_X86_64_PLT32    0000000000000000 add5 - 4\n00000000003a  000500000002 R_X86_64_PC32     0000000000000000 .rodata - 4\n000000000046  000300000002 R_X86_64_PC32     0000000000000000 .data - 4\n000000000058  000300000002 R_X86_64_PC32     0000000000000000 .data - 4\n...</pre></code>\n            <p>The compiler emitted three more <code>R_X86_64_PC32</code> relocations this time. They reference symbols with index <code>3</code> and <code>5</code>, so let&#39;s find out what they are:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ readelf --symbols obj.o\n \nSymbol table &#039;.symtab&#039; contains 15 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND\n     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS obj.c\n     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1\n     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3\n     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4\n     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5\n     6: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    3 var\n     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    7\n     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    8\n     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    6\n    10: 0000000000000000    15 FUNC    GLOBAL DEFAULT    1 add5\n    11: 000000000000000f    36 FUNC    GLOBAL DEFAULT    1 add10\n    12: 0000000000000033    13 FUNC    GLOBAL DEFAULT    1 get_hello\n    13: 0000000000000040    12 FUNC    GLOBAL DEFAULT    1 get_var\n    14: 000000000000004c    19 FUNC    GLOBAL DEFAULT    1 set_var</pre></code>\n            <p>Entries <code>3</code> and <code>5</code> don&#39;t have any names attached, but they reference something in sections with index <code>3</code> and <code>5</code> respectively. In the output of the section table above, we can see that the section with index <code>3</code> is <code>.data</code> and the section with index <code>5</code> is <code>.rodata</code>. For a refresher on the most common sections in an ELF file check out our <a href=\"https://blog.cloudflare.com/how-to-execute-an-object-file-part-1/\">previous post</a>. To import our newly added code and make it work, we also need to map <code>.data</code> and <code>.rodata</code> sections in addition to the <code>.text</code> section and process these <code>R_X86_64_PC32</code> relocations.</p><p>There is one caveat though. If we check <a href=\"https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.95.pdf\">the specification</a>, we&#39;ll see that <code>R_X86_64_PC32</code> relocation produces a 32-bit output similar to the <code>R_X86_64_PLT32</code> relocation. This means that the &quot;distance&quot; in memory between the patched position in <code>.text</code> and the referenced symbol has to be small enough to fit into a 32-bit value (1 bit for the positive/negative sign and 31 bits for the actual data, so less than 2147483647 bytes). Our <code>loader</code> program uses <a href=\"https://man7.org/linux/man-pages/man2/mmap.2.html\">mmap system call</a> to allocate memory for the object section copies, but <a href=\"https://man7.org/linux/man-pages/man2/mmap.2.html\">mmap</a> may allocate the mapping almost anywhere in the process address space. If we modify the <code>loader</code> program to call <a href=\"https://man7.org/linux/man-pages/man2/mmap.2.html\">mmap</a> for each section separately, we may end up having <code>.rodata</code> or <code>.data</code> section mapped too far away from the <code>.text</code> section and will not be able to process the <code>R_X86_64_PC32</code> relocations. In other words, we need to ensure that <code>.data</code> and <code>.rodata</code> sections are located relatively close to the <code>.text</code> section at runtime:</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/4e8Qr6ZYKMwqrHQAgJhnHD/4564b50135a73af5a36eb29ba877c320/runtime-diff.png\" alt=\"runtime-diff\" class=\"kg-image\" width=\"314\" height=\"543\" loading=\"lazy\"/>\n            \n            </figure><p>One way to achieve that would be to allocate the memory we need for all the sections with one <a href=\"https://man7.org/linux/man-pages/man2/mmap.2.html\">mmap call</a>. Then, we’d break it in chunks and assign proper access permissions to each chunk. Let&#39;s modify our <code>loader</code> program to do just that:</p><p><i>loader.c</i>:</p>\n            <pre class=\"language-cpp\"><code class=\"language-cpp\">...\n \n/* runtime base address of the imported code */\nstatic uint8_t *text_runtime_base;\n/* runtime base of the .data section */\nstatic uint8_t *data_runtime_base;\n/* runtime base of the .rodata section */\nstatic uint8_t *rodata_runtime_base;\n \n...\n \nstatic void parse_obj(void)\n{\n...\n \n    /* find the `.text` entry in the sections table */\n    const Elf64_Shdr *text_hdr = lookup_section(&quot;.text&quot;);\n    if (!text_hdr) {\n        fputs(&quot;Failed to find .text\\n&quot;, stderr);\n        exit(ENOEXEC);\n    }\n \n    /* find the `.data` entry in the sections table */\n    const Elf64_Shdr *data_hdr = lookup_section(&quot;.data&quot;);\n    if (!data_hdr) {\n        fputs(&quot;Failed to find .data\\n&quot;, stderr);\n        exit(ENOEXEC);\n    }\n \n    /* find the `.rodata` entry in the sections table */\n    const Elf64_Shdr *rodata_hdr = lookup_section(&quot;.rodata&quot;);\n    if (!rodata_hdr) {\n        fputs(&quot;Failed to find .rodata\\n&quot;, stderr);\n        exit(ENOEXEC);\n    }\n \n    /* allocate memory for `.text`, `.data` and `.rodata` copies rounding up each section to whole pages */\n    text_runtime_base = mmap(NULL, page_align(text_hdr-&gt;sh_size) + page_align(data_hdr-&gt;sh_size) + page_align(rodata_hdr-&gt;sh_size), PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (text_runtime_base == MAP_FAILED) {\n        perror(&quot;Failed to allocate memory&quot;);\n        exit(errno);\n    }\n \n    /* .data will come right after .text */\n    data_runtime_base = text_runtime_base + page_align(text_hdr-&gt;sh_size);\n    /* .rodata will come after .data */\n    rodata_runtime_base = data_runtime_base + page_align(data_hdr-&gt;sh_size);\n \n    /* copy the contents of `.text` section from the ELF file */\n    memcpy(text_runtime_base, obj.base + text_hdr-&gt;sh_offset, text_hdr-&gt;sh_size);\n    /* copy .data */\n    memcpy(data_runtime_base, obj.base + data_hdr-&gt;sh_offset, data_hdr-&gt;sh_size);\n    /* copy .rodata */\n    memcpy(rodata_runtime_base, obj.base + rodata_hdr-&gt;sh_offset, rodata_hdr-&gt;sh_size);\n \n    do_text_relocations();\n \n    /* make the `.text` copy readonly and executable */\n    if (mprotect(text_runtime_base, page_align(text_hdr-&gt;sh_size), PROT_READ | PROT_EXEC)) {\n        perror(&quot;Failed to make .text executable&quot;);\n        exit(errno);\n    }\n \n    /* we don&#039;t need to do anything with .data - it should remain read/write */\n \n    /* make the `.rodata` copy readonly */\n    if (mprotect(rodata_runtime_base, page_align(rodata_hdr-&gt;sh_size), PROT_READ)) {\n        perror(&quot;Failed to make .rodata readonly&quot;);\n        exit(errno);\n    }\n}\n \n...</pre></code>\n            <p>Now that we have runtime addresses of <code>.data</code> and <code>.rodata</code>, we can update the relocation runtime address lookup function:</p><p><i>loader.c</i>:</p>\n            <pre class=\"language-cpp\"><code class=\"language-cpp\">...\n \nstatic uint8_t *section_runtime_base(const Elf64_Shdr *section)\n{\n    const char *section_name = shstrtab + section-&gt;sh_name;\n    size_t section_name_len = strlen(section_name);\n \n    if (strlen(&quot;.text&quot;) == section_name_len &amp;&amp; !strcmp(&quot;.text&quot;, section_name))\n        return text_runtime_base;\n \n    if (strlen(&quot;.data&quot;) == section_name_len &amp;&amp; !strcmp(&quot;.data&quot;, section_name))\n        return data_runtime_base;\n \n    if (strlen(&quot;.rodata&quot;) == section_name_len &amp;&amp; !strcmp(&quot;.rodata&quot;, section_name))\n        return rodata_runtime_base;\n \n    fprintf(stderr, &quot;No runtime base address for section %s\\n&quot;, section_name);\n    exit(ENOENT);\n}</pre></code>\n            <p>And finally we can import and execute our new functions:</p><p><i>loader.c</i>:</p>\n            <pre class=\"language-cpp\"><code class=\"language-cpp\">...\n \nstatic void execute_funcs(void)\n{\n    /* pointers to imported functions */\n    int (*add5)(int);\n    int (*add10)(int);\n    const char *(*get_hello)(void);\n    int (*get_var)(void);\n    void (*set_var)(int num);\n \n...\n \n    printf(&quot;add10(%d) = %d\\n&quot;, 42, add10(42));\n \n    get_hello = lookup_function(&quot;get_hello&quot;);\n    if (!get_hello) {\n        fputs(&quot;Failed to find get_hello function\\n&quot;, stderr);\n        exit(ENOENT);\n    }\n \n    puts(&quot;Executing get_hello...&quot;);\n    printf(&quot;get_hello() = %s\\n&quot;, get_hello());\n \n    get_var = lookup_function(&quot;get_var&quot;);\n    if (!get_var) {\n        fputs(&quot;Failed to find get_var function\\n&quot;, stderr);\n        exit(ENOENT);\n    }\n \n    puts(&quot;Executing get_var...&quot;);\n    printf(&quot;get_var() = %d\\n&quot;, get_var());\n \n    set_var = lookup_function(&quot;set_var&quot;);\n    if (!set_var) {\n        fputs(&quot;Failed to find set_var function\\n&quot;, stderr);\n        exit(ENOENT);\n    }\n \n    puts(&quot;Executing set_var(42)...&quot;);\n    set_var(42);\n \n    puts(&quot;Executing get_var again...&quot;);\n    printf(&quot;get_var() = %d\\n&quot;, get_var());\n}\n...</pre></code>\n            <p>Let&#39;s try it out:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ gcc -o loader loader.c \n$ ./loader \nCalculated relocation: 0xffffffdc\nCalculated relocation: 0xffffffcf\nExecuting add5...\nadd5(42) = 47\nExecuting add10...\nadd10(42) = 52\nExecuting get_hello...\nget_hello() = ]�UH��\nExecuting get_var...\nget_var() = 1213580125\nExecuting set_var(42)...\nSegmentation fault</pre></code>\n            <p>Uh-oh! We forgot to implement the new <code>R_X86_64_PC32</code> relocation type. The <a href=\"https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.95.pdf\">relocation formula</a> here is <code>S + A - P</code>. We already know about <code>A</code> and <code>P</code>. As for <code>S</code> (quoting from <a href=\"https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.95.pdf\">the spec</a>):</p><blockquote><p>“the value of the symbol whose index resides in the relocation entry&quot;</p></blockquote><p>In our case, it is essentially the same as <code>L</code> for <code>R_X86_64_PLT32</code>. We can just reuse the implementation and remove the debug output in the process:</p><p><i>loader.c</i>:</p>\n            <pre class=\"language-cpp\"><code class=\"language-cpp\">...\n \n/* from https://elixir.bootlin.com/linux/v5.11.6/source/arch/x86/include/asm/elf.h#L51 */\n#define R_X86_64_PC32 2\n#define R_X86_64_PLT32 4\n \n...\n \nstatic void do_text_relocations(void)\n{\n    /* we actually cheat here - the name .rela.text is a convention, but not a\n     * rule: to figure out which section should be patched by these relocations\n     * we would need to examine the rela_text_hdr, but we skip it for simplicity\n     */\n    const Elf64_Shdr *rela_text_hdr = lookup_section(&quot;.rela.text&quot;);\n    if (!rela_text_hdr) {\n        fputs(&quot;Failed to find .rela.text\\n&quot;, stderr);\n        exit(ENOEXEC);\n    }\n \n    int num_relocations = rela_text_hdr-&gt;sh_size / rela_text_hdr-&gt;sh_entsize;\n    const Elf64_Rela *relocations = (Elf64_Rela *)(obj.base + rela_text_hdr-&gt;sh_offset);\n \n    for (int i = 0; i &lt; num_relocations; i++) {\n        int symbol_idx = ELF64_R_SYM(relocations[i].r_info);\n        int type = ELF64_R_TYPE(relocations[i].r_info);\n \n        /* where to patch .text */\n        uint8_t *patch_offset = text_runtime_base + relocations[i].r_offset;\n        /* symbol, with respect to which the relocation is performed */\n        uint8_t *symbol_address = section_runtime_base(&amp;sections[symbols[symbol_idx].st_shndx]) + symbols[symbol_idx].st_value;\n \n        switch (type)\n        {\n        case R_X86_64_PC32:\n            /* S + A - P, 32 bit output, S == L here */\n        case R_X86_64_PLT32:\n            /* L + A - P, 32 bit output */\n            *((uint32_t *)patch_offset) = symbol_address + relocations[i].r_addend - patch_offset;\n            break;\n        }\n    }\n}\n \n...</pre></code>\n            <p>Now we should be done. Another try:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ gcc -o loader loader.c \n$ ./loader \nExecuting add5...\nadd5(42) = 47\nExecuting add10...\nadd10(42) = 52\nExecuting get_hello...\nget_hello() = Hello, world!\nExecuting get_var...\nget_var() = 5\nExecuting set_var(42)...\nExecuting get_var again...\nget_var() = 42</pre></code>\n            <p>This time we can successfully import functions that reference static constant data and global variables. We can even manipulate the object file’s internal state through the defined accessor interface. As before, the complete source code for this post is <a href=\"https://github.com/cloudflare/cloudflare-blog/tree/master/2021-03-obj-file/2\">available on GitHub</a>.</p><p>In the next post, we will look into importing and executing object code with references to external libraries. Stay tuned!</p>",
		"id": "6S16duVAPX4oHU5pN43RlW",
		"localeList": {
			"name": "How to execute an object file: Part 2 Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "Continue learning how to import and execute code from an object file. This time we will investigate ELF relocations.",
		"metadata": {
			"title": "How to execute an object file: Part 2",
			"description": "Continue learning how to import and execute code from an object file. This time we will investigate ELF relocations.",
			"imgPreview": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/3Yqpdu1EB5mb4zJQqE8NT2/9585e8365286582f62db2465da457601/how-to-execute-an-object-file-part-2-W3oZBs.png"
		},
		"primary_author": {},
		"published_at": "2021-04-02T12:00:00.000+01:00",
		"slug": "how-to-execute-an-object-file-part-2",
		"tags": [
			{
				"id": "383iv0UQ6Lp0GZwOAxGq2p",
				"name": "Linux",
				"slug": "linux"
			},
			{
				"id": "6lhzEBz2B56RKa4nUEAGYJ",
				"name": "Programming",
				"slug": "programming"
			},
			{
				"id": "2UVIYusJwlvsmPYl2AvSuR",
				"name": "Deep Dive",
				"slug": "deep-dive"
			}
		],
		"title": "How to execute an object file: Part 2",
		"updated_at": "2024-08-27T01:51:22.159Z",
		"url": "https://blog.cloudflare.com/how-to-execute-an-object-file-part-2"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}