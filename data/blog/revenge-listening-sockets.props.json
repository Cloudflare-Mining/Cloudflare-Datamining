{
	"locale": "en-us",
	"post": {
		"access": true,
		"authors": [
			{
				"id": "5d1644b141acde0011a94f30",
				"name": "Marek Majkowski",
				"slug": "marek-majkowski",
				"profile_image": "http://blog.cloudflare.com/content/images/2017/03/b5967d6c687939594adb6992723d0529.jpeg",
				"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-101.png",
				"bio": null,
				"website": null,
				"location": null,
				"facebook": null,
				"twitter": "@majek04",
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/marek-majkowski/"
			}
		],
		"canonical_url": null,
		"codeinjection_foot": null,
		"codeinjection_head": null,
		"comment_id": "4779",
		"comments": false,
		"created_at": "2016-04-01T08:41:43.000+01:00",
		"custom_excerpt": "Back in November we wrote a blog post about one latency spike. Today I'd like to share a continuation of that story. As it turns out, the misconfigured rmem setting wasn't the only source of added latency. It looked like Mr Wolf hadn't finished his job.",
		"custom_template": null,
		"email_subject": null,
		"excerpt": "Back in November we wrote a blog post about one latency spike. Today I'd like to share a continuation of that story. As it turns out, the misconfigured rmem setting wasn't the only source of added latency. It looked like Mr Wolf hadn't finished his job.",
		"feature_image": "http://blog.cloudflare.com/content/images/2018/08/a-net.png",
		"feature_image_alt": null,
		"feature_image_caption": null,
		"featured": false,
		"frontmatter": null,
		"html": "<!--kg-card-begin: markdown--><p>Back in November we wrote <a href=\"http://blog.cloudflare.com/the-story-of-one-latency-spike/\">a blog post about one latency spike</a>. Today I'd like to share a continuation of that story. As it turns out, the misconfigured <code>rmem</code> setting wasn't the only source of added latency.</p>\n<p>It looked like Mr. Wolf hadn't finished his job.</p>\n<iframe width=\"640\" height=\"360\" src=\"https://www.youtube.com/embed/h4WbjwBJXw0?t=33\" frameborder=\"0\" allowfullscreen></iframe>\n<br>\n<p>After adjusting the previously discussed <code>rmem</code> sysctl we continued monitoring our systems' latency. Among other things we measured <code>ping</code> times to our edge servers. While the worst case improved and we didn't see 1000ms+ pings anymore, the line still wasn't flat. Here's a graph of ping latency between an idling internal machine and a production server. The test was done within the datacenter, the packets never went to the public internet. The Y axis of the chart shows <code>ping</code> times in milliseconds, the X axis is the time of the measurement. Measurements were taken every second for over 6 hours:</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2016/04/ping-48m4-csv-before.png\" alt=\"\" loading=\"lazy\"></p>\n<p>As you can see most pings finished below 1ms. But out of 21,600 measurements about 20 had high latency of up to 100ms. Not ideal, is it?</p>\n<h2 id=\"systemtap\">System tap</h2>\n<p>The latency occurred within our datacenter and the packets weren't lost. This suggested a kernel issue again. Linux responds to ICMP pings from its soft interrupt handling code. A delay in handling <code>ping</code> indicates a delay in Soft IRQ handling which is really bad and can affect all packets delivered to a machine. Using the <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2016-04-bind-to-star/histogram-kernel.stp\">system tap script</a> we were able to measure the time distribution of the main soft IRQ function <code>net_rx_action</code>:</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2016/04/a-net.png\" alt=\"\" loading=\"lazy\"></p>\n<p>This distribution was pretty awful. While most of the calls to <code>net_rx_action</code> were handled in under 81us (average), the slow outliers were really bad. Three calls took a whopping 32ms! No wonder the <code>ping</code> times were off.</p>\n<h2 id=\"theinet_lookupisslow\">The <code>inet_lookup</code> is slow</h2>\n<p>With some back and forth with flame graphs and the <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2016-04-bind-to-star/histogram-kernel.stp\"><code>histogram-kernel.stp</code> script</a> we went deeper to look for the culprit. We found that <a href=\"http://lxr.free-electrons.com/source/net/ipv4/tcp_ipv4.c?v=3.18#L1585\"><code>tcp_v4_rcv</code></a> had a similarly poor latency distribution. More specifically the problem lies between lines 1637 and 1642 in the <code>tcp_v4_rcv</code> function in the <code>tcp_ipv4.c</code> file. We wrote <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2016-04-bind-to-star/histogram-kernel2.stp\">another script to show</a> just that:</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2016/04/a-tcp.png\" alt=\"\" loading=\"lazy\"></p>\n<p>The latency is created at this specific line in <code>tcp_v4_rcv</code> function:</p>\n<pre><code class=\"language-.c\">sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, th-&gt;source, th-&gt;dest);\n</code></pre>\n<p>The numbers shown above indicate that the function usually terminated quickly, in under 2us, but sometimes it hit a slow path and took 1-2ms to finish.</p>\n<p>The <a href=\"http://lxr.free-electrons.com/source/include/net/inet_hashtables.h?v=3.18#L343\"><code>__inet_lookup_skb</code></a> is inlined which makes it tricky to accurately measure. Fortunately the function is simple - all it does is to call <code>__inet_lookup_established</code> and <code>__inet_lookup_listener</code>. It's the latter function that was causing the trouble:</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2016/04/a-tcp-copy.png\" alt=\"\" loading=\"lazy\"></p>\n<p>Let's discuss how <code>__inet_lookup</code> works. This function tries to find an appropriate connection <code>sock struct</code> structure for a packet. This is done in the <code>__inet_lookup_established</code> call. If that fails, the <code>__inet_lookup</code> will attempt to find a bound socket in listening state that could potentially handle the packet. For example, if the packet is SYN and the listening socket exists we should respond with SYN+ACK. If there is no bound listening socket we should send an RST instead. The <code>__inet_lookup_listener</code> function finds the bound socket in the <code>LHTABLE</code> hash table. It does so by using the destination port as a hash and picks an appropriate bucket in the hash table. Then it iterates over it linearly to find the matching listening socket.</p>\n<p>To understand the problem we traced the slow packets, with <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2016-04-bind-to-star/duration-inet-lookup2.stp\">another crafted system tap script</a>. It hooks onto <code>__inet_lookup_listener</code> and prints out the details of only the slow packets:</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2016/04/a-inet.png\" alt=\"\" loading=\"lazy\"></p>\n<p>With this data we went deeper and matched these log lines to specific packets captured with <code>tcpdump</code>.  I'll spare you the details, but these are inbound SYN and RST packets which destination port modulo 32 is equal to 21. Check it out:</p>\n<ul>\n<li>16725 % 32 = 21</li>\n<li>53 % 32 = 21</li>\n<li>63925 % 32 = 21</li>\n</ul>\n<p>Now, where does this magic number come from?</p>\n<h2 id=\"thelisteninghashtable\">The listening hash table</h2>\n<p>As mentioned above, Linux maintains a listening hash table containing the listening TCP sockets - the <code>LHTABLE</code>. It has a fixed size of <a href=\"http://lxr.free-electrons.com/source/include/net/inet_hashtables.h?v=3.18#L117\">32 buckets</a>:</p>\n<pre><code class=\"language-.txt\">/* Yes, really, this is all you need. */\n#define INET_LHTABLE_SIZE       32\n</code></pre>\n<p>To recap:</p>\n<ul>\n<li>All the SYN and RST packets trigger a lookup in LHTABLE. Since the connection entry doesn't exist the <code>__inet_lookup_established</code> call fails and <code>__inet_lookup_listener</code> will be called.</li>\n<li>LHTABLE is small - it has only 32 buckets.</li>\n<li>LHTABLE is hashed by destination port only.</li>\n</ul>\n<p>It's time for a quick diversion. Let's speak about CloudFlare's DNS server.</p>\n<h2 id=\"letsspeakaboutdns\">Let's speak about DNS</h2>\n<p>At CloudFlare we are using a custom DNS server called <code>rrdns</code>. Among many other requirements, the server is designed to withstand DDoS attacks.</p>\n<p>Even though our server is pretty fast, when a large attack kicks in it might be unable to cope with the attack load. If that happens we must contain the damage - even if one IP address is under a heavy attack the server must still handle legitimate traffic on other IP addresses. In fact, our DNS architecture is designed to spread the load among 16k IP addresses.</p>\n<p>When <a href=\"https://www.cloudflare.com/ddos/under-attack/\">an IP address is under attack</a>, and the server is not keeping up with incoming packets, the kernel receive queue on a UDP socket will overflow. We monitor that by looking at the <code>netstat</code> counters:</p>\n<pre><code>$ netstat -s --udp\nUdp:\n    43957575 packet receive errors\n</code></pre>\n<p>With that number increasing we can see the affected IP addresses by listing the UDP sockets with non-empty receive queues:</p>\n<pre><code>$ netstat -ep4ln --udp|grep 53 |egrep -v &quot;^udp *0&quot;\nudp   524293  0 173.245.1.1:53  0.0.0.0:*   0\nudp   524288  0 173.245.2.3:53  0.0.0.0:*   0\n</code></pre>\n<p>In this case two IP addresses received heavy UDP traffic. It was more than the DNS server could handle, the receive queues built up and eventually overflowed. Fortunately, because we are binding to specific IP addresses, overflowing some UDP receive queues won't affect any other IP addresses.</p>\n<p>Binding to specific IP addresses is critical to keep our DNS infrastructure online. With this setup even if other mitigation techniques fail and the DNS server is left exposed to the packet flood, we are certain the attack will not affect handling DNS on other IP addresses.</p>\n<p>But what does that have to do with the <code>LHTABLE</code>? Well, in our setup we bound to specific IP addresses for both UDP <em>and</em> TCP. While having 16k listening <a href=\"http://lxr.free-electrons.com/source/net/ipv4/udp.c?v=3.18#L476\">sockets in UDP is okay</a>, it turns out it is not fine for TCP.</p>\n<h2 id=\"whathappened\">What happened</h2>\n<p>Due to our DNS setup we had 16k TCP sockets bound to different IP addresses on port 53. Since the port number is fixed, all these sockets ended in exactly one <code>LHTABLE</code> bucket. This particular bucket was number 21 (53 % 32 = 21). When an RST or SYN packet hit it, the <code>__inet_lookup_listener</code> call had to traverse all 16k socket entries. This wasn't fast, in fact it took 2ms to finish.</p>\n<p>To solve the problem we deployed two changes:</p>\n<ul>\n<li>\n<p>For TCP connections our DNS server now binds to ANY_IP address (aka: 0.0.0.0:53, *:53). We call this &quot;bind to star&quot;. While binding to specific IP addresses is still necessary for UDP, there is little benefit in doing that for the TCP traffic. For TCP we can bind to star safely, without compromising our DDoS defenses.</p>\n</li>\n<li>\n<p>We increased the <code>LHTABLE</code> size in our kernels. We are not the first to do that: Bill Sommerfeld from Google <a href=\"http://patchwork.ozlabs.org/patch/79014/\">suggested that back in 2011</a>.</p>\n</li>\n</ul>\n<p>With these changes deployed the <code>ping</code> times within our datacenter are finally flat, as they should always have been:</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2016/04/ping-48m3-csv-after.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"finalwords\">Final words</h2>\n<p>You can't have a very large number of bound TCP sockets and we learned that the hard way. We learned a bit about the Linux networking stack: the fact that <code>LHTABLE</code> is fixed size and is hashed by destination port only. Once again we showed a couple of <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2016-04-bind-to-star\">powerful of System Tap scripts</a>.</p>\n<p>With the fixes deployed maximum latency numbers have dropped significantly. We are confident that soft interrupt handling in <code>net_rx_action</code> is behaving well.</p>\n<p>Mr Wolf has finally finished his assignment.</p>\n<iframe width=\"640\" height=\"360\" src=\"https://www.youtube.com/embed/YgxACD-rL5c\" frameborder=\"0\"></iframe>\n<br>\n<p>If this sounds interesting, <a href=\"https://www.cloudflare.com/join-our-team/\">consider joining us</a>. We have teams in Singapore, San Francisco and London.</p>\n<!--kg-card-end: markdown-->",
		"id": "5d16453b41acde0011a95585",
		"meta_description": null,
		"meta_title": null,
		"og_description": null,
		"og_image": null,
		"og_title": null,
		"primary_author": {
			"id": "5d1644b141acde0011a94f30",
			"name": "Marek Majkowski",
			"slug": "marek-majkowski",
			"profile_image": "http://blog.cloudflare.com/content/images/2017/03/b5967d6c687939594adb6992723d0529.jpeg",
			"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-101.png",
			"bio": null,
			"website": null,
			"location": null,
			"facebook": null,
			"twitter": "@majek04",
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/marek-majkowski/"
		},
		"primary_tag": {
			"id": "5d16450341acde0011a95214",
			"name": "Programming",
			"slug": "programming",
			"description": null,
			"feature_image": null,
			"visibility": "public",
			"meta_title": null,
			"meta_description": null,
			"og_image": null,
			"og_title": null,
			"og_description": null,
			"twitter_image": null,
			"twitter_title": null,
			"twitter_description": null,
			"codeinjection_head": null,
			"codeinjection_foot": null,
			"canonical_url": null,
			"accent_color": null,
			"url": "http://blog.cloudflare.com/tag/programming/"
		},
		"published_at": "2016-04-05T13:05:01.000+01:00",
		"reading_time": 6,
		"slug": "revenge-listening-sockets",
		"tags": [
			{
				"id": "5d16450341acde0011a95214",
				"name": "Programming",
				"slug": "programming",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/programming/"
			},
			{
				"id": "5d16450341acde0011a951d6",
				"name": "DNS",
				"slug": "dns",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/dns/"
			},
			{
				"id": "5d16450341acde0011a951ce",
				"name": "Reliability",
				"slug": "reliability",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/reliability/"
			},
			{
				"id": "5d16450341acde0011a951ff",
				"name": "Linux",
				"slug": "linux",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/linux/"
			}
		],
		"title": "The revenge of the listening sockets",
		"twitter_description": null,
		"twitter_image": null,
		"twitter_title": null,
		"updated_at": "2023-11-13T16:50:38.000+00:00",
		"url": "http://blog.cloudflare.com/revenge-listening-sockets/",
		"uuid": "4f287d90-2840-4e16-bbd4-c731398b0f3b",
		"visibility": "public"
	}
}