<div class="mb2 gray5">15 min read</div>
<div class="post-content lh-copy gray1">
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2023/06/image7-3.png" class="kg-image" alt="Every request, every microsecond: scalable machine learning at Cloudflare" loading="lazy" width="1999" height="1125"></figure>
	<p>In this post, we will take you through the advancements we've made in our machine learning capabilities. We'll describe the technical strategies that have enabled us to expand the number of machine learning features and models, all while substantially reducing the processing time for each HTTP request on our network. Let's begin.</p>
	<h2 id="background">Background</h2>
	<p>For a comprehensive understanding of our evolved approach, it's important to grasp the context within which our machine learning detections operate. Cloudflare, on average, serves over <strong>46 million HTTP requests per second</strong>, surging to more than 63 million requests per second during peak times.</p>
	<p>Machine learning detection plays a crucial role in ensuring the security and integrity of this vast network. In fact, it classifies the largest volume of requests among all our detection mechanisms, providing the final <a href="https://developers.cloudflare.com/bots/concepts/bot-score" target="_blank">Bot Score</a> decision for <strong>over 72%</strong> of all HTTP requests. Going beyond, we run several machine learning models in shadow mode for every HTTP request.</p>
	<p>At the heart of our machine learning infrastructure lies our reliable ally, <a href="https://catboost.ai" target="_blank">CatBoost</a>. It enables ultra low-latency model inference and ensures high-quality predictions to detect novel threats such as <a href="https://blog.cloudflare.com/machine-learning-mobile-traffic-bots">stopping bots targeting our customers' mobile apps</a>. However, it's worth noting that <strong>machine learning model inference</strong> is just one component of the overall latency equation. Other critical components include <strong>machine learning feature extraction and preparation</strong>. In our quest for optimal performance, we've continuously optimized each aspect contributing to the overall latency of our system.</p>
	<p>Initially, our machine learning models relied on <strong>single-request features</strong>, such as presence or value of certain headers. However, given the ease of spoofing these attributes, we evolved our approach. We turned to <strong>inter-request features</strong> that leverage aggregated information across multiple dimensions of a request in a sliding time window. For example, we now consider factors like the number of unique user agents associated with certain request attributes.</p>
	<p>The extraction and preparation of inter-request features were handled by <strong>Gagarin</strong>, a Go-based feature serving platform we developed. As a request arrived at Cloudflare, we extracted dimension keys from the request attributes. We then looked up the corresponding machine learning features in the <a href="https://github.com/thibaultcha/lua-resty-mlcache" target="_blank">multi-layered cache</a>. If the desired machine learning features were not found in the cache, a <strong>memcached "get" request</strong> was made to Gagarin to fetch those. Then machine learning features were plugged into CatBoost models to produce detections, which were then surfaced to the customers via Firewall and Workers fields and internally through our <a href="https://blog.cloudflare.com/http-analytics-for-6m-requests-per-second-using-clickhouse">logging pipeline to ClickHouse</a>. This allowed our data scientists to run further experiments, producing more features and models.</p>
	<figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://blog.cloudflare.com/content/images/2023/06/image3-3.png" class="kg-image" alt="" loading="lazy" width="1999" height="1044">
		<figcaption>Previous system design for serving machine learning features over Unix socket using Gagarin.</figcaption>
	</figure>
	<p>Initially, Gagarin exhibited decent latency, with a median latency around <strong>200 microseconds</strong> to serve all machine learning features for given keys. However, as our system evolved and we introduced more features and dimension keys, coupled with increased traffic, the cache hit ratio began to wane. The median latency had increased to <strong>500 microseconds</strong> and during peak times, the latency worsened significantly, with the p99 latency soaring to roughly <strong>10 milliseconds</strong>. Gagarin underwent extensive low-level tuning, optimization, profiling, and benchmarking. Despite these efforts, we encountered the limits of inter-process communication (IPC) using Unix Domain Socket (UDS), among other challenges, explored below.</p>
	<h3 id="problem-definition">Problem definition</h3>
	<p>In summary, the previous solution had its drawbacks, including:</p>
	<ul>
		<li><strong>High tail latency</strong>: during the peak time, a portion of requests experienced increased &nbsp;latency caused by CPU contention on the Unix socket and Lua garbage collector.</li>
		<li><strong>Suboptimal resource utilization: </strong>CPU and RAM utilization was not optimized to the full potential, leaving less resources for other services running on the server.</li>
		<li><strong>Machine learning features availability</strong>: decreased due to memcached timeouts, which resulted in a higher likelihood of false positives or false negatives for a subset of the requests.</li>
		<li><strong>Scalability constraints</strong>: as we added more machine learning features, we approached the scalability limit of our infrastructure.</li>
	</ul>
	<p>Equipped with a comprehensive understanding of the challenges and armed with quantifiable metrics, we ventured into the next phase: seeking a more efficient way to fetch and serve machine learning features.</p>
	<h2 id="exploring-solutions">Exploring solutions</h2>
	<p>In our quest for more efficient methods of fetching and serving machine learning features, we evaluated several alternatives. The key approaches included:</p>
	<p><strong>Further optimizing Gagarin</strong>: as we pushed our Go-based memcached server to its limits, we encountered a lower bound on latency reductions. This arose from IPC over UDS synchronization overhead and multiple data copies, the serialization/deserialization overheads, as well as the inherent latency of garbage collector and the performance of hashmap lookups in Go.</p>
	<p><strong>Considering Quicksilver</strong>: we contemplated using <a href="https://blog.cloudflare.com/tag/quicksilver">Quicksilver</a>, but the volume and update frequency of machine learning features posed capacity concerns and potential negative impacts on other use cases. Moreover, it uses a Unix socket with the memcached protocol, reproducing the same limitations previously encountered.</p>
	<p><strong>Increasing multi-layered cache size:</strong> we investigated expanding cache size to accommodate tens of millions of dimension keys. However, the associated memory consumption, due to duplication of these keys and their machine learning features across worker threads, rendered this approach untenable.</p>
	<p><strong>Sharding the Unix socket</strong>: we considered sharding the Unix socket to alleviate contention and improve performance. Despite showing potential, this approach only partially solved the problem and introduced more system complexity.</p>
	<p><strong>Switching to RPC:</strong> we explored the option of using RPC for communication between our front line server and Gagarin. However, since RPC still requires some form of communication bus (such as TCP, UDP, or UDS), it would not significantly change the performance compared to the memcached protocol over UDS, which was already simple and minimalistic.</p>
	<p>After considering these approaches, we shifted our focus towards investigating alternative Inter-Process Communication (IPC) mechanisms.</p>
	<h3 id="ipc-mechanisms">IPC mechanisms</h3>
	<p>Adopting a <a href="https://en.wikipedia.org/wiki/First_principle" target="_blank">first principles</a> design approach, we questioned: "What is the most efficient low-level method for data transfer between two processes provided by the operating system?" Our goal was to find a solution that would enable the direct serving of machine learning features from memory for corresponding HTTP requests. By eliminating the need to traverse the Unix socket, we aimed to reduce CPU contention, improve latency, and minimize data copying.</p>
	<p>To identify the most efficient IPC mechanism, we evaluated various options available within the Linux ecosystem. We used <a href="https://github.com/goldsborough/ipc-bench" target="_blank">ipc-bench</a>, an open-source benchmarking tool specifically designed for this purpose, to measure the latencies of different IPC methods in our test environment. The measurements were based on sending one million 1,024-byte messages forth and back (i.e., ping pong) between two processes.</p><!--kg-card-begin: html-->
	<style type="text/css">
		.tg {
			border-collapse: collapse;
			border-color: #ccc;
			border-spacing: 0;
		}

		.tg td {
			background-color: #fff;
			border-color: #ccc;
			border-style: solid;
			border-width: 1px;
			color: #333;
			font-family: Arial, sans-serif;
			font-size: 14px;
			overflow: hidden;
			padding: 10px 5px;
			word-break: normal;
		}

		.tg th {
			background-color: #f0f0f0;
			border-color: #ccc;
			border-style: solid;
			border-width: 1px;
			color: #333;
			font-family: Arial, sans-serif;
			font-size: 14px;
			font-weight: normal;
			overflow: hidden;
			padding: 10px 5px;
			word-break: normal;
		}

		.tg .tg-ekg0 {
			background-color: #EFEFEF;
			font-weight: bold;
			text-align: left;
			vertical-align: top
		}

		.tg .tg-82rs {
			background-color: #FFF2CC;
			text-align: left;
			vertical-align: top
		}

		.tg .tg-4dna {
			background-color: #B6D7A8;
			text-align: left;
			vertical-align: top
		}

		.tg .tg-0lax {
			text-align: left;
			vertical-align: top
		}

		.tg .tg-teb0 {
			background-color: #D9EAD3;
			text-align: left;
			vertical-align: top
		}
	</style>
	<table class="tg" width="100%">
		<thead>
			<tr>
				<th class="tg-ekg0"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">IPC method</span></th>
				<th class="tg-ekg0"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Avg duration, μs</span></th>
				<th class="tg-ekg0"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Avg throughput, msg/s</span></th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">eventfd (bi-directional)</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">9.456</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">105,533</span></td>
			</tr>
			<tr>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">TCP sockets</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">8.74</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">114,143</span></td>
			</tr>
			<tr>
				<td class="tg-82rs"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Unix domain sockets</span></td>
				<td class="tg-82rs"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">5.609</span></td>
				<td class="tg-82rs"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">177,573</span></td>
			</tr>
			<tr>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">FIFOs (named pipes)</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">5.432</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">183,388</span></td>
			</tr>
			<tr>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Pipe</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">4.733</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">210,369</span></td>
			</tr>
			<tr>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Message Queue</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">4.396</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">226,421</span></td>
			</tr>
			<tr>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Unix Signals</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">2.45</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">404,844</span></td>
			</tr>
			<tr>
				<td class="tg-teb0"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Shared Memory</span></td>
				<td class="tg-teb0"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">0.598</span></td>
				<td class="tg-teb0"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">1,616,014</span></td>
			</tr>
			<tr>
				<td class="tg-4dna"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Memory-Mapped Files</span></td>
				<td class="tg-4dna"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">0.503</span></td>
				<td class="tg-4dna"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">1,908,613</span></td>
			</tr>
		</tbody>
	</table><!--kg-card-end: html-->
	<p>Based on our evaluation, we found that Unix sockets, while taking care of synchronization, were not the fastest IPC method available. The two fastest IPC mechanisms were shared memory and memory-mapped files. Both approaches offered similar performance, with the former using a specific tmpfs volume in /dev/shm and dedicated system calls, while the latter could be stored in any volume, including tmpfs or HDD/SDD.</p>
	<h3 id="missing-ingredients">Missing ingredients</h3>
	<p>In light of these findings, we decided to employ <a href="https://en.wikipedia.org/wiki/Memory-mapped_file" target="_blank"><strong>memory-mapped files</strong></a> as the IPC mechanism for serving machine learning features. This choice promised reduced latency, decreased CPU contention, and minimal data copying. However, it did not inherently offer data synchronization capabilities like Unix sockets. Unlike Unix sockets, memory-mapped files are simply files in a Linux volume that can be mapped into memory of the process. This sparked several critical questions:</p>
	<ol>
		<li>How could we efficiently fetch an array of hundreds of float features for given dimension keys when dealing with a file?</li>
		<li>How could we ensure safe, concurrent and frequent updates for tens of millions of keys?</li>
		<li>How could we avert the CPU contention previously encountered with Unix sockets?</li>
		<li>How could we effectively support the addition of more dimensions and features in the future?</li>
	</ol>
	<p>To address these challenges we needed to further evolve this new approach by adding a few key ingredients to the recipe.</p>
	<h2 id="augmenting-the-idea">Augmenting the Idea</h2>
	<p>To realize our vision of memory-mapped files as a method for serving machine learning features, we needed to employ several key strategies, touching upon aspects like data synchronization, data structure, and deserialization.</p>
	<h3 id="wait-free-synchronization">Wait-free synchronization</h3>
	<p>When dealing with concurrent data, ensuring safe, concurrent, and frequent updates is paramount. Traditional locks are often not the most efficient solution, especially when dealing with high concurrency environments. Here's a rundown on three different synchronization techniques:</p>
	<p><strong>With-lock synchronization</strong>: a common approach using mechanisms like mutexes or spinlocks. It ensures only one thread can access the resource at a given time, but can suffer from contention, blocking, and priority inversion, just as evident with Unix sockets.</p>
	<p><strong>Lock-free synchronization</strong>: this non-blocking approach employs atomic operations to ensure at least one thread always progresses. It eliminates traditional locks but requires careful handling of edge cases and race conditions.</p>
	<p><strong>Wait-free synchronization:</strong> a more advanced technique that guarantees every thread makes progress and completes its operation without being blocked by other threads. It provides stronger progress guarantees compared to lock-free synchronization, ensuring that each thread completes its operation within a finite number of steps.</p><!--kg-card-begin: html-->
	<style type="text/css">
		.tg {
			border-collapse: collapse;
			border-color: #ccc;
			border-spacing: 0;
		}

		.tg td {
			background-color: #fff;
			border-color: #ccc;
			border-style: solid;
			border-width: 1px;
			color: #333;
			font-family: Arial, sans-serif;
			font-size: 14px;
			overflow: hidden;
			padding: 10px 5px;
			word-break: normal;
		}

		.tg th {
			background-color: #f0f0f0;
			border-color: #ccc;
			border-style: solid;
			border-width: 1px;
			color: #333;
			font-family: Arial, sans-serif;
			font-size: 14px;
			font-weight: normal;
			overflow: hidden;
			padding: 10px 5px;
			word-break: normal;
		}

		.tg .tg-baqh {
			text-align: center;
			vertical-align: top
		}

		.tg .tg-lbnr {
			background-color: #FCE5CD;
			font-weight: bold;
			text-align: center;
			vertical-align: top
		}

		.tg .tg-amwm {
			font-weight: bold;
			text-align: center;
			vertical-align: top
		}

		.tg .tg-kxn2 {
			background-color: #EFEFEF;
			font-weight: bold;
			text-align: center;
			vertical-align: top
		}
	</style>
	<table class="tg" width="100%">
		<thead>
			<tr>
				<th class="tg-amwm"></th>
				<th class="tg-kxn2"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Disjoint Access Parallelism</span></th>
				<th class="tg-kxn2"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Starvation Freedom</span></th>
				<th class="tg-kxn2"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Finite Execution Time</span></th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td class="tg-lbnr"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">With lock</span></td>
				<td class="tg-baqh"><img src="https://lh3.googleusercontent.com/mWo5ulSY0xrqrZamHxCTIpbHoK_IZXV3ApCFxhltGDZorv-jCY8cQm5O8aep8OIWqxxoHuO6EJLLMfUIBePSbyKEHPV9vF2FRvGWkK0VPxQrEuGONLQmmHmt0HLN4OyWQoXhKTZa2PILE7uv13on3IY" width="19" height="19" alt=""></td>
				<td class="tg-baqh"><img src="https://lh3.googleusercontent.com/mWo5ulSY0xrqrZamHxCTIpbHoK_IZXV3ApCFxhltGDZorv-jCY8cQm5O8aep8OIWqxxoHuO6EJLLMfUIBePSbyKEHPV9vF2FRvGWkK0VPxQrEuGONLQmmHmt0HLN4OyWQoXhKTZa2PILE7uv13on3IY" width="19" height="19" alt=""></td>
				<td class="tg-baqh"><img src="https://lh3.googleusercontent.com/mWo5ulSY0xrqrZamHxCTIpbHoK_IZXV3ApCFxhltGDZorv-jCY8cQm5O8aep8OIWqxxoHuO6EJLLMfUIBePSbyKEHPV9vF2FRvGWkK0VPxQrEuGONLQmmHmt0HLN4OyWQoXhKTZa2PILE7uv13on3IY" width="19" height="19" alt=""></td>
			</tr>
			<tr>
				<td class="tg-lbnr"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Lock-free</span></td>
				<td class="tg-baqh"><img src="https://lh5.googleusercontent.com/INhbT87NAysOwV9HTJAV8a1eIMOaGW7VXSsEfyEGoM2J1TvjhlBsuDoFzuHRF-9CJav33USYa69OlyrfgYovpbKNo_WCgJWq3LOJkZavZLu61QUb-Up4G3i166cVvOrBYB2wqIU065iBV3FWOpHm0pE" width="24" height="15" alt=""></td>
				<td class="tg-baqh"><img src="https://lh3.googleusercontent.com/mWo5ulSY0xrqrZamHxCTIpbHoK_IZXV3ApCFxhltGDZorv-jCY8cQm5O8aep8OIWqxxoHuO6EJLLMfUIBePSbyKEHPV9vF2FRvGWkK0VPxQrEuGONLQmmHmt0HLN4OyWQoXhKTZa2PILE7uv13on3IY" width="19" height="19" alt=""></td>
				<td class="tg-baqh"><img src="https://lh3.googleusercontent.com/mWo5ulSY0xrqrZamHxCTIpbHoK_IZXV3ApCFxhltGDZorv-jCY8cQm5O8aep8OIWqxxoHuO6EJLLMfUIBePSbyKEHPV9vF2FRvGWkK0VPxQrEuGONLQmmHmt0HLN4OyWQoXhKTZa2PILE7uv13on3IY" width="19" height="19" alt=""></td>
			</tr>
			<tr>
				<td class="tg-lbnr"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Wait-free</span></td>
				<td class="tg-baqh"><img src="https://lh5.googleusercontent.com/INhbT87NAysOwV9HTJAV8a1eIMOaGW7VXSsEfyEGoM2J1TvjhlBsuDoFzuHRF-9CJav33USYa69OlyrfgYovpbKNo_WCgJWq3LOJkZavZLu61QUb-Up4G3i166cVvOrBYB2wqIU065iBV3FWOpHm0pE" width="24" height="15" alt=""></td>
				<td class="tg-baqh"><img src="https://lh5.googleusercontent.com/INhbT87NAysOwV9HTJAV8a1eIMOaGW7VXSsEfyEGoM2J1TvjhlBsuDoFzuHRF-9CJav33USYa69OlyrfgYovpbKNo_WCgJWq3LOJkZavZLu61QUb-Up4G3i166cVvOrBYB2wqIU065iBV3FWOpHm0pE" width="24" height="15" alt=""></td>
				<td class="tg-baqh"><img src="https://lh5.googleusercontent.com/INhbT87NAysOwV9HTJAV8a1eIMOaGW7VXSsEfyEGoM2J1TvjhlBsuDoFzuHRF-9CJav33USYa69OlyrfgYovpbKNo_WCgJWq3LOJkZavZLu61QUb-Up4G3i166cVvOrBYB2wqIU065iBV3FWOpHm0pE" width="24" height="15" alt=""></td>
			</tr>
		</tbody>
	</table><!--kg-card-end: html-->
	<p>Our <a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm#Wait-freedom" target="_blank">wait-free</a> data access pattern draws inspiration from <a href="https://www.kernel.org/doc/html/next/RCU/whatisRCU.html" target="_blank">Linux kernel's Read-Copy-Update (RCU) pattern</a> and the <a href="https://github.com/pramalhe/ConcurrencyFreaks/blob/master/papers/left-right-2014.pdf" target="_blank">Left-Right concurrency control technique</a>. In our solution, we maintain two copies of the data in separate memory-mapped files. Write access to this data is managed by a single writer, with multiple readers able to access the data concurrently.</p>
	<p>We store the synchronization state, which coordinates access to these data copies, in a third memory-mapped file, referred to as "state". This file contains an atomic 64-bit integer, which represents an <strong><code>InstanceVersion</code> </strong>and a pair of additional atomic 32-bit variables, tracking the number of active readers for each data copy. The <strong><code>InstanceVersion</code></strong> consists of the currently active data file index (1 bit), the data size (39 bits, accommodating data sizes up to 549 GB), and a data checksum (24 bits).</p>
	<h3 id="zero-copy-deserialization">Zero-copy deserialization</h3>
	<p>To efficiently store and fetch machine learning features, we needed to address the challenge of deserialization latency. Here, <a href="https://en.wikipedia.org/wiki/Zero-copy" target="_blank">zero-copy</a> deserialization provides an answer. This technique reduces the time and memory required to access and use data by directly referencing bytes in the serialized form.</p>
	<p>We turned to <a href="https://rkyv.org" target="_blank">rkyv</a>, a zero-copy deserialization framework in Rust, to help us with this task. rkyv implements total zero-copy deserialization, meaning no data is copied during deserialization and no work is done to deserialize data. It achieves this by structuring its encoded representation to match the in-memory representation of the source type.</p>
	<p>One of the key features of rkyv that our solution relies on is its ability to access <strong><code>HashMap</code></strong> data structures in a zero-copy fashion. This is a unique capability among Rust serialization libraries and one of the main reasons we chose rkyv for our implementation. It also has a vibrant <a href="https://discord.gg/65F6MdnbQh" target="_blank">Discord community</a>, eager to offer best-practice advice and accommodate feature requests.</p>
	<figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.cloudflare.com/content/images/2023/06/Screenshot-2023-06-16-at-18.18.02.png" class="kg-image" alt="" loading="lazy" width="1618" height="772">
		<figcaption><a href="https://rkyv.org/feature-comparison.html" target="_blank">Feature comparison: rkyv vs FlatBuffers and Cap'n Proto</a></figcaption>
	</figure>
	<h2 id="enter-mmap-sync-crate">Enter mmap-sync crate</h2>
	<p>Leveraging the benefits of <strong>memory-mapped files</strong>, <strong>wait-free synchronization</strong> and <strong>zero-copy deserialization</strong>, we've crafted a unique and powerful tool for managing high-performance, concurrent data access between processes. We've packaged these concepts into a Rust crate named <a href="https://github.com/cloudflare/mmap-sync" target="_blank"><strong><code>mmap-sync</code></strong></a>, which we're thrilled to open-source for the wider community.</p>
	<p>At the core of the <strong><code>mmap-sync</code></strong> package is a structure named <strong><code>Synchronizer</code></strong>. It offers an avenue to read and write any data expressible as a Rust struct. Users simply have to implement or derive a specific Rust trait surrounding struct definition - a task requiring just a single line of code. The <strong><code>Synchronizer</code></strong> presents an elegantly simple interface, equipped with "write" and "read" methods.</p><!--kg-card-begin: markdown-->
	<pre><code class="language-rust">impl Synchronizer {
    /// Write a given `entity` into the next available memory mapped file.
    pub fn write&lt;T&gt;(&amp;mut self, entity: &amp;T, grace_duration: Duration) -&gt; Result&lt;(usize, bool), SynchronizerError&gt; {
        …
    }

    /// Reads and returns `entity` struct from mapped memory wrapped in `ReadResult`
    pub fn read&lt;T&gt;(&amp;mut self) -&gt; Result&lt;ReadResult&lt;T&gt;, SynchronizerError&gt; {
        …
    }
}

/// FeaturesMetadata stores features along with their metadata
#[derive(Archive, Deserialize, Serialize, Debug, PartialEq)]
#[archive_attr(derive(CheckBytes))]
pub struct FeaturesMetadata {
    /// Features version
    pub version: u32,
    /// Features creation Unix timestamp
    pub created_at: u32,
    /// Features represented by vector of hash maps
    pub features: Vec&lt;HashMap&lt;u64, Vec&lt;f32&gt;&gt;&gt;,
}
</code></pre>
	<!--kg-card-end: markdown-->
	<p>A read operation through the <strong><code>Synchronizer</code></strong> performs zero-copy deserialization and returns a "guarded" <strong><code>Result</code></strong> encapsulating a reference to the Rust struct using <a href="https://rust-unofficial.github.io/patterns/patterns/behavioural/RAII.html" target="_blank">RAII design pattern</a>. This operation also increments the atomic counter of active readers using the struct. Once the <strong><code>Result</code></strong> is out of scope, the <strong><code>Synchronizer</code></strong> decrements the number of readers.</p>
	<p>The synchronization mechanism used in <strong><code>mmap-sync</code></strong> is not only "lock-free" but also "wait-free". This ensures an upper bound on the number of steps an operation will take before it completes, thus providing a performance guarantee.</p>
	<p>The data is stored in shared mapped memory, which allows the <strong><code>Synchronizer</code></strong> to “write” to it and “read” from it concurrently. This design makes <strong><code>mmap-sync</code></strong> a highly efficient and flexible tool for managing shared, concurrent data access.</p>
	<p>Now, with an understanding of the underlying mechanics of <strong><code>mmap-sync</code></strong>, let's explore how this package plays a key role in the broader context of our Bot Management platform, particularly within the newly developed components: the <strong><code>bliss</code></strong> service and library.</p>
	<h2 id="system-design-overhaul">System design overhaul</h2>
	<p>Transitioning from a Lua-based module that made memcached requests over Unix socket to Gagarin in Go to fetch machine learning features, our new design represents a significant evolution. This change pivots around the introduction of <strong><code>mmap-sync</code></strong>, our newly developed Rust package, laying the groundwork for a substantial performance upgrade. This development led to a comprehensive system redesign and introduced two new components that form the backbone of our <em>Bots Liquidation Intelligent Security System</em> - or <strong>BLISS</strong>, in short: the bliss service and the bliss library.</p>
	<figure class="kg-card kg-image-card kg-width-wide"><img src="https://blog.cloudflare.com/content/images/2023/06/after-bliss-diagram-v2.png" class="kg-image" alt="" loading="lazy" width="1600" height="929"></figure>
	<h3 id="bliss-service">Bliss service</h3>
	<p>The <strong>bliss</strong> <strong>service</strong> operates as a Rust-based, multi-threaded sidecar daemon. It has been designed for optimal batch processing of vast data quantities and extensive I/O operations. Among its key functions, it fetches, parses, and stores machine learning features and dimensions for effortless data access and manipulation. This has been made possible through the incorporation of the <a href="https://tokio.rs" target="_blank">Tokio</a> event-driven platform, which allows for efficient, non-blocking I/O operations.</p>
	<h3 id="bliss-library">Bliss library</h3>
	<p>Operating as a single-threaded dynamic library, the <strong>bliss library</strong> seamlessly integrates into each worker thread using the Foreign Function Interface (FFI) via a Lua module. Optimized for minimal resource usage and ultra-low latency, this lightweight library performs tasks without the need for heavy I/O operations. It efficiently serves machine learning features and generates corresponding detections.</p>
	<p>In addition to leveraging the <strong><code>mmap-sync</code></strong> package for efficient machine learning feature access, our new design includes several other performance enhancements:</p>
	<ul>
		<li><strong>Allocations-free operation:</strong> bliss library re-uses pre-allocated data structures and performs no heap allocations, only low-cost stack allocations. To enforce our zero-allocation policy, we run integration tests using the <a href="https://docs.rs/dhat/latest/dhat" target="_blank">dhat heap profiler</a>.</li>
		<li><strong>SIMD optimizations</strong>: wherever possible, the bliss library employs vectorized CPU instructions. For instance, AVX2 and SSE4 instruction sets are used to expedite <a href="https://crates.io/crates/faster-hex" target="_blank">hex-decoding</a> of certain request attributes, enhancing speed by tenfold.</li>
		<li><strong>Compiler tuning:</strong> We compile both the bliss service and library with the following flags for superior performance: </li>
	</ul><!--kg-card-begin: markdown-->
	<pre><code class="language-toml">[profile.release]
codegen-units = 1
debug = true
lto = "fat"
opt-level = 3
</code></pre>
	<!--kg-card-end: markdown-->
	<ul>
		<li><strong>Benchmarking &amp; profiling:</strong> We use <a href="https://bheisler.github.io/criterion.rs/book/index.html" target="_blank">Criterion</a> for benchmarking every major feature or component within bliss. Moreover, we are also able to use the Go pprof profiler on Criterion benchmarks to view flame graphs and more:</li>
	</ul><!--kg-card-begin: markdown-->
	<pre><code class="language-bash">cargo bench -p integration -- --verbose --profile-time 100

go tool pprof -http=: ./target/criterion/process_benchmark/process/profile/profile.pb
</code></pre>
	<!--kg-card-end: markdown-->
	<p>This comprehensive overhaul of our system has not only streamlined our operations but also has been instrumental in enhancing the overall performance of our Bot Management platform. Stay tuned to witness the remarkable changes brought about by this new architecture in the next section.</p>
	<h2 id="rollout-results">Rollout results</h2>
	<p>Our system redesign has brought some truly "blissful" dividends. Above all, our commitment to a seamless user experience and the trust of our customers have guided our innovations. We ensured that the transition to the new design was seamless, maintaining full backward compatibility, with no customer-reported false positives or negatives encountered. This is a testament to the robustness of the new system.</p>
	<p>As the old adage goes, the proof of the pudding is in the eating. This couldn't be truer when examining the dramatic latency improvements achieved by the redesign. Our overall processing latency for HTTP requests at Cloudflare improved by an average of <strong>12.5% </strong>compared to the previous system.</p>
	<p>This improvement is even more significant in the Bot Management module, where latency improved by an average of <strong>55.93%</strong>.</p>
	<figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.cloudflare.com/content/images/2023/06/image6.png" class="kg-image" alt="" loading="lazy" title="Chart" width="1700" height="1052">
		<figcaption>Bot Management module latency, in microseconds.</figcaption>
	</figure>
	<p>More specifically, our machine learning features fetch latency has improved by several orders of magnitude:</p><!--kg-card-begin: html-->
	<style type="text/css">
		.tg {
			border-collapse: collapse;
			border-color: #ccc;
			border-spacing: 0;
		}

		.tg td {
			background-color: #fff;
			border-color: #ccc;
			border-style: solid;
			border-width: 1px;
			color: #333;
			font-family: Arial, sans-serif;
			font-size: 14px;
			overflow: hidden;
			padding: 10px 5px;
			word-break: normal;
		}

		.tg th {
			background-color: #f0f0f0;
			border-color: #ccc;
			border-style: solid;
			border-width: 1px;
			color: #333;
			font-family: Arial, sans-serif;
			font-size: 14px;
			font-weight: normal;
			overflow: hidden;
			padding: 10px 5px;
			word-break: normal;
		}

		.tg .tg-ekg0 {
			background-color: #EFEFEF;
			font-weight: bold;
			text-align: left;
			vertical-align: top
		}

		.tg .tg-uw2d {
			background-color: #FCE5CD;
			font-weight: bold;
			text-align: left;
			vertical-align: top
		}

		.tg .tg-0lax {
			text-align: left;
			vertical-align: top
		}

		.tg .tg-ipcz {
			color: #38761D;
			font-weight: bold;
			text-align: left;
			vertical-align: top
		}
	</style>
	<table class="tg" width="100%">
		<thead>
			<tr>
				<th class="tg-ekg0"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Latency metric</span></th>
				<th class="tg-ekg0"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Before (μs)</span></th>
				<th class="tg-ekg0"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">After (μs)</span></th>
				<th class="tg-ekg0"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Change</span></th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td class="tg-uw2d"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">p50</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">532</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">9</span></td>
				<td class="tg-ipcz"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#38761D;background-color:transparent">-98.30%</span><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent"> or </span><span style="font-weight:700;font-style:normal;text-decoration:none;color:#00F;background-color:transparent">x59</span></td>
			</tr>
			<tr>
				<td class="tg-uw2d"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">p99</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">9510</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">18</span></td>
				<td class="tg-ipcz"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#38761D;background-color:transparent">-99.81%</span><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent"> or </span><span style="font-weight:700;font-style:normal;text-decoration:none;color:#00F;background-color:transparent">x528</span></td>
			</tr>
			<tr>
				<td class="tg-uw2d"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">p999</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">16000</span></td>
				<td class="tg-0lax"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">29</span></td>
				<td class="tg-ipcz"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#38761D;background-color:transparent">-99.82%</span><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent"> or </span><span style="font-weight:700;font-style:normal;text-decoration:none;color:#00F;background-color:transparent">x551</span></td>
			</tr>
		</tbody>
	</table><!--kg-card-end: html-->
	<p><br></p>
	<p>To truly grasp this impact, consider this: with Cloudflare’s average rate of 46 million requests per second, a saving of <strong>523 microseconds</strong> per request equates to saving over 24,000 days or <strong>65 years</strong> of processing time every single day!</p>
	<p>In addition to latency improvements, we also reaped other benefits from the rollout:</p>
	<ul>
		<li><strong>Enhanced feature availability</strong>: thanks to eliminating Unix socket timeouts, machine learning feature availability is now a robust 100%, resulting in fewer false positives and negatives in detections.</li>
		<li><strong>Improved resource utilization</strong>: our system overhaul liberated resources equivalent to thousands of CPU cores and hundreds of gigabytes of RAM - a substantial enhancement of our server fleet's efficiency.</li>
		<li><strong>Code cleanup:</strong> another positive spin-off has been in our Lua and Go code. Thousands of lines of less performant and less memory-safe code have been weeded out, reducing technical debt.</li>
		<li><strong>Upscaled machine learning capabilities:</strong> last but certainly not least, we've significantly expanded our machine learning features, dimensions, and models. This upgrade empowers our machine learning inference to handle hundreds of machine learning features and dozens of dimensions and models.</li>
	</ul>
	<h2 id="conclusion">Conclusion</h2>
	<p>In the wake of our redesign, we've constructed a powerful and efficient system that truly embodies the essence of 'bliss'. Harnessing the advantages of memory-mapped files, wait-free synchronization, allocation-free operations, and zero-copy deserialization, we've established a robust infrastructure that maintains peak performance while achieving remarkable reductions in latency. As we navigate towards the future, we're committed to leveraging this platform to further improve our Security machine learning products and cultivate innovative features. Additionally, we're excited to share parts of this technology through an open-sourced Rust package <a href="https://github.com/cloudflare/mmap-sync" target="_blank"><strong><code>mmap-sync</code></strong></a>.</p>
	<p>As we leap into the future, we are building upon our platform's impressive capabilities, exploring new avenues to amplify the power of machine learning. We are deploying a new machine learning model built on BLISS with select customers. If you are a Bot Management subscriber and want to test the new model, please reach out to your account team.</p>
	<p>Separately, we are on the lookout for more Cloudflare customers who want to run their own machine learning models at the edge today. If you’re a developer considering making the switch to Workers for your application, sign up for our <a href="https://blog.cloudflare.com/introducing-constellation">Constellation AI closed beta</a>. If you’re a Bot Management customer and looking to run an already trained, lightweight model at the edge, <a href="https://www.cloudflare.com/lp/byo-machine-learning-model" target="_blank">we would love to hear from you</a>. Let's embark on this path to bliss together.</p>
</div>