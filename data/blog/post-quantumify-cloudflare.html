<div class="mb2 gray5">11 min read</div>
<div class="post-content lh-copy gray1">
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1K9ML9RdjOIFgWZdFdrLg7/35b77f333580363855da9235ca3b46ce/image6-10.png" alt="blog post about the services at Cloudflare that are migrating to post-quantum." class="kg-image" width="1801" height="1013" loading="lazy">

	</figure>
	<p>Theoretically, there is no impediment to adding <a href="https://blog.cloudflare.com/post-quantum-taxonomy">post-quantum cryptography</a> to any system. But the reality is harder. In the middle of last year, we posed ourselves a big challenge: <b>to change all</b> <b><i>internal connections</i></b> <b>at Cloudflare to use post-quantum cryptography</b>. We call this, in a cheeky way, “post-quantum-ifying” our services. Theoretically, this should be simple: swap algorithms for post-quantum ones and move along. But with dozens of different services in various programming languages (as we have at Cloudflare), it is not so simple. The challenge is big but we are here and up for the task! In this blog post, we will look at what our plan was, where we are now, and what we have learned so far. Welcome to the first announcement of a post-quantum future at Cloudflare: our connections are going to be quantum-secure!</p>
	<div class="flex anchor relative">
		<h3 id="what-are-we-doing">What are we doing?</h3>
		<a href="https://blog.cloudflare.com/#what-are-we-doing" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>The life of most requests at Cloudflare <a href="https://blog.cloudflare.com/more-data-more-data">begins and ends at the edge</a> of our global network. Not all requests are equal and on their path they are transmitted by several protocols. Some of those protocols provide security properties whilst others do not. For the protocols that do, for context, Cloudflare uses: <a href="https://blog.cloudflare.com/rfc-8446-aka-tls-1-3">TLS</a>, <a href="https://blog.cloudflare.com/tag/quic">QUIC</a>, <a href="https://blog.cloudflare.com/1111-warp-better-vpn">WireGuard</a>, <a href="https://blog.cloudflare.com/tag/dnssec">DNSSEC</a>, <a href="https://blog.cloudflare.com/anycast-ipsec">IPsec</a>, <a href="https://blog.cloudflare.com/privacy-pass-v3">Privacy Pass</a>, and more. Migrating all of these protocols and connections to use post-quantum cryptography is a formidable task. It is also a task that we do not treat lightly because:</p>
	<ul>
		<li>
			<p>We have to be assured that the security properties provided by the protocols are not diminished.</p>
		</li>
		<li>
			<p>We have to be assured that performance is not negatively affected.</p>
		</li>
		<li>
			<p>We have to be wary of other requirements of our ever-changing ecosystem (like, for example, keeping in mind our <a href="https://www.cloudflare.com/en-gb/press-releases/2021/cloudflare-hits-milestone-in-fedramp-approval">FedRAMP certification efforts</a>).</p>
		</li>
	</ul>
	<p>Given these requirements, we had to decide on the following:</p>
	<ul>
		<li>
			<p>How are we going to introduce post-quantum cryptography into the protocols?</p>
		</li>
		<li>
			<p>Which protocols will we be migrating to post-quantum cryptography?</p>
		</li>
		<li>
			<p>Which Cloudflare services will be targeted for this migration?</p>
		</li>
	</ul>
	<p>Let’s explore now what we chose: welcome to our path!</p>
	<div class="flex anchor relative">
		<h3 id="tls-and-post-quantum-in-the-real-world">TLS and post-quantum in the real world</h3>
		<a href="https://blog.cloudflare.com/#tls-and-post-quantum-in-the-real-world" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>One of the most used security protocols is Transport Layer Security (TLS). It is the vital protocol that protects most of the data that flows over the Internet today. Many of Cloudflare’s internal services also rely on TLS for security. It seemed natural that, for our migration to post-quantum cryptography, we would start with this protocol.</p>
	<p>The protocol provides three security properties: integrity, authentication, and confidentiality. The algorithms used to provide the first property, integrity, seem to not be <a href="https://research.kudelskisecurity.com/2017/02/01/defeating-quantum-algorithms-with-hash-functions">quantum-threatened</a> (there is <a href="https://eprint.iacr.org/2012/606.pdf">some research</a> on the matter). The second property, authentication, is under quantum threat, but we will not focus on it for reasons detailed later. The third property, confidentiality, is the one that we are interested in protecting as it is urgent to do this now.</p>
	<p>Confidentiality assures that no one other than the intended receiver and sender of a message can read the transmitted message. Confidentiality is especially threatened by quantum computers as an attacker can record traffic now and decrypt it in the future (when they get access to a quantum computer): this means that all past and current traffic, not just future traffic, is vulnerable to be read by anyone who obtains a quantum computer (and has stored the encrypted traffic captured today).</p>
	<p>At Cloudflare, to protect many of our connections, we use TLS. We mainly use the latest version of the protocol, TLS 1.3, but we do sometimes still use TLS 1.2 (as seen in the image, though, it only shows the connections between websites to our network). &nbsp;As we are a company that pushes for innovation, this means that we are intent on using this time of migration to post-quantum cryptography as an opportunity to also update TLS handshakes to 1.3 and be assured that we are using TLS in the right way (by, for example, ensuring that we are not using deprecated features of TLS).</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5toLKjOnOcTdY4jkqTodFb/80452cac0010e2311e76e31c0a138820/image2-24.png" alt="Image of Cloudflare’s TLS and QUIC usage taken on the 17/02/2022 and showing the last 7 days." class="kg-image" width="1224" height="482" loading="lazy">

	</figure>
	<p>Cloudflare’s TLS and QUIC usage <a href="https://radar.cloudflare.com/#anchor-tls-versions-vs">taken on</a> the 17/02/2022 and showing the last 7 days.</p>
	<p>Changing TLS 1.3 to provide quantum-resistant security for its confidentiality means changing the ‘key exchange’ phase of the TLS handshake. Let’s briefly look at how the TLS 1.3 handshake works.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5qFzOkZw6F47b7q1FeoJrf/c781aa2f7621d61664b7f7efafe3927e/image3-26.png" alt="Image showing a TLS 1.3 handshake" class="kg-image" width="740" height="652" loading="lazy">

	</figure>
	<p>The TLS 1.3 handshake</p>
	<p>In <a href="https://datatracker.ietf.org/doc/html/rfc8446">TLS 1.3</a>, there will always be two parties: a client and a server. A client is a party that wants the server to “serve” them something, which could be a website, emails, chat messages, voice messages, and more. The handshake is the process by which the server and client attempt to agree on a shared secret, which will be used to encrypt the subsequent exchange of data (this shared secret is called the “master secret”). The client selects their favorite key exchange algorithms and submits one or more “key shares” to the server (they send both the name of the key share and its public key parameter). The server picks one of the key exchange algorithms (assuming that it supports one of them), and replies back with their own key share. Both the server and the client then combine the key shares to compute a shared secret (the “master secret”), which is used to protect the remainder of the connection. If the client only chooses algorithms that the server does not support, the server instead replies with the algorithms that it does support and asks the client to try again. During this initial conversation, the client and server also agree on authentication methods and the parameters for encryption, but we can leave that aside for today in this blog post. This description is also simplified to focus only in the “key exchange” phase.</p>
	<p>There is a mechanism to add post-quantum cryptography to this procedure: you advertise post-quantum algorithms in the list of key shares, so the final derived shared key (the “master secret”) is quantum secure. But there are requirements we had to take into account when doing this with our connections: the security of much post-quantum cryptography is still under debate and we need to respect our <a href="https://www.cloudflare.com/en-gb/trust-hub/compliance-resources">compliance efforts</a>. The solution to these requirements is to use a <a href="https://datatracker.ietf.org/doc/draft-ietf-tls-hybrid-design">“hybrid” mechanism</a>.</p>
	<p>A “hybrid” mechanism means to use both a “pre-quantum” or “classical” algorithm and a “post-quantum” algorithm, and mixing both generated shared secrets into the derivation of the “master secret”. The combination of both shared secrets is of the form \Z′ = Z || T\ (for TLS and with the fixed size shared secrets, simple concatenation is secure. In other cases, you have to be a bit more careful). This procedure is a concatenation consisting of:</p>
	<ul>
		<li>
			<p>A “classical” shared secret <i>Z</i>, derived following the guidelines of <a href="https://www.nist.gov/standardsgov/compliance-faqs-federal-information-processing-standards-fips#:~:text=are%20FIPS%20developed%3F-,What%20are%20Federal%20Information%20Processing%20Standards%20(FIPS)%3F,by%20the%20Secretary%20of%20Commerce.">Federal Information Processing Standards</a> (FIPS 104-2) <a href="https://en.wikipedia.org/wiki/FIPS_140-2">approved mechanisms</a> (as recommended <a href="https://csrc.nist.gov/publications/detail/sp/800-56a/rev-3/final">over</a> <a href="https://csrc.nist.gov/publications/detail/sp/800-56b/rev-2/final">here</a>), like, for example, the <a href="https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session6-adalier-mehmet.pdf">P-256 elliptic curve</a>.</p>
		</li>
		<li>
			<p>An auxiliary shared secret <i>T</i>, derived with some other method: in this case, in a quantum-secure way.</p>
		</li>
	</ul>
	<p>The usage of a “hybrid” approach allows us to safeguard our connections in case the security of the post-quantum algorithm fails. It also results in a suitable-for-FIPS secret, as it is approved in the <a href="https://csrc.nist.gov/publications/detail/sp/800-56c/rev-2/final">“Recommendation for Key-Derivation Methods in Key-Establishment Schemes”</a> (SP 800-56C Rev. 2), which is listed in the <a href="https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402annexd.pdf">Annex D</a>, as an approved key establishing technique for FIPS 140-2.</p>
	<p>At Cloudflare, we are using different TLS libraries. We decided to add post-quantum cryptography to those, specifically, to the <a href="https://csrc.nist.gov/projects/cryptographic-module-validation-program/Certificate/3318"><i>BoringCrypto</i></a> library or the compiled version of <a href="https://github.com/golang/go/tree/dev.boringcrypto.go1.8">Golang with <i>BoringCrypto</i></a>. We added <a href="https://github.com/cloudflare/circl/tree/master/kem/kyber">our implementation</a> of the <a href="https://pq-crystals.org/kyber/resources.shtml">Kyber-512</a> algorithm (this algorithm can be eventually swapped by another one; we’re not picking any here. We are using it for our testing phase) to those libraries and implemented the “hybrid” mechanism as part of the TLS handshake. For the “classical” algorithm we used <a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography">curve P-256</a>. We then compiled certain services with these new TLS libraries.</p>
	<p>Name of algorithm</p>
	<p>Number of times loop executed</p>
	<p>Average runtime per operation</p>
	<p>Number of bytes required per operation</p>
	<p>Number of allocations</p>
	<p>Curve P-256</p>
	<p>23,056</p>
	<p>52,204 ns/op</p>
	<p>256 B/op</p>
	<p>5 allocs/op</p>
	<p>Kyber-512</p>
	<p>100,977</p>
	<p>11,793 ns/op</p>
	<p>832 B/op</p>
	<p>3 allocs/op</p>
	<p>Table 1: Benchmarks of the “key share” operation of Curve P-256 and Kyber-512: Scalar Multiplication and Encapsulation respectively. Benchmarks ran on Darwin, amd64, Intel(R) Core(TM) i7-9750H CPU @ 2.60 GHz.</p>
	<p>Note that as TLS supports the described “negotiation” mechanism for the key exchange, the client and server have a way of mutually deciding what algorithms they want to use. This means that it is not required that both a client or a server support or even prefer the exact same algorithms: they just need to share support for a single algorithm for a handshake to succeed. In turn, herewith, even if we advertise post-quantum cryptography and a server/client does not support it, they will not fail but rather agree on some other algorithm they share.</p>
	<p>A note on a matter we left on hold above: why are we not migrating the authentication phase of TLS to post-quantum? Certificate-based authentication in TLS, which is the one we commonly use at Cloudflare, also depends on systems on the wider Internet. Thus, changes to authentication require a coordinated and much wider effort to change. Certificates are attested as proofs of identity by outside parties: migrating authentication means coordinating a ceremony of migration with these outside parties. Note though that at Cloudflare we use a <a href="https://blog.cloudflare.com/how-to-build-your-own-public-key-infrastructure">PKI with internally-hosted Certificate Authorities (CAs)</a>, which means that we can more easily change our algorithms. This will still need careful planning. We will not do this today, but we will in the near future.</p>
	<div class="flex anchor relative">
		<h3 id="cloudflare-services">Cloudflare services</h3>
		<a href="https://blog.cloudflare.com/#cloudflare-services" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>The first step of our post-quantum migration is done. We have TLS libraries with post-quantum cryptography using a hybrid mechanism. The second step is to test this new mechanism in specific Cloudflare connections and services. We will look at three systems from Cloudflare that we have started migrating to post-quantum cryptography. The services in question are: Logfwrdr, Cloudflare Tunnel, and GoKeyless.</p>
	<div class="flex anchor relative">
		<h3 id="a-post-quantum-logfwdr">A post-quantum Logfwdr</h3>
		<a href="https://blog.cloudflare.com/#a-post-quantum-logfwdr" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p><a href="https://blog.cloudflare.com/more-data-more-data">Logfwdr</a> is an internal service, written in Golang, that handles structured logs, and sends them from our servers for processing (to a subservice called ‘Logreceiver’) where they write them to Kafka. The connection between Logfwdr and Logreceiver is protected by TLS. The same goes for the connection between Logreceiver and <a href="https://kafka.apache.org">Kafka</a> in core. Logfwdr pushes its logs through “streams” for processing.</p>
	<p>This service seemed an ideal candidate for migrating to post-quantum cryptography as its architecture is simple, it has long-lived connections, and it handles a lot of traffic. In order to first test the viability of using post-quantum cryptography, we created our own instance of Logreceiver and deployed it. We also created our own stream (the “pq-stream”), which is basically a copy of a HTTP stream (which was remarkably easy to add). We then compiled these services with the modified TLS library and we got a post-quantum protected Logfwdr.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2YlRJqczYHpPshoEZzpu9b/160d794b37b407bb09fd345b889101c7/image7-5.png" alt="Graph showing the TLS latency of Logfwdr for selected servers." class="kg-image" width="517" height="343" loading="lazy">

	</figure>
	<p>Figure 1: TLS latency of Logfwdr for selected metals. Notice how post-quantum cryptography is faster than non-post-quantum one (it is labeled with a “PQ” acronym).</p>
	<p>What we found was that using post-quantum cryptography is faster than using “classical” cryptography! This was expected, though, as we are using a lattice-based post-quantum algorithm (Kyber512). The TLS latency of both post-quantum handshakes and “classical” ones can be noted in Figure 1. The figure shows more handshakes are executed than usual behavior as these servers are frequently restarted.</p>
	<p>Note though that we are not using “only” post-quantum cryptography but rather the “hybrid” mechanism described above. This could increase performance times: in this case, the increase was minimal and still kept the post-quantum handshakes faster than the classical ones. Perhaps what makes the TLS handshakes faster in the post-quantum case is the usage of TLS 1.3, as the “classical” Logfwdr is using TLS 1.2. Logfwdr, though, is a service that executes long-lived handshakes, so in aggregate TLS 1.2 is not “slower” but it does have a slower start time.</p>
	<p>As shown in Figure 2, the average batch duration of the post-quantum stream is lower than when not using post-quantum cryptography. This may be in part due to the fact that we are not sending the quantum-protected data all the way to Kafka (as the non-post-quantum stream is doing). We didn’t yet change the connection to Kafka post-quantum.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/7s0OprfksLusP0685ydiYl/69af1192a703c1224f746673d83c44d2/image8-3.png" alt="Graph comparing the average batch send duration of post-quantum (orange) and non-post-quantum streams (green)." class="kg-image" width="1620" height="580" loading="lazy">

	</figure>
	<p>Figure 2: Average batch send duration: post-quantum (orange) and non-post-quantum streams (green).</p>
	<p>We didn’t encounter any failures during this testing that ran for about some weeks. This gave us good insight that putting post-quantum cryptography into our internal network with actual data is possible. It also gave us confidence to begin migrating codebases to modified TLS libraries, which we will maintain.</p>
	<p>What are the next steps for Logfwdr? Now that we confirmed it is possible, we will first start migrating stream by stream to this hybrid mechanism until we reach full post-quantum migration.</p>
	<div class="flex anchor relative">
		<h3 id="a-post-quantum-gokeyless">A post-quantum gokeyless</h3>
		<a href="https://blog.cloudflare.com/#a-post-quantum-gokeyless" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p><a href="https://blog.cloudflare.com/going-keyless-everywhere"><i>gokeyless</i></a> is our own way to separate servers and TLS long-term private keys. With it, private keys are kept on a specialized key server operated by customers on their own architecture or, if using <a href="https://blog.cloudflare.com/introducing-cloudflare-geo-key-manager">Geo Key Manager</a>, in selected Cloudflare locations. We also use it for Cloudflare-held private keys with a service creatively known as <i>gokeyless-internal</i>. The final piece of this architecture is another service called <a href="https://blog.cloudflare.com/scaling-geo-key-manager"><i>Keynotto</i></a>. Keynotto is a service written in Rust that only mints RSA and ECDSA key signatures (that are executed with the stored private key).</p>
	<p>How does the overall architecture of gokeyless work? Let’s start with a request. The request arrives at the Cloudflare network and we perform TLS termination. Any signing request is forwarded to Keynotto. A small portion of requests (specifically from GeoKDL or external gokeyless) cannot be handled by Keynotto directly, and are instead forwarded to gokeyless-internal. gokeyless-internal also acts as a key server proxy, as it redirects connections to the customer’s keyservers (external gokeyless). <a href="https://github.com/cloudflare/gokeyless">External gokeyless</a> is both the server that a customer runs and the client that will be used to contact it. The architecture can be seen in Figure 3.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5c2XtFKTmHLgy9XNmAfJsh/496e49511e6aea34309abbae92b846f5/image5-10.png" alt="Diagram of the life of a gokeyless request." class="kg-image" width="1801" height="525" loading="lazy">

	</figure>
	<p>Figure 3: The life of a gokeyless request.</p>
	<p>Migrating the transport that this architecture uses to post-quantum cryptography is a bigger challenge, as it involves migrating a service that lives on the customer side. So, for our testing phase, we decided to go for the simpler path that we are able to change ourselves: the TLS handshake between Keynotto and gokeyless-internal. This small test-bed means two things: first, that we needed to change another TLS library (as Keynotto is written in Rust) and, second, that we needed to change gokeyless-internal in such a way that it used post-quantum cryptography only for the handshakes with Keynotto and for nothing else. Note that we did not migrate the signing operations that gokeyless or Keynotto executes with the stored private key; we just migrated the transport connections.</p>
	<p>Adding post-quantum cryptography to the <a href="https://github.com/rustls/rustls">rustls codebase</a> was a straightforward exercise and we exposed an easy-to-use API call to signal the usage of post-quantum cryptography (as seen in Figure 4 and Figure 5). One thing that we noted when reviewing the TLS usage in several Cloudflare services is that giving the option to choose the algorithms for a ciphersuite, key share, and authentication in the TLS handshake confuses users. It seemed more straightforward to define the algorithm at the library level, and have a boolean or API call signal the need for this post-quantum algorithm.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4i2qzprdHeQ5F7Y9CLn1S2/354947695ac81ead9fd7e414a562bc37/image9-3.png" alt="post-Quantum API for rustls." class="kg-image" width="1320" height="290" loading="lazy">

	</figure>
	<p>Figure 4: post-Quantum API for rustls.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5rk2okKUdjZmpisim3f5bk/bd2b2bec41309221236591c53b071d6d/image4-16.png" alt="usage post-quantum API for rustls." class="kg-image" width="970" height="442" loading="lazy">

	</figure>
	<p>Figure 5: usage of the post-quantum API for rustls.</p>
	<p>We ran a small test between Keynotto and gokeyless-internal with much success. Our next steps are to integrate this test into the real connection between Keynotto and gokeyless-internal, and to devise a plan for a customer post-quantum protected gokeyless external. This is the first instance in which our migration to post-quantum will not be ending at our edge but rather at the customer’s connection point.</p>
	<div class="flex anchor relative">
		<h3 id="a-post-quantum-cloudflare-tunnel">A post-quantum Cloudflare Tunnel</h3>
		<a href="https://blog.cloudflare.com/#a-post-quantum-cloudflare-tunnel" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p><a href="https://www.cloudflare.com/en-gb/products/tunnel">Cloudflare Tunnel</a> is a reverse proxy that allows customers to quickly connect their private services and networks to the Cloudflare network without having to expose their public IPs or ports through their firewall. It is mainly managed at the customer level through the <a href="https://github.com/cloudflare/cloudflared">usage of <i>cloudflared</i></a><i>,</i> a lightweight server-side daemon_,_ in their infrastructure. <i>cloudflared</i> opens several long-lived TCP connections (although, <i>cloudflared</i> is <a href="https://blog.cloudflare.com/getting-cloudflare-tunnels-to-connect-to-the-cloudflare-network-with-quic">increasingly using the QUIC</a> protocol) to servers on <a href="https://www.cloudflare.com/en-gb/learning/serverless/glossary/what-is-edge-computing">Cloudflare’s global network</a>. When a request to a hostname comes, it is proxied through these connections to the origin service behind <i>cloudflared</i>.</p>
	<p>The easiest part of the service to make post-quantum secure appears to be the connection between our network (with a service part of Tunnel called <i>origintunneld</i> located there) and <i>cloudflared</i>, which we have started migrating. While exploring this path and looking at the whole life of a Tunnel connection, we found something more interesting, though. When the Tunnel connections eventually reach core, they end up going to a service called <i>Tunnelstore</i>. <i>Tunnelstore</i> runs as a stateless application in a Kubernetes deployment, and to provide TLS termination (alongside load balancing and more) it uses a <a href="https://kubernetes.io">Kubernetes</a> <a href="https://kubernetes.io/docs/concepts/services-networking/ingress">ingress</a>.</p>
	<p>The <a href="https://blog.cloudflare.com/cloudflare-ingress-controller">Kubernetes ingress</a> we use at Cloudflare is made of <a href="https://www.envoyproxy.io">Envoy</a> and <a href="https://projectcontour.io">Contour</a>. The latter configures the former depending on Kubernetes resources. Envoy uses the <a href="https://www.envoyproxy.io/docs/envoy/latest/faq/build/boringssl">BoringSSL library</a> for TLS. Switching TLS libraries in Envoy seemed difficult: there are <a href="https://github.com/envoyproxy/envoy-openssl">thoughts</a> on how to integrate OpenSSL to it (and <a href="https://github.com/open-quantum-safe/oqs-demos/issues/79">even some thoughts</a> on adding post-quantum cryptography) and <a href="https://github.com/envoyproxy/envoy/pull/7377">ways to switch TLS libraries</a>. Adding post-quantum cryptography to a modified version of BoringSSL, and then specifying <a href="https://github.com/google/boringssl/blob/master/INCORPORATING.md">that dependency</a> in the <a href="https://github.com/envoyproxy/envoy/blob/main/bazel/repository_locations.bzl#L74">Bazel file of Envoy</a> seems to be the path to go for, as our internal test has confirmed (as seen in Figure 6). As for Contour, for many years, Cloudflare has been running their own patched version of it: we will have to again patch this version with our Golang library to provide post-quantum cryptography. We will make these libraries (and the TLS ones) available for usage.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/itO6WZ2vhxBBR8Jy8iWRp/5c435ec9ccac61b74fe0f9499b171011/image1-27.png" alt="Image displaying an option to allow post-quantum cryptography in Envoy." class="kg-image" width="1862" height="316" loading="lazy">

	</figure>
	<p>Figure 6: Option to allow post-quantum cryptography in Envoy.</p>
	<p>Changing the Kubernetes ingress at Cloudflare not only makes Tunnel completely quantum-safe (beyond the connection between our global network and <i>cloudflared</i>), but it also makes any other services using ingress safe. Our first tests on migrating Envoy and Contour to TLS libraries that contain post-quantum protections have been successful, and now we have to test how it behaves in the whole ingress ecosystem.</p>
	<div class="flex anchor relative">
		<h3 id="what-is-next">What is next?</h3>
		<a href="https://blog.cloudflare.com/#what-is-next" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>The main tests are now done. We now have TLS libraries (in Go, Rust, and C) that give us post-quantum cryptography. We have two systems ready to deploy post-quantum cryptography, and a shared service (Kubernetes ingress) that we can change. At the beginning of the blog post, we said that “the life of most requests at Cloudflare begins and ends at the edge of our global network”: our aim is that post-quantum cryptography does not end there, but rather reaches all the way to where customers connect as well. Let’s explore the future challenges and this customer post-quantum path in this <a href="https://blog.cloudflare.com/post-quantum-future">other blog post</a>!</p>
</div>