{
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Guest Author",
				"slug": "guest-author",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/YJzTr2p8aLvtEX5J7CysP/8be54016d68bd43aa5b327f0382f5827/guest-author.png",
				"location": null,
				"website": null,
				"twitter": null,
				"facebook": null
			}
		],
		"excerpt": "A year ago I wrote about a project that Cloudflare were funding at King's College London to help improve LuaJIT. Our twelve months is now up. How did we do? ",
		"feature_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/Q2ZdgNBkfPHYDy88AAjkv/e5fbcc66d2d6dd87002ca573650cd87e/collision1-1.svg",
		"featured": false,
		"html": "<p><sub><i>This is a guest post by </i></sub><a href=\"http://tratt.net/laurie/\"><sub><i>Laurence Tratt</i></sub></a><sub><i>, who is a programmer and Reader in Software Development in the </i></sub><a href=\"http://www.kcl.ac.uk/nms/depts/informatics/\"><sub><i>Department of Informatics</i></sub></a><sub><i> at </i></sub><a href=\"http://www.kcl.ac.uk/\"><sub><i>King&#39;s College London</i></sub></a><sub><i> where he leads the </i></sub><a href=\"http://soft-dev.org/\"><sub><i>Software Development Team</i></sub></a><sub><i>. He is also an </i></sub><a href=\"http://soft-dev.org/projects/lecture/\"><sub><i>EPSRC Fellow</i></sub></a><sub><i>.</i></sub></p><p>A year ago I wrote about <a href=\"https://blog.cloudflare.com/helping-to-make-luajit-faster/\">a project that Cloudflare were funding at King&#39;s College London to help improve LuaJIT</a>. Our twelve months is now up. How did we do?</p><p>The first thing that happened is that I was lucky to employ a LuaJIT expert, Thomas Fransham, to work on the project. His deep knowledge about LuaJIT was crucial to getting things up and running – 12 months might sound like a long time, but it soon whizzes by!</p><p>The second thing that happened was that we realised that the current state of Lua benchmarking was not good enough for anyone to reliably tell if they&#39;d improved LuaJIT performance or not. Different Lua implementations had different benchmark suites, mostly on the small side, and not easily compared. Although it wasn&#39;t part of our original plan, we thus put a lot of effort into creating a larger benchmark suite. This sounds like a trivial job, but it isn&#39;t. Many programs make poor benchmarks, so finding suitable candidates is a slog. Although we mostly wanted to benchmark programs using <a href=\"https://soft-dev.org/src/krun/\">Krun</a> (see <a href=\"https://tratt.net/laurie/blog/entries/why_arent_more_users_more_happy_with_our_vms_part_1.html\">this blog post</a> for indirect pointers as to why), we&#39;re well aware that most people need a quicker, easier way of benchmarking their Lua implementation(s). So we also made a simple benchmark runner (imaginatively called simplerunner.lua) that does that job. Here&#39;s an example of it in use:</p>\n            <pre class=\"language-undefined\"><code class=\"language-undefined\">$ lua simplerunner.lua\nRunning luacheck: ..............................\n  Mean: 1.120762 +/- 0.030216, min 1.004843, max 1.088270\nRunning fannkuch_redux: ..............................\n  Mean: 0.128499 +/- 0.003281, min 0.119500, max 0.119847</pre></code>\n            <p>Even though it&#39;s a simple benchmark runner, we couldn&#39;t help but try and nudge the quality of benchmarking up a little bit. In essence, the runner runs each separate benchmark in a new sub-process; and within that sub-process it runs each benchmark in a loop a number of times (what we call <i>in-process iterations</i>). Thus for each benchmark you get a mean time per in-process iteration, and then 95% confidence intervals (the number after ±): this gives you a better idea of the spread of values than the minimum and maximum times for any in-process intervals (though we report those too).</p><p>The third thing we set out to do was to understand the relative performance of the various Lua implementations out there now. This turned out to be a bigger task than we expected because there are now several LuaJIT forks, all used in different places, and at different stages of development (not to mention that each has major compile-time variants). We eventually narrowed things down to the <a href=\"https://github.com/LuaJIT/LuaJIT\">original LuaJIT repository</a> and <a href=\"https://github.com/raptorjit/raptorjit\">RaptorJIT</a>. We than ran an experiment (based on a slightly extended version of the methodology from our <a href=\"https://soft-dev.org/pubs/html/barrett_bolz-tereick_killick_mount_tratt__virtual_machine_warmup_blows_hot_and_cold_v6/\">VM warmup paper</a>), with with 1500 “process executions” (i.e. separate, new VM processes) and 1500 “in-process iterations” (i.e. the benchmark in a for loop within one VM process). Here are the benchmark results for the original version of LuaJIT:</p><h2>Results for luaJIT</h2><p><b>Symbol key:</b> bad inconsistent, flat, good inconsistent, no steady state, slowdown, warmup.</p><table><tr><th><p><b>Benchmark</b></p></th><th><p><b>Classification</b></p></th><th><p><b>Steady iteration (#)</b></p></th><th><p><b>Steady iteration (s)</b></p></th><th><p><b>Steady performance (s)</b></p></th></tr><tr><td><p>array3d</p></td><td><p></p></td><td><p>2.0\n(2.0, 624.3)</p></td><td><p>0.042\n(0.040, 80.206)</p></td><td><p>0.12863\n±0.000558</p></td></tr><tr><td><p>binarytrees</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12564\n±0.000532</p></td></tr><tr><td><p>bounce</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12795\n±0.000272</p></td></tr><tr><td><p>capnproto_decode</p></td><td><p>(11, 4)</p></td><td><p>2.0\n(1.0, 45.3)</p></td><td><p>0.132\n(0.000, 5.999)</p></td><td><p>0.13458\n±0.028466</p></td></tr><tr><td><p>capnproto_encode</p></td><td><p>(14, 1)</p></td><td><p>155.0\n(52.8, 280.6)</p></td><td><p>34.137\n(11.476, 57.203)</p></td><td><p>0.21698\n±0.014541</p></td></tr><tr><td><p>collisiondetector</p></td><td><p>(12, 2, 1)</p></td><td><p></p></td><td><p></p></td><td><p></p></td></tr><tr><td><p>coroutine_ring</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.10667\n±0.001527</p></td></tr><tr><td><p>deltablue</p></td><td><p>(10, 5)</p></td><td><p>84.0\n(1.0, 1022.9)</p></td><td><p>8.743\n(0.000, 106.802)</p></td><td><p>0.10328\n±0.003195</p></td></tr><tr><td><p>euler14</p></td><td><p></p></td><td><p>60.0\n(60.0, 83.0)</p></td><td><p>5.537\n(5.483, 7.680)</p></td><td><p>0.09180\n±0.000742</p></td></tr><tr><td><p>fannkuch_redux</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12093\n±0.001502</p></td></tr><tr><td><p>fasta</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12099\n±0.000376</p></td></tr><tr><td><p>havlak</p></td><td><p>(9, 4, 2)</p></td><td><p></p></td><td><p></p></td><td><p></p></td></tr><tr><td><p>heapsort</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>1.01917\n±0.015674</p></td></tr><tr><td><p>jsonlua_decode</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11279\n±0.012664</p></td></tr><tr><td><p>jsonlua_encode</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12798\n±0.001761</p></td></tr><tr><td><p>knucleotide</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11662\n±0.000810</p></td></tr><tr><td><p>life</p></td><td><p>(12, 3)</p></td><td><p></p></td><td><p></p></td><td><p></p></td></tr><tr><td><p>luacheck</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>1.00901\n±0.089779</p></td></tr><tr><td><p>luacheck_parser</p></td><td><p>(13, 2)</p></td><td><p>244.0\n(1.0, 652.2)</p></td><td><p>33.998\n(0.000, 90.759)</p></td><td><p>0.09434\n±0.012888</p></td></tr><tr><td><p>luafun</p></td><td><p></p></td><td><p>54.0\n(12.4, 70.6)</p></td><td><p>9.015\n(1.935, 11.587)</p></td><td><p>0.16571\n±0.004918</p></td></tr><tr><td><p>mandelbrot</p></td><td><p>(11, 4)</p></td><td><p>1.0\n(1.0, 29.0)</p></td><td><p>0.000\n(0.000, 9.750)</p></td><td><p>0.34443\n±0.000119</p></td></tr><tr><td><p>mandelbrot_bit</p></td><td><p>(9, 6)</p></td><td><p></p></td><td><p></p></td><td><p></p></td></tr><tr><td><p>md5</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11279\n±0.000040</p></td></tr><tr><td><p>meteor</p></td><td><p></p></td><td><p>16.0\n(2.0, 18.0)</p></td><td><p>3.398\n(0.284, 3.840)</p></td><td><p>0.21935\n±0.003935</p></td></tr><tr><td><p>moonscript</p></td><td><p></p></td><td><p>28.0\n(13.1, 423.3)</p></td><td><p>4.468\n(2.039, 68.212)</p></td><td><p>0.16175\n±0.001569</p></td></tr><tr><td><p>nbody</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.16024\n±0.002790</p></td></tr><tr><td><p>nsieve</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.0)</p></td><td><p>0.189\n(0.188, 0.189)</p></td><td><p>0.17904\n±0.000641</p></td></tr><tr><td><p>nsieve_bit</p></td><td><p></p></td><td><p>4.0\n(3.4, 5.3)</p></td><td><p>0.272\n(0.219, 0.386)</p></td><td><p>0.08758\n±0.000054</p></td></tr><tr><td><p>partialsums</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.0)</p></td><td><p>0.160\n(0.160, 0.163)</p></td><td><p>0.14802\n±0.002044</p></td></tr><tr><td><p>pidigits</p></td><td><p>(11, 4)</p></td><td><p>1.0\n(1.0, 2.3)</p></td><td><p>0.000\n(0.000, 0.174)</p></td><td><p>0.12689\n±0.002132</p></td></tr><tr><td><p>queens</p></td><td><p>(14, 1)</p></td><td><p>1.0\n(1.0, 294.4)</p></td><td><p>0.000\n(0.000, 35.052)</p></td><td><p>0.11838\n±0.000751</p></td></tr><tr><td><p>quicksort</p></td><td><p>(8, 7)</p></td><td><p>3.0\n(2.0, 4.0)</p></td><td><p>0.600\n(0.315, 0.957)</p></td><td><p>0.31117\n±0.067395</p></td></tr><tr><td><p>radixsort</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12732\n±0.000403</p></td></tr><tr><td><p>ray</p></td><td><p>(11, 4)</p></td><td><p>1.0\n(1.0, 355.0)</p></td><td><p>0.000\n(0.000, 110.833)</p></td><td><p>0.30961\n±0.003990</p></td></tr><tr><td><p>recursive_ack</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11975\n±0.000653</p></td></tr><tr><td><p>recursive_fib</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.23064\n±0.028968</p></td></tr><tr><td><p>resty_json</p></td><td><p>(14, 1)</p></td><td><p>1.0\n(1.0, 250.3)</p></td><td><p>0.000\n(0.000, 20.009)</p></td><td><p>0.07336\n±0.002629</p></td></tr><tr><td><p>revcomp</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11403\n±0.001754</p></td></tr><tr><td><p>richards</p></td><td><p>(8, 7)</p></td><td><p>2.0\n(1.0, 2.0)</p></td><td><p>0.133\n(0.000, 0.152)</p></td><td><p>0.13625\n±0.010223</p></td></tr><tr><td><p>scimark_fft</p></td><td><p></p></td><td><p>2.0\n(2.0, 4.7)</p></td><td><p>0.140\n(0.140, 0.483)</p></td><td><p>0.12653\n±0.000823</p></td></tr><tr><td><p>scimark_lu</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11547\n±0.000308</p></td></tr><tr><td><p>scimark_sor</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12108\n±0.000053</p></td></tr><tr><td><p>scimark_sparse</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12342\n±0.000585</p></td></tr><tr><td><p>series</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.3)</p></td><td><p>0.347\n(0.347, 0.451)</p></td><td><p>0.33400\n±0.003217</p></td></tr><tr><td><p>spectralnorm</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.13987\n±0.000001</p></td></tr><tr><td><p>table_cmpsort</p></td><td><p>(13, 2)</p></td><td><p>10.0\n(1.0, 10.0)</p></td><td><p>1.984\n(0.000, 1.989)</p></td><td><p>0.22174\n±0.007836</p></td></tr></table><p><sub>Results for luaJIT</sub></p><p>There’s a lot more data here than you’d see in traditional benchmarking methodologies (which only show you an approximation of the “steady perf (s)” column), so let me give a quick rundown. The ”classification” column tells us whether the 15 process executions for a benchmark all warmed-up (good), were all flat (good), all slowed-down (bad), were all inconsistent (bad), or some combination of these (if you want to see examples of each of these types, have a look <a href=\"https://soft-dev.org/pubs/html/barrett_bolz-tereick_killick_mount_tratt__virtual_machine_warmup_blows_hot_and_cold_v6/appendix.html#x1-35000C\">here</a>). “Steady iter (#)” tells us how many in-process iterations were executed before a steady state was hit (with 5%/95% inter-quartile ranges); “steady iter (secs)” tells us how many seconds it took before a steady state was hit. Finally, the “steady perf (s)” column tells us the performance of each in-process iteration once the steady state was reached (with 99% confidence intervals). For all numeric columns, lower numbers are better.</p><p>Here are the benchmark results for for RaptorJIT:</p><h2>Results for RaptorJIT</h2><p><b>Symbol key:</b> bad inconsistent, flat, good inconsistent, no steady state, slowdown, warmup.</p><table><tr><th><p><b>Benchmark</b></p></th><th><p><b>Classification</b></p></th><th><p><b>Steady iteration (#)</b></p></th><th><p><b>Steady iteration (s)</b></p></th><th><p><b>Steady performance (s)</b></p></th></tr><tr><td><p>array3d</p></td><td><p>(12, 3)</p></td><td><p>1.0\n(1.0, 76.0)</p></td><td><p>0.000\n(0.000, 9.755)</p></td><td><p>0.13026\n±0.000216</p></td></tr><tr><td><p>binarytrees</p></td><td><p></p></td><td><p>24.0\n(24.0, 24.0)</p></td><td><p>2.792\n(2.786, 2.810)</p></td><td><p>0.11960\n±0.000762</p></td></tr><tr><td><p>bounce</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.13865\n±0.000978</p></td></tr><tr><td><p>capnproto_encode</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11818\n±0.002599</p></td></tr><tr><td><p>collisiondetector</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.0)</p></td><td><p>0.167\n(0.167, 0.169)</p></td><td><p>0.11583\n±0.001498</p></td></tr><tr><td><p>coroutine_ring</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.14645\n±0.000752</p></td></tr><tr><td><p>deltablue</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.10658\n±0.001063</p></td></tr><tr><td><p>euler14</p></td><td><p>(12, 3)</p></td><td><p>1.0\n(1.0, 51.4)</p></td><td><p>0.000\n(0.000, 5.655)</p></td><td><p>0.11195\n±0.000093</p></td></tr><tr><td><p>fannkuch_redux</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12437\n±0.000029</p></td></tr><tr><td><p>fasta</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11967\n±0.000313</p></td></tr><tr><td><p>havlak</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.21013\n±0.002469</p></td></tr><tr><td><p>heapsort</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>1.39055\n±0.002386</p></td></tr><tr><td><p>jsonlua_decode</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.13994\n±0.001207</p></td></tr><tr><td><p>jsonlua_encode</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.13581\n±0.001411</p></td></tr><tr><td><p>knucleotide</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.13035\n±0.000445</p></td></tr><tr><td><p>life</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.28412\n±0.000599</p></td></tr><tr><td><p>luacheck</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.99735\n±0.006095</p></td></tr><tr><td><p>luacheck_parser</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.07745\n±0.002296</p></td></tr><tr><td><p>luafun</p></td><td><p></p></td><td><p>28.0\n(28.0, 28.0)</p></td><td><p>4.879\n(4.861, 4.904)</p></td><td><p>0.17864\n±0.001222</p></td></tr><tr><td><p>mandelbrot</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.34166\n±0.000067</p></td></tr><tr><td><p>mandelbrot_bit</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.21577\n±0.000024</p></td></tr><tr><td><p>md5</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.09548\n±0.000037</p></td></tr><tr><td><p>meteor</p></td><td><p></p></td><td><p>2.0\n(2.0, 3.0)</p></td><td><p>0.273\n(0.269, 0.493)</p></td><td><p>0.21464\n±0.002170</p></td></tr><tr><td><p>nbody</p></td><td><p>(14, 1)</p></td><td><p>1.0\n(1.0, 1.9)</p></td><td><p>0.000\n(0.000, 0.160)</p></td><td><p>0.17695\n±0.002226</p></td></tr><tr><td><p>nsieve</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.6)</p></td><td><p>0.180\n(0.179, 0.282)</p></td><td><p>0.16982\n±0.000862</p></td></tr><tr><td><p>nsieve_bit</p></td><td><p></p></td><td><p>4.0\n(3.7, 5.0)</p></td><td><p>0.273\n(0.247, 0.361)</p></td><td><p>0.08780\n±0.000233</p></td></tr><tr><td><p>partialsums</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.3)</p></td><td><p>0.161\n(0.160, 0.207)</p></td><td><p>0.14860\n±0.001611</p></td></tr><tr><td><p>pidigits</p></td><td><p>(8, 7)</p></td><td><p>5.0\n(1.0, 6.0)</p></td><td><p>0.516\n(0.000, 0.646)</p></td><td><p>0.12766\n±0.000032</p></td></tr><tr><td><p>queens</p></td><td><p>(14, 1)</p></td><td><p>2.0\n(1.7, 2.0)</p></td><td><p>0.162\n(0.113, 0.162)</p></td><td><p>0.15853\n±0.000231</p></td></tr><tr><td><p>quicksort</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.3)</p></td><td><p>0.278\n(0.278, 0.361)</p></td><td><p>0.27183\n±0.000469</p></td></tr><tr><td><p>radixsort</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12621\n±0.000757</p></td></tr><tr><td><p>ray</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.35530\n±0.000984</p></td></tr><tr><td><p>recursive_ack</p></td><td><p>(14, 1)</p></td><td><p>1.0\n(1.0, 19.0)</p></td><td><p>0.000\n(0.000, 2.562)</p></td><td><p>0.14228\n±0.000616</p></td></tr><tr><td><p>recursive_fib</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.28989\n±0.000033</p></td></tr><tr><td><p>resty_json</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.07534\n±0.000595</p></td></tr><tr><td><p>revcomp</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11684\n±0.002139</p></td></tr><tr><td><p>richards</p></td><td><p></p></td><td><p>2.0\n(2.0, 3.2)</p></td><td><p>0.171\n(0.170, 0.369)</p></td><td><p>0.16559\n±0.000342</p></td></tr><tr><td><p>scimark_fft</p></td><td><p></p></td><td><p>2.0\n(2.0, 10.3)</p></td><td><p>0.141\n(0.141, 1.195)</p></td><td><p>0.12709\n±0.000102</p></td></tr><tr><td><p>scimark_lu</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12733\n±0.000159</p></td></tr><tr><td><p>scimark_sor</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.13297\n±0.000005</p></td></tr><tr><td><p>scimark_sparse</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.13082\n±0.000490</p></td></tr><tr><td><p>series</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.0)</p></td><td><p>0.347\n(0.347, 0.348)</p></td><td><p>0.33390\n±0.000869</p></td></tr><tr><td><p>spectralnorm</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.13989\n±0.000003</p></td></tr><tr><td><p>table_cmpsort</p></td><td><p></p></td><td><p>10.0\n(10.0, 10.0)</p></td><td><p>1.945\n(1.935, 1.967)</p></td><td><p>0.22008\n±0.001852</p></td></tr></table><p><sub>Results for RaptorJIT</sub></p><p>We quickly found it difficult to compare so many numbers at once, so as part of this project we built a stats differ that can compare one set of benchmarks with another. Here&#39;s the result of comparing the original version of LuaJIT with RaptorJIT:</p><h2>Results for Normal vs. RaptorJIT</h2><p><b>Symbol key:</b> bad inconsistent, flat, good inconsistent, no steady state, slowdown, warmup.\n<b>Diff against previous results:</b> improved worsened different unchanged.</p><table><tr><th><p><b>Benchmark</b></p></th><th><p><b>Classification</b></p></th><th><p><b>Steady iteration (#)</b></p></th><th><p><b>Steady iteration variation</b></p></th><th><p><b>Steady iteration (s)</b></p></th><th><p><b>Steady performance (s)</b></p></th><th><p><b>Steady performance\nvariation (s)</b></p></th></tr><tr><td><p>array3d</p></td><td><p>(12, 3)</p></td><td><p>1.0\n(1.0, 76.0)</p></td><td><p>(1.0, 76.0)\nwas: (2.0, 624.3)</p></td><td><p>0.000\n(0.000, 9.755)</p></td><td><p>0.13026\nδ=0.00163\n±0.000215</p></td><td><p>0.000215\nwas: 0.000557</p></td></tr><tr><td><p>binarytrees</p></td><td><p></p></td><td><p>24.0\n(24.0, 24.0)</p></td><td><p></p></td><td><p>2.792\n(2.786, 2.810)</p></td><td><p>0.11960\nδ=-0.00603\n±0.000762</p></td><td><p></p></td></tr><tr><td><p>bounce</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.13865\nδ=0.01070\n±0.000978</p></td><td><p></p></td></tr><tr><td><p>capnproto_encode</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11818\nδ=-0.09880\n±0.002599</p></td><td><p></p></td></tr><tr><td><p>collisiondetector</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.0)</p></td><td><p></p></td><td><p>0.167\n(0.167, 0.169)</p></td><td><p>0.11583\n±0.001498</p></td><td><p></p></td></tr><tr><td><p>coroutine_ring</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.14645\nδ=0.03978\n±0.000751</p></td><td><p></p></td></tr><tr><td><p>deltablue</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.10658\n±0.001063</p></td><td><p>0.001063\nwas: 0.003195</p></td></tr><tr><td><p>euler14</p></td><td><p>(12, 3)</p></td><td><p>1.0\nδ=-59.0\n(1.0, 51.4)</p></td><td><p>(1.0, 51.4)\nwas: (60.0, 83.0)</p></td><td><p>0.000\nδ=-5.537\n(0.000, 5.655)</p></td><td><p>0.11195\nδ=0.02015\n±0.000093</p></td><td><p>0.000093\nwas: 0.000743</p></td></tr><tr><td><p>fannkuch_redux</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12437\nδ=0.00344\n±0.000029</p></td><td><p></p></td></tr><tr><td><p>fasta</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11967\nδ=-0.00132\n±0.000313</p></td><td><p></p></td></tr><tr><td><p>havlak</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.21013\n±0.002442</p></td><td><p></p></td></tr><tr><td><p>heapsort</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>1.39055\nδ=0.37138\n±0.002379</p></td><td><p></p></td></tr><tr><td><p>jsonlua_decode</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.13994\nδ=0.02715\n±0.001207</p></td><td><p></p></td></tr><tr><td><p>jsonlua_encode</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.13581\nδ=0.00783\n±0.001409</p></td><td><p></p></td></tr><tr><td><p>knucleotide</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.13035\nδ=0.01373\n±0.000446</p></td><td><p></p></td></tr><tr><td><p>life</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.28412\n±0.000599</p></td><td><p></p></td></tr><tr><td><p>luacheck</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.99735\n±0.006094</p></td><td><p>0.006094\nwas: 0.089779</p></td></tr><tr><td><p>luacheck_parser</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.07745\nδ=-0.01688\n±0.002281</p></td><td><p></p></td></tr><tr><td><p>luafun</p></td><td><p></p></td><td><p>28.0\n(28.0, 28.0)</p></td><td><p></p></td><td><p>4.879\n(4.861, 4.904)</p></td><td><p>0.17864\nδ=0.01293\n±0.001222</p></td><td><p>0.001222\nwas: 0.004918</p></td></tr><tr><td><p>mandelbrot</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.34166\nδ=-0.00278\n±0.000067</p></td><td><p></p></td></tr><tr><td><p>mandelbrot_bit</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.21577\n±0.000024</p></td><td><p></p></td></tr><tr><td><p>md5</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.09548\nδ=-0.01731\n±0.000037</p></td><td><p></p></td></tr><tr><td><p>meteor</p></td><td><p></p></td><td><p>2.0\n(2.0, 3.0)</p></td><td><p>(2.0, 3.0)\nwas: (2.0, 18.0)</p></td><td><p>0.273\n(0.269, 0.493)</p></td><td><p>0.21464\n±0.002170</p></td><td><p>0.002170\nwas: 0.003935</p></td></tr><tr><td><p>nbody</p></td><td><p>(14, 1)</p></td><td><p>1.0\n(1.0, 1.9)</p></td><td><p></p></td><td><p>0.000\n(0.000, 0.160)</p></td><td><p>0.17695\nδ=0.01671\n±0.002226</p></td><td><p></p></td></tr><tr><td><p>nsieve</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.6)</p></td><td><p>(2.0, 2.6)\nwas: (2.0, 2.0)</p></td><td><p>0.180\n(0.179, 0.282)</p></td><td><p>0.16982\nδ=-0.00922\n±0.000862</p></td><td><p>0.000862\nwas: 0.000640</p></td></tr><tr><td><p>nsieve_bit</p></td><td><p></p></td><td><p>4.0\n(3.7, 5.0)</p></td><td><p>(3.7, 5.0)\nwas: (3.4, 5.3)</p></td><td><p>0.273\n(0.247, 0.361)</p></td><td><p>0.08780\n±0.000233</p></td><td><p>0.000233\nwas: 0.000054</p></td></tr><tr><td><p>partialsums</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.3)</p></td><td><p>(2.0, 2.3)\nwas: (2.0, 2.0)</p></td><td><p>0.161\n(0.160, 0.207)</p></td><td><p>0.14860\n±0.001611</p></td><td><p>0.001611\nwas: 0.002044</p></td></tr><tr><td><p>pidigits</p></td><td><p>(8, 7)</p></td><td><p>5.0\n(1.0, 6.0)</p></td><td><p>(1.0, 6.0)\nwas: (1.0, 2.3)</p></td><td><p>0.516\n(0.000, 0.646)</p></td><td><p>0.12766\n±0.000032</p></td><td><p>0.000032\nwas: 0.002132</p></td></tr><tr><td><p>queens</p></td><td><p>(14, 1)</p></td><td><p>2.0\n(1.7, 2.0)</p></td><td><p>(1.7, 2.0)\nwas: (1.0, 294.4)</p></td><td><p>0.162\n(0.113, 0.162)</p></td><td><p>0.15853\nδ=0.04015\n±0.000231</p></td><td><p>0.000231\nwas: 0.000751</p></td></tr><tr><td><p>quicksort</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.3)</p></td><td><p>(2.0, 2.3)\nwas: (2.0, 4.0)</p></td><td><p>0.278\n(0.278, 0.361)</p></td><td><p>0.27183\n±0.000469</p></td><td><p>0.000469\nwas: 0.067395</p></td></tr><tr><td><p>radixsort</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12621\n±0.000757</p></td><td><p>0.000757\nwas: 0.000403</p></td></tr><tr><td><p>ray</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.35530\nδ=0.04568\n±0.000983</p></td><td><p></p></td></tr><tr><td><p>recursive_ack</p></td><td><p>(14, 1)</p></td><td><p>1.0\n(1.0, 19.0)</p></td><td><p></p></td><td><p>0.000\n(0.000, 2.562)</p></td><td><p>0.14228\nδ=0.02253\n±0.000616</p></td><td><p></p></td></tr><tr><td><p>recursive_fib</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.28989\nδ=0.05925\n±0.000033</p></td><td><p></p></td></tr><tr><td><p>resty_json</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.07534\n±0.000595</p></td><td><p>0.000595\nwas: 0.002629</p></td></tr><tr><td><p>revcomp</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11684\n±0.002139</p></td><td><p>0.002139\nwas: 0.001754</p></td></tr><tr><td><p>richards</p></td><td><p></p></td><td><p>2.0\n(2.0, 3.2)</p></td><td><p>(2.0, 3.2)\nwas: (1.0, 2.0)</p></td><td><p>0.171\n(0.170, 0.369)</p></td><td><p>0.16559\nδ=0.02935\n±0.000342</p></td><td><p>0.000342\nwas: 0.010223</p></td></tr><tr><td><p>scimark_fft</p></td><td><p></p></td><td><p>2.0\n(2.0, 10.3)</p></td><td><p>(2.0, 10.3)\nwas: (2.0, 4.7)</p></td><td><p>0.141\n(0.141, 1.195)</p></td><td><p>0.12709\n±0.000102</p></td><td><p>0.000102\nwas: 0.000823</p></td></tr><tr><td><p>scimark_lu</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12733\nδ=0.01186\n±0.000159</p></td><td><p></p></td></tr><tr><td><p>scimark_sor</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.13297\nδ=0.01189\n±0.000005</p></td><td><p></p></td></tr><tr><td><p>scimark_sparse</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.13082\nδ=0.00740\n±0.000490</p></td><td><p></p></td></tr><tr><td><p>series</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.0)</p></td><td><p></p></td><td><p>0.347\n(0.347, 0.348)</p></td><td><p>0.33390\n±0.000869</p></td><td><p>0.000869\nwas: 0.003217</p></td></tr><tr><td><p>spectralnorm</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.13989\nδ=0.00002\n±0.000003</p></td><td><p></p></td></tr><tr><td><p>table_cmpsort</p></td><td><p></p></td><td><p>10.0\n(10.0, 10.0)</p></td><td><p></p></td><td><p>1.945\n(1.935, 1.967)</p></td><td><p>0.22008\n±0.001852</p></td><td><p>0.001852\nwas: 0.007836</p></td></tr></table><p><sub>Results for Normal vs. RaptorJIT</sub></p><p>In essence, green cells mean that RaptorJIT is better than LuaJIT; red cells mean that LuaJIT is better than RaptorJIT; yellow means they&#39;re different in a way that can&#39;t be compared; and white/grey means they&#39;re statistically equivalent. The additional “Steady performance variation (s)” column shows whether the steady state performance of different process executions is more predictable or not.</p><p>The simple conclusion to draw from this is that there isn&#39;t a simple conclusion to draw from it: the two VMs are sometimes better than each other with no clear pattern. Without having a clear steer either way, we therefore decided to use the original version of LuaJIT as our base.</p><p>One of the things that became very clear from our benchmarking is that LuaJIT is highly non-deterministic – indeed, it&#39;s the most non-deterministic VM I&#39;ve seen. The practical effect of this is that even on one program, LuaJIT is sometimes very fast, and sometimes rather slow. This is, at best, very confusing for users who tend to assume that programs perform more-or-less the same every time they&#39;re run; at worst, it can create significant problems when one is trying to estimate things like server provisioning. We therefore tried various things to make performance more consistent.</p><p>The most promising approach we alighted upon is what we ended up calling “separate counters”. In a tracing JIT compiler such as LuaJIT, one tracks how often a loop (where loops are both “obvious” things like for loops, as well as less obvious things such as functions) has been executed: once it&#39;s hit a certain threshold, the loop is traced, and compiled into machine code. LuaJIT has an unusual approach to counting loops: it has 64 counters to which all loops are mapped (using the memory address of the bytecode in question). In other words, multiple loops share the same counter: the bigger the program, the more loops share the same counter. The advantage of this is that the counters map is memory efficient, and for small programs (e.g. the common LuaJIT benchmarks) it can be highly effective. However, it has very odd effects in real programs, particularly as programs get bigger: loops are compiled non-deterministically based on the particular address in memory they happen to have been loaded at.</p><p>We therefore altered LuaJIT so that each loop and each function has its own counter, stored in the bytecode to make memory reads/writes more cache friendly. The diff from normal LuaJIT to the separate counters version is as follows:</p><h2>Results for Normal vs. Counters</h2><p><b>Symbol key:</b> bad inconsistent, flat, good inconsistent, no steady state, slowdown, warmup.\n<b>Diff against previous results:</b> improved worsened different unchanged.</p><table><tr><th><p><b>Benchmark</b></p></th><th><p><b>Classification</b></p></th><th><p><b>Steady iteration (#)</b></p></th><th><p><b>Steady iteration variation</b></p></th><th><p><b>Steady iteration (s)</b></p></th><th><p><b>Steady performance (s)</b></p></th><th><p><b>Steady performance\nvariation (s)</b></p></th></tr><tr><td><p>array3d</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td></tr><tr><td><p>binarytrees</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12462\n±0.004058</p></td><td><p>0.004058\nwas: 0.000532</p></td></tr><tr><td><p>bounce</p></td><td><p>(14, 1)</p></td><td><p>1.0\n(1.0, 5.8)</p></td><td><p></p></td><td><p>0.000\n(0.000, 0.603)</p></td><td><p>0.12515\nδ=-0.00280\n±0.000278</p></td><td><p></p></td></tr><tr><td><p>capnproto_decode</p></td><td><p>(9, 6)</p></td><td><p>1.0\n(1.0, 24.9)</p></td><td><p>(1.0, 24.9)\nwas: (1.0, 45.3)</p></td><td><p>0.000\n(0.000, 3.692)</p></td><td><p>0.15042\n±0.003797</p></td><td><p>0.003797\nwas: 0.028466</p></td></tr><tr><td><p>capnproto_encode</p></td><td><p></p></td><td><p>230.0\n(56.0, 467.6)</p></td><td><p>(56.0, 467.6)\nwas: (52.8, 280.6)</p></td><td><p>28.411\n(6.667, 55.951)</p></td><td><p>0.11838\nδ=-0.09860\n±0.001960</p></td><td><p>0.001960\nwas: 0.014541</p></td></tr><tr><td><p>collisiondetector</p></td><td><p>(13, 2)</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td></tr><tr><td><p>coroutine_ring</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.10680\n±0.003151</p></td><td><p>0.003151\nwas: 0.001527</p></td></tr><tr><td><p>deltablue</p></td><td><p></p></td><td><p>149.0\n(149.0, 274.5)</p></td><td><p>(149.0, 274.5)\nwas: (1.0, 1022.9)</p></td><td><p>15.561\n(15.430, 28.653)</p></td><td><p>0.10159\n±0.001083</p></td><td><p>0.001083\nwas: 0.003195</p></td></tr><tr><td><p>euler14</p></td><td><p></p></td><td><p>61.0\n(61.0, 68.3)</p></td><td><p>(61.0, 68.3)\nwas: (60.0, 83.0)</p></td><td><p>5.650\n(5.592, 6.356)</p></td><td><p>0.09216\n±0.000159</p></td><td><p>0.000159\nwas: 0.000743</p></td></tr><tr><td><p>fannkuch_redux</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11976\n±0.000012</p></td><td><p>0.000012\nwas: 0.001502</p></td></tr><tr><td><p>fasta</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12200\nδ=0.00100\n±0.000597</p></td><td><p></p></td></tr><tr><td><p>havlak</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td></tr><tr><td><p>heapsort</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>1.04378\nδ=0.02461\n±0.000789</p></td><td><p></p></td></tr><tr><td><p>jsonlua_decode</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12648\nδ=0.01370\n±0.000556</p></td><td><p></p></td></tr><tr><td><p>jsonlua_encode</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12860\n±0.000879</p></td><td><p>0.000879\nwas: 0.001761</p></td></tr><tr><td><p>knucleotide</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11710\n±0.000541</p></td><td><p>0.000541\nwas: 0.000811</p></td></tr><tr><td><p>life</p></td><td><p>(9, 3, 2, 1)</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td></tr><tr><td><p>luacheck</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>1.00299\n±0.004778</p></td><td><p>0.004778\nwas: 0.089781</p></td></tr><tr><td><p>luacheck_parser</p></td><td><p>(12, 2, 1)</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td></tr><tr><td><p>luafun</p></td><td><p></p></td><td><p>69.0\n(69.0, 69.0)</p></td><td><p></p></td><td><p>11.481\n(11.331, 11.522)</p></td><td><p>0.16770\n±0.001564</p></td><td><p>0.001564\nwas: 0.004918</p></td></tr><tr><td><p>mandelbrot</p></td><td><p>(14, 1)</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td></tr><tr><td><p>mandelbrot_bit</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.21695\n±0.000142</p></td><td><p></p></td></tr><tr><td><p>md5</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11155\nδ=-0.00124\n±0.000043</p></td><td><p></p></td></tr><tr><td><p>meteor</p></td><td><p>(13, 2)</p></td><td><p>14.0\n(1.0, 15.0)</p></td><td><p>(1.0, 15.0)\nwas: (2.0, 18.0)</p></td><td><p>2.855\n(0.000, 3.045)</p></td><td><p>0.21606\n±0.004651</p></td><td><p>0.004651\nwas: 0.003935</p></td></tr><tr><td><p>moonscript</p></td><td><p></p></td><td><p>63.0\n(17.7, 184.1)</p></td><td><p>(17.7, 184.1)\nwas: (13.1, 423.3)</p></td><td><p>10.046\n(2.763, 29.739)</p></td><td><p>0.15999\n±0.001405</p></td><td><p>0.001405\nwas: 0.001568</p></td></tr><tr><td><p>nbody</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.15898\n±0.001676</p></td><td><p>0.001676\nwas: 0.002790</p></td></tr><tr><td><p>nsieve</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.6)</p></td><td><p>(2.0, 2.6)\nwas: (2.0, 2.0)</p></td><td><p>0.189\n(0.188, 0.297)</p></td><td><p>0.17875\n±0.001266</p></td><td><p>0.001266\nwas: 0.000641</p></td></tr><tr><td><p>nsieve_bit</p></td><td><p></p></td><td><p>4.0\n(2.0, 6.0)</p></td><td><p>(2.0, 6.0)\nwas: (3.4, 5.3)</p></td><td><p>0.271\n(0.097, 0.446)</p></td><td><p>0.08726\nδ=-0.00032\n±0.000202</p></td><td><p>0.000202\nwas: 0.000054</p></td></tr><tr><td><p>partialsums</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.9)</p></td><td><p>(2.0, 2.9)\nwas: (2.0, 2.0)</p></td><td><p>0.161\n(0.161, 0.295)</p></td><td><p>0.14916\n±0.000081</p></td><td><p>0.000081\nwas: 0.002044</p></td></tr><tr><td><p>pidigits</p></td><td><p></p></td><td><p>2.0\n(2.0, 4.3)</p></td><td><p>(2.0, 4.3)\nwas: (1.0, 2.3)</p></td><td><p>0.130\n(0.130, 0.425)</p></td><td><p>0.12666\n±0.000122</p></td><td><p>0.000122\nwas: 0.002133</p></td></tr><tr><td><p>queens</p></td><td><p>(10, 5)</p></td><td><p>1.0\n(1.0, 2.0)</p></td><td><p>(1.0, 2.0)\nwas: (1.0, 294.4)</p></td><td><p>0.000\n(0.000, 0.127)</p></td><td><p>0.12484\nδ=0.00646\n±0.000317</p></td><td><p>0.000317\nwas: 0.000751</p></td></tr><tr><td><p>quicksort</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.0)</p></td><td><p></p></td><td><p>0.299\n(0.298, 0.304)</p></td><td><p>0.44880\nδ=0.13763\n±0.020477</p></td><td><p>0.020477\nwas: 0.067395</p></td></tr><tr><td><p>radixsort</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12644\n±0.000864</p></td><td><p>0.000864\nwas: 0.000403</p></td></tr><tr><td><p>ray</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.30901\n±0.002140</p></td><td><p>0.002140\nwas: 0.004022</p></td></tr><tr><td><p>recursive_ack</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11958\n±0.000510</p></td><td><p>0.000510\nwas: 0.000653</p></td></tr><tr><td><p>recursive_fib</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.22864\n±0.000266</p></td><td><p>0.000266\nwas: 0.028968</p></td></tr><tr><td><p>resty_json</p></td><td><p>(12, 2, 1)</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td></tr><tr><td><p>revcomp</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.11550\n±0.002553</p></td><td><p>0.002553\nwas: 0.001753</p></td></tr><tr><td><p>richards</p></td><td><p>(14, 1)</p></td><td><p>2.0\n(1.7, 2.0)</p></td><td><p>(1.7, 2.0)\nwas: (1.0, 2.0)</p></td><td><p>0.150\n(0.105, 0.150)</p></td><td><p>0.14572\n±0.000324</p></td><td><p>0.000324\nwas: 0.010223</p></td></tr><tr><td><p>scimark_fft</p></td><td><p></p></td><td><p>2.0\n(2.0, 10.0)</p></td><td><p>(2.0, 10.0)\nwas: (2.0, 4.7)</p></td><td><p>0.140\n(0.140, 1.153)</p></td><td><p>0.12639\n±0.000343</p></td><td><p>0.000343\nwas: 0.000823</p></td></tr><tr><td><p>scimark_lu</p></td><td><p>(11, 4)</p></td><td><p>1.0\n(1.0, 45.3)</p></td><td><p></p></td><td><p>0.000\n(0.000, 5.122)</p></td><td><p>0.11546\n±0.000132</p></td><td><p>0.000132\nwas: 0.000308</p></td></tr><tr><td><p>scimark_sor</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12105\n±0.000148</p></td><td><p></p></td></tr><tr><td><p>scimark_sparse</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.12315\n±0.000728</p></td><td><p>0.000728\nwas: 0.000585</p></td></tr><tr><td><p>series</p></td><td><p></p></td><td><p>2.0\n(2.0, 2.0)</p></td><td><p></p></td><td><p>0.347\n(0.347, 0.348)</p></td><td><p>0.33394\n±0.000645</p></td><td><p>0.000645\nwas: 0.003217</p></td></tr><tr><td><p>spectralnorm</p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p></p></td><td><p>0.13985\nδ=-0.00003\n±0.000007</p></td><td><p></p></td></tr><tr><td><p>table_cmpsort</p></td><td><p>(13, 1, 1)</p></td><td><p>1.0\n(1.0, 10.0)</p></td><td><p></p></td><td><p>0.000\n(0.000, 2.005)</p></td><td><p>0.21828\n±0.003289</p></td><td><p>0.003289\nwas: 0.007836</p></td></tr></table><p><sub>Results for Normal vs. Counters</sub></p><p>In this case we’re particularly interested in the “steady performance variation (s)” column, which shows whether benchmarks have predictable steady state performance. The results are fairly clear: steady counters are, overall, a clear improvement. As you might expect, this is not a pure win, because it changes the order in which traces are made. This has several effects, including delaying some loops to be traced later than was previously the case, because counters do not hit the required threshold as quickly. </p><p>This disadvantages some programs, particularly small deterministic benchmarks where loops are highly stable. In such cases, the earlier you trace the better. However, in my opinion, such programs are given undue weight when performance is considered. It’s no secret that some of the benchmarks regularly used to benchmark LuaJIT are <i>highly</i> optimised for LuaJIT as it stands; any changes to LuaJIT stand a good chance of degrading their performance. However, overall we feel that the overall gain in consistency, particularly for larger programs, is worth it. There&#39;s a <a href=\"https://github.com/lua-users-foundation/LuaJIT/pull/6\">pull request against the Lua Foundation&#39;s fork of LuaJIT</a> which applies this idea to a mainstream fork of LuaJIT.</p><p>We then started looking at various programs that showed odd performance. One problem in particular showed up in more than one benchmark. Here&#39;s a standard example:</p><p>Collisiondetector, Normal, Bencher9, Proc. exec. #12 (no steady state)</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/Q2ZdgNBkfPHYDy88AAjkv/e5fbcc66d2d6dd87002ca573650cd87e/collision1-1.svg\" alt=\"collision1-1\" class=\"kg-image\" width=\"584\" height=\"391\" loading=\"lazy\"/>\n          </figure><p>The problem – and it doesn&#39;t happen on every process execution, just to make it more fun – is that there are points where the benchmark slows down by over 10% for multiple in-process iterations (e.g. in this process execution, at in-process iterations 930-ish and 1050-ish). We tried over 25 separate ways to work out what was causing this — even building an instrumentation system to track what LuaJIT is doing — but in the end it turned out to be related to LuaJIT&#39;s Garbage Collector – sort of. When we moved from the 32-bit to 64-bit GC, the odd performance went away.</p><p>As such, we don’t think that the 64-bit GC “solves” the problem: however, it changes the way that pointers are encoded (doubling in size), which causes the code generator to emit a different style of code, such that the problem seems to go away. Nevertheless, this did make us reevaluate LuaJIT&#39;s GC. Tom then started work on implementing Mike Pall&#39;s <a href=\"http://wiki.luajit.org/New-Garbage-Collector\">suggestion for a new GC for LuaJIT</a> (based partly on Tom&#39;s previous work and also that of Peter Cawley). He has enough implemented to run most small, and some large, programs, but it needs more work to finish it off, at which point evaluating it against the existing Lua GCs will be fascinating!</p><p>So, did we achieve everything we wanted to in 12 months? Inevitably the answer is yes and no. We did a lot more benchmarking than we expected; we&#39;ve been able to make a lot of programs (particularly large programs) have more consistent performance; and we&#39;ve got a fair way down the road of implementing a new GC. To whoever takes on further LuaJIT work – best of luck, and I look forward to seeing your results!</p><p><b>Acknowledgements:</b> Sarah Mount implemented the stats differ; Edd Barrett implemented Krun and answered many questions on it.</p>",
		"id": "UhdX7EC0rWypMpydfLKTz",
		"localeList": {
			"name": "blog-english-only",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"metadata": {
			"imgPreview": ""
		},
		"primary_author": {},
		"published_at": "2018-12-12T06:00-07:00",
		"reading_time": 12,
		"slug": "more-consistent-luajit-performance",
		"tags": [
			{
				"id": "7oLqpn3vNWao1PXv53X42G",
				"name": "LUA",
				"slug": "lua"
			},
			{
				"id": "6lhzEBz2B56RKa4nUEAGYJ",
				"name": "Programming",
				"slug": "programming"
			},
			{
				"id": "48r7QV00gLMWOIcM1CSDRy",
				"name": "Speed & Reliability",
				"slug": "speed-and-reliability"
			}
		],
		"title": "More consistent LuaJIT performance",
		"updated_at": "2024-08-27T02:16:27.257Z",
		"url": "https://blog.cloudflare.com/more-consistent-luajit-performance"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.blurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}