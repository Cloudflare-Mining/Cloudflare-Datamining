<div class="mb2 gray5">16 min read</div><img class="mr2" src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/5EMvAGGgjUtuYprycYpn7Q/4e39e365030cbe3c4aa176a14be80937/speeding-up-linux-disk-encryption.png" alt="">
<div class="post-content lh-copy gray1">
	<p>Data encryption at rest is a must-have for any modern Internet company. Many companies, however, don't encrypt their disks, because they fear the potential performance penalty caused by encryption overhead.</p>
	<p>Encrypting data at rest is vital for Cloudflare with <a href="https://www.cloudflare.com/network">more than 200 data centres across the world</a>. In this post, we will investigate the performance of disk encryption on Linux and explain how we made it at least two times faster for ourselves and our customers!</p>
	<h3>Encrypting data at rest</h3>
	<p>When it comes to encrypting data at rest there are several ways it can be implemented on a modern operating system (OS). Available techniques are tightly coupled with a <a href="https://en.wikibooks.org/wiki/The_Linux_Kernel/Storage">typical OS storage stack</a>. A simplified version of the storage stack and encryption solutions can be found on the diagram below:</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/1IM596LYKyiKGoM8dQv0a2/c2ec72f513ccebca898377be81ef057b/storage-stack.png" alt="storage-stack" class="kg-image" width="1510" height="740" loading="lazy">

	</figure>
	<p>On the top of the stack are applications, which read and write data in files (or streams). The file system in the OS kernel keeps track of which blocks of the underlying block device belong to which files and translates these file reads and writes into block reads and writes, however the hardware specifics of the underlying storage device is abstracted away from the filesystem. Finally, the block subsystem actually passes the block reads and writes to the underlying hardware using appropriate device drivers.</p>
	<p>The concept of the storage stack is actually similar to the <a href="https://www.cloudflare.com/learning/ddos/glossary/open-systems-interconnection-model-osi">well-known network OSI model</a>, where each layer has a more high-level view of the information and the implementation details of the lower layers are abstracted away from the upper layers. And, similar to the OSI model, one can apply encryption at different layers (think about <a href="https://www.cloudflare.com/learning/ssl/transport-layer-security-tls">TLS</a> vs <a href="https://en.wikipedia.org/wiki/IPsec">IPsec</a> or <a href="https://www.cloudflare.com/learning/access-management/what-is-a-vpn">a VPN</a>).</p>
	<p>For data at rest we can apply encryption either at the block layers (either in hardware or in software) or at the file level (either directly in applications or in the filesystem).</p>
	<h4>Block vs file encryption</h4>
	<p>Generally, the higher in the stack we apply encryption, the more flexibility we have. With application level encryption the application maintainers can apply any encryption code they please to any particular data they need. The downside of this approach is they actually have to implement it themselves and encryption in general is not very developer-friendly: one has to know the ins and outs of a specific cryptographic algorithm, properly generate keys, nonces, IVs etc. Additionally, application level encryption does not leverage OS-level caching and <a href="https://en.wikipedia.org/wiki/Page_cache">Linux page cache</a> in particular: each time the application needs to use the data, it has to either decrypt it again, wasting CPU cycles, or implement its own decrypted “cache”, which introduces more complexity to the code.</p>
	<p>File system level encryption makes data encryption transparent to applications, because the file system itself encrypts the data before passing it to the block subsystem, so files are encrypted regardless if the application has crypto support or not. Also, file systems can be configured to encrypt only a particular directory or have different keys for different files. This flexibility, however, comes at a cost of a more complex configuration. File system encryption is also considered less secure than block device encryption as only the contents of the files are encrypted. Files also have associated metadata, like file size, the number of files, the directory tree layout etc., which are still visible to a potential adversary.</p>
	<p>Encryption down at the block layer (often referred to as <a href="https://en.wikipedia.org/wiki/Disk_encryption">disk encryption</a> or full disk encryption) also makes data encryption transparent to applications and even whole file systems. Unlike file system level encryption it encrypts all data on the disk including file metadata and even free space. It is less flexible though - one can only encrypt the whole disk with a single key, so there is no per-directory, per-file or per-user configuration. From the crypto perspective, not all cryptographic algorithms can be used as the block layer doesn't have a high-level overview of the data anymore, so it needs to process each block independently. Most <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Common_modes">common algorithms require some sort of block chaining</a> to be secure, so are not applicable to disk encryption. Instead, <a href="https://en.wikipedia.org/wiki/Disk_encryption_theory#Block_cipher-based_modes">special modes were developed</a> just for this specific use-case.</p>
	<p>So which layer to choose? As always, it depends... Application and file system level encryption are usually the preferred choice for client systems because of the flexibility. For example, each user on a multi-user desktop may want to encrypt their home directory with a key they own and leave some shared directories unencrypted. On the contrary, on server systems, managed by SaaS/PaaS/IaaS companies (including Cloudflare) the preferred choice is configuration simplicity and security - with full disk encryption enabled any data from any application is automatically encrypted with no exceptions or overrides. We believe that all data needs to be protected without sorting it into "important" vs "not important" buckets, so the selective flexibility the upper layers provide is not needed.</p>
	<h4>Hardware vs software disk encryption</h4>
	<p>When encrypting data at the block layer it is possible to do it directly in the storage hardware, if the hardware <a href="https://en.wikipedia.org/wiki/Hardware-based_full_disk_encryption">supports it</a>. Doing so usually gives better read/write performance and consumes less resources from the host. However, since most hardware firmware is proprietary, it does not receive as much attention and review from the security community. In the past this led to <a href="https://www.us-cert.gov/ncas/current-activity/2018/11/06/Self-Encrypting-Solid-State-Drive-Vulnerabilities">flaws in some implementations of hardware disk encryption</a>, which render the whole security model useless. Microsoft, for example, <a href="https://support.microsoft.com/en-us/help/4516071/windows-10-update-kb4516071">started to prefer software-based disk encryption</a> since then.</p>
	<p>We didn't want to put our data and our customers' data to the risk of using potentially insecure solutions and we <a href="https://blog.cloudflare.com/helping-to-build-cloudflare-part-4">strongly believe in open-source</a>. That's why we rely only on software disk encryption in the Linux kernel, which is open and has been audited by many security professionals across the world.</p>
	<h3>Linux disk encryption performance</h3>
	<p>We aim not only to save bandwidth costs for our customers, but to deliver content to Internet users as fast as possible.</p>
	<p>At one point we noticed that our disks were not as fast as we would like them to be. Some profiling as well as a quick A/B test pointed to Linux disk encryption. Because not encrypting the data (even if it is supposed-to-be a public Internet cache) is not a sustainable option, we decided to take a closer look into Linux disk encryption performance.</p>
	<h4>Device mapper and dm-crypt</h4>
	<p>Linux implements transparent disk encryption via a <a href="https://en.wikipedia.org/wiki/Dm-crypt">dm-crypt module</a> and <code>dm-crypt</code> itself is part of <a href="https://en.wikipedia.org/wiki/Device_mapper">device mapper</a> kernel framework. In a nutshell, the device mapper allows pre/post-process IO requests as they travel between the file system and the underlying block device.</p>
	<p><code>dm-crypt</code> in particular encrypts "write" IO requests before sending them further down the stack to the actual block device and decrypts "read" IO requests before sending them up to the file system driver. Simple and easy! Or is it?</p>
	<h4>Benchmarking setup</h4>
	<p>For the record, the numbers in this post were obtained by running specified commands on an idle <a href="https://blog.cloudflare.com/a-tour-inside-cloudflares-g9-servers">Cloudflare G9 server</a> out of production. However, the setup should be easily reproducible on any modern x86 laptop.</p>
	<p>Generally, benchmarking anything around a storage stack is hard because of the noise introduced by the storage hardware itself. Not all disks are created equal, so for the purpose of this post we will use the fastest disks available out there - that is no disks.</p>
	<p>Instead Linux has an option to emulate a disk directly in <a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>. Since RAM is much faster than any persistent storage, it should introduce little bias in our results.</p>
	<p>The following command creates a 4GB ramdisk:</p>
	<pre class="language-bash"><code class="language-bash">$ sudo modprobe brd rd_nr=1 rd_size=4194304
$ ls /dev/ram0</code></pre>
	<p>Now we can set up a <code>dm-crypt</code> instance on top of it thus enabling encryption for the disk. First, we need to generate the disk encryption key, "format" the disk and specify a password to unlock the newly generated key.</p>
	<pre class="language-bash"><code class="language-bash">$ fallocate -l 2M crypthdr.img
$ sudo cryptsetup luksFormat /dev/ram0 --header crypthdr.img

WARNING!
========
This will overwrite data on crypthdr.img irrevocably.

Are you sure? (Type uppercase yes): YES
Enter passphrase:
Verify passphrase:</code></pre>
	<p>Those who are familiar with <code>LUKS/dm-crypt</code> might have noticed we used a <a href="http://man7.org/linux/man-pages/man8/cryptsetup.8.html">LUKS detached header</a> here. Normally, LUKS stores the password-encrypted disk encryption key on the same disk as the data, but since we want to compare read/write performance between encrypted and unencrypted devices, we might accidentally overwrite the encrypted key during our benchmarking later. Keeping the encrypted key in a separate file avoids this problem for the purposes of this post.</p>
	<p>Now, we can actually "unlock" the encrypted device for our testing:</p>
	<pre class="language-bash"><code class="language-bash">$ sudo cryptsetup open --header crypthdr.img /dev/ram0 encrypted-ram0
Enter passphrase for /dev/ram0:
$ ls /dev/mapper/encrypted-ram0
/dev/mapper/encrypted-ram0</code></pre>
	<p>At this point we can now compare the performance of encrypted vs unencrypted ramdisk: if we read/write data to <code>/dev/ram0</code>, it will be stored in <a href="https://en.wikipedia.org/wiki/Plaintext">plaintext</a>. Likewise, if we read/write data to <code>/dev/mapper/encrypted-ram0</code>, it will be decrypted/encrypted on the way by <code>dm-crypt</code> and stored in <a href="https://en.wikipedia.org/wiki/Ciphertext">ciphertext</a>.</p>
	<p>It's worth noting that we're not creating any file system on top of our block devices to avoid biasing results with a file system overhead.</p>
	<h4>Measuring throughput</h4>
	<p>When it comes to storage testing/benchmarking <a href="https://fio.readthedocs.io/en/latest/fio_doc.html">Flexible I/O tester</a> is the usual go-to solution. Let's simulate simple sequential read/write load with 4K block size on the ramdisk without encryption:</p>
	<pre class="language-bash"><code class="language-bash">$ sudo fio --filename=/dev/ram0 --readwrite=readwrite --bs=4k --direct=1 --loops=1000000 --name=plain
plain: (g=0): rw=rw, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1
fio-2.16
Starting 1 process
...
Run status group 0 (all jobs):
   READ: io=21013MB, aggrb=1126.5MB/s, minb=1126.5MB/s, maxb=1126.5MB/s, mint=18655msec, maxt=18655msec
  WRITE: io=21023MB, aggrb=1126.1MB/s, minb=1126.1MB/s, maxb=1126.1MB/s, mint=18655msec, maxt=18655msec

Disk stats (read/write):
  ram0: ios=0/0, merge=0/0, ticks=0/0, in_queue=0, util=0.00%</code></pre>
	<p>The above command will run for a long time, so we just stop it after a while. As we can see from the stats, we're able to read and write roughly with the same throughput around <code>1126 MB/s</code>. Let's repeat the test with the encrypted ramdisk:</p>
	<pre class="language-bash"><code class="language-bash">$ sudo fio --filename=/dev/mapper/encrypted-ram0 --readwrite=readwrite --bs=4k --direct=1 --loops=1000000 --name=crypt
crypt: (g=0): rw=rw, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1
fio-2.16
Starting 1 process
...
Run status group 0 (all jobs):
   READ: io=1693.7MB, aggrb=150874KB/s, minb=150874KB/s, maxb=150874KB/s, mint=11491msec, maxt=11491msec
  WRITE: io=1696.4MB, aggrb=151170KB/s, minb=151170KB/s, maxb=151170KB/s, mint=11491msec, maxt=11491msec</code></pre>
	<p>Whoa, that's a drop! We only get <code>~147 MB/s</code> now, which is more than 7 times slower! And this is on a totally idle machine!</p>
	<h4>Maybe, crypto is just slow</h4>
	<p>The first thing we considered is to ensure we use the fastest crypto. <code>cryptsetup</code> allows us to benchmark all the available crypto implementations on the system to select the best one:</p>
	<pre class="language-bash"><code class="language-bash">$ sudo cryptsetup benchmark
# Tests are approximate using memory only (no storage IO).
PBKDF2-sha1      1340890 iterations per second for 256-bit key
PBKDF2-sha256    1539759 iterations per second for 256-bit key
PBKDF2-sha512    1205259 iterations per second for 256-bit key
PBKDF2-ripemd160  967321 iterations per second for 256-bit key
PBKDF2-whirlpool  720175 iterations per second for 256-bit key
#  Algorithm | Key |  Encryption |  Decryption
     aes-cbc   128b   969.7 MiB/s  3110.0 MiB/s
 serpent-cbc   128b           N/A           N/A
 twofish-cbc   128b           N/A           N/A
     aes-cbc   256b   756.1 MiB/s  2474.7 MiB/s
 serpent-cbc   256b           N/A           N/A
 twofish-cbc   256b           N/A           N/A
     aes-xts   256b  1823.1 MiB/s  1900.3 MiB/s
 serpent-xts   256b           N/A           N/A
 twofish-xts   256b           N/A           N/A
     aes-xts   512b  1724.4 MiB/s  1765.8 MiB/s
 serpent-xts   512b           N/A           N/A
 twofish-xts   512b           N/A           N/A</code></pre>
	<p>It seems <code>aes-xts</code> with a 256-bit data encryption key is the fastest here. But which one are we actually using for our encrypted ramdisk?</p>
	<pre class="language-bash"><code class="language-bash">$ sudo dmsetup table /dev/mapper/encrypted-ram0
0 8388608 crypt aes-xts-plain64 0000000000000000000000000000000000000000000000000000000000000000 0 1:0 0</code></pre>
	<p>We do use <code>aes-xts</code> with a 256-bit data encryption key (count all the zeroes conveniently masked by <code>dmsetup</code> tool - if you want to see the actual bytes, add the <code>--showkeys</code> option to the above command). The numbers do not add up however: <code>cryptsetup benchmark</code> tells us above not to rely on the results, as "Tests are approximate using memory only (no storage IO)", but that is exactly how we've set up our experiment using the ramdisk. In a somewhat worse case (assuming we're reading all the data and then encrypting/decrypting it sequentially with no parallelism) doing <a href="https://en.wikipedia.org/wiki/Back-of-the-envelope_calculation">back-of-the-envelope calculation</a> we should be getting around <code>(1126 * 1823) / (1126 + 1823) =~696 MB/s</code>, which is still quite far from the actual <code>147 * 2 = 294 MB/s</code> (total for reads and writes).</p>
	<h4>dm-crypt performance flags</h4>
	<p>While reading the <a href="http://man7.org/linux/man-pages/man8/cryptsetup.8.html">cryptsetup man page</a> we noticed that it has two options prefixed with <code>--perf-</code>, which are probably related to performance tuning. The first one is <code>--perf-same_cpu_crypt</code> with a rather cryptic description:</p>
	<pre class="language-bash"><code class="language-bash">Perform encryption using the same cpu that IO was submitted on.  The default is to use an unbound workqueue so that encryption work is automatically balanced between available CPUs.  This option is only relevant for open action.</code></pre>
	<p>So we enable the option</p>
	<pre class="language-bash"><code class="language-bash">$ sudo cryptsetup close encrypted-ram0
$ sudo cryptsetup open --header crypthdr.img --perf-same_cpu_crypt /dev/ram0 encrypted-ram0</code></pre>
	<p>Note: according to the <a href="http://man7.org/linux/man-pages/man8/cryptsetup.8.html">latest man page</a> there is also a <code>cryptsetup refresh</code> command, which can be used to enable these options live without having to "close" and "re-open" the encrypted device. Our <code>cryptsetup</code> however didn't support it yet.</p>
	<p>Verifying if the option has been really enabled:</p>
	<pre class="language-bash"><code class="language-bash">$ sudo dmsetup table encrypted-ram0
0 8388608 crypt aes-xts-plain64 0000000000000000000000000000000000000000000000000000000000000000 0 1:0 0 1 same_cpu_crypt</code></pre>
	<p>Yes, we can now see <code>same_cpu_crypt</code> in the output, which is what we wanted. Let's rerun the benchmark:</p>
	<pre class="language-bash"><code class="language-bash">$ sudo fio --filename=/dev/mapper/encrypted-ram0 --readwrite=readwrite --bs=4k --direct=1 --loops=1000000 --name=crypt
crypt: (g=0): rw=rw, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1
fio-2.16
Starting 1 process
...
Run status group 0 (all jobs):
   READ: io=1596.6MB, aggrb=139811KB/s, minb=139811KB/s, maxb=139811KB/s, mint=11693msec, maxt=11693msec
  WRITE: io=1600.9MB, aggrb=140192KB/s, minb=140192KB/s, maxb=140192KB/s, mint=11693msec, maxt=11693msec</code></pre>
	<p>Hmm, now it is <code>~136 MB/s</code> which is slightly worse than before, so no good. What about the second option <code>--perf-submit_from_crypt_cpus</code>:</p>
	<pre class="language-bash"><code class="language-bash">Disable offloading writes to a separate thread after encryption.  There are some situations where offloading write bios from the encryption threads to a single thread degrades performance significantly.  The default is to offload write bios to the same thread.  This option is only relevant for open action.</code></pre>
	<p>Maybe, we are in the "some situation" here, so let's try it out:</p>
	<pre class="language-bash"><code class="language-bash">$ sudo cryptsetup close encrypted-ram0
$ sudo cryptsetup open --header crypthdr.img --perf-submit_from_crypt_cpus /dev/ram0 encrypted-ram0
Enter passphrase for /dev/ram0:
$ sudo dmsetup table encrypted-ram0
0 8388608 crypt aes-xts-plain64 0000000000000000000000000000000000000000000000000000000000000000 0 1:0 0 1 submit_from_crypt_cpus</code></pre>
	<p>And now the benchmark:</p>
	<pre class="language-bash"><code class="language-bash">$ sudo fio --filename=/dev/mapper/encrypted-ram0 --readwrite=readwrite --bs=4k --direct=1 --loops=1000000 --name=crypt
crypt: (g=0): rw=rw, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1
fio-2.16
Starting 1 process
...
Run status group 0 (all jobs):
   READ: io=2066.6MB, aggrb=169835KB/s, minb=169835KB/s, maxb=169835KB/s, mint=12457msec, maxt=12457msec
  WRITE: io=2067.7MB, aggrb=169965KB/s, minb=169965KB/s, maxb=169965KB/s, mint=12457msec, maxt=12457msec</code></pre>
	<p><code>~166 MB/s</code>, which is a bit better, but still not good...</p>
	<h4>Asking the community</h4>
	<p>Being desperate we decided to seek support from the Internet and <a href="https://www.spinics.net/lists/dm-crypt/msg07516.html">posted our findings to the <code>dm-crypt</code> mailing list</a>, but the response we got was not very encouraging:</p>
	<blockquote>
		<p>If the numbers disturb you, then this is from lack of understanding on your side. You are probably unaware that encryption is a heavy-weight operation...</p>
	</blockquote>
	<p>We decided to make a scientific research on this topic by typing "is encryption expensive" into Google Search and one of the top results, which actually contains meaningful measurements, is... <a href="https://blog.cloudflare.com/how-expensive-is-crypto-anyway">our own post about cost of encryption</a>, but in the context of <a href="https://www.cloudflare.com/learning/ssl/transport-layer-security-tls">TLS</a>! This is a fascinating read on its own, but the gist is: modern crypto on modern hardware is very cheap even at Cloudflare scale (doing millions of encrypted HTTP requests per second). In fact, it is so cheap that Cloudflare was the first provider to offer <a href="https://www.cloudflare.com/application-services/products/ssl">free SSL/TLS for everyone</a>.</p>
	<h4>Digging into the source code</h4>
	<p>When trying to use the custom <code>dm-crypt</code> options described above we were curious why they exist in the first place and what is that "offloading" all about. Originally we expected <code>dm-crypt</code> to be a simple "proxy", which just encrypts/decrypts data as it flows through the stack. Turns out <code>dm-crypt</code> does more than just encrypting memory buffers and a (simplified) IO traverse path diagram is presented below:</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/4UenGQJyEiOzxwISPhhGR1/87ade22c1dfbe6aeda5c77af9d29a0e5/dm-crypt.png" alt="dm-crypt" class="kg-image" width="1610" height="792" loading="lazy">

	</figure>
	<p>When the file system issues a write request, <code>dm-crypt</code> does not process it immediately - instead it puts it into a <a href="https://www.kernel.org/doc/html/v4.19/core-api/workqueue.html">workqueue</a> <a href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L3124">named "kcryptd"</a>. In a nutshell, a kernel workqueue just schedules some work (encryption in this case) to be performed at some later time, when it is more convenient. When "the time" comes, <code>dm-crypt</code> <a href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L1940">sends the request</a> to <a href="https://www.kernel.org/doc/html/v4.19/crypto/index.html">Linux Crypto API</a> for actual encryption. However, modern Linux Crypto API <a href="https://www.kernel.org/doc/html/v4.19/crypto/api-skcipher.html#symmetric-key-cipher-api">is asynchronous</a> as well, so depending on which particular implementation your system will use, most likely it will not be processed immediately, but queued again for "later time". When Linux Crypto API will finally <a href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L1980">do the encryption</a>, <code>dm-crypt</code> may try to <a href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L1909-L1910">sort pending write requests by putting each request</a> into a <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red-black tree</a>. Then a <a href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L1819">separate kernel thread</a> again at "some time later" actually takes all IO requests in the tree and <a href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L1864">sends them down the stack</a>.</p>
	<p>Now for read requests: this time we need to get the encrypted data first from the hardware, but <code>dm-crypt</code> does not just ask for the driver for the data, but queues the request into a different <a href="https://www.kernel.org/doc/html/v4.19/core-api/workqueue.html">workqueue</a> <a href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L3122">named "kcryptd_io"</a>. At some point later, when we actually have the encrypted data, we <a href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L1742">schedule it for decryption</a> using the now familiar "kcryptd" workqueue. "kcryptd" <a href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L1970">will send the request</a> to Linux Crypto API, which may decrypt the data asynchronously as well.</p>
	<p>To be fair the request does not always traverse all these queues, but the important part here is that write requests may be queued up to 4 times in <code>dm-crypt</code> and read requests up to 3 times. At this point we were wondering if all this extra queueing can cause any performance issues. For example, there is a <a href="https://www.usenix.org/conference/srecon19asia/presentation/plenz">nice presentation from Google</a> about the relationship between queueing and tail latency. One key takeaway from the presentation is:</p>
	<blockquote>
		<p>A significant amount of tail latency is due to queueing effects</p>
	</blockquote>
	<p>So, why are all these queues there and can we remove them?</p>
	<h4>Git archeology</h4>
	<p>No-one writes more complex code just for fun, especially for the OS kernel. So all these queues must have been put there for a reason. Luckily, the Linux kernel source is managed by <a href="https://en.wikipedia.org/wiki/Git">git</a>, so we can try to retrace the changes and the decisions around them.</p>
	<p>The "kcryptd" workqueue was in the source <a href="https://github.com/torvalds/linux/blob/1da177e4c3f41524e886b7f1b8a0c1fc7321cac2/drivers/md/dm-crypt.c">since the beginning of the available history</a> with the following comment:</p>
	<blockquote>
		<p>Needed because it would be very unwise to do decryption in an interrupt context, so bios returning from read requests get queued here.</p>
	</blockquote>
	<p>So it was for reads only, but even then - why do we care if it is interrupt context or not, if Linux Crypto API will likely use a dedicated thread/queue for encryption anyway? Well, back in 2005 Crypto API <a href="https://github.com/torvalds/linux/blob/1da177e4c3f41524e886b7f1b8a0c1fc7321cac2/Documentation/crypto/api-intro.txt">was not asynchronous</a>, so this made perfect sense.</p>
	<p>In 2006 <code>dm-crypt</code> <a href="https://github.com/torvalds/linux/commit/23541d2d288cdb54f417ba1001dacc7f3ea10a97">started to use</a> the "kcryptd" workqueue not only for encryption, but for submitting IO requests:</p>
	<blockquote>
		<p>This patch is designed to help dm-crypt comply with the new constraints imposed by the following patch in -mm: md-dm-reduce-stack-usage-with-stacked-block-devices.patch</p>
	</blockquote>
	<p>It seems the goal here was not to add more concurrency, but rather reduce kernel stack usage, which makes sense again as the kernel has a common stack across all the code, so it is a quite limited resource. It is worth noting, however, that the <a href="https://github.com/torvalds/linux/commit/6538b8ea886e472f4431db8ca1d60478f838d14b">Linux kernel stack has been expanded</a> in 2014 for x86 platforms, so this might not be a problem anymore.</p>
	<p>A <a href="https://github.com/torvalds/linux/commit/cabf08e4d3d1181d7c408edae97fb4d1c31518af">first version of "kcryptd_io" workqueue was added</a> in 2007 with the intent to avoid:</p>
	<blockquote>
		<p>starvation caused by many requests waiting for memory allocation...</p>
	</blockquote>
	<p>The request processing was bottlenecking on a single workqueue here, so the solution was to add another one. Makes sense.</p>
	<p>We are definitely not the first ones experiencing performance degradation because of extensive queueing: in 2011 a change was introduced to <a href="https://github.com/torvalds/linux/commit/20c82538e4f5ede51bc2b4795bc6e5cae772796d">conditionally revert some of the queueing for read requests</a>:</p>
	<blockquote>
		<p>If there is enough memory, code can directly submit bio instead queuing this operation in a separate thread.</p>
	</blockquote>
	<p>Unfortunately, at that time Linux kernel commit messages were not as verbose as today, so there is no performance data available.</p>
	<p>In 2015 <a href="https://github.com/torvalds/linux/commit/dc2676210c425ee8e5cb1bec5bc84d004ddf4179">dm-crypt started to sort writes</a> in a separate "dmcrypt_write" thread before sending them down the stack:</p>
	<blockquote>
		<p>On a multiprocessor machine, encryption requests finish in a different order than they were submitted. Consequently, write requests would be submitted in a different order and it could cause severe performance degradation.</p>
	</blockquote>
	<p>It does make sense as sequential disk access used to be much faster than the random one and <code>dm-crypt</code> was breaking the pattern. But this mostly applies to <a href="https://en.wikipedia.org/wiki/Hard_disk_drive">spinning disks</a>, which were still dominant in 2015. It may not be as important with modern fast <a href="https://en.wikipedia.org/wiki/Solid-state_drive">SSDs (including NVME SSDs)</a>.</p>
	<p>Another part of the commit message is worth mentioning:</p>
	<blockquote>
		<p>...in particular it enables IO schedulers like CFQ to sort more effectively...</p>
	</blockquote>
	<p>It mentions the performance benefits for the <a href="https://www.kernel.org/doc/Documentation/block/cfq-iosched.txt">CFQ IO scheduler</a>, but Linux schedulers have improved since then to the point that <a href="https://github.com/torvalds/linux/commit/f382fb0bcef4c37dc049e9f6963e3baf204d815c">CFQ scheduler has been removed</a> from the kernel in 2018.</p>
	<p>The same patchset <a href="https://github.com/torvalds/linux/commit/b3c5fd3052492f1b8d060799d4f18be5a5438">replaces the sorting list with a red-black tree</a>:</p>
	<blockquote>
		<p>In theory the sorting should be performed by the underlying disk scheduler, however, in practice the disk scheduler only accepts and sorts a finite number of requests. To allow the sorting of all requests, dm-crypt needs to implement its own sorting.</p>
		<p>The overhead associated with rbtree-based sorting is considered negligible so it is not used conditionally.</p>
	</blockquote>
	<p>All that make sense, but it would be nice to have some backing data.</p>
	<p>Interestingly, in the same patchset we see <a href="https://github.com/torvalds/linux/commit/0f5d8e6ee758f7023e4353cca75d785b2d4f6abe">the introduction of our familiar "submit_from_crypt_cpus" option</a>:</p>
	<blockquote>
		<p>There are some situations where offloading write bios from the encryption threads to a single thread degrades performance significantly</p>
	</blockquote>
	<p>Overall, we can see that every change was reasonable and needed, however things have changed since then:</p>
	<ul>
		<li>
			<p>hardware became faster and smarter</p>
		</li>
		<li>
			<p>Linux resource allocation was revisited</p>
		</li>
		<li>
			<p>coupled Linux subsystems were rearchitected</p>
		</li>
	</ul>
	<p>And many of the design choices above may not be applicable to modern Linux.</p>
	<h3>The "clean-up"</h3>
	<p>Based on the research above we decided to try to remove all the extra queueing and asynchronous behaviour and revert <code>dm-crypt</code> to its original purpose: simply encrypt/decrypt IO requests as they pass through. But for the sake of stability and further benchmarking we ended up not removing the actual code, but rather adding yet another <code>dm-crypt</code> option, which bypasses all the queues/threads, if enabled. The flag allows us to switch between the current and new behaviour at runtime under full production load, so we can easily revert our changes should we see any side-effects. The resulting patch can be found on the <a href="https://github.com/cloudflare/linux/blob/12a61de6dd06408f4f3c27f8019beb66366e98e3/patches/0023-Add-DM_CRYPT_FORCE_INLINE-flag-to-dm-crypt-target.patch">Cloudflare GitHub Linux repository</a>.</p>
	<h4>Synchronous Linux Crypto API</h4>
	<p>From the diagram above we remember that not all queueing is implemented in <code>dm-crypt</code>. Modern Linux Crypto API may also be asynchronous and for the sake of this experiment we want to eliminate queues there as well. What does "may be" mean, though? The OS may contain different implementations of the same algorithm (for example, <a href="https://en.wikipedia.org/wiki/AES_instruction_set">hardware-accelerated AES-NI on x86 platforms</a> and generic C-code AES implementations). By default the system chooses the "best" one based on <a href="https://www.kernel.org/doc/html/v4.19/crypto/architecture.html#crypto-api-cipher-references-and-priority">the configured algorithm priority</a>. <code>dm-crypt</code> allows overriding this behaviour and <a href="https://gitlab.com/cryptsetup/cryptsetup/-/wikis/DMCrypt#mapping-table-for-crypt-target">request a particular cipher implementation</a> using the <code>capi:</code> prefix. However, there is one problem. Let us actually check the available AES-XTS (this is our disk encryption cipher, remember?) implementations on our system:</p>
	<pre class="language-bash"><code class="language-bash">$ grep -A 11 'xts(aes)' /proc/crypto
name         : xts(aes)
driver       : xts(ecb(aes-generic))
module       : kernel
priority     : 100
refcnt       : 7
selftest     : passed
internal     : no
type         : skcipher
async        : no
blocksize    : 16
min keysize  : 32
max keysize  : 64
--
name         : __xts(aes)
driver       : cryptd(__xts-aes-aesni)
module       : cryptd
priority     : 451
refcnt       : 1
selftest     : passed
internal     : yes
type         : skcipher
async        : yes
blocksize    : 16
min keysize  : 32
max keysize  : 64
--
name         : xts(aes)
driver       : xts-aes-aesni
module       : aesni_intel
priority     : 401
refcnt       : 1
selftest     : passed
internal     : no
type         : skcipher
async        : yes
blocksize    : 16
min keysize  : 32
max keysize  : 64
--
name         : __xts(aes)
driver       : __xts-aes-aesni
module       : aesni_intel
priority     : 401
refcnt       : 7
selftest     : passed
internal     : yes
type         : skcipher
async        : no
blocksize    : 16
min keysize  : 32
max keysize  : 64</code></pre>
	<p>We want to explicitly select a synchronous cipher from the above list to avoid queueing effects in threads, but the only two supported are <code>xts(ecb(aes-generic))</code> (the generic C implementation) and <code>__xts-aes-aesni</code> (the <a href="https://en.wikipedia.org/wiki/AES_instruction_set">x86 hardware-accelerated implementation</a>). We definitely want the latter as it is much faster (we're aiming for performance here), but it is suspiciously marked as internal (see <code>internal: yes</code>). If we <a href="https://github.com/torvalds/linux/blob/fb33c6510d5595144d585aa194d377cf74d31911/include/linux/crypto.h#L91">check the source code</a>:</p>
	<blockquote>
		<p>Mark a cipher as a service implementation only usable by another cipher and never by a normal user of the kernel crypto API</p>
	</blockquote>
	<p>So this cipher is meant to be used only by other wrapper code in the Crypto API and not outside it. In practice this means, that the caller of the Crypto API needs to explicitly specify this flag, when requesting a particular cipher implementation, but <code>dm-crypt</code> does not do it, because by design it is not part of the Linux Crypto API, rather an "external" user. We already patch the <code>dm-crypt</code> module, so we could as well just add the relevant flag. However, there is another problem with <a href="https://en.wikipedia.org/wiki/AES_instruction_set">AES-NI</a> in particular: <a href="https://en.wikipedia.org/wiki/X87">x86 FPU</a>. "Floating point" you say? Why do we need floating point math to do symmetric encryption which should only be about bit shifts and XOR operations? We don't need the math, but AES-NI instructions use some of the CPU registers, which are dedicated to the FPU. Unfortunately the Linux kernel <a href="https://github.com/torvalds/linux/blob/fb33c6510d5595144d585aa194d377cf74d31911/arch/x86/kernel/fpu/core.c#L77">does not always preserve these registers in interrupt context</a> for performance reasons (saving/restoring FPU is expensive). But <code>dm-crypt</code> may execute code in interrupt context, so we risk corrupting some other process data and we go back to "it would be very unwise to do decryption in an interrupt context" statement in the original code.</p>
	<p>Our solution to address the above was to create another somewhat <a href="https://github.com/cloudflare/linux/blob/master/patches/0024-Add-xtsproxy-Crypto-API-module.patch">"smart" Crypto API module</a>. This module is synchronous and does not roll its own crypto, but is just a "router" of encryption requests:</p>
	<ul>
		<li>
			<p>if we can use the FPU (and thus AES-NI) in the current execution context, we just forward the encryption request to the faster, "internal" <code>__xts-aes-aesni</code> implementation (and we can use it here, because now we are part of the Crypto API)</p>
		</li>
		<li>
			<p>otherwise, we just forward the encryption request to the slower, generic C-based <code>xts(ecb(aes-generic))</code> implementation</p>
		</li>
	</ul>
	<h4>Using the whole lot</h4>
	<p>Let's walk through the process of using it all together. The first step is to <a href="https://github.com/cloudflare/linux/blob/master/patches">grab the patches</a> and recompile the kernel (or just compile <code>dm-crypt</code> and our <code>xtsproxy</code> modules).</p>
	<p>Next, let's restart our IO workload in a separate terminal, so we can make sure we can reconfigure the kernel at runtime under load:</p>
	<pre class="language-bash"><code class="language-bash">$ sudo fio --filename=/dev/mapper/encrypted-ram0 --readwrite=readwrite --bs=4k --direct=1 --loops=1000000 --name=crypt
crypt: (g=0): rw=rw, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1
fio-2.16
Starting 1 process
...</code></pre>
	<p>In the main terminal make sure our new Crypto API module is loaded and available:</p>
	<pre class="language-bash"><code class="language-bash">$ sudo modprobe xtsproxy
$ grep -A 11 'xtsproxy' /proc/crypto
driver       : xts-aes-xtsproxy
module       : xtsproxy
priority     : 0
refcnt       : 0
selftest     : passed
internal     : no
type         : skcipher
async        : no
blocksize    : 16
min keysize  : 32
max keysize  : 64
ivsize       : 16
chunksize    : 16</code></pre>
	<p>Reconfigure the encrypted disk to use our newly loaded module and enable our patched <code>dm-crypt</code> flag (we have to use low-level <code>dmsetup</code> tool as <code>cryptsetup</code> obviously is not aware of our modifications):</p>
	<pre class="language-bash"><code class="language-bash">$ sudo dmsetup table encrypted-ram0 --showkeys | sed 's/aes-xts-plain64/capi:xts-aes-xtsproxy-plain64/' | sed 's/$/ 1 force_inline/' | sudo dmsetup reload encrypted-ram0</code></pre>
	<p>We just "loaded" the new configuration, but for it to take effect, we need to suspend/resume the encrypted device:</p>
	<pre class="language-bash"><code class="language-bash">$ sudo dmsetup suspend encrypted-ram0 &amp;&amp; sudo dmsetup resume encrypted-ram0</code></pre>
	<p>And now observe the result. We may go back to the other terminal running the <code>fio</code> job and look at the output, but to make things nicer, here's a snapshot of the observed read/write throughput in <a href="https://grafana.com">Grafana</a>:</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/gU4JU2MqSRwllckZS17O0/57f0119b2961c63b67d39d6b4bb96c9b/read-throughput-annotated.png" alt="read-throughput-annotated" class="kg-image" width="2032" height="972" loading="lazy">

	</figure>
	<p></p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/6jxXWkIyojMU4AfFA3BVGm/f825e7309689bb314ca12a95b47b80bc/write-throughput-annotated.png" alt="write-throughput-annotated" class="kg-image" width="2056" height="944" loading="lazy">

	</figure>
	<p>Wow, we have more than doubled the throughput! With the total throughput of <code>~640 MB/s</code> we're now much closer to the expected <code>~696 MB/s</code> from above. What about the IO latency? (The <code>await</code> statistic from the <a href="http://man7.org/linux/man-pages/man1/iostat.1.html">iostat reporting tool</a>):</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/3gewP8Uml8nprMoLHFTeCR/473f839d51abfa2d7da9bfc1e8d3ffac/await-annotated.png" alt="await-annotated" class="kg-image" width="2024" height="688" loading="lazy">

	</figure>
	<p>The latency has been cut in half as well!</p>
	<h4>To production</h4>
	<p>So far we have been using a synthetic setup with some parts of the full production stack missing, like file systems, real hardware and most importantly, production workload. To ensure we’re not optimising imaginary things, here is a snapshot of the production impact these changes bring to the caching part of our stack:</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/6efmOs555BLNsL8xsxw7YP/9171510ee73c424b323f3cfd5e51bf05/prod.png" alt="prod" class="kg-image" width="2000" height="329" loading="lazy">

	</figure>
	<p>This graph represents a three-way comparison of the worst-case response times (99th percentile) for a <a href="https://blog.cloudflare.com/how-we-scaled-nginx-and-saved-the-world-54-years-every-day">cache hit in one of our servers</a>. The green line is from a server with unencrypted disks, which we will use as baseline. The red line is from a server with encrypted disks with the default Linux disk encryption implementation and the blue line is from a server with encrypted disks and our optimisations enabled. As we can see the default Linux disk encryption implementation has a significant impact on our cache latency in worst case scenarios, whereas the patched implementation is indistinguishable from not using encryption at all. In other words the improved encryption implementation does not have any impact at all on our cache response speed, so we basically get it for free! That’s a win!</p>
	<h3>We're just getting started</h3>
	<p>This post shows how an architecture review can double the performance of a system. Also we <a href="https://blog.cloudflare.com/how-expensive-is-crypto-anyway">reconfirmed that modern cryptography is not expensive</a> and there is usually no excuse not to protect your data.</p>
	<p>We are going to submit this work for inclusion in the main kernel source tree, but most likely not in its current form. Although the results look encouraging we have to remember that Linux is a highly portable operating system: it runs on powerful servers as well as small resource constrained IoT devices and on <a href="https://blog.cloudflare.com/arm-takes-wing">many other CPU architectures</a> as well. The current version of the patches just optimises disk encryption for a particular workload on a particular architecture, but Linux needs a solution which runs smoothly everywhere.</p>
	<p>That said, if you think your case is similar and you want to take advantage of the performance improvements now, you may <a href="https://github.com/cloudflare/linux/blob/master/patches">grab the patches</a> and hopefully provide feedback. The runtime flag makes it easy to toggle the functionality on the fly and a simple A/B test may be performed to see if it benefits any particular case or setup. These patches have been running across our <a href="https://www.cloudflare.com/network">wide network of more than 200 data centres</a> on five generations of hardware, so can be reasonably considered stable. Enjoy both performance and security from Cloudflare for all!</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/2QGDkwHsSsWOJBpiZYunWH/b5deb0fd8b2ebfb1cb240f56051ff88e/perf-sec.png" alt="perf-sec" class="kg-image" width="1024" height="512" loading="lazy">

	</figure>
	<h3>Update (October 11, 2020)</h3>
	<p>The main patch from this blog (in a slightly updated form) has been <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/md/dm-crypt.c?id=39d42fa96ba1b7d2544db3f8ed5da8fb0d5cb877">merged</a> into mainline Linux kernel and is available since version 5.9 and onwards. The main difference is the mainline version exposes two flags instead of one, which provide the ability to bypass dm-crypt workqueues for reads and writes independently. For details, see <a href="https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/dm-crypt.html">the official dm-crypt documentation</a>.</p>
</div>