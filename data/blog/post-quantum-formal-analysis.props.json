{
	"initialReadingTime": "21",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Thom Wiggers",
				"slug": "thom",
				"bio": "Thom was an intern at Cloudflare Research from October 2021 to the end of February 2022. His main research interest can be described as \"making the internet post-quantum\".",
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/4naBwZJ46pUs4Xf0Th7czz/dc234e011e53d3076b067657e0ada9f2/thom.jpeg",
				"location": "The Netherlands",
				"website": "https://thomwiggers.nl",
				"twitter": "@thomwiggers",
				"facebook": null
			},
			{
				"name": "Jonathan Hoyland",
				"slug": "jonathan-hoyland",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/3Fpo0FxrhZOsxWGkLkWqlj/72b8e8c99b1d2a95d852b1bc57d6bec4/jonathan-hoyland.jpg",
				"location": null,
				"website": null,
				"twitter": null,
				"facebook": null
			}
		],
		"excerpt": "This blogpost refers to the efforts to use formal/verification/implementation for post-quantum algorithms to achieve better assurance for them. It also touches on our Cloudflare efforts on this",
		"feature_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/6glweGeeBcTLf1YPoaTsNW/4d2294ab963ef7168ed290e8d7d49c4d/post-quantum-formal-analysis.png",
		"featured": false,
		"html": "<p><b>An introduction to formal analysis and our proof of the security of KEMTLS</b></p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/393auOPCMHtWuvmZxJZ44s/3dfd6f5623d9e91b27c0b9c6440df049/Blog-827---KEMs-and-KEMTLS.png\" alt=\"Blogpost around building confidence through cryptographic protocols using formal analysis.\" class=\"kg-image\" width=\"1600\" height=\"900\" loading=\"lazy\"/>\n            \n            </figure><p>Good morning everyone, and welcome to another Post-Quantum–themed blog post! Today we’re going to look at something a little different. Rather than look into the past or future quantum we’re going to look as far back as the ‘80s and ‘90s, to try and get some perspective on how we can determine whether a protocol is or is not secure. Unsurprisingly, this question comes up all the time. Cryptographers like to build fancy new cryptosystems, but just because we, the authors, can’t break our own designs, it doesn’t mean they are secure: it just means we are not smart enough to break them.</p><p>One might at this point wonder why in a post-quantum themed blog post we are talking about security proofs. The reason is simple: the new algorithms that claim to be safe against quantum threats need proofs showing that they actually are safe. In this blog post, not only are we going to introduce how we go about proving a protocol is secure, we’re going to introduce the security proofs of KEMTLS, a version of TLS designed to be more secure against quantum computers, and give you a whistle-stop tour of the formal analysis we did of it.</p><p>Let’s go back for the moment to not being smart enough to break a cryptosystem. Saying “I tried very hard to break this, and couldn’t” isn’t a very satisfying answer, and so for many years cryptographers (and others) have been trying to find a better one. There are some obvious approaches to building confidence in your cryptosystem, for example you could <a href=\"https://github.com/google/wycheproof\">try all previously known attacks</a>, and see if the system breaks. This approach will probably weed out any simple flaws, but it doesn’t mean that some new <a href=\"https://en.wikipedia.org/wiki/Cryptanalysis_of_the_Enigma\">attack won’t be found</a> or even that some new twist on an old one <a href=\"https://ieeexplore.ieee.org/document/8835216\">won’t be discovered</a>.</p><p>Another approach you can take is to offer a large prize to anyone who can break your new system; but to do that not only do you need a <a href=\"https://en.wikipedia.org/wiki/RSA_Factoring_Challenge\">big</a> <a href=\"https://www.microsoft.com/en-us/msrc/sike-cryptographic-challenge\">prize</a> that you can afford to give away if you’re wrong, you can’t be sure that everyone would prefer your prize to, for example, selling an attack to cybercriminals, or even to a government.</p><p>Simply trying hard, and inducing other people to do so too still felt unsatisfactory, so in the late ‘80s researchers started trying to use mathematical techniques to prove that their protocol <a href=\"https://en.wikipedia.org/wiki/Burrows%E2%80%93Abadi%E2%80%93Needham_logic\">was secure</a>. Now, if you aren’t versed in theoretical computer science you might not even have a clear idea of what it even means to “prove” a protocol is secure, let alone how you might go about it, so let’s start at the very beginning.</p><h3>A proof</h3><p>First things first: let’s nail down what we mean by a <i>proof</i>. At its most general level, a mathematical proof starts with some assumptions, and by making logical inferences it builds towards a statement. If you can derive your target statement from your initial assumptions then you can be sure that, if your assumptions are right, then your final statement is true.</p><p>Euclid’s famous work, <i>The Elements</i>, a standard math textbook for over 2,000 years, is written in this style. Euclid gives five “postulates”, or assumptions, from which he can derive a huge portion of the geometry known in his day. Euclid’s first postulate, that you can draw a straight line between any two points, is never proven, but taken as read. You can take his first postulate, and his third, that you can draw a circle with any center and radius, and use it to prove his first proposition, that you can draw an equilateral triangle given any finite line. For the curious, you can find <a href=\"https://gutenberg.org/ebooks/21076\">public-domain translations of Euclid’s work</a>.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/2qV3nhDT4bKQvndrAnbw9N/4cb92b559042aeb9484a9d7707ac54da/Screenshot-2022-02-15-at-22.27.54.png\" alt=\"image showing Euclid’s method of drawing an equilateral triangle.\" class=\"kg-image\" width=\"454\" height=\"340\" loading=\"lazy\"/>\n            \n            </figure><p>Euclid’s method of drawing an equilateral triangle based on the finite line AB, by drawing two circles around points A and B, with the radius AB. The intersection finds point C of the triangle. Original raster file uploader was Mcgill at en.wikibooks SVG: Beao, Public domain, via Wikimedia Commons.</p><p>Whilst it’s fairly easy to intuit how such geometry proofs work, it’s not immediately clear how one could prove something as abstract as the security of a cryptographic protocol. Proofs of protocols operate in a similar way. We build a logical argument starting from a set of assumptions. Security proofs, however, can be much, much bigger than anything in <i>The Elements</i> (for example, our proof of the security properties of <a href=\"https://thomwiggers.nl/publication/kemtls/kemtls.pdf\">KEMTLS</a>, which we will talk about later, is nearly 500,000 lines long) and the only reason we are able to do such complex proofs is that we have something of an advantage over Euclid. We have computers. Using a mix of human-guided theorem proving and automated algorithms we can prove incredibly complex things, such as the security of protocols as the one we will discuss.</p><p>Now we know that a proof is a set of logical steps built from a set of assumptions, let’s talk a bit about how security proofs work. First, we need to work out how to describe the protocol in terms that we can reason about. Over the years researchers have come up with many ways for describing computer processes mathematically, most famously <a href=\"https://www.wolframscience.com/prizes/tm23/images/Turing.pdf\">Alan Turing defined a-machines, which we now know as Turing Machines</a>, which describe a <i>computer program</i> in an <i>algebraic form</i>. A protocol is slightly more complex than a single program. A protocol can be seen as a number of computers running a set of computer programs that interact with each other.</p><p>We’re going to use a class of techniques called <a href=\"https://en.wikipedia.org/wiki/Process_calculus\"><i>process algebras</i></a> to describe the interacting processes of a protocol. At its most basic level, algebra is the art of generalizing a statement by replacing specific values with general symbols. In standard algebra, these specific values are numbers, so for example we can write <code>(cos 37)² + (sin 37)² = 1</code>, which is true, but we can generalize it to <code>(cos θ)² + (sin θ)² = 1</code>, replacing the specific value, 37, with the symbol θ.</p><p>Now you might be wondering why it’s useful to replace things with symbols. The answer is it lets us solve entire classes of problems instead of solving each individual instance. When it comes to security protocols, this is especially important. We can’t possibly try every possible set of inputs to a protocol and check nothing weird happens to one of them. In fact, one of the assumptions we’re going to make when we prove KEMTLS secure is that trying every possible value for some inputs is impossible<sup>1</sup>. By representing the protocol symbolically, we can write a proof that applies to all possible inputs of the protocol.</p><p>Let’s go back to algebra. A <i>process algebra</i> is similar to the kind of algebra you might have learnt in high school: we represent a computer program with symbols for the specific values. We also treat functions symbolically. Rather than try and compute what happens when we apply a function <code>f</code> to a value <code>x</code>, we just create a new symbol <code>f(x)</code>. An algebra also provides rules for manipulating expressions. For example, in standard algebra we can <i>transform</i> <code>y + 5 = x² - x</code> into <code>y = x² - x - 5</code>. A process algebra is the same: it not only defines a language to describe interacting processes, it also defines rules for how we can manipulate those expressions.</p><p>We can use tools, such as the one we use called <a href=\"https://tamarin-prover.github.io/\">Tamarin</a>, to help us do this reasoning. Every protocol has its own rules for what transformations are allowed. It is very useful to have a tool, like Tamarin, to which we can tell these rules and allow it to do all the work of symbol manipulation. Tamarin does far, far more than that, though.</p><p>A rule, that we tell Tamarin, might look like this:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">rule Register_pk:\n  [ Fr(~ltkA) ]\n--[ GenLtk($A, ~ltkA)]-&gt;\n  [ !Ltk($A, ~ltkA), !Pk($A, pk(~ltkA)), Out(pk(~ltkA)) ]</pre></code>\n            <p>This rule is used to represent that a protocol participant has acquired a new public/private key pair. The rule has three parts:</p><ul><li><p>The first part lists the preconditions. In this case, there is only one: we take a <code>Fr</code>esh value called <code>~ltkA</code>, the “long-term key of A”. This precondition is always met, because Tamarin always allows us to generate fresh values.</p></li><li><p>The third part lists the postconditions (what we get back when we apply the rule). Rather than operating on an initial statement, as in high-school algebra, Tamarin instead operates on what we call a model of “bag of facts”. Instead of starting with <code>y + 5 = x² - x</code>, we start with an empty “bag”, and from there, apply rules. These rules take facts out of the bag and put new ones in. In this case, we put in:</p><ul><li><p><code>!Ltk($A, ~ltkA)</code> which represents the private portion of the key, <code>~ltkA</code>, and the name of the participant it was issued to, <code>$A</code>.</p></li><li><p><code>!Pk($A, pk(~ltkA))</code>, which represents the public portion of the key, <code>pk(~ltkA)</code>, and the participant was issued to, <code>$A</code>.</p></li><li><p><code>Out(pk(~ltkA))</code>, which represents us publishing the public portion of the key, <code>pk(~ltkA)</code> to the network. Tamarin is based on the <a href=\"https://en.wikipedia.org/wiki/Dolev%E2%80%93Yao_model\">Dolev-Yao model</a>, which assumes the attacker controls the network. Thus, this fact makes <code>$A</code>’s public key available to the attacker.</p></li></ul></li></ul><p>We can only apply a rule if the preconditions are met: the facts we need appear in the bag. By having rules for each step of the protocol, we can apply the rules in order and simulate a run of the protocol. But, as I’m sure you’ve noticed, we skipped the second part of the rule. The second part of the rule is where we list what we call <i>actions</i>.</p><p>We use actions to record what happened in a protocol run. In our example, we have the action <code>GenLtk($A, ~ltkA)</code>. <code>GenLtk</code> means that a new Long-Term Key (LTK) has been <code>Gen</code>erated. Whenever we trigger the <code>Register_pk</code> rule, we note this with the two parameters:, <code>$A</code>, the party to whom the new key pair belongs; and <code>~ltkA</code>, the private part of the generated key<sup>2</sup>.</p><p>If we simulate a single run of the protocol, we can record a list of all the actions executed and put them in a list. However, at any point in the protocol, there may be multiple rules that can be triggered. A list only captures a single run of a protocol, but we want to reason about all possible runs of the protocol. We can arrange our rules into a tree: every time we have multiple rules that could be executed, we give each one of them its own branch.</p><p>If we could write this entire tree, it would represent every possible run of the protocol. Because every possible run appears in this tree, if we can show that there are no “bad” runs on this tree, we can be sure that the protocol is “secure”. We put “bad” and “secure” in quotation marks here because we <i>still</i> haven’t actually defined what those terms actually mean.</p><p>But before we get to that, let’s quickly recap what we have so far. We have:</p><ul><li><p>A protocol we want to prove.</p></li><li><p>A definition of <i>protocol,</i> as a number of computers running a set of computer programs that interact with each other.</p></li><li><p>A technique, <i>process algebras</i>, to describe the interacting processes of the protocol: this technique provides us with symbols and rules for manipulating them.</p></li><li><p>A tree that represents every possible run of the protocol.</p></li></ul><p>We can reason about a protocol by looking at properties that our tree gives. As we are interested in cryptographic protocols, we would like to reason about its security. “Security” is a pretty abstract concept and its meaning changes in different contexts. In our case, to prove something is secure, we first have to say <i>what our security goals</i> are. One thing we might want to prove is, for example, that an attacker can never learn the encryption key of a session. We capture this idea with a <i>reachability</i> lemma.</p><p>A reachability lemma asks whether there is a path in the tree that leads to a specific state: can we “reach” this state? In this case, we ask: “can we reach a state where the attacker knows the session key?” If the answer is “no”, we are sure that our protocol has that property (an attacker never learns the session key), or at least that that property is true in our protocol model.</p><p>So, if we want to prove the security of a cryptographic protocol, we need to:</p><ol><li><p>Define the goals of the security that is being proven.</p></li><li><p>Describe the protocol as an interacting process of symbols, rules, and expressions.</p></li><li><p>Build a tree of all the steps the protocol can take.</p></li><li><p>Check that the trees of protocol runs attain the goals of security we specified.</p></li></ol><p>This process of creating a model of a program and writing rigorous proofs about that model is called “formal analysis”.</p><p>Writing formal proofs of protocol correctness has been very effective at finding and fixing all kinds of issues. During the design of TLS 1.3, for example, it uncovered a number of serious security flaws that were eventually fixed prior to standardization. However, something we need to be wary of with formal analysis is being over-reliant on its results. It’s very possible to be so taken with the rigour of the process and of its mathematical proofs, that the result gets overinterpreted. Not only can a mistake exist in a proof, even in a machine-checked one, the proof may not actually prove what you think it does. There are many examples of this: <a href=\"https://en.wikipedia.org/wiki/Needham%E2%80%93Schroeder_protocol\">Needham-Schroeder</a> had a <a href=\"https://www.cs.cmu.edu/afs/cs/academic/class/17654-f01/www/refs/BAN.pdf\">proof of security written in the BAN logic</a>, before Lowe found <a href=\"https://www.sciencedirect.com/science/article/abs/pii/0020019095001442\">an attack on a case that the BAN logic did not cover</a>.</p><p>In fact, the initial specification of the TLS 1.3 proof made the assumption that nobody uses the same certificate for both a client and a server, even though this is not explicitly disallowed in the specification. This gap led to the <a href=\"https://eprint.iacr.org/2019/347\">“Selfie” vulnerability</a> where a client could be tricked into connecting to itself, potentially leading to resource exhaustion attacks.</p><p>Formal analysis of protocol designs also tells you nothing about whether a particular implementation correctly implements a protocol. In other <a href=\"/post-quantum-easycrypt-jasmin\">blog posts</a>, we will talk about this. Let’s now return to our core topic: the formal analysis of KEMTLS.</p><h3>Proving KEMTLS’s security</h3><p>Now that we have the needed notions, let’s get down to the nitty-gritty: we show you how we proved KEMTLS is secure. KEMTLS is a proposal to do authentication in TLS handshakes using key exchange (via key encapsulation mechanisms or KEMs). <a href=\"/making-protocols-post-quantum\">KEMTLS examines</a> the trade-offs between post-quantum signature schemes and post-quantum key exchange, as we discussed in <a href=\"/making-protocols-post-quantum\">other blog posts</a>.</p><p>The main idea of KEMTLS is the following: instead of using a signature to prove that you have access to the private key that corresponds to the (signing) public key in the certificate presented, we derive a shared secret <i>encapsulated to</i> a (KEM) public key. The party that presented the certificate can only derive (<i>decapsulate</i>) it from the resulting <i>encapsulation</i> (often also called the ciphertext) if they have access to the correct private key; and only then can they read encrypted traffic. A brief overview of how this looks in the “traditional arrows on paper” form is given below.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/4mgeVds1Jxd59Qoy4QT187/a160fc4038c04d95937c5ef8a17e6b76/image3-24.png\" alt=\"A client and a server exchange messages. The client holds an ephemeral private key and sends the public key to the server. The server holds a certificate and its private key. The server takes the client’s public key and sends back a ciphertext, obtained from an encapsulate operation, as well as the certificate. From the encapsulate operation, the server also obtains a shared secret key 1. The client receives the ciphertext and computes the same shared secret key. It then computes ciphertext 2 (and shared secret key 2) by encapsulating against the certificate public key. It sends over ciphertext 2 to the server. Both the client and server can then compute encryption key K, used to encrypt the application data.\" class=\"kg-image\" width=\"1038\" height=\"1297\" loading=\"lazy\"/>\n            \n            </figure><p>Brief overview of the core idea of KEMTLS.</p><p>We want to show that the KEMTLS handshake is secure, no matter how an adversary might mess with, reorder, or even create new protocol messages. Symbolic analysis tools such as Tamarin or <a href=\"https://bblanche.gitlabpages.inria.fr/proverif/\">ProVerif</a> are well suited to this task: as said, they allow us to consider every possible combination or manipulation of protocol messages, participants, and key information. We can then write lemmas about the behavior of the protocol.</p><h3>Why prove it in Tamarin?</h3><p>There exists a pen-and-paper proof of the KEMTLS handshake. You might ask: why should we still invest the effort of modeling it in a tool like Tamarin?</p><p>Pen-and-paper proofs are in theory fairly straightforward. However, they are <i>very hard</i> to get right. We need to carefully express the security properties of the protocol, and it is very easy to let assumptions lead you to write something that your model does not correctly cover. Verifying that a proof has been done correctly is also very difficult and requires almost as much careful attention as writing the proof itself. In fact, several mistakes in definitions of the properties of the model of the original KEMTLS proof were found, after the paper had been accepted and published at a top-tier security conference.</p><blockquote><p><i>? For those familiar with these kinds of game-based proofs, another “war story”: while modeling the ephemeral key exchange, the authors of KEMTLS initially assumed all we needed was an </i><a href=\"https://en.wikipedia.org/wiki/Ciphertext_indistinguishability#Indistinguishability_under_chosen-plaintext_attack_(IND-CPA)\"><i>IND-CPA</i></a><i> secure KEM. After writing out all the simulations in pseudo code (which is not part of the proof or the paper otherwise!), it turned out that we needed an additional oracle to answer a single decapsulation query, resulting in requiring a weaker variant of IND-CCA security of our KEM (namely, IND-1CCA security). Using an “only” IND-CPA-secure KEM turned out to not be secure!</i></p></blockquote><p>Part of the problem with pen-and-paper proofs is perhaps the human nature to read between the lines: we quickly figure out what is intended by a certain sentence, even if the intent is not strictly clarified. Computers do not allow that: to everyone’s familiar frustration whenever a computer has not done what you wanted, but just what you told it to do.</p><p>A benefit of computer code, though, is that all the effort is in writing the instructions. A carefully constructed model and proof result in an executable program: verifying should be as simple as being able to run it to the end. However, as always we need to:</p><ol><li><p>Be very careful that we have modeled the right thing and,</p></li><li><p>Note that even the machine prover might have bugs: this second computer-assisted proof is a complement to, and not a replacement of, the pen-and-paper proof.</p></li></ol><p>Another reason why computer proofs are interesting is because they give the ability to construct extensions. The <a href=\"https://eprint.iacr.org/2021/779\">“pre-distributed keys” extension of KEMTLS</a>, for example, has been only proven on paper in isolation. Tamarin allows us to construct that extension in the same space as the main proof, which will help rule out any cross-functional attacks. With this, the complexity of the proof is increased exponentially, but Tamarin allows us to handle that just by using more computer power. Doing the same on paper requires very, very careful consideration.</p><p>One final reason we wanted to perform this computer analysis is because whilst the pen-and-paper proof was in the computational model, our computer analysis is in the symbolic model. Computational proofs attain “high resolution” proofs, giving very tight bounds on exactly how secure a protocol is. Symbolic models are “low resolution”: giving a binary yes/no answer on whether a protocol meets the security goals (with the assumption that the underlying cryptographic primitives are secure). This might sound like computational proofs are the best: their downside is that one has to simplify the model in other areas. The computational proof of KEMTLS, for example, does not model TLS message formats, which a symbolic model can.</p><h3>Modeling KEMTLS in Tamarin</h3><p>Before we can start making security claims and asking Tamarin to prove them, we first need to explain to Tamarin what KEMTLS is. As we mentioned earlier, Tamarin treats the world as a “bag of facts”. Keys, certificates, identities, and protocol messages are all facts. Tamarin can take those facts and apply rules to them to construct (or deconstruct) new facts. Executing steps in the KEMTLS protocol is, in a very literal sense, just another way to perform such transformations — and if everything is well-designed, the only “honest” way to reach the end state of the protocol.</p><p>We need to start by modeling the protocol. We were fortunate to be able to reuse the work of <a href=\"https://tls13tamarin.github.io/TLS13Tamarin/\">Cremers et al.</a>, who contributed their significant modeling talent to the TLS 1.3 standardization effort. They created a very complete model of the TLS 1.3 protocol, which showed that the protocol is generally secure. For more details, see <a href=\"https://tls13tamarin.github.io/TLS13Tamarin/\">their paper</a>.</p><p>We modified the ephemeral key exchange by substituting the Diffie-Hellman operations in TLS 1.3 with the appropriate KEM operations. Similarly, we modified the messages that perform the certificate handling: instead of verifying a signature, we send back a KemEncapsulation message with the ciphertext. Let’s have a look at one of the changed rules. Don’t worry, it looks a bit scary, but we’re going to break it down for you. And also, don’t worry if you do not grasp all the details: we will cover the most necessary bits when they come up again, so you can also just skip to the next section “Modeling the adversary” instead.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">rule client_recv_server_cert_emit_kex:\nlet\n  // … snip\n  ss = kemss($k, ~saseed)\n  ciphertext = kemencaps($k, ss, certpk)\n  // NOTE: the TLS model uses M4 preprocessor macros for notation\n  // We also made some edits for clarity\nin\n  [\n    State(C2d, tid, $C, $S, PrevClientState),\n    In(senc{&lt;&#039;certificate&#039;, certpk&gt;}hs_keys),\n    !Pk($S, certpk),\n    Fr(~saseed)\n  ]\n  --[\n    C2d(tid),\n    KemEncap($k, certpk, ss)\n  ]-&gt;\n  [\n    State(C3, tid, $C, $S, ClientState),\n    Out(senc{&lt;&#039;encaps&#039;, ciphertext&gt;}hs_keyc)\n  ]</pre></code>\n            <p>This rule represents the client getting the server’s certificate and encapsulating a fresh key to it. It then sends the encapsulated key back to the server.</p><p>Note that the <code>let … in</code> part of the rule is used to assign expressions to variables. The real meat of the rule starts with the preconditions. As we can see, in this rule there are four preconditions that Tamarin needs to already have in its bag for this rule to be triggered:</p><ul><li><p>The first precondition is <code>State(C2d, …)</code>. This condition tells us that we have some client that has reached the stage <code>C2d</code>, which is what we call this stage in our representation. The remaining variables define the state of that client.</p></li><li><p>The second precondition is an <code>In</code> one. This is how Tamarin denotes messages received from the network. As we mentioned before, we assume that the network is controlled by the attacker. Until we can prove otherwise, we don’t know whether this message was created by the honest server, if it has been manipulated by the attacker, or even forged. The message contents, <code>senc{&lt;&#39;certificate&#39;, certpk&gt;}hs_keys</code>, is symmetrically encrypted ( <code>senc{}</code>) under the server’s handshake key (we’ve slightly edited this message for clarity, and removed various other bits to keep this at least somewhat readable, but you can see the whole definition in <a href=\"https://github.com/thomwiggers/TLS13Tamarin\">our model</a>).</p></li><li><p>The third precondition states the public key of the server, <code>!Pk(S, certpk)</code>. This condition is preceded by a <code>!</code> symbol, which means that it’s a permanent fact to be consumed many times. Usually, once a fact is removed from the bag, it is gone; but permanent facts remain. <code>S</code> is the name of the server, and <code>certpk</code> is the KEM public key.</p></li><li><p>The fourth precondition states the fresh random value, <code>~saseed</code>.</p></li></ul><p>The postconditions of this rule are a little simpler. We have:</p><ul><li><p><code>State(C3, …)</code>, which represents that the client (which was at the start of the rule in state <code>C2d</code>) is now in state <code>C3</code>.</p></li><li><p><code>Out(senc{&lt;&#39;encaps&#39;, ciphertext&gt;}hs_keyc)</code>, which represents the action of the client sending the encapsulated key to the network, encrypted under the client’s handshake key.</p></li></ul><p>The four actions recorded in this rule are:</p><ul><li><p>First, we record that the client with thread id <code>tid</code> reached the state <code>C2d</code>.</p></li><li><p>Second and third, we record that the client was running the protocol with various intermediate values. We use the phrase “running with” to indicate that although the client believes these values to be the correct, it can’t yet be certain that they haven’t been tampered with, so the client hasn’t committed yet to them.</p></li><li><p>Finally, we record the parameters we put into the KEM with the <code>KemEncap</code> action.</p></li></ul><p>We modify and add such rules to the TLS 1.3 model, so we can run KEMTLS instead of TLS 1.3. For a sanity check, we need to make sure that the protocol can actually be executed: a protocol that can not run, can not leak your secrets. We use a <i>reachability lemma</i> to do that:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">lemma exists_C2d:\n    exists-trace\n    &quot;Ex tid #j. C2d(tid)@#j&quot;</pre></code>\n            <p>This was the first lemma that we asked Tamarin to prove. Because we’ve marked this lemma <code>exists-trace</code>, it does not need to hold in all traces, all runs of the protocol. It just needs one. This lemma asks if there exists a trace ( <code>exists-trace</code>), where there exists ( <code>Ex</code> ) a variable <code>tid</code> and a time <code>#j</code> (times are marked with <code>#</code>) at which action <code>C2d(tid)</code> is recorded. What this captures is that Tamarin could find a branch of the tree where the rule described above was triggered. Thus, we know that our model can be executed, at least as far as <code>C2d</code>.</p><h3>Modeling the adversary</h3><p>In the symbolic model, all cryptography is perfect: if the adversary does not have a particular key, they can not perform any deconstructions to, for example, decrypt a message or decapsulate a ciphertext. Although a proof with this default adversary would show the protocol to be secure against, for example, reordering or replaying messages, we want it to be secure against a slightly stronger adversary. Fortunately, we can model this adversary. Let’s see how.</p><p>Let’s take an example. We have a rule that honestly generates long-term keys (certificates) for participants:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">rule Register_pk:\n  [ Fr(~ltkA) ] \n  --[  GenLtk($A, ~ltkA)  ]-&gt;\n  [ !Ltk($A, ~ltkA), \n    !Pk($A, kempk($k, ~ltkA)), \n    Out(kempk($k, ~ltkA))\n  ]</pre></code>\n            <p>This rule is very similar to the one we saw at the beginning of this blog post, but we’ve tweaked it to generate KEM public keys. It goes as follows: it generates a fresh value, and registers it as the actor <code>$A</code>’s long-term private key symbol <code>!Ltk</code> and <code>$A</code>’s public key symbol <code>!Pk</code> that we use to model our certificate infrastructure. It also sends ( <code>Out</code> ) the public key to the network such that the adversary has access to it.</p><p>The adversary can not deconstruct symbols like <code>Ltk</code> without rules to do so. Thus, we provide the adversary with a special <code>Reveal</code> query, that takes the <code>!Ltk</code> fact and reveals the private key:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">rule Reveal_Ltk:\n   [ !Ltk($A, ~ltkA) ] --[ RevLtk($A) ]-&gt; [ Out(~ltkA) ]</pre></code>\n            <p>Executing this rule registers the <code>RevLtk($A)</code> action, so that we know that <code>$A</code>’s certificate can no longer be trusted after <code>RevLtk</code> occurred.</p><h3>Writing security lemmas</h3><p>KEMTLS, like TLS, is a cryptographic handshake protocol. These protocols have the general goal to generate session keys that we can use to encrypt user’s traffic, preferably as quickly as possible. One thing we might want to prove is that these session keys are secret:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">lemma secret_session_keys [/*snip*/]:\n  &quot;All tid actor peer kw kr aas #i.\n      SessionKey(tid, actor, peer, &lt;aas, &#039;auth&#039;&gt;, &lt;kw, kr&gt;)@#i &amp;\n      not (Ex #r. RevLtk(peer)@#r &amp; #r &lt; #i) &amp;\n      not (Ex tid3 esk #r. RevEKemSk(tid3, peer, esk)@#r &amp; #r &lt; #i) &amp;\n      not (Ex tid4 esk #r. RevEKemSk(tid4, actor, esk)@#r &amp; #r &lt; #i)\n    ==&gt; not Ex #j. K(kr)@#j&quot;</pre></code>\n            <p>This lemma states that if the actor has completed the protocol and the attacker hasn’t used one of their special actions, then the attacker doesn’t know the actor’s read key, <code>kr</code>. We’ll go through the details of the lemma in a moment, but first let’s address some questions you might have about this proof statement.</p><p>The first question that might arise is: “If we are only secure in the case the attacker doesn’t use their special abilities then why bother modeling those abilities?” The answer has two parts:</p><ol><li><p>We do not restrict the attacker from using their abilities: they can compromise every key except the ones used by the participants in this session. If they managed to somehow make a different participant use the same ephemeral key, then this lemma wouldn’t hold, and we would not be able to prove it.</p></li><li><p>We allow the attacker to compromise keys used in this session <i>after</i> the session has completed. This means that what we are proving is: an attacker who recorded this session in the past and now has access to the long-term keys (by using their shiny new quantum computer, for example) can’t decrypt what happened in the session. This property is also known as <a href=\"https://en.wikipedia.org/wiki/Forward_secrecy\">forward secrecy</a>.</p></li></ol><p>The second question you might ask is: “Why do we only care about the read key?”. We only care about the read key because this lemma is symmetric, it holds for all actors. When a client and server have established a TLS session, the client’s read key is the server’s write key and vice versa. Because this lemma applies symmetrically to the client and the server, we prove that the attacker doesn’t know either of those keys.</p><p>Let’s return now to the syntax of this lemma.</p><p>This first line of this lemma is a “For all” statement over seven variables, which means that we are trying to prove that no matter what values these seven variables hold, the rest of the statement is true. These variables are:</p><ul><li><p>the thread id <code>tid</code>,</p></li><li><p>a protocol participant, <code>actor</code>,</p></li><li><p>the person they think they’re talking to, <code>peer</code>,</p></li><li><p>the final read and write keys, <code>kr</code> and <code>kw</code> respectively,</p></li><li><p>the actor’s authentication status, <code>aas</code>,</p></li><li><p>and a time <code>#i</code>.</p></li></ul><p>The next line of the lemma is about the <code>SessionKey</code> action. We record the <code>SessionKey</code> action when the client or the server thinks they have completed the protocol.</p><p>The next lines are about two attacker abilities: <code>RevLtk</code>, as discussed earlier; and <code>RevEKemSk</code>, which the attacker can use to reveal ephemeral secrets. The <code>K(x)</code> action means that the attacker learns (or rather, <code>K</code>nows) <code>x</code>. We, then, assert that if there does not <code>Ex</code>ist a <code>RevEKemSk</code> or <code>RevLtk</code> action on one of the keys used in the session, then there also does not exist a time when <code>K(kr)</code> (when the attacker learns the read key). <a href=\"https://en.wikipedia.org/wiki/Q.E.D.\"><i>Quod erat demonstrandum</i></a>. Let’s run the proofs now.</p><h3>Proving lemmas in Tamarin</h3><p>Tamarin offers two methods to prove security lemmas: it has an autoprover that can try to find the solution for you, or you can do it manually. Tamarin sometimes has a hard time figuring out what is important for proving a particular security property, and so manual effort is sometimes unavoidable.</p><p>The manual prover interface allows you to select what goal Tamarin should pursue step by step. A proof quickly splits into separate branches: in the picture, you see that Tamarin has already been able to prove the branches that are green, leaving us to make a choice for case 1.</p>\n            <figure class=\"kg-card kg-image-card kg-width-wide\">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/39wLyAIAVaVCmfgpQRrq7o/ba04bfb55d498bc2028cf48d47bf9c1d/pasted-image-0.png\" alt=\"The Tamarin prover’s user interface. On the left-hand side, there is a lemma, to which some steps have been applied. Some branches have been proven (they are marked green). There is one branch that is highlighted. On the right hand side, there are several goals listed that Tamarin can pursue.\" class=\"kg-image\" width=\"1203\" height=\"727\" loading=\"lazy\"/>\n            \n            </figure><p>Screenshot from the Tamarin user interface, showing a prompt for the next step in a proof. The branches of the proof that are marked green have already been proven.</p><p>Sometimes whilst working in the manual interface, you realize that there are certain subgoals that Tamarin is trying to prove while working on a bigger lemma. By writing what we call a helper lemma we can give Tamarin a shortcut of sorts. Rather than trying to solve all the subgoals of one big lemma, we can split the proof into more digestible chunks. Tamarin can then later reuse these helper lemmas when trying to prove bigger lemmas; much like factoring out functions while programming. Sometimes this even allows us to make lemmas auto-provable. Other times we can extract the kinds of decisions we’re making and heuristics we’re manually applying into a separate “oracle” script: a script that interacts with Tamarin’s prover heuristics on our behalf. This can also automate proving tricky lemmas.</p><p>Once you realize how much easier certain things are to prove with helper lemmas, you can get a bit carried away. However, you quickly find that Tamarin is being “distracted” by one of the helper lemmas and starts going down long chains of irrelevant reasoning. When this happens, you can hide the helper lemma from the main lemma you’re trying to prove, and sometimes that allows the autoprover to figure out the rest.</p><p>Unfortunately, all these strategies require a lot of intuition that is very hard to obtain without spending a lot of time hands-on with Tamarin. Tamarin can sometimes be a bit unclear about what lemmas it’s trying to apply. We had to resort to tricks, like using unique, highly recognizable variable names in lemmas, such that we can reconstruct where a certain goal in the Tamarin interface is coming from.</p><p>While doing this work, auto-proving lemmas has been incredibly helpful. Each time you make a tiny change in either a lemma (or any of the lemmas that are reused by it) or in the whole model, you have to re-prove everything. If we needed to put in lots of manual effort each time, this project would be nowhere near done.</p><p>This was demonstrated by two bugs we found in one of the core lemmas of the TLS 1.3 model. It turned out that after completing the proof, some refactoring changes were made to the <code>session_key_agreement</code> lemma. These changes seemed innocent, but actually changed the meaning of the lemma, so that it didn’t make sense anymore (the original definition did cover the right security properties, so luckily this doesn’t cause a security problem). Unfortunately, this took a lot of our time to figure out. However, after a huge effort, we’ve done it. We have a proof that <a href=\"https://github.com/thomwiggers/TLS13Tamarin\">KEMTLS achieves its security goals</a>.</p><h3>Conclusions</h3><p>Formal methods definitely have a place in the development of security protocols; the development process of TLS 1.3 has really demonstrated this. We think that any proposal for new security protocols should be accompanied by a machine-verified proof of its security properties. Furthermore, because many protocols are currently specified in natural language, formal specification languages should definitely be under consideration. Natural language is inherently ambiguous, and the inevitable differences in interpretation that come from that lead to all kinds of problems.</p><p>However, this work cannot be done by academics alone. Many protocols come out of industry who will need to do this for themselves. We would be the first to admit that the usability of these tools for non-experts is not all the way there yet — and industry and academia should collaborate on making these tools more accessible for everyone. We welcome and look forward to these collaborations in the future!</p><h4>References</h4><ul><li><p><a href=\"https://dl.acm.org/doi/10.1145/2637166.2637237\">“Why does cryptographic software fail?: a case study and open problems”</a> by David Lazar, Haogang Chen, Xi Wang and Nickolai Zeldovich</p></li><li><p><a href=\"https://eprint.iacr.org/2019/1393.pdf\">“SoK: Computer-Aided Cryptography”</a> by Manuel Barbosa, Gilles Barthe, Karthik Bhargavan, Bruno Blanchet, Cas Cremers, Kevin Liao and Bryan Parno</p></li><li><p><a href=\"https://eprint.iacr.org/2020/534/\">“Post-quantum TLS without handshake signatures”</a> by Peter Schwabe and Douglas Stebila and Thom Wiggers(*)</p></li><li><p><a href=\"https://eprint.iacr.org/2021/779/\">“More efficient post-quantum KEMTLS with pre-distributed public keys”</a> by Peter Schwabe and Douglas Stebila and Thom Wiggers (*)</p></li><li><p><a href=\"https://londmathsoc.onlinelibrary.wiley.com/doi/10.1112/plms/s2-42.1.230\">&quot;On computable numbers, with an application to the Entscheidungsproblem.&quot;</a> by Alan Turing</p></li><li><p><a href=\"https://dl.acm.org/doi/pdf/10.1145/3133956.3134063\">&quot;A comprehensive symbolic analysis of TLS 1.3.&quot;</a> by Cas Cremers, Marko Horvat, Jonathan Hoyland, Sam Scott, and Thyla van der Merwe (*)</p></li><li><p><a href=\"https://www.cs.cmu.edu/afs/cs/academic/class/17654-f01/www/refs/BAN.pdf\">&quot;A Logic of Authentication&quot;</a> by Michael Burrows, Martin Abadi, and Roger Michael Needham</p></li></ul><p>* The authors of this blog post were authors on these papers</p><p>.....</p><p><sup>1</sup>Of course, trying every value isn’t technically impossible, it’s just infeasible, so we make the simplifying assumption that it’s impossible, and just say our proof only applies if the attacker can’t just try every value. Other styles of proof that don’t make that assumption are possible, but we’re not going to go into them.</p><p><sup>2</sup>For simplicity, this representation assumes that the public portion of a key pair can be derived from the private part, which may not be true in practice. Usually this simplification won’t affect the analysis.</p>",
		"id": "7erNSwLGj4BHA9bhRf2HOq",
		"localeList": {
			"name": "Building Confidence in Cryptographic Protocols Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "This blogpost refers to the efforts to use formal/verification/implementation for post-quantum algorithms to achieve better assurance for them. It also touches on our Cloudflare efforts on this.",
		"metadata": {
			"title": "Building Confidence in Cryptographic Protocols",
			"description": "This blogpost refers to the efforts to use formal/verification/implementation for post-quantum algorithms to achieve better assurance for them. It also touches on our Cloudflare efforts on this.",
			"imgPreview": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/5h9cipq3Q9qktuvHosaLbi/a191d216f49dfb6ab5680ce110992cf8/post-quantum-formal-analysis-if2pj8.png"
		},
		"primary_author": {},
		"published_at": "2022-02-24T17:30:00.000+00:00",
		"slug": "post-quantum-formal-analysis",
		"tags": [
			{
				"id": "1x7tpPmKIUCt19EDgM1Tsl",
				"name": "Research",
				"slug": "research"
			},
			{
				"id": "1QsJUMpv0QBSLiVZLLQJ3V",
				"name": "Cryptography",
				"slug": "cryptography"
			},
			{
				"id": "6bIo7ayy56Fzdrtf9z2EWy",
				"name": "Post-Quantum",
				"slug": "post-quantum"
			}
		],
		"title": "Building Confidence in Cryptographic Protocols",
		"updated_at": "2024-08-27T01:36:09.946Z",
		"url": "https://blog.cloudflare.com/post-quantum-formal-analysis"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.blurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}