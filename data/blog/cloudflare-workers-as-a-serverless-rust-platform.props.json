{
	"initialReadingTime": "5",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Steven Pack",
				"slug": "stevenpack",
				"bio": "Partner Engineering Director",
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/5KBJRA6GGkWLzkmUgwTrMs/d8f2a46776c74dd2a77603f2742afc18/stevenpack.png",
				"location": "San Francisco Bay Area, California",
				"website": null,
				"twitter": "@steven_pack",
				"facebook": null
			}
		],
		"excerpt": "The Workers team just announced support for WebAssembly (WASM) within Workers. If you saw my post on Internet Native Apps, you'll know that I believe WebAssembly will play a big part in the apps of the future.",
		"feature_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/2BAx37OMGa3UKptJhvBifT/20f32b26091de8d034d4ebfac8456289/cloudflare-workers-as-a-serverless-rust-platform.png",
		"featured": false,
		"html": "<p><b><i>Update</i></b><i>: Rust Tooling for Workers has improved significantly since this post. Go </i><a href=\"/introducing-wrangler-cli/\"><i>here</i></a><i> to check out Wrangler, our new Rust+Workers cli</i></p><hr/><p>The Workers team just <a href=\"/webassembly-on-cloudflare-workers/\">announced support</a> for WebAssembly (WASM) within Workers. If you saw my post on <a href=\"/internet-native-applications/\">Internet Native Apps</a>, you&#39;ll know that I believe WebAssembly will play a big part in the apps of the future.</p><p>It&#39;s exciting times for Rust developers. Cloudflare&#39;s Serverless Platform, Cloudflare Workers, allows you to compile your code to WASM, upload to 150+ data centers and invoke those functions just as easily as if they were JavaScript functions. Today I&#39;m going to convert my lipsum generator to use Rust and explore the developer experience (hint: it&#39;s already pretty nice).</p><p>The Workers teams notes in the documentation:</p><blockquote><p>...WASM is not always the right tool for the job. For lightweight tasks like redirecting a request to a different URL or checking an authorization token, sticking to pure JavaScript is probably both faster and easier than WASM. WASM programs operate in their own separate memory space, which means that it&#39;s necessary to copy data in and out of that space in order to operate on it. Code that mostly interacts with external objects without doing any serious &quot;number crunching&quot; likely does not benefit from WASM.</p></blockquote><p>OK, I&#39;m unlikely to gain significant performance improvements on this particular project, but it serves as a good opportunity illustrate the developer experience and tooling. ?</p><h2>Setup the environment with wasm-pack</h2><p>Coding with WASM has been bleeding edge for a while, but Rust&#39;s tool for WASM development recently reached a fairly ergonomic state and even got a <a href=\"https://rustwasm.github.io/wasm-pack/\">website</a>. Make sure you have the <a href=\"https://rustwasm.github.io/wasm-pack/book/prerequisites/index.html\">prerequisites</a> installed and then follow the steps below to get started.</p><p>wasm-pack allows you to compile Rust to WebAssembly, as well as generate bindings between JavaScript objects and Rust objects. We&#39;ll talk about why that&#39;s important later.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\"># Install wasm-pack\ncurl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh\n\n# Cargo generate to build apps based on templates\ncargo install cargo-generate\n\n# And generate a HelloWorld wasm app, based on the wasm-pack template\ncargo generate --git https://github.com/rustwasm/wasm-pack-template\n\n?  Project Name: bob-ross-lorem-ipsum-rust\n?   Creating project called `bob-ross-lorem-ipsum-rust`...\n✨   Done! New project created /Volumes/HD2/Code/cloudflare/bobross/bob-ross-lipsum-rust/api-rust/bob-ross-lorem-ipsum-rust</pre></code>\n            <p>The <a href=\"https://rustwasm.github.io/wasm-pack/book/tutorial/template-deep-dive/cargo-toml.html\">WASM book</a> describes some of the glue in the Cargo.toml file, but the meat of the project is here:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">...\n#[wasm_bindgen]\nextern {\n    fn alert(s: &amp;str);\n}\n\n#[wasm_bindgen]\npub fn greet() {\n    alert(&quot;Hello, bob-ross-lorem-ipsum-rust!&quot;);\n}</pre></code>\n            <p>This does two things</p><ol><li><p>Binds to the &quot;external&quot; function in our host environment where the WASM will run. If that&#39;s the browser, it will popup a window.</p></li><li><p>It also defines a Rust function, greet() which will be made available as a function callable from the host environment, in our case JavaScript.</p></li></ol><p>Build with <code>wasm-pack build</code></p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ wasm-pack build\n  \n  [1/9] ?  Checking `rustc` version...\n  [2/9] ?  Checking crate configuration...\n  [3/9] ?  Adding WASM target...\n  [4/9] ?  Compiling to WASM...\n  [5/9] ?  Creating a pkg directory...\n  [6/9] ?  Writing a package.json...\n  ⚠️   [WARN]: Field &#039;description&#039; is missing from Cargo.toml. It is not necessary, but recommended\n  ⚠️   [WARN]: Field &#039;repository&#039; is missing from Cargo.toml. It is not necessary, but recommended\n  ⚠️   [WARN]: Field &#039;license&#039; is missing from Cargo.toml. It is not necessary, but recommended\n  [7/9] ?  Copying over your README...\n  [8/9] ⬇️  Installing wasm-bindgen...\n  [9/9] ?‍♀️  Running WASM-bindgen...\n  ✨   Done in 2 minutes\n| ?   Your wasm pkg is ready to publish at &quot;/Volumes/HD2/Code/cloudflare/bobross/bob-ross-lipsum-rust/bob-ross</pre></code>\n            <p>Subsequent builds will be faster. We eventually want to ship that .wasm file to a Worker, but I&#39;d like to keep things local and test in a browser first.</p><p>There&#39;s an <a href=\"https://www.npmjs.com/package/create-wasm-app\">npm</a> package that will create a templated webpack webapp, preconfigured to import WebAssembly node modules, which we&#39;ll use as a test harness.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ npm init wasm-app www\nnpx: installed 1 in 2.533s\n? Rust + ? Wasm = ❤</pre></code>\n            <p>Install the dependencies with <code>npm install</code> and then <code>npm start</code> to fire up the webpack bundled web server to serve your page</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ npm start\n\n&gt; create-wasm-app@0.1.0 start /Volumes/HD2/Code/cloudflare/bobross/bob-ross-lipsum-rust/bob-ross-lorem-ipsum-rust/www\n&gt; webpack-dev-server\n\nℹ ｢wds｣: Project is running at http://localhost:8080/</pre></code>\n            <p>Open your web browser at <a href=\"http://localhost:8080\">http://localhost:8080</a> and you should see your first WASM generated content!</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/7nGG5L8JRVz3j0DE8M7jds/c41efd82c76dbb6b9628c98d1f64d109/rust-wasm-hello-world.png\" alt=\"Rust WASM Hello World\" class=\"kg-image\" width=\"1038\" height=\"380\" loading=\"lazy\"/>\n            \n            </figure><p>OK, that&#39;s promising, but it&#39;s not actually our code. Our greet function returned <code>&quot;Hello, bob-ross-lorem-ipsum-rust!&quot;</code></p><p>If we open up <code>www/index.js</code>, we can see this:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">import * as wasm from &quot;hello-wasm-pack&quot;;\n\nwasm.greet();</pre></code>\n            <p>So it&#39;s importing a node module &quot;hello-wasm-pack&quot; which was part of the template. We want to import our <i>own</i> module we built with <code>cargo generate</code> earlier.</p><p>First, expose our WASM package as a node module:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\"># Create a global node_modules entry pointing to your local wasm pkg\n$ cd pkg\n$ npm link\n...\n/Users/steve/.nvm/versions/node/v8.11.3/lib/node_modules/bob-ross-lorem-ipsum-rust -&gt; /Volumes/HD2/Code/cloudflare/bob-ross-lorem-ipsum-rust/pkg</pre></code>\n            <p>Then make it available as a node_module in our test harness.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ cd ../www\n$ npm link bob-ross-lorem-ipsum-rust\n/Volumes/HD2/Code/cloudflare/bobross/bob-ross-lorem-ipsum-rust/www/node_modules/bob-ross-lorem-ipsum-rust -&gt; /Users/steve/.nvm/versions/node/v8.11.3/lib/node_modules/bob-ross-lorem-ipsum-rust -&gt; /Volumes/HD2/Code/cloudflare/bobross/bob-ross-lorem-ipsum-rust/pkg</pre></code>\n            <p>Import it in the index.js file</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">//import * as wasm from &quot;hello-wasm-pack&quot;;\nimport * as wasm from &quot;bob-ross-lorem-ipsum-rust&quot;</pre></code>\n            <p>and run!</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">npm run build\nnpm run start</pre></code>\n            <p>Better! That&#39;s our code.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/31yXXKuqGD2mkeKNer0Dok/22b841bf80503ef96127ae65778fea2a/rust-wasm-hello-world2.png\" alt=\"Rust WASM Hello World 2\" class=\"kg-image\" width=\"466\" height=\"144\" loading=\"lazy\"/>\n            \n            </figure><h3>Quick recap</h3><p>We have:</p><ul><li><p>A Hello, World WASM module</p></li><li><p>Exposed as an npm module</p></li><li><p>A webpack app which imports that module</p></li><li><p>And invokes the greet() function</p></li></ul><p>We&#39;re now going to port our Bob Ross Lorem Ipsum generator to Rust, and try it out locally before uploading as a worker. Check it out on in the <a href=\"https://github.com/stevenpack/bob-ross-lipsum-rust\">GitHub</a> repo, or follow along.</p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">\nuse std::vec::Vec;\nuse rand::distributions::{Range, Distribution};\nuse rand::rngs::SmallRng;\nuse rand::FromEntropy;\n\nstatic PHRASES: [&amp;str; 370] = [...elided for clarity];\n\nfn get_random_indexes(cnt: usize) -&gt; Vec&lt;usize&gt; {\n    let mut rng = get_rng();\n    let range = Range::new(0, PHRASES.len());    \n    (0..cnt)\n        .map(|_| range.sample(&amp;mut rng))\n        .collect()\n}\n\nfn get_phrase(idx: usize) -&gt; &amp;&#039;static str {\n    PHRASES[idx]        \n}\n\nfn get_rng() -&gt; SmallRng {    \n    SmallRng::from_entropy()\n}\n\nfn get_phrases(idxs: &amp;Vec&lt;usize&gt;) -&gt; Vec&lt;&amp;&#039;static str&gt; {    \n    idxs.iter()\n        .map(|idx| get_phrase(*idx))\n        .collect()\n}\n\nfn need_newline(newline: usize, idx: usize) -&gt; bool {\n    //idx+1 because idx is zero-based but we want a new line after &quot;every x phrases&quot;.\n    (newline &gt; 0) &amp;&amp; (idx &gt; 0) &amp;&amp; ((idx + 1) % newline == 0)\n}\n\nfn need_space(newline: usize, idx: usize) -&gt; bool {\n    !need_newline(newline, idx)\n}\n\nfn build_phrase_text(idxs: Vec&lt;usize&gt;, newline: usize) -&gt; String {\n    let phrases_vec = get_phrases(&amp;idxs);\n    let mut string = String::new();\n    for i in 0..phrases_vec.len() {\n        //the phrase\n        string.push_str(phrases_vec[i]);\n        //spaces between phrases\n        if need_space(newline, i) {\n            string.push(&#039; &#039;);\n        }\n        //new lines\n        if need_newline(newline, i) {\n            string.push_str(&quot;\\n\\n&quot;);\n        }\n    }\n    string\n}\n\npub fn get_phrase_text(phrase_cnt: usize, newline: usize) -&gt; String {\n    let idxs = get_random_indexes(phrase_cnt);\n    build_phrase_text(idxs,newline)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_test_indexes() -&gt; Vec&lt;usize&gt; {\n        vec![34, 2, 99, 43, 128, 300, 45, 56, 303, 42, 11]\n    }\n    \n    #[test]\n    fn get_phrases() {\n        let randoms = get_test_indexes();\n        let phrases = super::get_phrases(&amp;randoms);\n        println!(&quot;{:?}&quot;, phrases);\n    }\n}</pre></code>\n            <p>Running the tests shows everything looks good:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ cargo test -- --nocapture\n    Finished dev [unoptimized + debuginfo] target(s) in 0.40s                                                                                       \n     Running target/debug/deps/bob_ross_lorem_ipsum_rust-5be29ab9ead7494d\n\nrunning 1 test\n[&quot;Decide where your cloud lives. Maybe he lives right in here.&quot;, &quot;A fan brush is a fantastic piece of equipment. Use it. Make friends with it.&quot;, &quot;If we\\&#039;re going to have animals around we all have to be concerned about them and take care of them.&quot;, &quot;Don\\&#039;t kill all your dark areas - you need them to show the light.&quot;, &quot;It\\&#039;s almost like something out of a fairytale book.&quot;, &quot;We don\\&#039;t have anything but happy trees here.&quot;, &quot;Even the worst thing we can do here is good.&quot;, &quot;Everything is happy if you choose to make it that way.&quot;, &quot;We don\\&#039;t make mistakes we just have happy little accidents.&quot;, &quot;Don\\&#039;t hurry. Take your time and enjoy.&quot;, &quot;All you have to learn here is how to have fun.&quot;]\ntest phrases::tests::get_phrases ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre></code>\n            <p>And I&#39;ve exposed the method to WASM like this:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">#[wasm_bindgen]\npub fn get_phrase_text(phrase_cnt: usize, new_line: usize) -&gt; String {\n    phrases::get_phrase_text(phrase_cnt, new_line)\n}</pre></code>\n            <p>So, we should be good to call our WASM from the browser test harness. Let&#39;s modify <code>www/index.js</code> to invoke <code>get_phrase_text</code> and fire it up in the browser!</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">//wasm.greet();\nlet phraseText = wasm.get_phrase_text(100, 10);\nconsole.log(phraseText);\nalert(phraseText);</pre></code>\n            <p>Fail.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/7AIwddjpP7c8NrOrl5FONS/799b4b7bb0edc29d5eceb8a69b908475/rust-wasm-fail-no-entropy.png\" alt=\"Rust WASM Fail no entropy\" class=\"kg-image\" width=\"1152\" height=\"239\" loading=\"lazy\"/>\n            \n            </figure><p>If you&#39;ve played around with Rust, you&#39;ll know how jarring it can be to see your code compile and tests pass, only to have it blow up at runtime. The strictness of the language means your code behaves exactly as you expect more often than other languages, so this failure really threw me.</p><p>Analysing the stack trace, we can see the failure starts at FromEntropy. My first instinct was that the WASM host didn&#39;t support providing entropy. I re-jigged the code to use a time-based seed instead and that failed too. The common theme seemed to be both entropy, and the current time, both make system calls.</p><p>Reading through the relevant Github issues which discuss this <a href=\"https://github.com/rustwasm/team/issues/16\">here</a> and <a href=\"https://github.com/rust-lang/rust/pull/47102\">here</a>, it looks like the design for how Rust generated WASM will handle system calls remains open. If the compiler isn&#39;t able to guarantee the system calls will be available, shouldn&#39;t the linker fail to compile? I think the answer lies in the <code>wasm-unknown-unknown</code> triplet that we compile to. There are no guarantees on what the target platform provides when you target unknown, so you&#39;re on your own.</p><p>That said, we know that the v8 JavaScript engine will be our host in both the browser, and in Workers. There are libraries which allow us to make all Web APIs defined in the ECMAScript standard available to Rust, such as <a href=\"https://rustwasm.github.io/wasm-bindgen/api/js_sys/index.html\">js-sys</a></p><p>Using that, I can rewrite the failing <code>get_rng()</code> method to return a pseudo-random number generated seed with a time-based value using the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\">Date</a> object provided by the JavaScript host, rather than making a system call. Full code listing is on <a href=\"https://github.com/stevenpack/bob-ross-lipsum-rust\">Github</a></p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">fn get_rng() -&gt; SmallRng {    \n    use js_sys::Date;\n    use rand::SeedableRng;\n\n\t//from Javascript\t\n    let ticks = Date::now(); \n    //convert the number to byte array to use as a seed\n    let tick_bytes = transmute(ticks as u128); \n    SmallRng::from_seed(tick_bytes)\n}</pre></code>\n            <p>After another <code>wasm-pack build</code> and reloading our test page...</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/4tQ0dr6wWPBgr5koG2NNXK/675a7c90e81a182a90d8a48dcd381c51/rust-wasm-random-phrases.png\" alt=\"Generating random phrases\" class=\"kg-image\" width=\"810\" height=\"444\" loading=\"lazy\"/>\n            \n            </figure><p>Huzzah! OK, if my WASM module returns the right output in Chrome, I&#39;m feeling good about it working in Workers.</p><h2>From local browser harness to Workers</h2><p>You can use the <a href=\"https://developers.cloudflare.com/workers/api/\">API</a> or UI to upload. Below, I upload the .wasm file in my /pkg director and bind it to the global variable BOBROSS_WASM, where it will be available in my Worker.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/32dpvCO880Ktl6yq92ZjmN/8b1956d8e31b5cbc6e129ad6fb231c44/rust-wasm-upload.png\" alt=\"Rust WASM upload\" class=\"kg-image\" width=\"571\" height=\"409\" loading=\"lazy\"/>\n            \n            </figure><p>If you&#39;re following and looked at the output of the <code>wasm-pack build</code> command, you might have noticed it produced a JavaScript glue file in the pkg folder, which is actually what the browser executed.</p><p>It looks like this:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">/* tslint:disable */\nimport * as wasm from &#039;./bob_ross_lorem_ipsum_rust_bg&#039;;\n\nlet cachedDecoder = new TextDecoder(&#039;utf-8&#039;);\n\nlet cachegetUint8Memory = null;\nfunction getUint8Memory() {\n    if (cachegetUint8Memory === null || cachegetUint8Memory.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory;\n}\n\nfunction getStringFromWasm(ptr, len) {\n    return cachedDecoder.decode(getUint8Memory().subarray(ptr, ptr + len));\n}\n\nexport function __wbg_alert_8c454b1ebc6068d7(arg0, arg1) {\n    let varg0 = getStringFromWasm(arg0, arg1);\n    alert(varg0);\n}\n/**\n* @returns {void}\n*/\nexport function greet() {\n    return wasm.greet();\n}\n\nlet cachedGlobalArgumentPtr = null;\nfunction globalArgumentPtr() {\n    if (cachedGlobalArgumentPtr === null) {\n        cachedGlobalArgumentPtr = wasm.__wbindgen_global_argument_ptr();\n    }\n    return cachedGlobalArgumentPtr;\n}\n\nlet cachegetUint32Memory = null;\nfunction getUint32Memory() {\n    if (cachegetUint32Memory === null || cachegetUint32Memory.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory;\n}\n/**\n* @param {number} arg0\n* @param {number} arg1\n* @returns {string}\n*/\nexport function get_phrase_text(arg0, arg1) {\n    const retptr = globalArgumentPtr();\n    wasm.get_phrase_text(retptr, arg0, arg1);\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n\n    const realRet = getStringFromWasm(rustptr, rustlen).slice();\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n    return realRet;\n\n}\n\nconst __wbg_now_4410283ed4cdb45a_target = Date.now.bind(Date) || function() {\n    throw new Error(`wasm-bindgen: Date.now.bind(Date) does not exist`);\n};\n\nexport function __wbg_now_4410283ed4cdb45a() {\n    return __wbg_now_4410283ed4cdb45a_target();\n}</pre></code>\n            <p>It takes care of the marshalling of strings from WASM into JavaScript and freeing the memory it uses. In an ideal world, we&#39;d just include this in our Worker and be done. However, there a few differences between how Workers instantiates WebAssembly modules and the browser.</p><p>You need to:</p><ul><li><p>Remove the import line</p></li><li><p>Remove the export keywords</p></li><li><p>Wrap all the functions in a module</p></li><li><p>Create an importObject referencing the methods</p></li><li><p>Pass that in when you create the WebAssembly instance</p></li></ul><p><i>Update 28-Dec-2018: wasm-bindgen has been updated since this post. See this </i><a href=\"https://github.com/stevenpack/bob-ross-lipsum-rust/pull/1\"><i>PR</i></a><i> if you&#39;re getting errors related to the glue code. Thanks </i><a href=\"https://github.com/andrewdavidmackenzie\"><i>Andrew</i></a><i>!</i></p><p>You can view a <a href=\"/content/images/2018/10/rust-wasm-local-vs-worker-diff.png\">side-by-side diff</a> or a <a href=\"https://github.com/stevenpack/bob-ross-lipsum-rust/blob/master/worker/glue-to-worker.patch\">patch</a> to see the changes required to have it run in a Worker. Include the modified glue code into your worker and you can now call it like any other function. (Thanks for the tip Jake Riesterer!)</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">// Request Handler\nasync function handleRequest(request) {\n\n    let url = new URL(request.url);\n\n    //Serve the UI\n    if (url.pathname === &quot;/&quot; ) {\n        let init = { &quot;status&quot; : 200 , &quot;headers&quot; : { &#039;Content-Type&#039;: &#039;text/html&#039; } };\n        return new Response(ui, init);\n    }\n\n    let phraseCount = Math.min(parseInt(url.searchParams.get(&quot;phrases&quot;) || 100), 10000);\n    let newLine = Math.min(parseInt(url.searchParams.get(&quot;newline&quot;) || 0), 10000);\n\n    //Serverless Rust in 150+ data centers!\n    let phraseText = mod.get_phrase_text(phraseCount, newLine);\n    return new Response(phraseText);\n}</pre></code>\n            <p>Success!</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/5uC0hcvIpB50a7w5p5NdOE/8df2e4bbaa50312ff149bcf67e18219c/rust-wasm-success.png\" alt=\"Serverless Rust on the Edge\" class=\"kg-image\" width=\"705\" height=\"354\" loading=\"lazy\"/>\n            \n            </figure><p>The full <a href=\"https://github.com/stevenpack/bob-ross-lipsum-rust/blob/master/worker/worker.js\">source code</a> is on Github.</p><h3>Summary</h3><p>We can compile Rust to WASM, and call it from Serverless functions woven into the very fabric of the Internet. That&#39;s huge and I can&#39;t wait to do more of it.</p><p>There&#39;s some wrangling of the generated code required, but the tooling will improve over time. Once you&#39;ve modified the glue code, calling a function in Rust generated WASM modules is just as simple as JavaScript.</p><p>Are we Serverless yet? Yes we are.</p><p>In a future post, I&#39;ll extract out the phrases and the UI to the <a href=\"https://developers.cloudflare.com/workers/kv/\">KV store</a> to show a full fledged serverless app powered by Rust and WASM.</p>",
		"id": "13Q5KDegAIrmgsWVwnbxbs",
		"localeList": {
			"name": "Serverless Rust with Cloudflare Workers Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": null,
		"metadata": {
			"imgPreview": ""
		},
		"primary_author": {},
		"published_at": "2018-10-16T13:00:00.000+01:00",
		"slug": "cloudflare-workers-as-a-serverless-rust-platform",
		"tags": [
			{
				"id": "6hbkItfupogJP3aRDAq6v8",
				"name": "Cloudflare Workers",
				"slug": "workers"
			},
			{
				"id": "5cye1Bh5KxFh3pKSnX8Dsy",
				"name": "Serverless",
				"slug": "serverless"
			},
			{
				"id": "w4e8pkoz9c8xNDVhy9eNe",
				"name": "Rust",
				"slug": "rust"
			},
			{
				"id": "6lhzEBz2B56RKa4nUEAGYJ",
				"name": "Programming",
				"slug": "programming"
			},
			{
				"id": "4HIPcb68qM0e26fIxyfzwQ",
				"name": "Developers",
				"slug": "developers"
			},
			{
				"id": "3JAY3z7p7An94s6ScuSQPf",
				"name": "Developer Platform",
				"slug": "developer-platform"
			}
		],
		"title": "Serverless Rust with Cloudflare Workers",
		"updated_at": "2024-08-27T02:17:44.494Z",
		"url": "https://blog.cloudflare.com/cloudflare-workers-as-a-serverless-rust-platform"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.blurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}