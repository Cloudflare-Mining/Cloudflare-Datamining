<div class="mb2 gray5">23 min read</div>
<div class="post-content lh-copy gray1">
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/2gD2K91FPRozZcsZ8Z56XU/3087cb66b729eeeff4c25d0280fde189/post-quantum-_1_2x.png" alt="" class="kg-image" width="1616" height="987" loading="lazy">

	</figure>
	<p>We live in a completely connected society. A society connected by a variety of devices: laptops, mobile phones, wearables, self-driving or self-flying <i>things</i>. We have standards for a common language that allows these devices to communicate with each other. This is critical for wide-scale deployment – especially in cryptography where the smallest detail has great importance.</p>
	<p>One of the most important standards-setting organizations is the National Institute of Standards and Technology (NIST), which is hugely influential in determining which standardized cryptographic systems see worldwide adoption. At the end of 2016, NIST announced it would hold a multi-year open project with the goal of standardizing new post-quantum (PQ) cryptographic algorithms secure against both quantum and classical computers.</p>
	<p>Many of our devices have very different requirements and capabilities, so it may not be possible to select a “one-size-fits-all” algorithm during the process. NIST mathematician, Dustin Moody, indicated that institute will likely select more than one algorithm:</p>
	<blockquote>
		<p><i>“There are several systems in use that could be broken by a quantum computer - public-key encryption and digital signatures, to take two examples - and we will need different solutions for each of those systems.”</i></p>
	</blockquote>
	<p>Initially, NIST selected 82 candidates for further consideration from all submitted algorithms. At the beginning of 2019, this process entered its second stage. Today, there are 26 algorithms still in contention.</p>
	<h3>Post-quantum cryptography: what is it really and why do I need it?</h3>
	<p>In 1994, Peter Shor made a significant <a href="https://arxiv.org/abs/quant-ph/9508027">discovery</a> in quantum computation. He found an algorithm for integer factorization and computing discrete logarithms, both believed to be hard to solve in classical settings. Since then it has become clear that the 'hard problems' on which cryptosystems like RSA and elliptic curve cryptography (ECC) rely – integer factoring and computing discrete logarithms, respectively – are efficiently solvable with quantum computing.</p>
	<p>A quantum computer can help to solve some of the problems that are intractable on a classical computer. In theory, they could efficiently solve some <a href="https://www.quantamagazine.org/finally-a-problem-that-only-quantum-computers-will-ever-be-able-to-solve-20180621">fundamental problems</a> in mathematics. This amazing computing power would be highly beneficial, which is why companies are actually trying to build quantum computers. At first, Shor’s algorithm was merely a theoretical result – quantum computers powerful enough to execute it did not exist – but this is quickly changing. In March 2018, Google announced a 72-qubit universal quantum computer. While this is not enough to break say RSA-2048 (still <a href="https://arxiv.org/abs/1905.09749">more is needed</a>), many fundamental problems have already been solved.</p>
	<p>In anticipation of wide-spread quantum computing, we must start the transition from classical public-key cryptography primitives to post-quantum (PQ) alternatives. It may be that consumers will never get to hold a quantum computer, but a few powerful attackers who will get one can still pose a serious threat. Moreover, under the assumption that current TLS handshakes and ciphertexts are being captured and stored, a future attacker could crack these stored individual session keys and use those results to decrypt the corresponding individual ciphertexts. Even strong security guarantees, like <a href="https://blog.cloudflare.com/staying-on-top-of-tls-attacks">forward secrecy</a>, do not help out much there.</p>
	<p>In 2006, the academic research community launched a conference series dedicated to finding alternatives to RSA and ECC. This so-called <i>post-quantum cryptography</i> should run efficiently on a classical computer, but it should also be secure against attacks performed by a quantum computer. As a research field, it has grown substantially in popularity.</p>
	<p>Several companies, including Google, Microsoft, Digicert and Thales, are already testing the impact of deploying PQ cryptography. Cloudflare is involved in some of this, but we want to be a company that leads in this direction. The first thing we need to do is understand the real costs of deploying PQ cryptography, and that’s not obvious at all.</p>
	<h3>What options do we have?</h3>
	<p>Many submissions to the NIST project are still under study. Some are very new and little understood; others are more mature and already standardized as RFCs. Some have been broken or withdrawn from the process; others are more conservative or <a href="https://eprint.iacr.org/2017/351.pdf">illustrate</a> how far classical cryptography would need to be pushed so that a quantum computer could not crack it within a reasonable cost. Some are very slow and big; others are not. But most cryptographic schemes can be categorized into these families: <a href="https://web.eecs.umich.edu/~cpeikert/pubs/lattice-survey.pdf">lattice-based</a>, <a href="http://www.cryptosystem.net/hfe.pdf">multivariate</a>, <a href="https://link.springer.com/content/pdf/10.1007%2F0-387-34805-0_21.pdf">hash-based</a> (signatures only), <a href="https://ipnpr.jpl.nasa.gov/progress_report2/42-44/44N.PDF">code-based</a> and <a href="https://eprint.iacr.org/2011/506.pdf">isogeny-based</a>.</p>
	<p>For some algorithms, nevertheless, there is a fear they may be too inconvenient to use with today’s Internet. We must also be able to integrate new cryptographic schemes with existing protocols, such as <a href="https://www.cloudflare.com/learning/access-management/what-is-ssh">SSH</a> or TLS. To do that, designers of PQ cryptosystems must consider these characteristics:</p>
	<ul>
		<li>
			<p>Latency caused by encryption and decryption on both ends of the communication channel, assuming a variety of devices from big and fast servers to slow and memory constrained IoT (Internet of Things) devices</p>
		</li>
		<li>
			<p>Small public keys and signatures to minimize bandwidth</p>
		</li>
		<li>
			<p>Clear design that allows cryptanalysis and determining weaknesses that could be exploited</p>
		</li>
		<li>
			<p>Use of existing hardware for fast implementation</p>
		</li>
	</ul>
	<p>The work on post-quantum public key cryptosystems must be done in a full view of organizations, governments, cryptographers, and the public. Emerging ideas must be properly vetted by this community to ensure widespread support.</p>
	<h3>Helping Build a Better Internet</h3>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/3oHEFoSgnIAeuq111tpnEw/be0a3db100bd430c620e7a8601ccc713/pasted-image-0-5.png" alt="" class="kg-image" width="1156" height="338" loading="lazy">

	</figure>
	<p>To better understand the post-quantum world, Cloudflare began experimenting with these algorithms and used them to provide confidentiality in TLS connections.</p>
	<p>With Google, we are proposing a wide-scale experiment that combines client- and server-side data collection to evaluate the performance of key-exchange algorithms on actual users’ devices. We hope that this experiment helps choose an algorithm with the best characteristics for the future of the Internet. With Cloudflare’s highly distributed network of access points and Google’s Chrome browser, both companies are in a very good position to perform this experiment.</p>
	<p>Our goal is to understand how these algorithms act when used by real clients over real networks, particularly candidate algorithms with significant differences in public-key or ciphertext sizes. Our focus is on how different key sizes affect handshake time in the context of Transport Layer Security (TLS) as used on the web over HTTPS.</p>
	<p>Our primary candidates are an NTRU-based construction called HRSS-SXY (by <b>H</b>ülsing - <b>R</b>ijneveld - <b>S</b>chanck - <b>S</b>chwabe, and Tsunekazu <b>S</b>aito - Keita <b>X</b>agawa - Takashi <b>Y</b>amakawa) and an isogeny-based Supersingular Isogeny Key Encapsulation (SIKE). Details of both algorithms are described in more detail below in section "Dive into post-quantum cryptography". This table shows a few characteristics for both algorithms. Performance timings were obtained by running the BoringSSL speed test on an Intel Skylake CPU.</p><!--kg-card-begin: html-->
	<table>
		<tbody>
			<tr>
				<th>KEM</th>
				<th>Public Key size (bytes)</th>
				<th>Ciphertext (bytes)</th>
				<th>Secret size (bytes)</th>
				<th>KeyGen (op/sec)</th>
				<th>Encaps (op/sec)</th>
				<th>Decaps (op/sec)</th>
				<th>NIST level</th>
			</tr>
			<tr>
				<td>HRSS-SXY</td>
				<td>1138</td>
				<td>1138</td>
				<td>32</td>
				<td>3952.3</td>
				<td>76034.7</td>
				<td>21905.8</td>
				<td>1</td>
			</tr>

			<tr>
				<td>SIKE/p434</td>
				<td>330</td>
				<td>346</td>
				<td>16</td>
				<td>367.1</td>
				<td>228.0</td>
				<td>209.3</td>
				<td>1</td>
			</tr>
		</tbody>
	</table><!--kg-card-end: html-->
	<p>Currently the most commonly used key exchange algorithm (according to Cloudflare’s data) is the non-quantum X25519. Its public keys are 32 bytes and BoringSSL can generate 49301.2 key pairs, and is able to perform 19628.6 key agreements every second on my Skylake CPU.</p>
	<p>Note that HRSS-SXY shows a significant speed advantage, while SIKE has a size advantage. In our experiment, we will deploy these two algorithms on both the server side using Cloudflare’s infrastructure, and the client side using Chrome Canary; both sides will collect telemetry information about TLS handshakes using these two PQ algorithms to see how they perform in practice.</p>
	<h3>What do we expect to find?</h3>
	<p>In 2018, Adam Langley conducted an <a href="https://www.imperialviolet.org/2018/04/11/pqconftls.html">experiment</a> with the goal of evaluating the likely latency impact of a post-quantum key exchange in TLS. Chrome was augmented with the ability to include a dummy, arbitrarily-sized extension in the TLS ClientHello (fixed number of bytes of random noise). After taking into account the performance and key size offered by different types key-exchange schemes, he concluded that constructs based on structured lattices may be most suitable for future use in TLS.</p>
	<p>However, Langley also observed a peculiar phenomenon; client connections measured at 95th percentile had much higher latency than the median. It means that in those cases, isogeny-based systems may be a better choice. In the "Dive into post-quantum cryptography", we describe the difference between isogeny-based SIKE and lattice-based NTRU cryptosystems.</p>
	<p>In our experiment, we want to more thoroughly evaluate and ascribe root causes to these unexpected latency increases. We would particularly like to learn more about the characteristics of those networks: what causes increased latency? how does the performance cost of isogeny-based algorithms impact the TLS handshake? We want to answer key questions, like:</p>
	<ul>
		<li>
			<p>What is a good ratio for speed-to-key size (or how much faster could SIKE get to achieve the client-perceived performance of HRSS)?</p>
		</li>
		<li>
			<p>How do network middleboxes behave when clients use new PQ algorithms, and which networks have problematic middleboxes?</p>
		</li>
		<li>
			<p>How do the different properties of client networks affect TLS performance with different PQ key exchanges? Can we identify specific autonomous systems, device configurations, or network configurations that favor one algorithm over another? How is performance affected in the long tail?</p>
		</li>
	</ul>
	<h3>Experiment Design</h3>
	<p>Our experiment will involve both server- and client-side performance statistics collection from real users around the world (all the data is anonymized). Cloudflare is operating the server-side TLS connections. We will enable the <a href="https://www.imperialviolet.org/2018/12/12/cecpq2.html">CECPQ2</a> (HRSS + X25519) and <a href="https://tools.ietf.org/html/draft-kiefer-tls-ecdhe-sidh-00">CECPQ2b</a> (SIKE + X25519) key-agreement algorithms on all TLS-terminating edge servers.</p>
	<p>In this experiment, the ClientHello will contain a CECPQ2 or CECPQ2b public key (but never both). Additionally, Chrome will always include X25519 for servers that do not support post-quantum key exchange. The post-quantum key exchange will only be negotiated in TLS version 1.3 when both sides support it.</p>
	<p>Since Cloudflare only measures the server side of the connection, it is impossible to determine the time it takes for a ClientHello sent from Chrome to reach Cloudflare’s edge servers; however, we can measure the time it takes for the TLS ServerHello message containing post-quantum key exchange, to reach the client and for the client to respond.</p>
	<p>On the client side, Chrome Canary will operate the TLS connection. Google will enable either CECPQ2 or CECPQ2b in Chrome for the following mix of architecture and OSes:</p>
	<ul>
		<li>
			<p>x86-64: Windows, Linux, macOS, ChromeOS</p>
		</li>
		<li>
			<p>aarch64: Android</p>
		</li>
	</ul>
	<p>Our high-level expectation is to get similar results as Langley’s original experiment in 2018 — slightly increased latency for the 50th percentile and higher latency for the 95th. Unfortunately, data collected purely from real users’ connections may not suffice for diagnosing the root causes of why some clients experience excessive slowdown. To this end, we will perform follow-up experiments based on per-client information we collect server-side.</p>
	<p>Our primary hypothesis is that excessive slowdowns, like those Langley observed, are largely due to in-network events, such as middleboxes or bloated/lossy links. As a first-pass analysis, we will investigate whether the slowed-down clients share common network features, like common ASes, common transit networks, common link types, and so on. To determine this, we will run a traceroute from vantage points close to our servers back toward the clients (not overloading any particular links or hosts) and study whether some client locations are subject to slowdowns for all destinations or just for some.</p>
	<h3>Dive into post-quantum cryptography</h3>
	<p>Be warned: the details of PQ cryptography may be quite complicated. In some cases it builds on classical cryptography, and in other cases it is completely different math. It would be rather hard to describe details in a single blog post. Instead, we are giving you an intuition of post-quantum cryptography, rather than provide deep academic-level descriptions. We’re skipping a lot of details for the sake of brevity. Nevertheless, settle in for a bit of an epic journey because we have a lot to cover.</p>
	<h3>Key encapsulation mechanism</h3>
	<p>NIST requires that all key-agreement algorithms have a form of key-encapsulation mechanism (KEM). The KEM is a simplified form of public key encryption (PKE). As PKE, it also allows agreement on a secret, but in a slightly different way. The idea is that the session key is an output of the encryption algorithm, conversely to public key encryption schemes where session key is an input to the algorithm. In a KEM, Alice generates a random key and uses the pre-generated public key from Bob to encrypt (encapsulate) it. This results in a ciphertext sent to Bob. Bob uses his private key to decrypt (decapsulate) the ciphertext and retrieve the random key. The idea was initially introduced by <a href="https://eprint.iacr.org/2001/108">Cramer and Shoup</a>. Experience shows that such constructs are easier to design, analyze, and implement as the scheme is limited to communicating a fixed-size session key. Leonardo Da Vinci said, “Simplicity is the ultimate sophistication,” which is very true in cryptography.</p>
	<p>The key exchange (KEX) protocol, like <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Diffie-Hellman</a>, is yet a different construct: it allows two parties to agree on a shared secret that can be used as a symmetric encryption key. For example, Alice generates a key pair and sends a public key to Bob. Bob does the same and uses his own key pair with Alice’s public key to generate the shared secret. He then sends his public key to Alice who can now generate the same shared secret. What’s worth noticing is that both Alice and Bob perform exactly the same operations.</p>
	<p>KEM construction can be converted to KEX. Alice performs key generation and sends the public key to Bob. Bob uses it to encapsulate a symmetric session key and sends it back to Alice. Alice decapsulates the ciphertext received from Bob and gets the symmetric key. This is actually what we do in our experiment to make integration with the TLS protocol less complicated.</p>
	<h3>NTRU Lattice-based Encryption &nbsp;</h3>
	<p>We will enable the CECPQ2 implemented by Adam Langley from Google on our servers. He described this implementation in detail <a href="https://www.imperialviolet.org/2018/12/12/cecpq2.html">here</a>. This key exchange uses the HRSS algorithm, which is based on the NTRU (<b>N</b>-Th Degree <b>TRU</b>ncated Polynomial Ring) algorithm. Foregoing too much detail, I am going to explain how NTRU works and give simplified examples, and finally, compare it to HRSS.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/3mw4chMg1bmziLfBeRywAo/647988008e68bd97dede606f8d6eb6cc/polynomial-wheel_3x-1.png" alt="" class="kg-image" width="1600" height="1568" loading="lazy">

	</figure>
	<p>NTRU is a cryptosystem based on a polynomial ring. This means that we do not operate on numbers modulo a prime (like in RSA), but on polynomials of degree \( N \) , where the <i>degree</i> of a polynomial is the highest exponent of its variable. For example, \(x^7 + 6x^3 + 11x^2 \) has degree of 7.</p>
	<p>One can add polynomials in the ring in the usual way, by simply adding theirs coefficients modulo some integer. In NTRU this integer is called \( q \). Polynomials can also be multiplied, but remember, you are operating in the ring, therefore the result of a multiplication is always a polynomial of degree less than \(N\). It basically means that exponents of the resulting polynomial are added to modulo \(N\).</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/4fjc31dekJkPOBmLSlnJPS/235528f7c7d1845713ec06680c6e2598/1feQoHE5ePfzDfdzw01q3eQDZz6gCs6znHlzj24ThULscNMsvS6kdmoN0diX9cGbcpcB6T7WbUk5v1vdfLB1vSWizK3LFpW3b_4lNY6i-BwIEAtVdp1wCz-D85gC.png" alt="" class="kg-image" width="204" height="61" loading="lazy">

	</figure>
	<p>In other words, polynomial ring arithmetic is very similar to modular arithmetic<a href="https://betterexplained.com/articles/fun-with-modular-arithmetic">,</a> but instead of working with a set of numbers less than <i>N</i>, you are working with a set of polynomials with a degree less than <i>N</i>.</p>
	<p>To instantiate the NTRU cryptosystem, three domain parameters must be chosen:</p>
	<ul>
		<li>
			<p>\(N\) - degree of the polynomial ring, in NTRU the principal objects are polynomials of degree \(N-1\).</p>
		</li>
		<li>
			<p>\(p\) - small modulus used during key generation and decryption for reducing message coefficients.</p>
		</li>
		<li>
			<p>\(q\) - large modulus used during algorithm execution for reducing coefficients of the polynomials.</p>
		</li>
	</ul>
	<p>First, we generate a pair of public and private keys. To do that, two polynomials \(f\) and \(g\) are chosen from the ring in a way that their randomly generated coefficients are much smaller than \(q\). Then key generation computes two inverses of the polynomial: $$ f_p= f^{-1} \bmod{p} &nbsp; \\ &nbsp;f_q= f^{-1} \bmod{q} $$</p>
	<p>The last step is to compute $$ pk = p\cdot f_q\cdot g \bmod q $$, which we will use as public key <i>pk</i>. The private key consists of \(f\) and \(f_p\). The \(f_q\) is not part of any key, however it must remain secret.</p>
	<p>It might be the case that after choosing \(f\), the inverses modulo \(p\) and \( q \) do not exist. In this case, the algorithm has to start from the beginning and generate another \(f\). That’s unfortunate because calculating the inverse of a polynomial is a costly operation. HRSS brings an improvement to this issue since it ensures that those inverses always exist, making key generation faster than as proposed initially in NTRU.</p>
	<p>The encryption of a message \(m\) proceeds as follows. First, the message \(m\) is converted to a ring element \(pt\) (there exists an algorithm for performing this conversion in both directions). During encryption, NTRU randomly chooses one polynomial \(b\) called <i>blinder.</i> The goal of the blinder is to generate different ciphertexts per encyption. Thus, the ciphetext \(ct\) is obtained as $$ ct = (b\cdot pk + pt ) \bmod q $$ Decryption looks a bit more complicated but it can also be easily understood. Decryption uses both the secret value \(f\) and to recover the plaintext as $$ v = &nbsp;f \cdot ct \bmod q \\ pt = v \cdot f_p \bmod p $$</p>
	<p>This diagram demonstrates why and how decryption works.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/3m4bNrzq0NQFYpTObXuHYj/a0a31d23d5719664221a7a0e43f6ff9d/image-24.png" alt="" class="kg-image" width="700" height="355" loading="lazy">

	</figure>
	<p>Step-by-step correctness of decryption procedure.</p>
	<p>After obtaining \(pt\), the message \(m\) is recovered by inverting the conversion function.</p>
	<p>The underlying hard assumption is that given two polynomials: \(f\) and \(g\) whose coefficients are short compared to the modulus \(q\), it is difficult to distinguish \(pk = \frac{f}{g} \) from a random element in the ring. It means that it’s hard to find \(f\) and \(g\) given only public key <i>pk</i>.</p>
	<h3>Lattices</h3>
	<p>NTRU cryptosystem is a grandfather of lattice-based encryption schemes. The idea of using &nbsp;difficult problems for cryptographic purposes was due to <a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=144BBB9F0E87EF0D471151F0EACC7DB8?doi=10.1.1.40.2489&amp;rep=rep1&amp;type=pdf">Ajtai</a>. His work evolved into a whole area of research with the goal of creating more practical, lattice-based cryptosystems.</p>
	<h3>What is a lattice and why it can be used for post-quantum crypto?</h3>
	<p>The picture below visualizes lattice as points in a two-dimensional space. A lattice is defined by the origin \(O\) and base vectors \( \{ b_1 , b_2\} \). Every point on the lattice is represented as a linear combination of the base vectors, for example &nbsp;\(V = -2b_1+b_2\).</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/40Fg69tL7QYjTIzHk5s0z2/e984c766f1a40bbeb1946ff72d6b34c7/pasted-image-0--1--3.png" alt="" class="kg-image" width="787" height="460" loading="lazy">

	</figure>
	<p>There are two classical NP-hard problems in lattice-based cryptography:</p>
	<ol>
		<li>
			<p><b>Shortest Vector Problem</b> (SVP): Given a lattice, to find the shortest non-zero vector in the lattice. In the graph, the vector \(s\) is the shortest one. The SVP problem is NP-hard only under some assumptions.</p>
		</li>
		<li>
			<p><b>Closest Vector Problem</b> (CVP). Given a lattice and a vector \(V\) (not necessarily in the lattice), to find the closest vector to \(V\)<i>.</i> For example, the closest vector to \(t\) is \(z\).</p>
		</li>
	</ol>
	<p>In the graph above, it is easy for us to solve SVP and CVP by simple inspection. However, the lattices used in cryptography have higher dimensions, say above 1000, as well as highly non-orthogonal basis vectors. On these instances, the problems get extremely hard to solve. It’s even believed future quantum computers will have it tough.</p>
	<h3>NTRU vs HRSS</h3>
	<p>HRSS, which we use in our experiment, is based on NTRU, but a slightly better instantiation. The main improvements are:</p>
	<ul>
		<li>
			<p>Faster key generation algorithm.</p>
		</li>
		<li>
			<p>NTRU encryption can produce ciphertexts that are impossible to decrypt (true for many lattice-based schemes). But HRSS fixes this problem.</p>
		</li>
		<li>
			<p>HRSS is a key encapsulation mechanism.</p>
		</li>
	</ul>
	<h3>CECPQ2b - Isogeny-based Post-Quantum TLS</h3>
	<p>Following CECPQ2, we have integrated into BoringSSL another hybrid key exchange mechanism relying on SIKE. It is called CECPQ2b and we will use it in our experimentation in TLS 1.3. <a href="https://sike.org">SIKE</a> is a key encapsulation method based on Supersingular Isogeny Diffie-Hellman (SIDH). Read more about <a href="https://blog.cloudflare.com/sidh-go">SIDH</a> in our previous post. The math behind SIDH is related to elliptic curves. A comparison between SIDH and the classical Elliptic Curve Diffie-Hellman (ECDH) is given.</p>
	<p>An elliptic curve is a set of points that satisfy a specific mathematical equation. The equation of an elliptic curve may have multiple forms, the standard form is called the <i>Weierstrass</i> equation $$ y^2 = x^3 +ax +b &nbsp;$$ and its shape can look like the red curve.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/26PHEagKtiaocOpyT6e85j/a5452f4a29e7ff1701017052cab0b14e/pasted-image-0--2--3.png" alt="" class="kg-image" width="409" height="410" loading="lazy">

	</figure>
	<p>An interesting fact about elliptic curves is have a group structure. That is, the set of points on the curve have associated a binary operation called <i>point addition</i>. The set of points on the elliptic curve is closed under addition. Thus, adding two points results in another point that is also on the elliptic curve.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/65C2RgCyQ7TG84QUa4kYkd/d99b22cf2bc16197bf30cda24132314b/ecc.gif" alt="" class="kg-image" width="410" height="410" loading="lazy">

	</figure>
	<p>If we can add two different points on a curve, then we can also add one point to itself. And if we do it multiple times, then the resulting operations is known as a <i>scalar multiplication</i> and denoted as &nbsp;<i>\(Q = k\cdot P = P+P+\dots+P\)</i> for an integer \(k\).</p>
	<p>Multiplication of scalars is <i>commutative</i>. It means that two scalar multiplications can be evaluated in any order \( \color{darkred}{k_a}\cdot\color{darkgreen}{k_b} = &nbsp; \color{darkgreen}{k_b}\cdot\color{darkred}{k_a} \); this an important property that makes ECDH possible.</p>
	<p>It turns out that carefully if choosing an elliptic curve "correctly", scalar multiplication is easy to compute but extremely hard to reverse. Meaning, given two points \(Q\) and \(P\) such that \(Q=k\cdot P\), finding the integer k is a difficult task known as the Elliptic Curve Discrete Logarithm problem (ECDLP). This problem is suitable for cryptographic purposes.</p>
	<p>Alice and Bob agree on a secret key as follows. Alice generates a private key \( k_a\). Then, she uses some publicly known point \(P\) and calculates her public key as \( Q_a = k_a\cdot P\). Bob proceeds in similar fashion and gets \(k_b\) and \(Q_b = k_b\cdot P\). To agree on a shared secret, each party multiplies their private key with the public key of the other party. The result of this is the shared secret. Key agreement as described above, works thanks to the fact that scalars can commute:$$ &nbsp;\color{darkgreen}{k_a} \cdot Q_b = \color{darkgreen}{k_a} \cdot &nbsp;\color{darkred}{k_b} \cdot P \iff \color{darkred}{k_b} \cdot \color{darkgreen}{k_a} \cdot P = \color{darkred}{k_b} \cdot Q_a $$</p>
	<p>There is a vast theory behind elliptic curves. An introduction to <a href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography">elliptic curve cryptography</a> was posted before and more details can be found in this <a href="https://doi.org/10.1007/b97644">book</a>. Now, lets describe SIDH and compare with ECDH.</p>
	<h3>Isogenies on Elliptic Curves</h3>
	<p>Before explaining the details of SIDH key exchange, I’ll explain the 3 most important concepts, namely: <b><i>j-invariant, isogeny</i></b> and its <b><i>kernel.</i></b></p>
	<p>Each curve has a number that can be associated to it. Let’s call this number a <b><i>j-invariant.</i></b> This number is not unique per curve, meaning many curves have the same value of <b><i>j-invariant</i></b>, but it can be viewed as a way to group multiple elliptic curves into disjoint sets. We say that two curves are <b><i>isomorphic</i></b> if they are in the same set, called the <i>isomorphism class</i>. The j-invariant is a simple criterion to determine whether two curves are isomorphic. The j-invariant of a curve \(E\) in Weierstrass form \( y^2 = x^3 + ax + b\) is given as $$ j(E) = 1728\frac{4a^3}{4a^3 +27b^2} $$</p>
	<p>When it comes to <b><i>isogeny</i></b>, think about it as a map between two curves. Each point on some curve \( E \) is mapped by isogeny to the point on isogenous curve \( E' \). We denote mapping from curve \( E \) to \( E' \) by isogeny \( \phi \) as:</p>
	<p>$$\phi: E \rightarrow E' $$</p>
	<p>It depends on the map if those two curves are isomorphic or not. Isogeny can be visualised as:</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/4RSE4DdJxSwP5IspNUpc8D/d740de311582369c57f7a7647d9305eb/pasted-image-0--3--2.png" alt="" class="kg-image" width="336" height="150" loading="lazy">

	</figure>
	<p>There may exist many of those mappings, each curve used in SIDH has small number of isogenies to other curves. Natural question is how do we compute such isogeny. Here is where the <b><i>kernel</i></b> of an isogeny comes. The <b><i>kernel</i></b> uniquely determines isogeny (up to <i>isomorphism class</i>). Formulas for calculating isogeny from its kernel were initially <a href="https://www.researchgate.net/publication/246557704_Isogenies_entre_courbes_elliptiques">given by J. Vélu</a> and the idea of calculating them efficiently was <a href="https://eprint.iacr.org/2017/504.pdf">extended</a>.</p>
	<p>To finish, I will summarize what was said above with a picture.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/240s5FQy6PHpVMswhLAnAg/4e0424bbc4861eee65bf61cdae4792f9/pasted-image-0--4--2.png" alt="" class="kg-image" width="480" height="278" loading="lazy">

	</figure>
	<p>There are two <b>isomorphism classes</b> on the picture above. Both curves \(E_1\) and \(E_2\) are <b>isomorphic</b> and have &nbsp;j-invariant = 6. As curves \(E_3\) and \(E_4\) have j-invariant=13, they are in a different isomorphism class. There exists an <b>isogeny</b> \(\phi_2\) between curve \(E_3\) and \(E_2\), so they both are <b>isogeneous</b>. Curves \( \phi_1 \) and \( E_2 \) are isomorphic and there is isogeny \( \phi_1 \) between them. Curves \( E_1\) and \(E_4\) are not isomorphic.</p>
	<p>For brevity I’m skipping many important details, like details of the <i>finite field,</i> the fact that isogenies must be <i>separable</i> and that the kernel is <i>finite.</i> But curious readers can find a number of academic research papers available on the Internet.</p>
	<h3>Big picture: similarities with ECDH</h3>
	<p>Let’s generalize the ECDH algorithm described above, so that we can swap some elements and try to use Supersingular Isogeny Diffie-Hellman.</p>
	<p>Note that what actually happens during an ECDH key exchange is:</p>
	<ul>
		<li>
			<p>We have a set of points on elliptic curve, set <i>S</i></p>
		</li>
		<li>
			<p>We have another group of integers used for point multiplication, G</p>
		</li>
		<li>
			<p>We use an element from <i>Z</i> to act on an element from <i>S</i> to get another element from <i>S</i>:</p>
		</li>
	</ul>
	<p>$$ G \cdot S \rightarrow S $$</p>
	<p>Now the question is: what is our <i>G</i> and <i>S</i> in an SIDH setting? For SIDH to work, we need a big set of elements and something secret that will act on the elements from that set. This “group action” must also be resistant to attacks performed by quantum computers.</p>
	<p>In the SIDH setting, those two sets are defined as:</p>
	<ul>
		<li>
			<p>Set <i>S</i> is a set (graph) of j-invariants, such that all the curves are supersingular: \( S = [j(E_1), j(E_2), j(E_3), .... , j(E_n)]\)</p>
		</li>
		<li>
			<p>Set <i>G</i> is a set of isogenies acting on elliptic curves and transforming, for example, the elliptic curve \(E_1\) into \(E_n\):</p>
		</li>
	</ul>
	<h3>Random walk on supersingular graph</h3>
	<p>When we talk about <i>Isogeny Based Cryptography</i>, as a topic distinct from <i>Elliptic Curve Cryptography</i>, we usually mean algorithms and protocols that rely fundamentally on the structure of isogeny graphs. An example of such a (small) graph is pictured below.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/3VatBy9An0gtSVOCUZBdjG/bc7a2882a5c99a56de78eadd0f840443/isogeny-based-crypt0-1-.gif" alt="" class="kg-image" width="600" height="406" loading="lazy">

	</figure>
	<p>Animation based on Chloe Martindale <a href="https://2017.pqcrypto.org/school/slides/Isogeny_based_crypto.pdf">slide deck</a></p>
	<p>Each vertex of the graph represents a different j-invariant of a set of supersingular curves. The edges between vertices represent isogenies converting one elliptic curve to another. As you can notice, the graph is strongly connected, meaning every vertex can be reached from every other vertex. In the context of isogeny-based crypto, we call such a graph a <a href="https://en.wikipedia.org/wiki/Supersingular_isogeny_graph"><i>supersingular isogeny graph</i></a>. I’ll skip some technical details about the construction of this graph (look for those <a href="https://eprint.iacr.org/2011/506.pdf">here</a> or <a href="http://iml.univ-mrs.fr/~kohel/pub/thesis.pdf">here</a>), but instead describe ideas about how it can be used.</p>
	<p>As the graph is strongly connected, it is possible to <i>walk</i> a whole graph by starting from any vertex, randomly choosing an edge, following it to the next vertex and then start the process again on a new vertex. Such a way of visiting edges of this graph is called a <i>random walk.</i></p>
	<p>The random walk is a key concept that makes isogeny based crypto feasible. When you look closely at the graph, you can notice that each vertex has a small number of edges incident to it, this is why we can compute the isogenies efficiently. But also for any vertex there is only a limited number of isogenies to choose from, which doesn’t look like good base for a cryptographic scheme. The key question is - where does the security of the scheme come from exactly? In order to get it, it is necessary to visit a couple hundred vertices. What it means in practice is that secret isogeny (of <i>large degree</i>) is constructed as a composition of multiple isogenies (of <i>small, prime degree</i>). &nbsp;Which means, the secret isogeny is:</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/7pTiHpzM9xu84YbuXZozv8/90bd95dcd53a7bedb14d36fff26a36f9/CtdsWhxZs8vr7nj6LJCQhh4Mu3mP5VF5U2ayMvqZ_LVXIRBsVuduM2QwTsuy8V1izo53I5JcAFc0z6eA1LYP4FsviY4g_fqiDJc2-s8vZE_eHQGp6aQQrlhsdDDu.png" alt="" class="kg-image" width="344" height="25" loading="lazy">

	</figure>
	<p>This property and properties of the isogeny graph are <b>what makes</b> some of us believe that <b>scheme</b> has a good chance to be <b>secure</b><b><i>.</i></b> More specifically, there is no efficient way of finding a path that connects \( E_0 \) with \( E_n \), even with quantum computer at hand. The security level of a system depends on value <i>n</i> - the number of steps taken during the walk.</p>
	<p>The random walk is a core process used when both generating public keys and computing shared secrets. It starts with party generating random value <i>m</i> (see more below), starting curve \(E_0\) and points P and Q on this curve. Those values are used to compute the kernel of an isogeny \( R_1 \) in the following way:</p>
	<p>$$ R_1 = P + m \cdot Q $$</p>
	<p>Thanks to formulas given by <a href="https://www.researchgate.net/publication/246557704_Isogenies_entre_courbes_elliptiques">Vélu</a> we can now use the point \( R_1 \) to compute the isogeny, the party will choose to move from a vertex to another one. After the isogeny \( \phi_{R_1} \) is calculated it is applied to \( E_0 \) &nbsp;which results in a new curve \( E_1 \):</p>
	<p>$$ \phi_{R_1}: E_0 \rightarrow E_1 $$</p>
	<p>Isogeny is also applied to points P and Q. Once on \( E_1 \) the process is repeated. This process is applied <i>n</i> times, and at the end a party ends up on some curve \( E_n \) which defines isomorphism class, so also j-invariant.</p>
	<h3>Supersingular Isogeny Diffie-Hellman</h3>
	<p>The core idea in SIDH is to compose two random walks on an isogeny graph of elliptic curves in such a way that the end node of both ways of composing is the same.</p>
	<p>In order to do it, scheme sets public parameters - starting curve \( E_0 \) and 2 pairs of base points on this curve <i>\( (PA,QA) \)</i> , <i>\( (PB,QB) \)</i>. Alice generates her random secret keys <i>m,</i> and calculates a secret isogeny \( \phi_q \) by performing a <i>random walk</i> as described above. The walk finishes with 3 values: elliptic curve \( E_a \) she has ended up with and pair of points \( \phi_a(PB) \) and \( \phi_a(QB) \) after pushing through Alice’s secret isogeny. Bob proceeds analogously which results in the triple \( {E_b, \phi_b(PA), \phi_b(QA)} \). The triple forms a public key which is exchanged between parties.</p>
	<p>The picture below visualizes the operation. The black dots represent curves grouped in the same <i>isomorphism classes</i> represented by light blue circles. Alice takes the orange path ending up on a curve \( E_a \) in a separate isomorphism class than Bob after taking his dark blue path ending on \( E_b \). SIDH is parametrized in a way that Alice and Bob will always end up in different isomorphism classes.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/4coOPO3i8W2RxZpT8aS4Th/e5c750c91c40fa3fdd1c0f56e85caedb/pasted-image-0--5--2.png" alt="" class="kg-image" width="625" height="486" loading="lazy">

	</figure>
	<p>Upon receipt of triple \( { E_a, \phi_a(PB), \phi_a(QB) } \) &nbsp;from Alice, Bob will use his secret value <i>m</i> to calculate a new kernel - but instead of using point \(PA\) and \(QA\) to calculate an isogeny kernel, he will now use images \( \phi_a(PB) \) and \( \phi_a(QB) \) received from Alice:</p>
	<p>$$ R’_1 = \phi_a(PB) + m \cdot \phi_a(QB) $$</p>
	<p>Afterwards, he uses \( R’_1 \) to start the walk again resulting in the isogeny \( \phi’_b: E_a \rightarrow E_{ab} \). Allice proceeds analogously resulting in the isogeny \(\phi’_a: E_b \rightarrow E_{ba} \). With isogenies calculated this way, both Alice and Bob will converge in the same isomorphism class. The math math may seem complicated, hopefully the picture below makes it easier to understand.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/2o7VmACLF5SYhrydaRyBRo/1a4389d9196c137d1577e4a6954806fc/pasted-image-0--6--2.png" alt="" class="kg-image" width="660" height="486" loading="lazy">

	</figure>
	<p>Bob computes a new isogeny and starts his random walk from \( E_a \) received from Alice. He ends up on some curve \(E_{ba}\). Similarly, Alice calculates a new isogeny, applies it on \( E_b \) received from Bob and her random walk ends on some curve \(E_{ab}\). Curves \(E_{ab}\) and \(E_{ba}\) are not likely to be the same, but construction guarantees that they are isomorphic_._ As mentioned earlier, isomorphic curves have the same value of j-invariant, &nbsp;hence the shared secret is a value of j-invariant \(j(E_{ab})\).</p>
	<p>Coming back to differences between SIDH and ECDH - we can split them into four categories: the elements of the group we are operating on, the cornerstone computation required to agree on a shared secret, the elements representing secret values, and the difficult problem on which the security relies.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/4JOy8niIRMJP7yIY0hAcoE/034a706b8d458f15048d514174321551/pasted-image-0--7--2.png" alt="" class="kg-image" width="601" height="221" loading="lazy">

	</figure>
	<p>Comparison based on Craig Costello’ s <a href="http://www.craigcostello.com.au/wp-content/uploads/Craig-isogenies-tutorial.pdf">slide deck</a>.</p>
	<p>In ECDH there is a secret key which is an integer scalar, in case of SIDH it is a secret isogeny, which also is generated from an integer scalar. In the case of ECDH one multiplies a point on a curve by a scalar, in the case of SIDH it is a random walk in an isogeny graph. In the case of ECDH, the public key is a point on a curve, in the case of SIDH, the public part is a curve itself and the image of some points after applying isogeny. The shared secret in the case of ECDH is a point on a curve, in the case of SIDH it is a j-invariant.</p>
	<h3>SIKE: Supersingular Isogeny Key Encapsulation</h3>
	<p>SIDH could potentially be used as a drop-in replacement of the ECDH protocol. We have actually implemented a proof-of-concept and added it to our implementation of TLS 1.3 in the <a href="https://github.com/cloudflare/tls-tris">tls-tris</a> library and described (together with Mozilla) implementation details in this <a href="https://tools.ietf.org/html/draft-kiefer-tls-ecdhe-sidh-00">draft</a>. Nevertheless, there is a problem with SIDH - the keys can be used only once. In 2016, a few researchers came up with an active <a href="https://eprint.iacr.org/2016/859">attack</a> on SIDH which works only when public keys are reused. In the context of TLS, it is not a big problem, because for each session a fresh key pair is generated (ephemeral keys), but it may not be true for other applications.</p>
	<p>SIKE is an isogeny key encapsulation which solves this problem. Bob can generate SIKE keys, upload the public part somewhere in the Internet and then anybody can use it whenever he wants to communicate with Bob securely. SIKE reuses SIDH - internally both sides of the connection always perform SIDH key generation, SIDH key agreement and apply some other cryptographic primitives in order to convert SIDH to KEM. SIKE is implemented in a few variants - each variant corresponds to the security levels using 128-, 192- and 256-bit secret keys. Higher security level means longer running time. More details about SIKE can be found <a href="https://sike.org">here</a>.</p>
	<p>SIKE is also one of the candidates in NIST post-quantum "<a href="https://csrc.nist.gov/Projects/Post-Quantum-Cryptography">competition</a>".</p>
	<p>I’ve skipped many important details to give a brief description of how isogeny based crypto works. If you’re curious and hungry for details, look at either of these Cloudflare <a href="https://www.youtube.com/watch?v=ctP24WKusX0">meetups</a>, where Deirdre Connolly talked about isogeny-based cryptography or this <a href="https://videos.2017.pqcrypto.org/school/#martindale1">talk</a> by Chloe Martindale during PQ Crypto School 2017. And if you would like to know more about quantum attacks on this scheme, I highly recommend <a href="https://eprint.iacr.org/2019/103.pdf">this</a> work.</p>
	<h2>Conclusion</h2>
	<p>Quantum computers that can break meaningful cryptographic parameter settings do not exist, yet. They won't be built for at least the next few years. Nevertheless, they have already changed the way we look at current cryptographic deployments. There are at least two reasons it’s worth investing in PQ cryptography:</p>
	<ul>
		<li>
			<p>It takes a lot of time to build secure cryptography and we don’t actually know when today’s classical cryptography will be broken. There is a need for a good mathematical base: an initial idea of what may be secure against something that doesn't exist yet. If you have an idea, you also need good implementation, constant time, resistance to things like <a href="https://www.paulkocher.com/doc/TimingAttacks.pdf">time</a> and <a href="https://www.youtube.com/watch?v=fLEjSU1a748">cache</a> <a href="https://en.wikipedia.org/wiki/Side-channel_attack">side-channels</a>, <a href="https://link.springer.com/content/pdf/10.1007%2FBFb0052259.pdf">DFA</a>, <a href="https://link.springer.com/content/pdf/10.1007%2Fs13389-011-0006-y.pdf">DPA</a>, <a href="https://en.wikipedia.org/wiki/Electromagnetic_attack">EM</a>, and a bunch of other abbreviations indicating <a href="https://csrc.nist.gov/csrc/media/events/physical-security-testing-workshop/documents/papers/physecpaper19.pdf">side-channel</a> resistance. There is also deployment of, for example, algorithms based on elliptic curves were introduced in '85, but started to really be used in production only during the last decade, 20 or so years later. Obviously, the implementation must be blazingly fast! Last, but not least, integration: we need time to develop standards to allow integration of PQ cryptography with protocols like TLS.</p>
		</li>
		<li>
			<p>Even though efficient quantum computers probably won't exist for another few years, the threat is real. Data encrypted with current cryptographic algorithms can be recorded now with hopes of being broken in the future.</p>
		</li>
	</ul>
	<p>Cloudflare is motivated to help build the Internet of tomorrow with the tools at hand today. Our interest is in cryptographic techniques that can be integrated into existing protocols and widely deployed on the Internet as seamlessly as possible. PQ cryptography, like the rest of cryptography, includes many cryptosystems that can be used for communications in today’s Internet; Alice and Bob need to perform some computation, but they do not need to buy new hardware to do that.</p>
	<p>Cloudflare sees great potential in those algorithms and believes that some of them can be used as a safe replacement for classical public-key cryptosystems. Time will tell if we’re justified in this belief!</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/6eUX7xZqv0SKXlOXdRzbVM/2fdca936e7f2e5074cea943860593115/crypto-week-2019-header-circle_2x-2.png" alt="" class="kg-image" width="1600" height="1173" loading="lazy">

	</figure>
</div>