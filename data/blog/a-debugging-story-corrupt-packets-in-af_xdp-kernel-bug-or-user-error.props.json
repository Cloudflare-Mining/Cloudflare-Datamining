{
	"locale": "en-us",
	"localesAvailable": [
		"zh-cn",
		"zh-tw"
	],
	"post": {
		"authors": [
			{
				"name": "Shawn Bohrer",
				"slug": "shawn",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/5caDpqzavLG1OKlZHXEaIs/af07acdbfae9351bfbcdecbd970f72f9/shawn.jpg",
				"location": null,
				"website": null,
				"twitter": "@bohrers",
				"facebook": null
			},
			{
				"name": "Bastien Dhiver",
				"slug": "bastien",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/1bbY0aIxVcuCRJ00Ev1ULr/b14fb28f94156c816bafb39bdb8ab2be/bastien.JPG",
				"location": null,
				"website": null,
				"twitter": null,
				"facebook": null
			}
		],
		"excerpt": "A race condition in the virtual ethernet driver of the Linux kernel led to occasional packet content corruptions, which resulted in unwanted packet drops by one of our DDoS mitigation systems. This blogpost describes the thought process and technique we used to debug this complex issue.",
		"feature_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/7kOETjanO706dqICLlsbVi/273ebbe0d76e367dbb5dba4c09999857/a-debugging-story-corrupt-packets-in-af_xdp-kernel-bug-or-user-error.png",
		"featured": false,
		"html": "<p></p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/6y8e5gSMEYuaTCmUVwscON/b02f4adb1ac59344125568a7790a6cc3/image2-33.png\" alt=\"A debugging story: corrupt packets in AF_XDP; a kernel bug or user error?\" class=\"kg-image\" width=\"1801\" height=\"1013\" loading=\"lazy\"/>\n            \n            </figure><h3>panic: Invalid TCP packet: Truncated</h3><p>A few months ago we started getting a handful of crash reports for flowtrackd, our <a href=\"https://developers.cloudflare.com/ddos-protection/tcp-protection/\">Advanced TCP Protection</a> system that runs on our global network. The provided stack traces indicated that the panics occurred while parsing a TCP packet that was truncated.</p><p>What was most interesting wasn’t that we failed to parse the packet. It isn’t rare that we receive malformed packets from the Internet that are (deliberately or not) truncated. Those packets will be caught the first time we parse them and won’t make it to the latter processing stages. However, in our case, the panic occurred the second time we parsed the packet, indicating it had been truncated <b>after</b> we received it and successfully parsed it the first time. Both parse calls were made from a single green thread and referenced the same packet buffer in memory, and we made no attempts to mutate the packet in between.</p><p>It can be easy to dread discovering a bug like this. Is there a race condition? Is there memory corruption? Is this a kernel bug? A compiler bug? Our plan to get to the root cause of this potentially complex issue was to identify symptom(s) related to the bug, create theories on what may be occurring and create a way to test our theories or gather more information.</p><p>Before we get into the details we first need some background information about <code>AF_XDP</code> and our setup.</p><h3>AF_XDP overview</h3><p><a href=\"https://www.kernel.org/doc/html/latest/networking/af_xdp.html\">AF_XDP</a> is the high performance asynchronous user-space networking API in the Linux kernel. For network devices that support it, AF_XDP provides a way to perform extremely fast, zero-copy packet forwarding using a memory buffer that’s shared between the kernel and a user-space application.</p><p>A number of components need to be set up by the user-space application to start interacting with the packets entering a network device using AF_XDP.</p><p>First, a shared packet buffer (UMEM) is created. This UMEM is divided into equal-sized “frames” that are referenced by a “descriptor address,” which is just the offset from the start of the UMEM.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/7sZldzVDmiFTIbWi5VROpW/6bde251d538b13c99322ead690395894/image12-2.png\" alt=\"AF_XDP UMEM representation\" class=\"kg-image\" width=\"1600\" height=\"810\" loading=\"lazy\"/>\n            \n            </figure><p>Next, multiple AF_XDP sockets (XSKs) are created – one for each hardware queue on the network device – and bound to the UMEM. Each of these sockets provides four ring buffers (or “queues”) which are used to send descriptors back and forth between the kernel and user-space.</p><p>User-space sends packets by taking an unused descriptor and copying the packet into that descriptor (or rather, into the UMEM frame that the descriptor points to). It gives the descriptor to the kernel by enqueueing it on the <b>TX queue</b>. Some time later, the kernel dequeues the descriptor from the <b>TX queue</b> and transmits the packet that it points to out of the network device. Finally, the kernel gives the descriptor back to user-space by enqueueing it on the <b>COMPLETION queue</b>, so that user-space can reuse it later to send another packet.</p><p>To receive packets, user-space provides the kernel with unused descriptors by enqueueing them on the <b>FILL queue</b>. The kernel copies packets it receives into these unused descriptors, and then gives them to user-space by enqueueing them on the <b>RX queue</b>. Once user-space processes the packets it dequeues from the <b>RX queue</b>, it either transmits them back out of the network device by enqueueing them on the <b>TX queue</b>, or it gives them back to the kernel for later reuse by enqueueing them on the <b>FILL queue</b>.</p><!--kg-card-begin: html--><table width=\"100%\">\n<thead>\n  <tr>\n    <th>Queue</th>\n    <th>User space</th>\n    <th>Kernel space</th>\n    <th>Content description</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>COMPLETION</td>\n    <td>Consumes</td>\n    <td>Produces</td>\n    <td>Descriptors containing a packet that was successfully transmitted by the kernel</td>\n  </tr>\n  <tr>\n    <td>FILL</td>\n    <td>Produces</td>\n    <td>Consumes</td>\n    <td>Descriptors that are empty and ready to be used by the kernel to receive packets</td>\n  </tr>\n  <tr>\n    <td>RX</td>\n    <td>Consumes</td>\n    <td>Produces</td>\n    <td>Descriptors containing a packet that was recently received by the kernel</td>\n  </tr>\n  <tr>\n    <td>TX</td>\n    <td>Produces</td>\n    <td>Consumes</td>\n    <td>Descriptors containing a packet that is ready to be transmitted by the kernel</td>\n  </tr>\n</tbody>\n</table><!--kg-card-end: html--><p>Finally, a BPF program is attached to the network device. Its job is to direct incoming packets to whichever XSK is associated with the specific hardware queue that the packet was received on.</p><p>Here is an overview of the interactions between the kernel and user-space:</p>\n            <figure class=\"kg-card kg-image-card kg-width-wide\">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/5g3TzP8qFYPWMxEXeXxhz3/0071ee946ede5ebe3f96887be1304764/Untitled-2.png\" alt=\"\" class=\"kg-image\" width=\"1600\" height=\"866\" loading=\"lazy\"/>\n            \n            </figure><h3>Our setup</h3><p>Our application uses AF_XDP on a pair of multi-queue veth interfaces (“outer” and “inner”) that are each in different network namespaces. We follow the process outlined above to bind an XSK to each of the interfaces’ queues, forward packets from one interface to the other, send packets back out of the interface they were received on, or drop them. This functionality enables us to implement bidirectional traffic inspection to perform DDoS mitigation logic.</p><p>This setup is depicted in the following diagram:</p>\n            <figure class=\"kg-card kg-image-card kg-width-wide\">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/nAwNZF6NfDJK6sz1yymW2/d9a504dbc65fc41227657adf9516c12e/Untitled--1--1.png\" alt=\"\" class=\"kg-image\" width=\"1600\" height=\"646\" loading=\"lazy\"/>\n            \n            </figure><h3>Information gathering</h3><p>All we knew to start with was that our program was occasionally seeing corruption that seemed to be impossible. We didn’t know what these corrupt packets actually looked like. It was possible that their contents would reveal more details about the bug and how to reproduce it, so our first step was to log the packet bytes and discard the packet instead of panicking. We could then take the logs with packet bytes in them and create a PCAP file to analyze with <a href=\"https://www.wireshark.org/\">Wireshark</a>. This showed us that the packets looked mostly normal, except for Wireshark’s TCP analyzer complaining that their “IPv4 total length exceeds packet length”. In other words, the “total length” IPv4 header field said the packet should be (for example) 60 bytes long, but the packet itself was only 56 bytes long.</p><h3>Lengths mismatch</h3><p>Could it be possible that the number of bytes we read from the RX ring was incorrect? Let’s check.</p><p>An XDP descriptor has the following <a href=\"https://elixir.bootlin.com/linux/v5.15.77/source/include/uapi/linux/if_xdp.h#L103\">C struct</a>:</p>\n            <pre class=\"language-c\"><code class=\"language-c\">struct xdp_desc {\n\t__u64 addr;\n\t__u32 len;\n\t__u32 options;\n};</pre></code>\n            <p>Here the len member tells us the total size of the packet pointed to by addr in the UMEM frame.</p><p>Our first interaction with the packet content happens in the BPF code attached to the network interfaces.</p><p>There our entrypoint function gets a pointer to a xdp_md C struct with <a href=\"https://elixir.bootlin.com/linux/v5.15.77/source/include/uapi/linux/bpf.h#L5442\">the following definition</a>:</p>\n            <pre class=\"language-c\"><code class=\"language-c\">struct xdp_md {\n\t__u32 data;\n\t__u32 data_end;\n\t__u32 data_meta;\n\t/* Below access go through struct xdp_rxq_info */\n\t__u32 ingress_ifindex; /* rxq->dev->ifindex */\n\t__u32 rx_queue_index;  /* rxq->queue_index  */\n\n\t__u32 egress_ifindex;  /* txq->dev->ifindex */\n};</pre></code>\n            <p>This context structure contains two pointers (<code>as __u32</code>) referring to start and the end of the packet. Getting the packet length can be done by subtracting data from data_end.</p><p>If we compare that value with the one we get from the descriptors, we would surely find they are the same right?</p><p>We can use the BPF helper function <a href=\"https://man7.org/linux/man-pages/man7/bpf-helpers.7.html\"><code>bpf_xdp_adjust_meta()</code></a> (since the veth driver supports it) to declare a metadata space that will hold the packet buffer length that we computed. We use it the same way <a href=\"https://elixir.bootlin.com/linux/v5.15.77/source/samples/bpf/xdp2skb_meta_kern.c#L41\">this kernel sample code</a> does.</p><p>After deploying the new code in production, we saw the following lines in our logs:</p>\n            <figure class=\"kg-card kg-image-card kg-width-wide\">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/2NG7NbMAC6kpbMT1mBZtwT/04f59b6964651b17fc1469f1feec4871/pasted-image-0-2.png\" alt=\"\" class=\"kg-image\" width=\"1476\" height=\"607\" loading=\"lazy\"/>\n            \n            </figure><p>Here you can see three interesting things:</p><ol><li><p>As we theorized, the length of the packet when first seen in XDP doesn’t match the length present in the descriptor.</p></li><li><p>We had already observed from our truncated packet panics that sometimes the descriptor length is shorter than the actual packet length, however the prints show that sometimes the descriptor length might be larger than the real packet bytes.</p></li><li><p>These often appeared to happen in “pairs” where the XDP length and descriptor length would swap between packets.</p></li></ol><h3>Two packets and one buffer?</h3><p>Seeing the XDP and descriptor lengths swap in “pairs” was perhaps the first lightbulb moment. Are these two different packets being written to the same buffer? This also revealed a key piece of information that we failed to add to our debug prints, the descriptor address! We took this opportunity to print additional information like the packet bytes, and to print at multiple locations in the path to see if anything changed over time.</p><p>The real key piece of information that these debug prints revealed was that not only were each swapped “pair” sharing a descriptor address, but nearly every corrupt packet on a single server was always using the same descriptor address. Here you can see 49750 corrupt packets that all used descriptor address 69837056:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ cat flowtrackd.service-2022-11-03.log | grep 87m237 | grep -o -E 'desc_addr: [[:digit:]]+' | sort | uniq -c\n  49750 desc_addr: 69837056</pre></code>\n            <p>This was the second lightbulb moment. Not only are we trying to copy two packets to the same buffer, but it is always the same buffer. Perhaps the problem is that this descriptor has been inserted into the AF_XDP rings twice? We tested this theory by updating our consumer code to test if a batch of descriptors read from the RX ring ever contained the same descriptor twice. This wouldn’t guarantee that the descriptor isn’t in the ring twice since there is no guarantee that the two descriptors will be in the same read batch, but we were lucky enough that it did catch the same descriptor twice in a single read proving this was our issue. In hindsight the <a href=\"https://www.kernel.org/doc/html/latest/networking/af_xdp.html\">linux kernel AF_XDP documentation</a> points out this very issue:</p><blockquote><p><i>Q: My packets are sometimes corrupted. What is wrong?</i></p></blockquote><blockquote><p><i>A: Care has to be taken not to feed the same buffer in the UMEM into more than one ring at the same time. If you for example feed the same buffer into the FILL ring and the TX ring at the same time, the NIC might receive data into the buffer at the same time it is sending it. This will cause some packets to become corrupted. Same thing goes for feeding the same buffer into the FILL rings belonging to different queue ids or netdevs bound with the XDP_SHARED_UMEM flag.</i></p></blockquote><p>We now understand <i>why</i> we have corrupt packets, but we still don’t understand how a descriptor ever ends up in the AF_XDP rings twice. I would love to blame this on a kernel bug, but as the documentation points out this is more likely that we’ve placed the descriptor in the ring twice in our application. Additionally, since this is listed as a FAQ for AF_XDP we will need sufficient evidence proving that this is caused by a kernel bug and not user error before reporting to the kernel mailing list(s).</p><h3>Tracking descriptor transitions</h3><p>Auditing our application code did not show any obvious location where we might be inserting the same descriptor address into either the FILL or TX ring twice. We do however know that descriptors transition through a set of known states, and we could track those transitions with a state machine. The below diagram shows all the possible valid transitions:</p>\n            <figure class=\"kg-card kg-image-card kg-width-wide\">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/7c0EnogcWg13acmzNWQmiJ/a0b5e40e062e66dc1bb36a038ce11002/af_xdp_descriptor_transitions.png\" alt=\"\" class=\"kg-image\" width=\"1403\" height=\"441\" loading=\"lazy\"/>\n            \n            </figure><p>For example, a descriptor going from the RX ring to either the FILL or the TX ring is a perfectly valid transition. On the other hand, a descriptor going from the FILL ring to the COMP ring is an invalid transition.</p><p>To test the validity of the descriptor transitions, we added code to track their membership across the rings. This produced some of the following log messages:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">Nov 16 23:49:01 fuzzer4 flowtrackd[45807]: thread 'flowtrackd-ZrBh' panicked at 'descriptor 26476800 transitioned from Fill to Tx'\nNov 17 02:09:01 fuzzer4 flowtrackd[45926]: thread 'flowtrackd-Ay0i' panicked at 'descriptor 18422016 transitioned from Comp to Rx'\nNov 29 10:52:08 fuzzer4 flowtrackd[83849]: thread 'flowtrackd-5UYF' panicked at 'descriptor 3154176 transitioned from Tx to Rx'</pre></code>\n            <p>The first print shows a descriptor was put on the FILL ring and transitioned directly to the TX ring without being read from the RX ring first. This appears to hint at a bug in our application, perhaps indicating that our application duplicates the descriptor putting one copy in the FILL ring and the other copy in the TX ring.</p><p>The second invalid transition happened for a descriptor moving from the COMP ring to the RX ring without being put first on the FILL ring. This appears to hint at a kernel bug, perhaps indicating that the kernel duplicated a descriptor and put it both in the COMP ring and the RX ring.</p><p>The third invalid transition was from the TX to the RX ring without going through the FILL or COMP ring first. This seems like an extended case of the previous COMP to RX transition and again hints at a possible kernel bug.</p><p>Confused by the results we double-checked our tracking code and attempted to find any possible way our application could duplicate a descriptor putting it both in the FILL and TX rings. With no bugs found we felt we needed to gather more information.</p><h3>Using ftrace as a “flight recorder”</h3><p>While using a state machine to catch invalid descriptor transitions was able to catch these cases, it still lacked a number of important details which might help track down the ultimate cause of the bug. We still didn’t know if the bug was a kernel issue or an application issue. Confusingly the transition states seemed to indicate it was both.</p><p>To gather some more information we ideally wanted to be able to track the history of a descriptor. Since we were using a shared UMEM a descriptor could in theory transition between interfaces, and receive queues. Additionally, our application uses a single green thread to handle each XSK, so it might be interesting to track those descriptor transitions by XSK, CPU, and thread. A simple but unscalable way to achieve this would be to simply print this information at every transition point. This of course is not really an option for a production environment that needs to be able to process millions of packets per second. Both the amount of data produced and the overhead of printing that information will not work.</p><p>Up to this point we had been carefully debugging this issue in production systems. The issue was rare enough that even with our large production deployment it might take a day for some production machines to start to display the issue. If we did want to explore more resource intensive debugging techniques we needed to see if we could reproduce this in a test environment. For this we created 10 virtual machines that were continuously load testing our application with <a href=\"https://iperf.fr/\">iperf</a>. Fortunately with this setup we were able to reproduce the issue about once a day, giving us some more freedom to try some more resource intensive debugging techniques.</p><p>Even using a virtual machine it still doesn’t scale to print logs at every descriptor transition, but do you really need to see every transition? In theory the most interesting events are the events right before the bug occurs. We could build something that internally keeps a log of the last N events and only dump that log when the bug occurs. Something like a black box flight recorder used in airplanes to track the events leading up to a crash. Fortunately for us, we don’t really need to build this, and instead can use the Linux kernel’s <a href=\"https://www.kernel.org/doc/html/latest/trace/ftrace.html\">ftrace</a> feature, which has some additional features that might help us ultimately track down the cause of this bug.</p><p>ftrace is a kernel feature that operates by internally keeping a set of per-CPU ring buffers of trace events. Each event stored in the ring buffer is time-stamped and contains some additional information about the context where the event occurred, the CPU, and what process or thread was running at the time of the event. Since these events are stored in per-CPU ring buffers, once the ring is full, new events will overwrite the oldest events leaving a log of the most recent events on that CPU. Effectively we have our flight recorder that we desired, all we need to do is add our events to the ftrace ring buffers and disable tracing when the bug occurs.</p><p>ftrace is controlled using virtual files in the debugfs filesystem. Tracing can be enabled and disabled by writing either a 1 or a 0 to:</p><p><code>/sys/kernel/debug/tracing/tracing_on</code></p><p>We can update our application to insert our own events into the tracing ring buffer by writing our messages into the trace_marker file:</p><p><code>/sys/kernel/debug/tracing/trace_marker</code></p><p>And finally after we’ve reproduced the bug and our application has disabled tracing we can extract the contents of all the ring buffers into a single trace file by reading the trace file:</p><p><code>/sys/kernel/debug/tracing/trace</code></p><p>It is worth noting that writing messages to the trace_marker virtual file still involves making a system call and copying your message into the ring buffers. This can still add overhead and in our case where we are logging several prints per packet that overhead might be significant. Additionally, ftrace is a systemwide kernel tracing feature, so you may need to either adjust the permissions of virtual files, or run your application with the appropriate permissions.</p><p>There is of course one more big advantage of using ftrace to assist in debugging this issue. As shown above we can log our own application messages to ftrace using the trace_marker file, but at its core ftrace is a kernel tracing feature. This means that we can additionally use ftrace to log events from the kernel side of the AF_XDP packet processing. There are several ways to do this, but for our purposes we used kprobes so that we could target very specific lines of code and print some variables. kprobes can be created directly in ftrace, but I find it easier to create them using the “perf probe” command of perf tool in Linux. Using the “-L” and “-V” arguments you can find which lines of a function can be probed and which variables can be viewed at those probe points. Finally, you can add the probe with the “-a” argument. For example after examining the kernel code we insert the following probe in the receive path of a XSK:</p><p><code>perf probe -a &#39;__xsk_rcv_zc:7 addr len xs xs-&gt;pool-&gt;fq xs-&gt;dev&#39;</code></p><p>This will probe line 7 of __xsk_rcv_zc() and print the descriptor address, the packet length, the XSK address, the fill queue address and the net device address. For context here is what <a href=\"https://elixir.bootlin.com/linux/v5.15.77/source/net/xdp/xsk.c#L152\"><code>__xsk_rcv_zc()</code></a> looks like from the perf probe command:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ perf probe -L __xsk_rcv_zc\n      0  static int __xsk_rcv_zc(struct xdp_sock *xs, struct xdp_buff *xdp, u32 len)\n         {\n                struct xdp_buff_xsk *xskb = container_of(xdp, struct xdp_buff_xsk, xdp);\n                u64 addr;\n                int err;\n         \n                addr = xp_get_handle(xskb);\n      7         err = xskq_prod_reserve_desc(xs->rx, addr, len);\n      8         if (err) {\n                        xs->rx_queue_full++;\n                        return err;\n                }</pre></code>\n            <p>In our case line 7 is the call to xskq_prod_reserve_desc(). At this point in the code the kernel has already removed a descriptor from the FILL queue and copied a packet into that descriptor. The call to xsk_prod_reserve_desc() will ensure that there is space in the RX queue, and if there is space will add that descriptor to the RX queue. It is important to note that while xskq_prod_reserve_desc() will put the descriptor in the RX queue it does not update the producer pointer of the RX ring or notify the XSK that packets are ready to be read because the kernel tries to batch these operations.</p><p>Similarly, we wanted to place a probe in the transmit path on the kernel side and ultimately placed the following probe:</p><p><code>perf probe -a &#39;xp_raw_get_data:0 addr&#39;</code></p><p>There isn’t much interesting to show here in <a href=\"https://elixir.bootlin.com/linux/v5.15.77/source/net/xdp/xsk_buff_pool.c#L542\">the code</a>, but this probe is placed at a location where descriptors have been removed from the TX queue but have not yet been put in the COMPLETION queue.</p><p>In both of these probes it would have been nice to put the probes at the earliest location where descriptors were added or removed from the XSK queues, and to print as much information as possible at these locations. However, in practice the locations where kprobes can be placed and the variables available at those locations limits what can be seen.</p><p>With the probes created we still need to enable them to be seen in ftrace. This can be done with:</p><p><code>echo 1 &gt; /sys/kernel/debug/tracing/events/probe/__xsk_rcv_zc_L7/enableecho 1 &gt; /sys/kernel/debug/tracing/events/probe/xp_raw_get_data/enable</code></p><p>With our application updated to trace the transition of every descriptor and stop tracing when an invalid transition occurred we were ready to test again.</p><h3>Tracking descriptor state is not enough</h3><p>Unfortunately our initial test of our “flight recorder” didn’t immediately tell us anything new. Instead, it mostly confirmed what we already knew, which was that somehow we would end up in a state with the same descriptor twice. It also highlighted the fact that catching an invalid descriptor transition doesn’t mean you have caught the earliest point where the duplicate descriptor appeared. For example assume we have our descriptor A and our duplicate A’. If these are already both present in the FILL queue it is perfectly valid to:</p><p><code>RX A -&gt; FILL ARX A’ -&gt; FILL A’</code></p><p>This can occur for many cycles, before an invalid transition eventually occurs when both descriptors are seen either in the same batch or between queues.</p><p>Instead, we needed to rethink our approach. We knew that the kernel removes descriptors from the FILL queue, fills them, and places them in the RX queue. This means that for any given XSK the order that descriptors are inserted into the FILL queue should match the order that they come out of the RX queue. If a descriptor was ever duplicated in this kernel RX path we should see the duplicate descriptor appear out-of-order. With this in mind we updated our application to independently track the order of the FILL queue using a double ended queue. As our application puts descriptors into the FILL queue we also push the descriptor address into the tail of our tracking queue and when we receive packets we pop the descriptor address from the head of our tracking queue and ensure the address matches. If it ever doesn’t match we again can log to trace_marker and stop ftrace.</p><p>Below is the end of the first trace we captured with the updated code tracking the order of the FILL to RX queues. The color has been added to improve readability:</p>\n            <figure class=\"kg-card kg-image-card kg-width-wide\">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/uSATZc25o3ESPjeXWQVUX/c3114ccb1029770a3a400eebbe8e9b1f/Screenshot-2023-01-16-at-14.16.47.png\" alt=\"\" class=\"kg-image\" width=\"1422\" height=\"636\" loading=\"lazy\"/>\n            \n            </figure><!--kg-card-begin: html--><p>Here you can see the power of our ftrace flight recorder. For example, we can follow the full cycle of descriptor </span><span style=\"color:#ff00ff\">0x16ce900</span> as it is first received in the kernel, received by our application which forwards the packet by adding to the TX queue, the kernel transmitting, and finally our application receiving the completion and placing the descriptor back in the FILL queue.</p>\n<p>\nThe trace starts to get interesting on the next two packets received by the kernel. We can see <span style=\"color:#980000\">0x160a100</span> received first in the kernel and then by our application. However things go wrong when the kernel receives <span style=\"color:#00ff00\">0x13d3900</span> but our application receives <span style=\"color:#ff0000\">0x1229100</span>. The last print of the trace shows the result of our descriptor order tracking. We can see that the kernel side appears to match our next expected descriptor and the next two descriptors, yet unexpectedly we see <span style=\"color:#ff0000\">0x1229100</span> arrive out of nowhere. We do think that the descriptor is present in the FILL queue, but it is much further down the line in the queue. Another potentially interesting detail is that between <span style=\"color:#980000\">0x160a100</span> and <span style=\"color:#00ff00\">0x13d3900</span> the kernel&rsquo;s softirq switches from CPU 1 to CPU 2.</p>\n<!--kg-card-end: html--><p>If you recall, our __xsk_rcv_zc_L7 kprobe was placed on the call to xskq_prod_reserve_desc() which adds the descriptor to the RX queue. Below we can examine that function to see if there are any clues on how the descriptor address received by our application could be different from what we think should have been inserted by the kernel.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">static inline int xskq_prod_reserve_desc(struct xsk_queue *q,\n                                     \tu64 addr, u32 len)\n{\n    \tstruct xdp_rxtx_ring *ring = (struct xdp_rxtx_ring *)q->ring;\n    \tu32 idx;\n \n    \tif (xskq_prod_is_full(q))\n            \treturn -ENOBUFS;\n \n    \t/* A, matches D */\n    \tidx = q->cached_prod++ & q->ring_mask;\n    \tring->desc[idx].addr = addr;\n    \tring->desc[idx].len = len;\n \n    \treturn 0;\n}</pre></code>\n            <p>Here you can see that the queue’s cached_prod pointer is incremented first before we update the descriptor address and length. As the name implies the cached_prod pointer isn’t the actual producer pointer which means that at some point <code>xsk_flush()</code> must be called to sync the cached_prod pointer and the prod pointer to actually expose the newly received descriptors to user-mode. Perhaps there is a race where <code>xsk_flush()</code> is called after updating the <code>cached_prod</code> pointer, but before the actual descriptor address has been updated in the ring? If this were to occur our application would see the old descriptor address from that slot in the RX queue and would cause us to “duplicate” that descriptor.</p><p>We can test our theory by making two more changes. First we can update our application to write back a known “poisoned” descriptor address to each RX queue slot after we have received a packet. In this case we chose <code>0xdeadbeefdeadbeef</code> as our known invalid address and if we ever receive this value back out of the RX queue we know a race has occurred and exposed an uninitialized descriptor. The second change we can make is to add a kprobe on <code>xsk_flush()</code> to see if we can actually capture the race in the trace.</p><p><code>perf probe -a &#39;xsk_flush:0 xs&#39;</code></p>\n            <figure class=\"kg-card kg-image-card kg-width-wide\">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/1Xx2qaoywvGvlb0VsenLAw/6202379ff2efc2d6a6190851fd1a9c72/Screenshot-2023-01-16-at-14.16.05.png\" alt=\"\" class=\"kg-image\" width=\"1426\" height=\"196\" loading=\"lazy\"/>\n            \n            </figure><!--kg-card-begin: html--><p>Here we appear to have our smoking gun. As we predicted we can see that <span style=\"font-family:'Roboto Mono',monospace\"><span style=\"color:#000000\">xsk_flush()</span></span> is called on CPU 0 while a softirq is currently in progress on CPU 2. After the flush our application sees the expected <span style=\"font-size:11pt\"><span style=\"font-family:'Roboto Mono',monospace\"><span style=\"color:#0000ff\">0xff0900</span></span></span> filled in from the softirq on CPU 0, and then <span style=\"font-family:'Roboto Mono',monospace\"><span style=\"color:#ff0000\">0xdeadbeefdeadbeef</span></span> which is our poisoned uninitialized descriptor address.</p>\n<!--kg-card-end: html--><p>We now have evidence that the following order of operations is happening:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">CPU 2                                                   CPU 0\n-----------------------------------                     --------------------------------\n__xsk_rcv_zc(struct xdp_sock *xs):                      xsk_flush(struct xdp_sock *xs):\n                                        \nidx = xs->rx->cached_prod++ & xs->rx->ring_mask; \n                                                        // Flush the cached pointer as the new head pointer of\n                                                        // the RX ring.\n                                                        smp_store_release(&xs->rx->ring->producer, xs->rx->cached_prod);\n\n                                                        // Notify user-side that new descriptors have been produced to\n                                                        // the RX ring.\n                                                        sock_def_readable(&xs->sk);\n\n                                                        // flowtrackd reads a descriptor \"too soon\" where the addr\n                                                        // and/or len fields have not yet been updated.\nxs->rx->ring->desc[idx].addr = addr;\nxs->rx->ring->desc[idx].len = len;</pre></code>\n            <p>The AF_XDP documentation states that: <i>“All rings are single-producer/single-consumer, so the user-space application needs explicit synchronization of multiple processes/threads are reading/writing to them.”</i> The explicit synchronization requirement must also apply on the kernel side. How can two operations on the RX ring of a socket run at the same time?</p><p>On Linux, a mechanism called <a href=\"https://wiki.linuxfoundation.org/networking/napi\">NAPI</a> prevents CPU interrupts from occurring every time a packet is received by the network interface. It instructs the network driver to process a certain amount of packets at a frequent interval. For the veth driver that polling function is called <a href=\"https://elixir.bootlin.com/linux/v5.15.77/source/drivers/net/veth.c#L906\">veth_poll</a>, and it is <a href=\"https://elixir.bootlin.com/linux/v5.15.77/source/drivers/net/veth.c#L1015\">registered</a> as the function handler for each queue of the XDP enabled network device. A NAPI-compliant network driver provides the guarantee that the processing of the packets tied to a NAPI context (<code>struct napi_struct *napi</code>) will not be happening at the same time on multiple processors. In our case, a NAPI context exists for each queue of the device which means per AF_XDP socket and their associated set of ring buffers (RX, TX, FILL, COMPLETION).</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">static int veth_poll(struct napi_struct *napi, int budget)\n{\n\tstruct veth_rq *rq =\n\t\tcontainer_of(napi, struct veth_rq, xdp_napi);\n\tstruct veth_stats stats = {};\n\tstruct veth_xdp_tx_bq bq;\n\tint done;\n\n\tbq.count = 0;\n\n\txdp_set_return_frame_no_direct();\n\tdone = veth_xdp_rcv(rq, budget, &bq, &stats);\n\n\tif (done < budget && napi_complete_done(napi, done)) {\n\t\t/* Write rx_notify_masked before reading ptr_ring */\n\t\tsmp_store_mb(rq->rx_notify_masked, false);\n\t\tif (unlikely(!__ptr_ring_empty(&rq->xdp_ring))) {\n\t\t\tif (napi_schedule_prep(&rq->xdp_napi)) {\n\t\t\t\tWRITE_ONCE(rq->rx_notify_masked, true);\n\t\t\t\t__napi_schedule(&rq->xdp_napi);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stats.xdp_tx > 0)\n\t\tveth_xdp_flush(rq, &bq);\n\tif (stats.xdp_redirect > 0)\n\t\txdp_do_flush();\n\txdp_clear_return_frame_no_direct();\n\n\treturn done;\n}</pre></code>\n            <p><code>veth_xdp_rcv()</code> processes as many packets as the budget variable is set to, marks the NAPI processing as complete, potentially reschedules a NAPI polling, and <b>then</b>, calls <code>xdp_do_flush()</code>, breaking the NAPI guarantee cited above. After the call to <code>napi_complete_done()</code>, any CPU is free to execute the <code>veth_poll()</code> function before all the flush operations of the previous call are complete, allowing the race on the RX ring.</p><p>The race condition can be fixed by completing all the packet processing before signaling the NAPI poll as complete. The patch as well as the discussion on the kernel mailing list that lead to the fix are available here: <a href=\"https://lore.kernel.org/bpf/20221220185903.1105011-1-sbohrer@cloudflare.com/\">[PATCH] veth: Fix race with AF_XDP exposing old or uninitialized descriptors</a>. The patch was recently merged upstream.</p><h3>Conclusion</h3><p>We’ve found and fixed a race condition in the Linux virtual ethernet (veth) driver that was corrupting packets for AF_XDP enabled devices!</p><p>This issue was a tough one to find (and to reproduce) but logical iterations lead us all the way down to the internals of the Linux kernel where we saw that a few lines of code were not executed in the correct order.</p><p>A rigorous methodology and the knowledge of the right debugging tools are essential to go about tracking down the root cause of potentially complex bugs.</p><p>This was important for us to fix because while TCP was designed to recover from occasional packet drops, randomly dropping legitimate packets slightly increased the latency of connection establishments and data transfers across our network.</p><p>Interested about other deep dive kernel debugging journeys? Read more of them on <a href=\"/\">our blog</a>!</p>",
		"id": "5bnyvGSAmPfUzfkmoNLY40",
		"localeList": {
			"name": "A debugging story: corrupt packets in AF_XDP; a kernel bug or user error? Config",
			"enUS": "English for Locale",
			"zhCN": "Translated for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "Translated for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "A race condition in the virtual ethernet driver of the Linux kernel led to occasional packet content corruptions, which resulted in unwanted packet drops by one of our DDoS mitigation systems. This blogpost describes the thought process and technique we used to debug this complex issue.",
		"metadata": {
			"title": "A debugging story: corrupt packets in AF_XDP; a kernel bug or user error?",
			"description": "A race condition in the virtual ethernet driver of the Linux kernel led to occasional packet content corruptions, which resulted in unwanted packet drops by one of our DDoS mitigation systems. This blogpost describes the thought process and technique we used to debug this complex issue.",
			"imgPreview": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/JRLOu3ykW8Z6d8WPD2Z2m/9d3768993b05ebf558ab6e691afda8bc/a-debugging-story-corrupt-packets-in-af_xdp-kernel-bug-or-user-error-1inXzH.png"
		},
		"primary_author": {},
		"published_at": "2023-01-16T13:46:45.000+00:00",
		"reading_time": 18,
		"slug": "a-debugging-story-corrupt-packets-in-af_xdp-kernel-bug-or-user-error",
		"tags": [
			{
				"id": "2UVIYusJwlvsmPYl2AvSuR",
				"name": "Deep Dive",
				"slug": "deep-dive"
			},
			{
				"id": "383iv0UQ6Lp0GZwOAxGq2p",
				"name": "Linux",
				"slug": "linux"
			}
		],
		"title": "A debugging story: corrupt packets in AF_XDP; a kernel bug or user error?",
		"updated_at": "2024-08-27T01:43:10.466Z",
		"url": "https://blog.cloudflare.com/a-debugging-story-corrupt-packets-in-af_xdp-kernel-bug-or-user-error"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.blurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}