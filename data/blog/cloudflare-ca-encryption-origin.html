<div class="mb2 gray5">11 min read</div>
<div class="post-content lh-copy gray1">
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/3LGGPwBbcwri0fn60opcSq/b36cf5210208537312ad821f4225c168/illustration-ssl-certificate.png" alt="" class="kg-image" width="645" height="200" loading="lazy">

	</figure>
	<h3>Free and performant encryption to the origin for CloudFlare customers</h3>
	<p>In the fall of 2014 CloudFlare <a href="https://blog.cloudflare.com/introducing-universal-ssl">launched Universal SSL</a> and doubled the number of sites on the Internet accessible via HTTPS. In just a few days we issued certificates protecting millions of our customers’ domains and became the easiest way to secure your website with SSL/TLS.</p>
	<p>At the time, we "strongly recommend[ed] that site owners install a certificate on their web servers so we can encrypt traffic to the origin." This recommendation was followed by a <a href="https://blog.cloudflare.com/origin-server-connection-security-with-universal-ssl">blog post</a> describing two readily-available options for doing so—creating a self-signed certificate and purchasing a publicly trusted certificate—and a third, still-in-beta option: using our private CA. Even though out-of-pocket costs of acquiring public CA certificates <a href="https://letsencrypt.org">have since fallen to $0</a> since that post, we have continued to receive requests from our customers for an even easier (and more performant) option.</p>
	<p>Operating a public certificate authority is difficult because you don't directly control either endpoint of the HTTPS connection (browser or web server). As a result, public CAs are limited both in their ability to issue certificates optimized for inter-server communication, as well as in their ability to revoke certificates if they are compromised. Our situation at CloudFlare is markedly different: we affirmatively control the edge of our network so we have the flexibility to build and operate a secure CA that’s capable of issuing highly streamlined certificates and ensuring they are utilized securely.</p>
	<h3>Less is more: removing the extraneous</h3>
	<p>With Origin CA, we questioned all aspects of certificate issuance and browser validation, from domain control validation (DCV) to path bundling and revocation checking. We asked ourselves what cruft public CAs would remove from certificates if they only needed to work with one browser, whose codebase they maintained? Questions such as "why bloat certificates with intermediate CAs when they only need to speak with our NGINX-based reverse proxy" and "why force customers to reconfigure their web or name server to pass DCV checks when they’ve already demonstrated control during zone onboarding?" helped shape our efforts.</p>
	<p>The result of us asking these questions and removing anything not needed to secure the connection between our servers and yours is described below, along with the benefits you may see and the interfaces you may use. We’re excited to introduce this third option for protecting your origin—more secure than self-signed certificates and more convenient, performant, and cost effective than publicly trusted certificates—and look forward to hearing about all the various ways you may use it.</p>
	<h3>What are the incremental benefits of Origin CA over public certificates?</h3>
	<h4>1. Ease of issuance and renewal</h4>
	<p>The most difficult and time-consuming part of securing your origin with TLS is obtaining—and renewing—a certificate. Or many certificates if you’re using a provider that doesn’t support wildcards. Often this process requires intimate knowledge of OpenSSL or related command line tools, a reconfiguration of your web or DNS server to accommodate domain control validation, and a regularly scheduled reminder or cron job to perform this process again every year (or even every few months). With Origin CA, we took the opportunity to remove as many of these obstacles as possible.</p>
	<p>Customers more comfortable in the GUI can, with just two clicks, securely generate a private key and wildcard certificate that will be trusted by our systems for anywhere from 7 days to 15 years. And those who prefer more control over the process can use our API or CLI to issue certificates of specified validity, key type, and key size. Regardless of the user interface chosen, the potentially complicated validation process has been replaced by a simple API key now available in your account on the CloudFlare dashboard; we’ve already verified you control your zone, there’s no need to prove it again.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/4aKKwwFmI91bim9WOmJ0HE/964987aa5fa3c333362f82248b16e87c/strict-ssl.png" alt="" class="kg-image" width="1000" height="480" loading="lazy">

	</figure>
	<h4>2. Wildcard certificates reduce complexity</h4>
	<p>If your origin server handles traffic for more than a few hostnames, it can get unwieldy to place a long list of SANs on each certificate request. The alternative—placing just one SAN on each certificate and using Server Name Indication (SNI) extension to lazy load the correct certificate—can easily get out of hand. In this deployment scenario the number of certificates required is a non-trivial fraction of the the number of hostnames you wish to protect (not to mention you may not even be allowed to do so on shared hosts).</p>
	<p>Beyond provisioning efforts, placing too many SANs on a single certificate can <a href="https://cabforum.org/pipermail/performance/2014-May/000047.html">significantly increase the size</a> of the certificate. Larger certificates consume more bandwidth at your origin (which, unlike CloudFlare, may bill you for marginal bandwidth consumption). The obvious answer for protecting more than a few hostnames (or even domains) on your origin is to use wildcard certificates. With Origin CA, you can request a single certificate containing wildcards for any and all of the zones registered in your account; you can even add wildcards covering multiple levels of a domain, e.g., <code>*.example.com</code>, <code>*.secure.example.com</code>, and <code>*.another-example.com</code> can all co-exist on the same certificate.</p>
	<h4>3. Speed and simplicity of revocation</h4>
	<p>If you’ve ever tried revoking a publicly trusted certificate—or relying on browsers to distrust a revoked certificate—you know how unreliable the process can be. Take your pick of explanations from Google crypto-wunderkind Adam Langley—<a href="https://www.imperialviolet.org/2011/03/18/revocation.html">Revocation doesn’t work</a> (2011); <a href="https://www.imperialviolet.org/2014/04/19/revchecking.html">No, don’t enable revocation checking</a> (2014); or <a href="https://www.imperialviolet.org/2014/04/29/revocationagain.html">Revocation still doesn’t work</a> (2014)—they all reach the same conclusion: browser-based revocation checking is broken and useless without hard fails. (The advent of the OCSP Must-Staple extension should improve the situation, but if history is any indication it will be quite a while before sufficient browsers, certificate authorities, and issued certificates support it.)</p>
	<p>Fortunately with Origin CA, we only need one "browser" to respect revocation: our edge. Failing hard—the only acceptable way to fail from a security perspective—is incredibly simple (and fast) when your user agent has an in-memory list of all valid certificates. (Try doing that with the millions of certificates issued by dozens of CAs over the past few years!) Rather than fire requests across the public Internet and praying they return quickly enough, our NGINX instances can just query a local database for each new HTTPS session and confirm in microseconds whether you’ve revoked the certificate for any reason.</p>
	<p>And if/when the time comes to revoke, a single click and confirmation is all that’s required for our edge to distrust the certificate. If you expose or misplace your private key (and can’t find it under the couch or in the pockets of yesterday’s pants), simply navigate to the Crypto tab and click the "x" icon next to the compromised certificate. Within seconds we’ll push this revocation status worldwide and our edge servers will refuse to communicate with origins serving the revoked certificate. Such speed, security, and reliability is impossible without total control over the CA and browser ecosystem.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/5k3l2VOBwjSwhRBAOEZLgw/da92ae3db4bc9b91916e6f6e9c5c41ba/revoke-modal.png" alt="" class="kg-image" width="920" height="960" loading="lazy">

	</figure>
	<p>Even if published to the world, to abuse your CloudFlare Origin CA certificate an attacker would either need to compromise your CloudFlare account or take control of your <a href="https://www.cloudflare.com/learning/dns/glossary/what-is-a-domain-name-registrar">registrar</a> or DNS provider account. In any case, you'd have a lot more to worry about than just a compromised certificate.</p>
	<h4>4. Widely supported install base</h4>
	<p>While most web server operators will elect to download the default PEM format for their certificate (as expected by Apache httpd and NGINX), many others will require a different variation. As illustrated in the screenshots below, certificates can be downloaded in several different formats, including DER, the binary equivalent of PEM’s ASCII, and PKCS#7, the Microsoft IIS Server and Apache Tomcat-compatible choice. Simply pick what works for your server and download it; there’s no need to learn cryptic command-line methods for converting.</p>
	<p>Besides additional formats, we also have <a href="https://support.cloudflare.com/hc/en-us/articles/218408028">instructions for a wide variety of operating systems and web servers</a>. After generating your certificate simply select your desired destination from the 80+ different options and instructions specific to your environment will be displayed.</p>
	<h4>5. Optimized certificates increase performance and reduce origin bandwidth consumption</h4>
	<p>Before a user agent can securely transmit HTTP actions like GET and POST to a web server, it must first establish the TLS session. To do so, the client kicks off a handshake by <a href="https://blog.cloudflare.com/tls-certificate-optimization-technical-details#step1clienthello">sending its own capabilities</a> and the server responds with the negotiated cipher suite and certificate that should be used to protect the conversation agreeing upon a symmetric key.</p>
	<p>Until the client receives—and validates—the certificate(s) sent across the network by the origin, it is unable to complete the handshake and commence with requesting data. As such, it’s in the best interest of performance-sensitive users to make this certificate as small and unencumbered as possible. (Ideally the packet containing the certificate even fits within a single frame and is not fragmented during transmission.) One <a href="https://cabforum.org/pipermail/performance/2014-May/000047.html">brief survey</a> by a member of the <a href="https://cabforum.org">CA/B Forum</a> found that while the majority of certificates were between 1-2 kB, several thousand were found in the wild at least 10 kB in size, with one even over 50(!) kB.</p>
	<p>With Origin CA certificates, we’ve stripped everything that’s extraneous to communication between our servers and yours to produce the smallest possible certificate and handshake. For example, we have no need to bundle intermediate certificates to assist browsers in building paths to trusted roots; no need to include signed certificate timestamps (SCTs) for purposes of certificate transparency and EV treatment; no need to include links to Certification Practice Statements or other URLs; and no need to listen to Online Certificate Status Protocol (OCSP) responses from third-parties.</p>
	<p>Eliminating these unnecessary components typically found in certificates from public CAs has allowed us to reduce the size of the handshake by up to 70%, from over 4500 bytes in some cases to under 1300. You can replicate this test yourself using the following two OpenSSL s_client calls:</p>
	<pre class="language-bash"><code class="language-bash">$ for host in google.com bing.com cloudflare.com patriots.com; do echo -en "$host\t" &amp;&amp; openssl s_client -connect www.$host:443 -servername www.$host 2&gt;/dev/null /dev/null </code>
            <h3>How can Origin CA be used?</h3><p>Now that you've learned why you may want to use Origin CA-issued certificates on your origin, let’s explore the various interfaces you have for issuing (and revoking) them. Effective immediately, certificates for your origin can be issued in an automated fashion through our <a href="https://blog.cloudflare.com/cloudflare-ca-encryption-origin/#2apiapplicationprogramminginterface">API</a> or <a href="https://blog.cloudflare.com/cloudflare-ca-encryption-origin#3clicommandlineinterfacelinuxonly">CLI</a>, or through a guided wizard in the Crypto app on the <a href="https://www.cloudflare.com">CloudFlare Dashboard</a>. Each of the three available methods is described below along with examples:</p><h4>1. GUI: Crypto app in the CloudFlare Dashboard</h4><p>To get started, login to <a href="https://www.cloudflare.com/a/login">the dashboard</a> and click on the Crypto icon.</p>
            <figure class="kg-card kg-image-card ">
            
            <img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/7aYmz9vQ74KDbgLUdkoghd/44a035da25632fcf2dada27d6a30fdb4/heading.png" alt="" class="kg-image" width="1936" height="348" loading="lazy">
            
            </figure><p>Next, scroll down to the Origin Certificates card and click the "Create Certificate" button.</p>
            <figure class="kg-card kg-image-card ">
            
            <img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/16CIs13h8n6Utv9q0vzMFO/3237f8b2c9cfc0c4914a558e2818ba86/origin-certificates-emptytable.png" alt="" class="kg-image" width="1958" height="522" loading="lazy">
            
            </figure><p>At this point, you must decide whether you wish to provide your own certificate signing request (CSR) or let your browser create one using its cryptographic libraries.</p><p>If you’ve already generated a private key and CSR, select the radio button labeled "I have my own CSR" and paste the CSR contents into the textbox that appears. Alternatively, leave the default option of “Let CloudFlare generate a key pair using my browser” selected. (If you are accessing the dashboard using an older browser, i.e., one that does not support <a href="https://www.w3.org/TR/WebCryptoAPI">Web Crypto API</a>, you will only see one option.)</p>
            <figure class="kg-card kg-image-card ">
            
            <img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/7tbWU0IOrjnp3dgQ1W2m5p/0f9c2b76faeae58add069ac53bb5db34/create-step1.png" alt="" class="kg-image" width="1634" height="1200" loading="lazy">
            
            </figure><p>By default, the list of hostnames your origin certificate covers includes the apex of the currently selected zone (example.com) and one level of wildcard (*.example.com). If you’d like to protect additional hostnames outside this list (e.g., *.secure.example.com), simply type them in the input box at the bottom of the modal. You may add up to 100 hostnames (or wildcards) on a single certificate, spanning multiple zones, provided they are for zones active in your account. Please keep in mind that each additional SAN increases the size of your certificate, so applications requiring frequent updates to the origin (and thus TLS handshakes) you should use as few SANs as possible.</p><p>After entering additional hostnames (or confirming the defaults will suffice), click Next and your certificate will be generated. By default, it will be displayed in PEM format, which is what web servers such as Apache httpd and NGINX expect. If you require an alternative format, such as PKCS#7 for Microsoft’s IIS or Apache Tomcat, change the dropdown box appropriately and save the contents to your server. Or if you’d like to use a binary format such as DER, select that and click the download button.</p>
            <figure class="kg-card kg-image-card ">
            
            <img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/1ES61XNDaqGSGALF2KrHQn/676dcf8c3a077522868fb3fbfa8efc4b/generated-cert.png" alt="" class="kg-image" width="1703" height="970" loading="lazy">
            
            </figure><p>Lastly, choose your web server from the select box at the bottom of the window and click "Show instructions". Doing so will open installation instructions in a new browser window that, once followed, will allow you to adjust your SSL setting (at the top of the Crypto app) to "Strict" mode.</p><h4>2. API: Application Programming Interface</h4><p>If you would like to automate the process of issuing certificates for your origin, or require more control over the parameters (e.g., shorter-lived certificates, greater key size, etc.), you can make use of our <a href="https://api.cloudflare.com/#origin-ca-properties">certificates API endpoint</a>.</p><p>Before calling the <a href="https://www.cloudflare.com/learning/security/api/what-is-an-api">API</a> you will first need to generate a certificate signing request. To do so, you can use <a href="https://github.com/cloudflare/cfssl">cfssl</a> or <a href="https://www.openssl.org">OpenSSL</a>. Instructions for the former can be <a href="https://blog.cloudflare.com/universal-ssl-encryption-all-the-way-to-the-origin-for-free">found here</a>, while our friends at DigiCert have provided an <a href="https://www.digicert.com/easy-csr/openssl.htm">easy-to-use wizard</a> for the latter. Don't worry about including subject alternative names (SANs) in the CSR —&nbsp;we’ll take those in separately through the JSON payload.</p><h5>i. Generate a private key and CSR</h5>
            <pre class="language-bash"><code class="language-bash">$ openssl req -new -newkey rsa:2048 -nodes -out www_example_com.csr -keyout www_example_com.key -subj "/C=US/ST=California/L=/O=/CN=www.example.com"
Generating a 2048 bit RSA private key
.............................+++
.....................................................................................................................................+++
writing new private key to 'www_example_com.key'</code></pre>
	<h5>ii. Obtain your Certificate API token</h5>
	<p>Log in to the CloudFlare dashboard, and click My Settings under your username in the top-right &nbsp;hand corner. Scroll down to the API Key panel and click "View API Key".</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/2R4UWX1Op2jBlpfPW5e6kU/bf74052f2492140c0e873a72e483aad0/api-key-panel.png" alt="" class="kg-image" width="1944" height="560" loading="lazy">

	</figure>
	<p>Click within the window that pops up and then copy the contents that is auto-selected to your clipboard. Save the key to an environment variable as it will be used in the subsequent curl command.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/1dS3x5a8AGAuZcewhbA05d/704873d37a4d2f6ed8c0cfc7be9472cf/scoped-token-data.png" alt="" class="kg-image" width="926" height="546" loading="lazy">

	</figure>
	<pre class="language-bash"><code class="language-bash">$ &nbsp;&nbsp;export CF_API_KEY="v1.0-c9..."</code></pre>
	<h5>iii. Make the API call</h5>
	<p>Note that you will need to remove newlines from the CSR as newlines are not permitted in JSON and add them back into the certificate that’s returned. When you remove them you should replace the newline character (hex code 0A) with the string "\n".</p>
	<pre class="language-bash"><code class="language-bash">$ curl -sX POST https://api.cloudflare.com/client/v4/certificates/ \
-H "Content-Type: application/json" \
-H "Accept: application/json" \
-H "X-AUTH-USER-SERVICE-KEY: $CF_API_KEY" \
--data '{"hostnames":["example.com","*.example.com"],"requested_validity":"365","request_type":"origin-rsa","csr":"-----BEGIN CERTIFICATE REQUEST-----...-----END CERTIFICATE REQUEST-----"}'</code></pre>
	<h5>iv. Extract certificate from API response</h5>
	<pre class="language-bash"><code class="language-bash">{
 &nbsp;"success": true, "errors": [], "messages": [],
 &nbsp;"result": {
 &nbsp;&nbsp;&nbsp;"id": "0x47530d8f561faa08",
 &nbsp;&nbsp;&nbsp;"certificate": "-----BEGIN CERTIFICATE-----...-----END CERTIFICATE-----",
 &nbsp;&nbsp;&nbsp;"hostnames": [ "example.com", "*.example.com" ],
 &nbsp;&nbsp;&nbsp;"expires_on": "2014-01-01T05:20:00.12345Z",
 &nbsp;&nbsp;&nbsp;"request_type": "origin-rsa",
    "requested_validity": "365",
 &nbsp;&nbsp;&nbsp;"csr": "-----BEGIN CERTIFICATE REQUEST-----...-----END CERTIFICATE REQUEST-----"
 &nbsp;}
}</code></pre>
	<h4>3. CLI: Command Line Interface (Linux only)</h4>
	<p>Lastly, if you’re using a Linux platform that supports RPM or DEB packages, the easiest way to request certificates is with the Origin CA CLI. Before proceeding, make sure you follow the instructions above in the API example to save your API key in the CF_API_KEY environment variable.</p>
	<p>To get started, browse to <a href="https://pkg.cloudflare.com">https://pkg.cloudflare.com/</a> and follow the instructions to add the CloudFlare Package Repository to your system. With the new package server in place, use apt or yum to install the "cfca" package (binary placed in /usr/local/bin on DEbian, e.g.,) and then issue a certificate in a manner similar to the following examples:</p>
	<h5>i. Default parameters (RSA key, 15 year validity)</h5>
	<pre class="language-bash"><code class="language-bash">$ /usr/local/bin/cfca getcert -hostnames example.com,*.example.com
2016/04/25 19:47:23 [INFO] generate received request
2016/04/25 19:47:23 [INFO] received CSR
2016/04/25 19:47:23 [INFO] generating key: rsa-2048
2016/04/25 19:47:24 [INFO] encoded CSR
2016/04/25 19:47:24 [INFO] Connecting to https://api.cloudflare.com/client/v4/certificates/
2016/04/25 19:47:25 [INFO] Successfully issued certificate for:
*.example.com
example.com
2016/04/25 19:47:25 [INFO] Saved generated private key to wildcard.example.com.key
2016/04/25 19:47:25 [INFO] Saved issued certificate to wildcard.example.com.pem</code></pre>
	<h5>ii. Short-lived multi-zone ECC example (ECDSA key, 7 day validity)</h5>
	<pre class="language-bash"><code class="language-bash">$ /usr/local/bin/cfca getcert -days 7 -hostnames *.foo.com,*.bar.com -key-type ecdsa -key-size 256
2016/04/26 12:24:24 [INFO] generate received request
2016/04/26 12:24:24 [INFO] received CSR
2016/04/26 12:24:24 [INFO] generating key: ecdsa-256
2016/04/26 12:24:24 [INFO] encoded CSR
2016/04/26 12:24:24 [INFO] Connecting to https://api.cloudflare.com/client/v4/certificates/
2016/04/26 12:24:28 [INFO] Successfully issued certificate for:
*.foo.com
*.bar.com
2016/04/26 12:24:28 [INFO] Saved generated private key to wildcard.foo.com.key
2016/04/26 12:24:28 [INFO] Saved issued certificate to wildcard.foo.com.pem

$ cat wildcard.foo.com.pem | openssl x509 -noout -text | grep "Not After\|Public Key Algorithm\|DNS"
Not After : May &nbsp;3 19:19:00 2016 GMT
Public Key Algorithm: id-ecPublicKey
DNS:*.foo.com, DNS:*.bar.com</code></pre>
	<h3>Final Recommendations &amp; Feedback</h3>
	<p>As you use Origin CA to generate certificates and secure your origin servers, keep these recommendations in mind:</p>
	<ol>
		<li>
			<p>Use Origin CA to generate certificates for your origin servers, using wildcards for each zone to keep SANs to a minimum.</p>
		</li>
		<li>
			<p>Upgrade each zone’s SSL setting from "Flexible" or "Full" to "Strict" mode you have Origin CA or public CA certificates installed protecting all hostnames in that zone.</p>
		</li>
		<li>
			<p>If you were previously enrolled in our beta Origin CA program, you should issue new certificates so they include revocation endpoints.</p>
		</li>
		<li>
			<p>When pausing CloudFlare or gray-clouding individual zones, be aware that you and your visitors may receive errors in their browsers until you orange-cloud (reverse proxy) them again.</p>
		</li>
	</ol>
	<p>If you encounter any difficulty issuing certificates, or have any other concerns or suggestions, please open a <a href="https://support.cloudflare.com">support ticket</a> and we will be happy to assist you.</p>
	</pre>
</div>