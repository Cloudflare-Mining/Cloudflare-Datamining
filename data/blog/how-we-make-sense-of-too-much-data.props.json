{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "8",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Constantin Pan",
				"slug": "constantin-pan",
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2ICl6tt16EVQTzZBDsUY8e/ea13d3c440b722fdcd261a9240105222/_tmp_mini_magick20220928-42-1vrdnmo.jpg",
				"location": "London"
			},
			{
				"name": "Jim Hawkridge",
				"slug": "jim-hawkridge",
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2Exc0INWMvhkHxGvQWUYlK/bf19c60e186ba3457df51302858959fe/_tmp_mini_magick20220928-42-1isuz89.jpg"
			}
		],
		"excerpt": "Here we explain how we made our data pipeline scale to 700 million events per second while becoming more resilient than ever before. We share some math behind our approach and some of the designs of ",
		"feature_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/75NKwswtRHDDkYNKWPeKlr/8ecd9aba303acb2a48b2087226dab070/BLOG-2486_1.png",
		"featured": false,
		"html": "<p>Cloudflare&#39;s network provides an enormous array of services to our customers. We collect and deliver associated data to customers in the form of event logs and aggregated analytics. As of December 2024, our data pipeline is ingesting up to 706M events per second generated by Cloudflare&#39;s services, and that represents 100x growth since our <a href=\"https://blog.cloudflare.com/http-analytics-for-6m-requests-per-second-using-clickhouse/\"><u>2018 data pipeline blog post</u></a>. </p><p>At peak, we are moving 107 <a href=\"https://simple.wikipedia.org/wiki/Gibibyte\"><u>GiB</u></a>/s of compressed data, either pushing it directly to customers or subjecting it to additional queueing and batching.</p><p>All of these data streams power things like <a href=\"https://developers.cloudflare.com/logs/\"><u>Logs</u></a>, <a href=\"https://developers.cloudflare.com/analytics/\"><u>Analytics</u></a>, and billing, as well as other products, such as training machine learning models for bot detection. This blog post is focused on techniques we use to efficiently and accurately deal with the high volume of data we ingest for our Analytics products. A previous <a href=\"https://blog.cloudflare.com/cloudflare-incident-on-november-14-2024-resulting-in-lost-logs/\"><u>blog post</u></a> provides a deeper dive into the data pipeline for Logs. </p><p>The pipeline can be roughly described by the following diagram.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5ihv6JXx19nJiEyfCaCg8V/ad7081720514bafd070cc38a04bc7097/BLOG-2486_2.jpg\" alt=\"BLOG-2486 2\" class=\"kg-image\" width=\"1999\" height=\"1939\" loading=\"lazy\"/>\n          </figure><p>The data pipeline has multiple stages, and each can and will naturally break or slow down because of hardware failures or misconfiguration. And when that happens, there is just too much data to be able to buffer it all for very long. Eventually some will get dropped, causing gaps in analytics and a degraded product experience unless proper mitigations are in place.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"dropping-data-to-retain-information\">Dropping data to retain information</h3>\n            <a href=\"#dropping-data-to-retain-information\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>How does one retain valuable information from more than half a billion events per second, when some must be dropped? Drop it in a controlled way, by downsampling.</p><p>Here is a visual analogy showing the difference between uncontrolled data loss and downsampling. In both cases the same number of pixels were delivered. One is a higher resolution view of just a small portion of a popular painting, while the other shows the full painting, albeit blurry and highly pixelated.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4kUGB4RLQzFb7cphMpHqAg/e7ccf871c73e0e8ca9dcac32fe265f18/Screenshot_2025-01-24_at_10.57.17_AM.png\" alt=\"\" class=\"kg-image\" width=\"1008\" height=\"409\" loading=\"lazy\"/>\n          </figure><p>As we noted above, any point in the pipeline can fail, so we want the ability to downsample at any point as needed. Some services proactively downsample data at the source before it even hits Logfwdr. This makes the information extracted from that data a little bit blurry, but much more useful than what otherwise would be delivered: random chunks of the original with gaps in between, or even nothing at all. The amount of &quot;blur&quot; is outside our control (we make our best effort to deliver full data), but there is a robust way to estimate it, as discussed in the <a href=\"/how-we-make-sense-of-too-much-data/#extracting-value-from-downsampled-data\"><u>next section</u></a>.</p><p>Logfwdr can decide to downsample data sitting in the buffer when it overflows. Logfwdr handles many data streams at once, so we need to prioritize them by assigning each data stream a weight and then applying <a href=\"https://en.wikipedia.org/wiki/Max-min_fairness\"><u>max-min fairness</u></a> to better utilize the buffer. It allows each data stream to store as much as it needs, as long as the whole buffer is not saturated. Once it is saturated, streams divide it fairly according to their weighted size.</p><p>In our implementation (Go), each data stream is driven by a goroutine, and they cooperate via channels. They consult a single tracker object every time they allocate and deallocate memory. The tracker uses a <a href=\"https://en.wikipedia.org/wiki/Heap_(data_structure)\"><u>max-heap</u></a> to always know who the heaviest participant is and what the total usage is. Whenever the total usage goes over the limit, the tracker repeatedly sends the &quot;please shed some load&quot; signal to the heaviest participant, until the usage is again under the limit.</p><p>The effect of this is that healthy streams, which buffer a tiny amount, allocate whatever they need without losses. But any lagging streams split the remaining memory allowance fairly.</p><p>We downsample more or less uniformly, by always taking some of the least downsampled batches from the buffer (using min-heap to find those) and merging them together upon downsampling.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/15VP0VYkrvkQboX9hrOy0q/e3d087fe704bd1b0ee41eb5b7a24b899/BLOG-2486_4.png\" alt=\"BLOG-2486 4\" class=\"kg-image\" width=\"1999\" height=\"923\" loading=\"lazy\"/>\n          </figure><p><sup><i>Merging keeps the batches roughly the same size and their number under control.</i></sup></p><p>Downsampling is cheap, but since data in the buffer is compressed, it causes recompression, which is the single most expensive thing we do to the data. But using extra CPU time is the last thing you want to do when the system is under heavy load! We compensate for the recompression costs by starting to downsample the fresh data as well (before it gets compressed for the first time) whenever the stream is in the &quot;shed the load&quot; state.</p><p>We called this approach &quot;bottomless buffers&quot;, because you can squeeze effectively infinite amounts of data in there, and it will just automatically be thinned out. Bottomless buffers resemble <a href=\"https://en.wikipedia.org/wiki/Reservoir_sampling\"><u>reservoir sampling</u></a>, where the buffer is the reservoir and the population comes as the input stream. But there are some differences. First is that in our pipeline the input stream of data never ends, while reservoir sampling assumes it ends to finalize the sample. Secondly, the resulting sample also never ends.</p><p>Let&#39;s look at the next stage in the pipeline: Logreceiver. It sits in front of a distributed queue. The purpose of logreceiver is to partition each stream of data by a key that makes it easier for Logpush, Analytics inserters, or some other process to consume.</p><p>Logreceiver proactively performs adaptive sampling of analytics. This improves the accuracy of analytics for small customers (receiving on the order of 10 events per day), while more aggressively downsampling large customers (millions of events per second). Logreceiver then pushes the same data at multiple resolutions (100%, 10%, 1%, etc.) into different topics in the distributed queue. This allows it to keep pushing something rather than nothing when the queue is overloaded, by just skipping writing the high-resolution samples of data.</p><p>The same goes for Inserters: they can skip <i>reading or writing</i> high-resolution data. The Analytics APIs can skip <i>reading</i> high resolution data. The analytical database might be unable to read high resolution data because of overload or degraded cluster state or because there is just too much to read (very wide time range or very large customer). Adaptively dropping to lower resolutions allows the APIs to return <i>some</i> results in all of those cases.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"extracting-value-from-downsampled-data\">Extracting value from downsampled data</h3>\n            <a href=\"#extracting-value-from-downsampled-data\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>Okay, we have some downsampled data in the analytical database. It looks like the original data, but with some rows missing. How do we make sense of it? How do we know if the results can be trusted?</p><p>Let&#39;s look at the math.</p>Since the amount of sampling can vary over time and between nodes in the distributed system, we need to store this information along with the data. With each event $x_i$ we store its sample interval, which is the reciprocal to its inclusion probability $\\pi_i = \\frac{1}{\\text{sample interval}}$. For example, if we sample 1 in every 1,000 events, each of the events included in the resulting sample will have its $\\pi_i = 0.001$, so the sample interval will be 1,000. When we further downsample that batch of data, the inclusion probabilities (and the sample intervals) multiply together: a 1 in 1,000 sample from a 1 in 1,000 sample is a 1 in 1,000,000 sample of the original population. The sample interval of an event can also be interpreted roughly as the number of original events that this event represents, so in the literature it is known as weight $w_i = \\frac{1}{\\pi_i}$.\n</p>\nWe rely on the <a href=\"https://en.wikipedia.org/wiki/Horvitz%E2%80%93Thompson_estimator\">Horvitz-Thompson estimator</a> (HT, <a href=\"https://www.stat.cmu.edu/~brian/905-2008/papers/Horvitz-Thompson-1952-jasa.pdf\">paper</a>) in order to derive analytics about $x_i$. It gives two estimates: the analytical estimate (e.g. the population total or size) and the estimate of the variance of that estimate. The latter enables us to figure out how accurate the results are by building <a href=\"https://en.wikipedia.org/wiki/Confidence_interval\">confidence intervals</a>. They define ranges that cover the true value with a given probability <i>(confidence level)</i>. A typical confidence level is 0.95, at which a confidence interval (a, b) tells that you can be 95% sure the true SUM or COUNT is between a and b.\n</p><p>So far, we know how to use the HT estimator for doing SUM, COUNT, and AVG.</p>Given a sample of size $n$, consisting of values $x_i$ and their inclusion probabilities $\\pi_i$, the HT estimator for the population total (i.e. SUM) would be\n\n$$\\widehat{T}=\\sum_{i=1}^n{\\frac{x_i}{\\pi_i}}=\\sum_{i=1}^n{x_i w_i}.$$\n\nThe variance of $\\widehat{T}$ is:\n\n$$\\widehat{V}(\\widehat{T}) = \\sum_{i=1}^n{x_i^2 \\frac{1 - \\pi_i}{\\pi_i^2}} + \\sum_{i \\neq j}^n{x_i x_j \\frac{\\pi_{ij} - \\pi_i \\pi_j}{\\pi_{ij} \\pi_i \\pi_j}},$$\n\nwhere $\\pi_{ij}$ is the probability of both $i$-th and $j$-th events being sampled together.\n</p>\nWe use <a href=\"https://en.wikipedia.org/wiki/Poisson_sampling\">Poisson sampling</a>, where each event is subjected to an independent <a href=\"https://en.wikipedia.org/wiki/Bernoulli_trial\">Bernoulli trial</a> (\"coin toss\") which determines whether the event becomes part of the sample. Since each trial is independent, we can equate $\\pi_{ij} = \\pi_i \\pi_j$, which when plugged in the variance estimator above turns the right-hand sum to zero:\n\n$$\\widehat{V}(\\widehat{T}) = \\sum_{i=1}^n{x_i^2 \\frac{1 - \\pi_i}{\\pi_i^2}} + \\sum_{i \\neq j}^n{x_i x_j \\frac{0}{\\pi_{ij} \\pi_i \\pi_j}},$$\n\nthus\n\n$$\\widehat{V}(\\widehat{T}) = \\sum_{i=1}^n{x_i^2 \\frac{1 - \\pi_i}{\\pi_i^2}} = \\sum_{i=1}^n{x_i^2 w_i (w_i-1)}.$$\n\nFor COUNT we use the same estimator, but plug in $x_i = 1$. This gives us:\n\n$$\\begin{align}\n\\widehat{C} &= \\sum_{i=1}^n{\\frac{1}{\\pi_i}} = \\sum_{i=1}^n{w_i},\\\\\n\\widehat{V}(\\widehat{C}) &= \\sum_{i=1}^n{\\frac{1 - \\pi_i}{\\pi_i^2}} = \\sum_{i=1}^n{w_i (w_i-1)}.\n\\end{align}$$\n\nFor AVG we would use\n\n$$\\begin{align}\n\\widehat{\\mu} &= \\frac{\\widehat{T}}{N},\\\\\n\\widehat{V}(\\widehat{\\mu}) &= \\frac{\\widehat{V}(\\widehat{T})}{N^2},\n\\end{align}$$\n\nif we could, but the original population size $N$ is not known, it is not stored anywhere, and it is not even possible to store because of custom filtering at query time. Plugging $\\widehat{C}$ instead of $N$ only partially works. It gives a valid estimator for the mean itself, but not for its variance, so the constructed confidence intervals are unusable.\n</p>\nIn all cases the corresponding pair of estimates are used as the $\\mu$ and $\\sigma^2$ of the normal distribution (because of the <a href=\"https://en.wikipedia.org/wiki/Central_limit_theorem\">central limit theorem</a>), and then the bounds for the confidence interval (of confidence level ) are:\n\n$$\\Big( \\mu - \\Phi^{-1}\\big(\\frac{1 + \\alpha}{2}\\big) \\cdot \\sigma, \\quad \\mu + \\Phi^{-1}\\big(\\frac{1 + \\alpha}{2}\\big) \\cdot \\sigma\\Big).$$<p>We do not know the N, but there is a workaround: simultaneous confidence intervals. Construct confidence intervals for SUM and COUNT independently, and then combine them into a confidence interval for AVG. This is known as the <a href=\"https://www.sciencedirect.com/topics/mathematics/bonferroni-method\"><u>Bonferroni method</u></a>. It requires generating wider (half the &quot;inconfidence&quot;) intervals for SUM and COUNT. Here is a simplified visual representation, but the actual estimator will have to take into account the possibility of the orange area going below zero.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/69Vvi2CHSW8Gew0TWHSndj/1489cfe1ff57df4e7e1ca3c31a8444a5/BLOG-2486_5.png\" alt=\"BLOG-2486 5\" class=\"kg-image\" width=\"991\" height=\"504\" loading=\"lazy\"/>\n          </figure><p>In SQL, the estimators and confidence intervals look like this:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">WITH sum(x * _sample_interval)                              AS t,\n     sum(x * x * _sample_interval * (_sample_interval - 1)) AS vt,\n     sum(_sample_interval)                                  AS c,\n     sum(_sample_interval * (_sample_interval - 1))         AS vc,\n     -- ClickHouse does not expose the erf⁻¹ function, so we precompute some magic numbers,\n     -- (only for 95% confidence, will be different otherwise):\n     --   1.959963984540054 = Φ⁻¹((1+0.950)/2) = √2 * erf⁻¹(0.950)\n     --   2.241402727604945 = Φ⁻¹((1+0.975)/2) = √2 * erf⁻¹(0.975)\n     1.959963984540054 * sqrt(vt) AS err950_t,\n     1.959963984540054 * sqrt(vc) AS err950_c,\n     2.241402727604945 * sqrt(vt) AS err975_t,\n     2.241402727604945 * sqrt(vc) AS err975_c\nSELECT t - err950_t AS lo_total,\n       t            AS est_total,\n       t + err950_t AS hi_total,\n       c - err950_c AS lo_count,\n       c            AS est_count,\n       c + err950_c AS hi_count,\n       (t - err975_t) / (c + err975_c) AS lo_average,\n       t / c                           AS est_average,\n       (t + err975_t) / (c - err975_c) AS hi_average\nFROM ...</pre></code>\n            <p>Construct a confidence interval for each timeslot on the timeseries, and you get a confidence band, clearly showing the accuracy of the analytics. The figure below shows an example of such a band in shading around the line.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4JEnnC6P4BhM8qB8J5yKqt/3635835967085f9b24f64a5731457ddc/BLOG-2486_6.png\" alt=\"BLOG-2486 6\" class=\"kg-image\" width=\"1726\" height=\"574\" loading=\"lazy\"/>\n          </figure>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"sampling-is-easy-to-screw-up\">Sampling is easy to screw up</h3>\n            <a href=\"#sampling-is-easy-to-screw-up\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>We started using confidence bands on our internal dashboards, and after a while noticed something scary: a systematic error! For one particular website the &quot;total bytes served&quot; estimate was higher than the true control value obtained from rollups, and the confidence bands were way off. See the figure below, where the true value (blue line) is outside the yellow confidence band at all times.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/CHCyKyXqPMj8DnMpBUf3N/772fb61f02b79c59417f66d9dc0b5d19/BLOG-2486_7.png\" alt=\"BLOG-2486 7\" class=\"kg-image\" width=\"1013\" height=\"716\" loading=\"lazy\"/>\n          </figure><p>We checked the stored data for corruption, it was fine. We checked the math in the queries, it was fine. It was only after reading through the source code for all of the systems responsible for sampling that we found a candidate for the root cause.</p><p>We used simple random sampling everywhere, basically &quot;tossing a coin&quot; for each event, but in Logreceiver sampling was done differently. Instead of sampling <i>randomly</i> it would perform <i>systematic sampling</i> by picking events at equal intervals starting from the first one in the batch.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4xUwjxdylG5ARlFlDtv1OC/76db68677b7ae072b0a065f59d82c6f2/BLOG-2486_8.png\" alt=\"BLOG-2486 8\" class=\"kg-image\" width=\"763\" height=\"158\" loading=\"lazy\"/>\n          </figure><p>Why would that be a problem?</p>There are two reasons. The first is that we can no longer claim $\\pi_{ij} = \\pi_i \\pi_j$, so the simplified variance estimator stops working and confidence intervals cannot be trusted. But even worse, the estimator for the total becomes biased. To understand why exactly, we wrote a short repro code in Python:\n<br></p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">import itertools\n\ndef take_every(src, period):\n    for i, x in enumerate(src):\n    if i % period == 0:\n        yield x\n\npattern = [10, 1, 1, 1, 1, 1]\nsample_interval = 10 # bad if it has common factors with len(pattern)\ntrue_mean = sum(pattern) / len(pattern)\n\norig = itertools.cycle(pattern)\nsample_size = 10000\nsample = itertools.islice(take_every(orig, sample_interval), sample_size)\n\nsample_mean = sum(sample) / sample_size\n\nprint(f&quot;{true_mean=} {sample_mean=}&quot;)</pre></code>\n            <p>After playing with different values for <code><b>pattern</b></code> and <code><b>sample_interval</b></code> in the code above, we realized where the bias was coming from.</p><p>Imagine a person opening a huge generated HTML page with many small/cached resources, such as icons. The first response will be big, immediately followed by a burst of small responses. If the website is not visited that much, responses will tend to end up all together at the start of a batch in Logfwdr. Logreceiver does not cut batches, only concatenates them. The first response remains first, so it always gets picked and skews the estimate up.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2WZUzqCwr2A6WgX1T5UE8z/7a2e08b611fb64e64a61e3d5c792fe23/BLOG-2486_9.png\" alt=\"BLOG-2486 9\" class=\"kg-image\" width=\"888\" height=\"659\" loading=\"lazy\"/>\n          </figure><p>We checked the hypothesis against the raw unsampled data that we happened to have because that particular website was also using one of the <a href=\"https://developers.cloudflare.com/logs/\"><u>Logs</u></a> products. We took all events in a given time range, and grouped them by cutting at gaps of at least one minute. In each group, we ranked all events by time and looked at the variable of interest (response size in bytes), and put it on a scatter plot against the rank inside the group.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2IXtqGkRjV0xs3wvwx609A/81e67736cacbccdd839c2177769ee4fe/BLOG-2486_10.png\" alt=\"BLOG-2486 10\" class=\"kg-image\" width=\"1379\" height=\"861\" loading=\"lazy\"/>\n          </figure><p>A clear pattern! The first response is much more likely to be larger than average.</p><p>We fixed the issue by making Logreceiver shuffle the data before sampling. As we rolled out the fix, the estimation and the true value converged.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4TL1pKDLw7MA6yGMSCahJN/227cb22054e0e8fe65c7766aa6e4b541/BLOG-2486_11.png\" alt=\"BLOG-2486 11\" class=\"kg-image\" width=\"1371\" height=\"716\" loading=\"lazy\"/>\n          </figure><p>Now, after battle testing it for a while, we are confident the HT estimator is implemented properly and we are using the correct sampling process.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"using-cloudflares-analytics-apis-to-query-sampled-data\">Using Cloudflare&#39;s analytics APIs to query sampled data</h3>\n            <a href=\"#using-cloudflares-analytics-apis-to-query-sampled-data\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>We already power most of our analytics datasets with sampled data. For example, the <a href=\"https://developers.cloudflare.com/analytics/analytics-engine/\"><u>Workers Analytics Engine</u></a> exposes the <a href=\"https://developers.cloudflare.com/analytics/analytics-engine/sql-api/#sampling\"><u>sample interval</u></a> in SQL, allowing our customers to build their own dashboards with confidence bands. In the GraphQL API, all of the data nodes that have &quot;<a href=\"https://developers.cloudflare.com/analytics/graphql-api/sampling/#adaptive-sampling\"><u>Adaptive</u></a>&quot; in their name are based on sampled data, and the sample interval is exposed as a field there as well, though it is not possible to build confidence intervals from that alone. We are working on exposing confidence intervals in the GraphQL API, and as an experiment have added them to the count and edgeResponseBytes (sum) fields on the httpRequestsAdaptiveGroups nodes. This is available under <code><b>confidence(level: X)</b></code>.</p><p>Here is a sample GraphQL query:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">query HTTPRequestsWithConfidence(\n  $accountTag: string\n  $zoneTag: string\n  $datetimeStart: string\n  $datetimeEnd: string\n) {\n  viewer {\n    zones(filter: { zoneTag: $zoneTag }) {\n      httpRequestsAdaptiveGroups(\n        filter: {\n          datetime_geq: $datetimeStart\n          datetime_leq: $datetimeEnd\n      }\n      limit: 100\n    ) {\n      confidence(level: 0.95) {\n        level\n        count {\n          estimate\n          lower\n          upper\n          sampleSize\n        }\n        sum {\n          edgeResponseBytes {\n            estimate\n            lower\n            upper\n            sampleSize\n          }\n        }\n      }\n    }\n  }\n}\n</pre></code>\n            <p>The query above asks for the estimates and the 95% confidence intervals for <code><b>SUM(edgeResponseBytes)</b></code> and <code><b>COUNT</b></code>. The results will also show the sample size, which is good to know, as we rely on the <a href=\"https://en.wikipedia.org/wiki/Central_limit_theorem\"><u>central limit theorem</u></a> to build the confidence intervals, thus small samples don&#39;t work very well.</p><p>Here is the response from this query:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">{\n  &quot;data&quot;: {\n    &quot;viewer&quot;: {\n      &quot;zones&quot;: [\n        {\n          &quot;httpRequestsAdaptiveGroups&quot;: [\n            {\n              &quot;confidence&quot;: {\n                &quot;level&quot;: 0.95,\n                &quot;count&quot;: {\n                  &quot;estimate&quot;: 96947,\n                  &quot;lower&quot;: &quot;96874.24&quot;,\n                  &quot;upper&quot;: &quot;97019.76&quot;,\n                  &quot;sampleSize&quot;: 96294\n                },\n                &quot;sum&quot;: {\n                  &quot;edgeResponseBytes&quot;: {\n                    &quot;estimate&quot;: 495797559,\n                    &quot;lower&quot;: &quot;495262898.54&quot;,\n                    &quot;upper&quot;: &quot;496332219.46&quot;,\n                    &quot;sampleSize&quot;: 96294\n                  }\n                }\n              }\n            }\n          ]\n        }\n      ]\n    }\n  },\n  &quot;errors&quot;: null\n}\n</pre></code>\n            <p>The response shows the estimated count is 96947, and we are 95% confident that the true count lies in the range 96874.24 to 97019.76. Similarly, the estimate and range for the sum of response bytes are provided.</p><p>The estimates are based on a sample size of 96294 rows, which is plenty of samples to calculate good confidence intervals.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"conclusion\">Conclusion</h3>\n            <a href=\"#conclusion\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>We have discussed what kept our data pipeline scalable and resilient despite doubling in size every 1.5 years, how the math works, and how it is easy to mess up. We are constantly working on better ways to keep the data pipeline, and the products based on it, useful to our customers. If you are interested in doing things like that and want to help us build a better Internet, check out our <a href=\"http://www.cloudflare.com/careers\"><u>careers page</u></a>.</p>",
		"id": "64DSvKdN853gq5Bx3Cyfij",
		"localeList": {
			"name": "blog-english-only",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "Here we explain how we made our data pipeline scale to 700 million events per second while becoming more resilient than ever before. We share some math behind our approach and some of the designs of ",
		"metadata": {
			"title": "Over 700 million events/second: How we make sense of too much data",
			"description": "Here we explain how we made our data pipeline scale to 700 million events per second while becoming more resilient than ever before. We share some math behind our approach and some of the designs of our systems, as well as issues that we had to face and bugs we had to chase.",
			"imgPreview": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3IbyM2qrP1QNY2qYgOLZo8/f235ea2206c509938d943cdef8a084c8/BLOG-2486_OG.png"
		},
		"primary_author": {},
		"published_at": "2025-01-27T14:00+00:00",
		"slug": "how-we-make-sense-of-too-much-data",
		"tags": [
			{
				"id": "2MJs149fz91foS5KPlD4hr",
				"name": "Bugs",
				"slug": "bugs"
			},
			{
				"id": "2OotqBxtRdi5MuC90AlyxE",
				"name": "Analytics",
				"slug": "analytics"
			},
			{
				"id": "5fXI7jwkVL8rNyKrfpk0Lw",
				"name": "Data",
				"slug": "data"
			},
			{
				"id": "6GfYtlrIy3UkkZHclLS3LX",
				"name": "GraphQL",
				"slug": "graphql"
			},
			{
				"id": "1pPf2NNj9SXrC0A0ERKp9v",
				"name": "SQL",
				"slug": "sql"
			},
			{
				"id": "KDI5hQcs301H8vxpGKXO0",
				"name": "Go",
				"slug": "go"
			},
			{
				"id": "2UVIYusJwlvsmPYl2AvSuR",
				"name": "Deep Dive",
				"slug": "deep-dive"
			},
			{
				"id": "64P6m4UbJfOqbY74LBs8GN",
				"name": "Sampling",
				"slug": "sampling"
			}
		],
		"title": "Over 700 million events/second: How we make sense of too much data",
		"updated_at": "2025-01-27T14:00:02.609Z",
		"url": "https://blog.cloudflare.com/how-we-make-sense-of-too-much-data"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.icon_aria_label": "Search",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"search.result_stat_empty": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong>",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"search.autocomplete_title": "Insert a query. Press enter to send",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}