{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "6",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Marek Majkowski",
				"slug": "marek-majkowski",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/1JuU5qavgwVeqR8BAUrd6U/bd09672287e7cf04d4347d9a47607eb5/marek-majkowski.jpeg",
				"location": null,
				"website": null,
				"twitter": "@majek04",
				"facebook": null
			}
		],
		"excerpt": "The Linux AIO is designed for, well, Asynchronous disk IO! Disk files are not the same thing as network sockets! Is it even possible to use the Linux AIO API with network sockets in the first place?\n\nThe answer turns out to be a strong YES!\n",
		"feature_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/2ZpaAETYvADuip6gpfOvTP/01adfb4e76ed4452595650b6d7b7e523/io_submit-the-epoll-alternative-youve-never-heard-about.jpg",
		"featured": false,
		"html": "<p>My curiosity was piqued by an LWN article about <a href=\"https://lwn.net/Articles/743714/\">IOCB_CMD_POLL - A new kernel polling interface</a>. It discusses an addition of a new polling mechanism to Linux AIO API, which was merged in 4.18 kernel. The whole idea is rather intriguing. The author of the patch is proposing to use the Linux AIO API with things like network sockets.</p><p>Hold on. The Linux AIO is designed for, well, <b>A</b>synchronous disk <b>IO</b>! Disk files are not the same thing as network sockets! Is it even possible to use the Linux AIO API with network sockets in the first place?</p><p>The answer turns out to be a strong YES! In this article I&#39;ll explain how to use the strengths of Linux AIO API to write better and faster network servers.</p><p>But before we start, what is Linux AIO anyway?</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/eFqY9nu5REcVlHdjmlag3/47c84df38ca7420fad6baedbef3ad26b/6891085910_3390ebe29f_k.jpg\" alt=\"\" class=\"kg-image\" width=\"2048\" height=\"1182\" loading=\"lazy\"/>\n            \n            </figure><p><a href=\"https://www.flickr.com/photos/schill/6891085910/\">Photo</a> by <a href=\"https://www.flickr.com/photos/schill\">Scott Schiller</a> CC/BY/2.0</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"introduction-to-linux-aio\">Introduction to Linux AIO</h2>\n            <a href=\"#introduction-to-linux-aio\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Linux AIO exposes asynchronous disk IO to userspace software.</p><p>Historically on Linux, all disk operations were blocking. Whether you did <code>open()</code>, <code>read()</code>, <code>write()</code> or <code>fsync()</code>, you could be sure your thread would stall if the needed data and meta-data was not ready in disk cache. This usually isn&#39;t a problem. If you do small amount of IO or have plenty of memory, the disk syscalls would gradually fill the cache and on average be rather fast.</p><p>The IO operation performance drops for IO-heavy workloads, like databases or caching web proxies. In such applications it would be tragic if a whole server stalled, just because some odd <code>read()</code> syscall had to wait for disk.</p><p>To work around this problem, applications use one of the three approaches:</p><p>(1) Use thread pools and offload blocking syscalls to worker threads. This is what glibc POSIX AIO (not to be confused with Linux AIO) wrapper does. (See: <a href=\"https://www.ibm.com/developerworks/linux/library/l-async/\">IBM&#39;s documentation</a>). This is also what we ended up doing in our application at Cloudflare - <a href=\"/how-we-scaled-nginx-and-saved-the-world-54-years-every-day/\">we offloaded read() and open() calls to a thread pool</a>.</p><p>(2) Pre-warm the disk cache with <code>posix_fadvise(2)</code> and hope for the best.</p><p>(3) Use Linux AIO with XFS filesystem, <a href=\"https://lwn.net/Articles/671649/\">file opened with O_DIRECT</a>, and <a href=\"https://www.scylladb.com/2016/02/09/qualifying-filesystems/\">avoid the undocumented pitfalls</a>.</p><p>None of these methods is perfect. Even the Linux AIO if used carelessly, could still block in the <code>io_submit()</code> call. This was recently mentioned <a href=\"https://lwn.net/Articles/724198/\">in another LWN article</a>:</p><blockquote><p>The Linux asynchronous I/O (AIO) layer tends to have many critics and few defenders, but most people at least expect it to actually be asynchronous. In truth, an AIO operation can block in the kernel for a number of reasons, making AIO difficult to use in situations where the calling thread truly cannot afford to block.</p></blockquote><p>Now that we know what Linux AIO API doesn&#39;t do well, let&#39;s see where it shines.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"simplest-linux-aio-program\">Simplest Linux AIO program</h2>\n            <a href=\"#simplest-linux-aio-program\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>To use Linux AIO you first need <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2019-01-io-submit/aio_passwd.c\">to define the 5 needed syscalls</a> - glibc doesn&#39;t provide wrapper functions. To use Linux AIO we need:</p><p>(1) First call <code>io_setup()</code> to setup the <code>aio_context</code> data structure. Kernel will hand us an opaque pointer.</p><p>(2) Then we can call <code>io_submit()</code> to submit a vector of &quot;I/O control blocks&quot; <code>struct iocb</code> for processing.</p><p>(3) Finally, we can call <code>io_getevents()</code> to block and wait for a vector of <code>struct io_event</code> - completion notification of the iocb&#39;s.</p><p>There are 8 commands that can be submitted in an iocb. Two read, two write, two fsync variants and a POLL command introduced in 4.18 Kernel:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">IOCB_CMD_PREAD = 0,\nIOCB_CMD_PWRITE = 1,\nIOCB_CMD_FSYNC = 2,\nIOCB_CMD_FDSYNC = 3,\nIOCB_CMD_POLL = 5,   /* from 4.18 */\nIOCB_CMD_NOOP = 6,\nIOCB_CMD_PREADV = 7,\nIOCB_CMD_PWRITEV = 8,</pre></code>\n            <p>The <a href=\"https://github.com/torvalds/linux/blob/f346b0becb1bc62e45495f9cdbae3eef35d0b635/include/uapi/linux/aio_abi.h#L73-L107\"><code>struct iocb</code></a> passed to <code>io_submit</code> is large, and tuned for disk IO. Here&#39;s a simplified version:</p>\n            <pre class=\"language-.c\"><code class=\"language-.c\">struct iocb {\n  __u64 data;           /* user data */\n  ...\n  __u16 aio_lio_opcode; /* see IOCB_CMD_ above */\n  ...\n  __u32 aio_fildes;     /* file descriptor */\n  __u64 aio_buf;        /* pointer to buffer */\n  __u64 aio_nbytes;     /* buffer size */\n...\n}</pre></code>\n            <p>The completion notification retrieved from <code>io_getevents</code>:</p>\n            <pre class=\"language-.c\"><code class=\"language-.c\">struct io_event {\n  __u64  data;  /* user data */\n  __u64  obj;   /* pointer to request iocb */\n  __s64  res;   /* result code for this event */\n  __s64  res2;  /* secondary result */\n};\n</pre></code>\n            <p>Let&#39;s try an example. Here&#39;s the simplest program reading /etc/passwd file with Linux AIO API:</p>\n            <pre class=\"language-.c\"><code class=\"language-.c\">fd = open(&quot;/etc/passwd&quot;, O_RDONLY);\n\naio_context_t ctx = 0;\nr = io_setup(128, &amp;ctx);\n\nchar buf[4096];\nstruct iocb cb = {.aio_fildes = fd,\n                  .aio_lio_opcode = IOCB_CMD_PREAD,\n                  .aio_buf = (uint64_t)buf,\n                  .aio_nbytes = sizeof(buf)};\nstruct iocb *list_of_iocb[1] = {&amp;cb};\n\nr = io_submit(ctx, 1, list_of_iocb);\n\nstruct io_event events[1] = {{0}};\nr = io_getevents(ctx, 1, 1, events, NULL);\n\nbytes_read = events[0].res;\nprintf(&quot;read %lld bytes from /etc/passwd\\n&quot;, bytes_read);</pre></code>\n            <p>Full source is, <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2019-01-io-submit/aio_passwd.c\">as usual, on github</a>. Here&#39;s an strace of this program:</p>\n            <pre class=\"language-.txt\"><code class=\"language-.txt\">openat(AT_FDCWD, &quot;/etc/passwd&quot;, O_RDONLY)\nio_setup(128, [0x7f4fd60ea000])\nio_submit(0x7f4fd60ea000, 1, [{aio_lio_opcode=IOCB_CMD_PREAD, aio_fildes=3, aio_buf=0x7ffc5ff703d0, aio_nbytes=4096, aio_offset=0}])\nio_getevents(0x7f4fd60ea000, 1, 1, [{data=0, obj=0x7ffc5ff70390, res=2494, res2=0}], NULL)</pre></code>\n            <p>This all worked fine! But the disk read was not asynchronous: the <code>io_submit</code> syscall blocked and did all the work! The <code>io_getevents</code> call finished instantly. We could try to make the disk read async, but this requires O_DIRECT flag which skips the caches.</p><p>Lets try to better illustrate the blocking nature of <code>io_submit</code> on normal files. Here&#39;s similar example, showing strace when reading large 1GiB block from <code>/dev/zero</code>:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">io_submit(0x7fe1e800a000, 1, [{aio_lio_opcode=IOCB_CMD_PREAD, aio_fildes=3, aio_buf=0x7fe1a79f4000, aio_nbytes=1073741824, aio_offset=0}]) \\\n    = 1 &lt;0.738380&gt;\nio_getevents(0x7fe1e800a000, 1, 1, [{data=0, obj=0x7fffb9588910, res=1073741824, res2=0}], NULL) \\\n    = 1 &lt;0.000015&gt;</pre></code>\n            <p>The kernel spent 738ms in <code>io_submit</code> and only 15us in <code>io_getevents</code>. The kernel behaves the same way with network sockets - all the work is done in <code>io_submit</code>.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/1Aem3ZSReNmWJZwFNQmySO/466e6ee542111b1aec2a6f02ae40e4e2/Network_card-2.jpg\" alt=\"\" class=\"kg-image\" width=\"2000\" height=\"876\" loading=\"lazy\"/>\n            \n            </figure><p><a href=\"https://commons.wikimedia.org/wiki/File:Network_card.jpg\">Photo</a> by <a href=\"https://commons.wikimedia.org/wiki/User:Helix84\">Helix84</a> CC/BY-SA/3.0</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"linux-aio-with-sockets-batching\">Linux AIO with sockets - batching</h2>\n            <a href=\"#linux-aio-with-sockets-batching\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>The implementation of <code>io_submit</code> is rather conservative. Unless the passed descriptor is O_DIRECT file, it will just block and perform the requested action. In case of network sockets it means:</p><ul><li><p>For blocking sockets IOCB_CMD_PREAD will hang until a packet arrives.</p></li><li><p>For non-blocking sockets IOCB_CMD_PREAD will -11 (EAGAIN) return code.</p></li></ul><p>These are exactly the same semantics as for vanilla <code>read()</code> syscall. It&#39;s fair to say that for network sockets <code>io_submit</code> is no smarter than good old read/write calls.</p><p>It&#39;s important to note the <code>iocb</code> requests passed to kernel are evaluated in-order sequentially.</p><p>While Linux AIO won&#39;t help with async operations, it can definitely be used for syscall batching!</p><p>If you have a web server needing to send and receive data from hundreds of network sockets, using <code>io_submit</code> can be a great idea. This would avoid having to call <code>send</code> and <code>recv</code> hundreds of times. This will improve performance - jumping back and forth from userspace to kernel is not free, especially <a href=\"https://gist.github.com/antirez/9e716670f76133ec81cb24036f86ee95\">since the meltdown and spectre mitigations</a>.</p><p>One buffer</p><p>Multiple buffers</p><p>One file descriptor</p><p>read()</p><p>readv()</p><p>Many file descriptors</p><p>io_submit + IOCB_CMD_PREAD</p><p>io_submit + IOCB_CMD_PREADV</p><p>To illustrate the batching aspect of <code>io_submit</code>, let&#39;s create a small program forwarding data from one TCP socket to another. In simplest form, without Linux AIO, the program would have a trivial flow like this:</p>\n            <pre class=\"language-.py\"><code class=\"language-.py\">while True:\n  d = sd1.read(4096)\n  sd2.write(d)</pre></code>\n            <p>We can express the same logic with Linux AIO. The code will look like this:</p>\n            <pre class=\"language-.c\"><code class=\"language-.c\">struct iocb cb[2] = {{.aio_fildes = sd2,\n                      .aio_lio_opcode = IOCB_CMD_PWRITE,\n                      .aio_buf = (uint64_t)&amp;buf[0],\n                      .aio_nbytes = 0},\n                     {.aio_fildes = sd1,\n                     .aio_lio_opcode = IOCB_CMD_PREAD,\n                     .aio_buf = (uint64_t)&amp;buf[0],\n                     .aio_nbytes = BUF_SZ}};\nstruct iocb *list_of_iocb[2] = {&amp;cb[0], &amp;cb[1]};\nwhile(1) {\n  r = io_submit(ctx, 2, list_of_iocb);\n\n  struct io_event events[2] = {};\n  r = io_getevents(ctx, 2, 2, events, NULL);\n  cb[0].aio_nbytes = events[1].res;\n}</pre></code>\n            <p>This code submits two jobs to <code>io_submit</code>. First, request to write data to <code>sd2</code> then to read data from <code>sd1</code>. After the read is done, the code fixes up the write buffer size and loops again. The code does a cool trick - the first write is of size 0. We are doing so since we can fuse write+read in one io_submit (but not read+write). After a read is done we have to fix the write buffer size.</p><p>Is this code faster than the simple read/write version? Not yet. Both versions have two syscalls: read+write and io_submit+io_getevents. Fortunately, we can improve it.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"getting-rid-of-io_getevents\">Getting rid of io_getevents</h2>\n            <a href=\"#getting-rid-of-io_getevents\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>When running <code>io_setup()</code>, the kernel allocates a couple of pages of memory for the process. This is how this memory block looks like in /proc//maps:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">marek:~$ cat /proc/`pidof -s aio_passwd`/maps\n...\n7f7db8f60000-7f7db8f63000 rw-s 00000000 00:12 2314562     /[aio] (deleted)\n...</pre></code>\n            <p>The [aio] memory region (12KiB in my case) was allocated by the <code>io_setup</code>. This memory range is used a ring buffer storing the completion events. In most cases, there isn&#39;t any reason to call the real <code>io_getevents</code> syscall. The completion data can be easily retrieved from the ring buffer without the need of consulting the kernel. Here is a fixed version of the code:</p>\n            <pre class=\"language-.c\"><code class=\"language-.c\">int io_getevents(aio_context_t ctx, long min_nr, long max_nr,\n                 struct io_event *events, struct timespec *timeout)\n{\n    int i = 0;\n\n    struct aio_ring *ring = (struct aio_ring*)ctx;\n    if (ring == NULL || ring-&gt;magic != AIO_RING_MAGIC) {\n        goto do_syscall;\n    }\n\n    while (i &lt; max_nr) {\n        unsigned head = ring-&gt;head;\n        if (head == ring-&gt;tail) {\n            /* There are no more completions */\n            break;\n        } else {\n            /* There is another completion to reap */\n            events[i] = ring-&gt;events[head];\n            read_barrier();\n            ring-&gt;head = (head + 1) % ring-&gt;nr;\n            i++;\n        }\n    }\n\n    if (i == 0 &amp;&amp; timeout != NULL &amp;&amp; timeout-&gt;tv_sec == 0 &amp;&amp; timeout-&gt;tv_nsec == 0) {\n        /* Requested non blocking operation. */\n        return 0;\n    }\n\n    if (i &amp;&amp; i &gt;= min_nr) {\n        return i;\n    }\n\ndo_syscall:\n    return syscall(__NR_io_getevents, ctx, min_nr-i, max_nr-i, &amp;events[i], timeout);\n}\n</pre></code>\n            <p><a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2019-01-io-submit/aio_poll.c#L63\">Here&#39;s full code</a>. This ring buffer interface is poorly documented. I adapted this code from <a href=\"https://github.com/axboe/fio/blob/702906e9e3e03e9836421d5e5b5eaae3cd99d398/engines/libaio.c#L149-L172\">the axboe/fio project</a>.</p><p>With this code fixing the <code>io_getevents</code> function, our Linux AIO version of the TCP proxy needs only one syscall per loop, and indeed is a tiny bit faster than the read+write code.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/5BUl6rp23b2NJ1XX8Z7RmV/1de1221ac1f6541ac1aa4436b12d812d/16026681353_90b26e0731_z.jpg\" alt=\"\" class=\"kg-image\" width=\"640\" height=\"361\" loading=\"lazy\"/>\n            \n            </figure><p><a href=\"https://www.flickr.com/photos/99279135@N05/16026681353/\">Photo</a> by <a href=\"https://www.flickr.com/photos/99279135@N05/\">Train Photos</a> CC/BY-SA/2.0</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"epoll-alternative\">Epoll alternative</h2>\n            <a href=\"#epoll-alternative\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>With the addition of IOCB_CMD_POLL in kernel 4.18, one could use <code>io_submit</code> also as select/poll/epoll equivalent. For example, here&#39;s some code waiting for data on a socket:</p>\n            <pre class=\"language-.c\"><code class=\"language-.c\">struct iocb cb = {.aio_fildes = sd,\n                  .aio_lio_opcode = IOCB_CMD_POLL,\n                  .aio_buf = POLLIN};\nstruct iocb *list_of_iocb[1] = {&amp;cb};\n\nr = io_submit(ctx, 1, list_of_iocb);\nr = io_getevents(ctx, 1, 1, events, NULL);</pre></code>\n            <p><a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2019-01-io-submit/aio_poll.c\">Full code</a>. Here&#39;s the strace view:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">io_submit(0x7fe44bddd000, 1, [{aio_lio_opcode=IOCB_CMD_POLL, aio_fildes=3}]) \\\n    = 1 &lt;0.000015&gt;\nio_getevents(0x7fe44bddd000, 1, 1, [{data=0, obj=0x7ffef65c11a8, res=1, res2=0}], NULL) \\\n    = 1 &lt;1.000377&gt;</pre></code>\n            <p>As you can see this time the &quot;async&quot; part worked fine, the <code>io_submit</code> finished instantly and the <code>io_getevents</code> successfully blocked for 1s while awaiting data. This is pretty powerful and can be used instead of the <code>epoll_wait()</code> syscall.</p><p>Furthermore, normally dealing with <code>epoll</code> requires juggling <code>epoll_ctl</code> syscalls. Application developers go to great lengths to avoid calling this syscall too often. <a href=\"http://man7.org/linux/man-pages/man7/epoll.7.html\">Just read the man page</a> on EPOLLONESHOT and EPOLLET flags. Using <code>io_submit</code> for polling works around this whole complexity, and doesn&#39;t require any spurious syscalls. Just push your sockets to the iocb request vector, call <code>io_submit</code> exactly once and wait for completions. The API can&#39;t be simpler than this.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"summary\">Summary</h2>\n            <a href=\"#summary\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>In this blog post we reviewed the Linux AIO API. While initially conceived to be a disk-only API, it seems to be working in the same way as normal read/write syscalls on network sockets. But as opposed to read/write <code>io_submit</code> allows syscall batching, potentially improving performance.</p><p>Since kernel 4.18 <code>io_submit</code> and <code>io_getevents</code> can be used to wait for events like POLLIN and POLLOUT on network sockets. This is great, and could be used as a replacement for <code>epoll()</code> in the event loop.</p><p>I can imagine a network server that could just be doing <code>io_submit</code> and <code>io_getevents</code> syscalls, as opposed to the usual mix of <code>read</code>, <code>write</code>, <code>epoll_ctl</code> and <code>epoll_wait</code>. With such design the syscall batching aspect of <code>io_submit</code> could really shine. Such a server would be meaningfully faster.</p><p>Sadly, even with recent Linux AIO API improvements, the larger discussion remains. Famously, <a href=\"https://lwn.net/Articles/671657/\">Linus hates it</a>:</p><blockquote><p>AIO is a horrible ad-hoc design, with the main excuse being &quot;other, less gifted people, made that design, and we are implementing it for compatibility because database people - who seldom have any shred of taste - actually use it&quot;. But AIO was always really really ugly.</p></blockquote><p>Over the years there had been multiple attempts on creating a better batching and async interfaces, unfortunately, lacking coherent vision. For example, <a href=\"https://github.com/torvalds/linux/blob/6f0d349d922ba44e4348a17a78ea51b7135965b1/Documentation/networking/msg_zerocopy.rst\">recent addition of <code>sendto(MSG_ZEROCOPY)</code></a> allows for truly async transmission operations, but no batching. <code>io_submit</code> allows batching but not async. It&#39;s even worse than that - Linux currently has three ways of delivering async notifications - signals, <code>io_getevents</code> and <code>MSG_ERRQUEUE</code>.</p><p>Having said that I&#39;m really excited to see the new developments which allow developing faster network servers. I&#39;m jumping on the code to replace my rusty epoll event loops with io_submit!</p>",
		"id": "6zyOz9SzvPQNiQFsPWodxb",
		"localeList": {
			"name": "io_submit: The epoll alternative you've never heard about Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": null,
		"metadata": {
			"imgPreview": ""
		},
		"primary_author": {},
		"published_at": "2019-01-04T11:02:26.000+00:00",
		"slug": "io_submit-the-epoll-alternative-youve-never-heard-about",
		"tags": [
			{
				"id": "383iv0UQ6Lp0GZwOAxGq2p",
				"name": "Linux",
				"slug": "linux"
			},
			{
				"id": "5x72ei67SoD11VQ0uqFtpF",
				"name": "API",
				"slug": "api"
			},
			{
				"id": "4HIPcb68qM0e26fIxyfzwQ",
				"name": "Developers",
				"slug": "developers"
			}
		],
		"title": "io_submit: The epoll alternative you've never heard about",
		"updated_at": "2024-08-27T02:15:41.166Z",
		"url": "https://blog.cloudflare.com/io_submit-the-epoll-alternative-youve-never-heard-about"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}