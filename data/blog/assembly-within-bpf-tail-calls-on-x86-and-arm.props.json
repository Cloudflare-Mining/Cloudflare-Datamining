{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "11",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Jakub Sitnicki",
				"slug": "jakub",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6RLFhbkBfkn8gecOR2w7wW/1146ae51b6182b10a997c82813c13503/jakub.jpg",
				"location": null,
				"website": null,
				"twitter": null,
				"facebook": null,
				"publiclyIndex": true
			}
		],
		"excerpt": "We have first adopted the BPF tail calls when building our XDP-based packet processing pipeline. BPF tail calls have served us well since then. But they do have their caveats",
		"feature_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1TbQBOKbB8dbvWSXjrFo7n/c6cf037c1bc485bad5e852f59fcb56d3/assembly-within-bpf-tail-calls-on-x86-and-arm.png",
		"featured": false,
		"html": "\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3lk8AVPci0nIoH0jHfBTzC/d96fefa82025c4a8cc0b88f554d6dd77/unnamed-3.png\" alt=\"Assembly within! BPF tail calls on x86 and ARM\" class=\"kg-image\" width=\"1600\" height=\"900\" loading=\"lazy\"/>\n            \n            </figure><p>Early on when we learn to program, we get introduced to the concept of <a href=\"https://ocw.mit.edu/courses/6-00sc-introduction-to-computer-science-and-programming-spring-2011/resources/lecture-6-recursion/\">recursion</a>. And that it is handy for computing, among other things, sequences defined in terms of recurrences. Such as the famous <a href=\"https://en.wikipedia.org/wiki/Fibonacci_number\">Fibonnaci numbers</a> - <i>Fn = Fn-1 + Fn-2</i>.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5Zkbmk81PBl2lx62bzcNz4/ce5eb7474578577dd0c5d4c3284d73f2/Screenshot-2022-10-10-at-10.13.32.png\" alt=\"\" class=\"kg-image\" width=\"1618\" height=\"418\" loading=\"lazy\"/>\n            \n            </figure><p>Later on, perhaps when diving into multithreaded programming, we come to terms with the fact that <a href=\"https://textbook.cs161.org/memory-safety/x86.html#26-stack-pushing-and-popping\">the stack space</a> for call frames is finite. And that there is an “okay” way and a “cool” way to calculate the Fibonacci numbers using recursion:</p>\n            <pre class=\"language-c\"><code class=\"language-c\">// fib_okay.c\n\n#include &lt;stdint.h&gt;\n\nuint64_t fib(uint64_t n)\n{\n        if (n == 0 || n == 1)\n                return 1;\n\n        return fib(n - 1) + fib(n - 2);\n}</pre></code>\n            <p>Listing 1. An okay Fibonacci number generator implementation</p>\n            <pre class=\"language-c\"><code class=\"language-c\">// fib_cool.c\n\n#include &lt;stdint.h&gt;\n\nstatic uint64_t fib_tail(uint64_t n, uint64_t a, uint64_t b)\n{\n    if (n == 0)\n        return a;\n    if (n == 1)\n        return b;\n\n    return fib_tail(n - 1, b, a + b);\n}\n\nuint64_t fib(uint64_t n)\n{\n    return fib_tail(n, 1, 1);\n}</pre></code>\n            <p>Listing 2. A better version of the same</p><p>If we take a look at the machine code the compiler produces, the “cool” variant translates to a nice and tight sequence of instructions:</p><p>⚠ DISCLAIMER: This blog post is assembly-heavy. We will be looking at assembly code for x86-64, arm64 and BPF architectures. If you need an introduction or a refresher, I can recommend <a href=\"https://github.com/Apress/low-level-programming\">“Low-Level Programming”</a> by Igor Zhirkov for x86-64, and <a href=\"https://github.com/Apress/programming-with-64-bit-ARM-assembly-language\">“Programming with 64-Bit ARM Assembly Language”</a> by Stephen Smith for arm64. For BPF, see the <a href=\"https://www.kernel.org/doc/html/latest/bpf/standardization/instruction-set.html\">Linux kernel documentation</a>.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/7bahmmfAErsC7aO9LUTzTa/e685101ca35f092cd482993e3b86405b/Screenshot-2022-10-10-at-10.25.23.png\" alt=\"\" class=\"kg-image\" width=\"1574\" height=\"700\" loading=\"lazy\"/>\n            \n            </figure><p>Listing 3. <code>fib_cool.c</code> compiled for x86-64 and arm64</p><p>The “okay” variant, disappointingly, leads to <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2022-10-bpf-tail-call/fib_okay.x86-64.disasm\">more instructions</a> than a listing can fit. It is a spaghetti of <a href=\"https://en.wikipedia.org/wiki/Basic_block\">basic blocks</a>.</p><!--kg-card-begin: html--><p><a href=\"https://raw.githubusercontent.com/cloudflare/cloudflare-blog/master/2022-10-bpf-tail-call/fib_okay.dot.png\" target=\"_blank\"><img style=\"border-width: 0px; border-style: none;\" src=\"/content/images/2022/10/image6.png\" alt=\"\" width=\"1000\" height=\"161\" /></a></p><!--kg-card-end: html--><p>But more importantly, it is not free of <a href=\"https://textbook.cs161.org/memory-safety/x86.html#29-x86-function-call-in-assembly\">x86 call instructions</a>.</p>\n            <pre class=\"language-shell\"><code class=\"language-shell\">$ objdump -d fib_okay.o | grep call\n 10c:   e8 00 00 00 00          call   111 &lt;fib+0x111&gt;\n$ objdump -d fib_cool.o | grep call\n$</pre></code>\n            <p>This has an important consequence - as fib recursively calls itself, the stacks keep growing. We can observe it with a bit of <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2022-10-bpf-tail-call/trace_rsp.gdb\">help from the debugger</a>.</p>\n            <pre class=\"language-shell\"><code class=\"language-shell\">$ gdb --quiet --batch --command=trace_rsp.gdb --args ./fib_okay 6\nBreakpoint 1 at 0x401188: file fib_okay.c, line 3.\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.\nn = 6, %rsp = 0xffffd920\nn = 5, %rsp = 0xffffd900\nn = 4, %rsp = 0xffffd8e0\nn = 3, %rsp = 0xffffd8c0\nn = 2, %rsp = 0xffffd8a0\nn = 1, %rsp = 0xffffd880\nn = 1, %rsp = 0xffffd8c0\nn = 2, %rsp = 0xffffd8e0\nn = 1, %rsp = 0xffffd8c0\nn = 3, %rsp = 0xffffd900\nn = 2, %rsp = 0xffffd8e0\nn = 1, %rsp = 0xffffd8c0\nn = 1, %rsp = 0xffffd900\n13\n[Inferior 1 (process 50904) exited normally]\n$</pre></code>\n            <p>While the “cool” variant makes no use of the stack.</p>\n            <pre class=\"language-shell\"><code class=\"language-shell\">$ gdb --quiet --batch --command=trace_rsp.gdb --args ./fib_cool 6\nBreakpoint 1 at 0x40118a: file fib_cool.c, line 13.\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.\nn = 6, %rsp = 0xffffd938\n13\n[Inferior 1 (process 50949) exited normally]\n$</pre></code>\n            \n    <div class=\"flex anchor relative\">\n      <h2 id=\"where-did-the-calls-go\">Where did the <code>calls</code> go?</h2>\n      <a href=\"#where-did-the-calls-go\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>The smart compiler turned the last function call in the body into a regular jump. Why was it allowed to do that?</p><p>It is the last instruction in the function body we are talking about. The caller stack frame is going to be destroyed right after we return anyway. So why keep it around when we can reuse it for the callee’s <a href=\"https://eli.thegreenplace.net/2011/02/04/where-the-top-of-the-stack-is-on-x86/\">stack frame</a>?</p><p>This optimization, known as <a href=\"https://en.wikipedia.org/wiki/Tail_call#In_assembly\">tail call elimination</a>, leaves us with no function calls in the “cool” variant of our fib implementation. There was only one call to eliminate - right at the end.</p><p>Once applied, the call becomes a jump (loop). If assembly is not your second language, decompiling the fib_cool.o object file with <a href=\"https://ghidra-sre.org/\">Ghidra</a> helps see the transformation:</p>\n            <pre class=\"language-c\"><code class=\"language-c\">long fib(ulong param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  \n  if (param_1 &lt; 2) {\n    lVar3 = 1;\n  }\n  else {\n    lVar3 = 1;\n    lVar2 = 1;\n    do {\n      lVar1 = lVar3;\n      param_1 = param_1 - 1;\n      lVar3 = lVar2 + lVar1;\n      lVar2 = lVar1;\n    } while (param_1 != 1);\n  }\n  return lVar3;\n}</pre></code>\n            <p>Listing 4. <code>fib_cool.o</code> decompiled by Ghidra</p><p>This is very much desired. Not only is the generated machine code much shorter. It is also way faster due to lack of calls, which pop up on the <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2022-10-bpf-tail-call/fib_okay_50.perf.txt#L85\">profile</a> for fib_okay.</p><p>But I am no <a href=\"https://github.com/dendibakh/perf-ninja\">performance ninja</a> and this blog post is not about compiler optimizations. So why am I telling you about it?</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4pi98zHx1blOehbqwhB1LP/049a1532b192261cdfedade320e871a1/image5.jpg\" alt=\"\" class=\"kg-image\" width=\"1470\" height=\"954\" loading=\"lazy\"/>\n            \n            </figure><p><a href=\"https://commons.wikimedia.org/wiki/File:Lemur_catta_-_tail_length_01.jpg\">Alex Dunkel (Maky), CC BY-SA 3.0</a>, via <a href=\"https://creativecommons.org/licenses/by-sa/3.0\">Wikimedia Commons</a></p>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"tail-calls-in-bpf\">Tail calls in BPF</h2>\n      <a href=\"#tail-calls-in-bpf\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>The concept of tail call elimination made its way into the BPF world. Although not in the way you might expect. Yes, the LLVM compiler does get rid of the trailing function calls when building for -target bpf. The transformation happens at the intermediate representation level, so it is backend agnostic. This can save you some <a href=\"https://docs.cilium.io/en/stable/bpf/#bpf-to-bpf-calls\">BPF-to-BPF function calls</a>, which you can spot by looking for call -N instructions in the BPF assembly.</p><p>However, when we talk about tail calls in the BPF context, we usually have something else in mind. And that is a mechanism, built into the BPF JIT compiler, for <a href=\"https://docs.cilium.io/en/stable/bpf/#tail-calls\">chaining BPF programs</a>.</p><p>We first adopted BPF tail calls when building our <a href=\"https://legacy.netdevconf.info/0x13/session.html?talk-XDP-based-DDoS-mitigation\">XDP-based packet processing pipeline</a>. Thanks to it, we were able to divide the processing logic into several XDP programs. Each responsible for doing one thing.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3ANc6el4eTdaklbTHnlzPH/688282a0c8534d50fd1d8c1143c53058/image8.png\" alt=\"Slide from “XDP based DDoS Mitigation” talk by Arthur Fabre\" class=\"kg-image\" width=\"931\" height=\"492\" loading=\"lazy\"/>\n            \n            </figure><p>Slide from “<a href=\"https://legacy.netdevconf.info/0x13/session.html?talk-XDP-based-DDoS-mitigation\">XDP based DDoS Mitigation</a>” talk by <a href=\"/author/arthur/\">Arthur Fabre</a></p><p>BPF tail calls have served us well since then. But they do have their caveats. Until recently it was impossible to have both BPF tails calls and BPF-to-BPF function calls in the same XDP program on arm64, which is one of the supported architectures for us.</p><p>Why? Before we get to that, we have to clarify what a BPF tail call actually does.</p>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"a-tail-call-is-a-tail-call-is-a-tail-call\">A tail call is a tail call is a tail call</h2>\n      <a href=\"#a-tail-call-is-a-tail-call-is-a-tail-call\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>BPF exposes the tail call mechanism through the <a href=\"https://elixir.bootlin.com/linux/v5.15.63/source/include/uapi/linux/bpf.h#L1712\">bpf_tail_call helper</a>, which we can invoke from our BPF code. We don’t directly point out which BPF program we would like to call. Instead, we pass it a BPF map (a container) capable of holding references to BPF programs (BPF_MAP_TYPE_PROG_ARRAY), and an index into the map.</p>\n            <pre class=\"language-txt\"><code class=\"language-txt\">long bpf_tail_call(void *ctx, struct bpf_map *prog_array_map, u32 index)\n\n       Description\n              This  special  helper is used to trigger a &quot;tail call&quot;, or\n              in other words, to jump into  another  eBPF  program.  The\n              same  stack frame is used (but values on stack and in reg‐\n              isters for the caller are not accessible to  the  callee).\n              This  mechanism  allows  for  program chaining, either for\n              raising the maximum number of available eBPF instructions,\n              or  to  execute  given programs in conditional blocks. For\n              security reasons, there is an upper limit to the number of\n              successive tail calls that can be performed.</pre></code>\n            <p><a href=\"https://man7.org/linux/man-pages/man7/bpf-helpers.7.html\">bpf-helpers(7) man page</a></p><p>At first glance, this looks somewhat similar to the <a href=\"https://man7.org/linux/man-pages/man2/execve.2.html\">execve(2) syscall</a>. It is easy to mistake it for a way to execute a new program from the current program context. To quote the excellent <a href=\"https://docs.cilium.io/en/stable/bpf/#tail-calls\">BPF and XDP Reference Guide</a> from the Cilium project documentation:</p><blockquote><p><i>Tail calls can be seen as a mechanism that allows one BPF program to call another, without returning to the old program. Such a call has minimal overhead as unlike function calls, it is implemented as a long jump, reusing the same stack frame.</i></p></blockquote><p>But once we add <a href=\"https://docs.cilium.io/en/stable/bpf/#bpf-to-bpf-calls\">BPF function calls</a> into the mix, it becomes clear that the BPF tail call mechanism is indeed an implementation of tail call elimination, rather than a way to replace one program with another:</p><blockquote><p><i>Tail calls, before the actual jump to the target program, will unwind only its current stack frame. As we can see in the example above, if a tail call occurs from within the sub-function, the function’s (func1) stack frame will be present on the stack when a program execution is at func2. Once the final function (func3) function terminates, all the previous stack frames will be unwinded and control will get back to the caller of BPF program caller.</i></p></blockquote><p>Alas, one with sometimes slightly surprising semantics. Consider the code <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2022-10-bpf-tail-call/tail_call_ex3.bpf.c\">like below</a>, where a BPF function calls the <code>bpf_tail_call()</code> helper:</p>\n            <pre class=\"language-c\"><code class=\"language-c\">struct {\n    __uint(type, BPF_MAP_TYPE_PROG_ARRAY);\n    __uint(max_entries, 1);\n    __uint(key_size, sizeof(__u32));\n    __uint(value_size, sizeof(__u32));\n} bar SEC(&quot;.maps&quot;);\n\nSEC(&quot;tc&quot;)\nint serve_drink(struct __sk_buff *skb __unused)\n{\n    return 0xcafe;\n}\n\nstatic __noinline\nint bring_order(struct __sk_buff *skb)\n{\n    bpf_tail_call(skb, &amp;bar, 0);\n    return 0xf00d;\n}\n\nSEC(&quot;tc&quot;)\nint server1(struct __sk_buff *skb)\n{\n    return bring_order(skb);    \n}\n\nSEC(&quot;tc&quot;)\nint server2(struct __sk_buff *skb)\n{\n    __attribute__((musttail)) return bring_order(skb);  \n}</pre></code>\n            <p>We have two seemingly not so different BPF programs - <code>server1()</code> and <code>server2()</code>. They both call the same BPF function <code>bring_order()</code>. The function tail calls into the <code>serve_drink()</code> program, if the <code>bar[0]</code> map entry points to it (let’s assume that).</p><p>Do both <code>server1</code> and <code>server2</code> return the same value? Turns out that - no, they don’t. We get a hex ? from <code>server1</code>, and a ☕ from <code>server2</code>. How so?</p><p>First thing to notice is that a BPF tail call unwinds just the current function stack frame. Code past the <code>bpf_tail_call()</code> invocation in the function body never executes, providing the tail call is successful (the map entry was set, and the tail call limit has not been reached).</p><p>When the tail call finishes, control returns to the caller of the function which made the tail call. Applying this to our example, the control flow is <code>serverX() --&gt; bring_order() --&gt; bpf_tail_call() --&gt; serve_drink() -return-&gt; serverX()</code> for both programs.</p><p>The second thing to keep in mind is that the compiler does not know that the bpf_tail_call() helper changes the control flow. Hence, the unsuspecting compiler optimizes the code as if the execution would continue past the BPF tail call.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/57RsaISELMEErCz7js2C0w/70efe8757f435fb6450ae26c50ff0f2b/image2-8.png\" alt=\"\" class=\"kg-image\" width=\"1999\" height=\"742\" loading=\"lazy\"/>\n            \n            </figure><p>The call graph for <code>server1()</code> and <code>server2()</code> is the same, but the return value differs due to build time optimizations.</p><p>In our case, the compiler thinks it is okay to propagate the constant which <code>bring_order()</code> returns to <code>server1()</code>. Possibly catching us by surprise, if we didn’t check the <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2022-10-bpf-tail-call/tail_call_ex3.bpf.disasm\">generated BPF assembly</a>.</p><p>We can prevent it by <a href=\"https://clang.llvm.org/docs/AttributeReference.html#musttail\">forcing the compiler</a> to make a tail call to <code>bring_order()</code>. This way we ensure that whatever <code>bring_order()</code> returns will be used as the <code>server2()</code> program result.</p><p>? General rule - for least surprising results, use <a href=\"https://clang.llvm.org/docs/AttributeReference.html#musttail\"><code>musttail attribute</code></a> when calling a function that contain a BPF tail call.</p><p>How does the <code>bpf_tail_call()</code> work underneath then? And why the BPF verifier wouldn’t let us mix the function calls with tail calls on arm64? Time to dig deeper.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5rp6nKgRPwuuXUzAyolOA9/1b740786194fceb11c2fdf26e1c5a1d7/image7.jpg\" alt=\"Public Domain image\" class=\"kg-image\" width=\"1999\" height=\"1235\" loading=\"lazy\"/>\n            \n            </figure><p>Public Domain <a href=\"https://www.rawpixel.com/image/3578996/free-photo-image-bulldozer-construction-site\">image</a></p>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"bpf-tail-call-on-x86-64\">BPF tail call on x86-64</h2>\n      <a href=\"#bpf-tail-call-on-x86-64\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>What does a <code>bpf_tail_call()</code> helper call translate to after BPF JIT for x86-64 has compiled it? How does the implementation guarantee that we don’t end up in a tail call loop forever?</p><p>To find out we will need to piece together a few things.</p><p>First, there is the BPF JIT compiler source code, which lives in <a href=\"https://elixir.bootlin.com/linux/v5.19.12/source/arch/x86/net/bpf_jit_comp.c\"><code>arch/x86/net/bpf_jit_comp.c</code></a>. Its code is annotated with helpful comments. We will focus our attention on the following call chain within the JIT:</p><!--kg-card-begin: html--><p><a href=\"https://elixir.bootlin.com/linux/v5.19.12/source/arch/x86/net/bpf_jit_comp.c#L894\"><span style=\"font-weight: 400;\">do_jit()</span><span style=\"font-weight: 400;\"> ?</span><span style=\"font-weight: 400;\"><br /></span></a><span style=\"font-weight: 400;\"> &emsp;&emsp;</span><a href=\"https://elixir.bootlin.com/linux/v5.19.12/source/arch/x86/net/bpf_jit_comp.c#L292\"><span style=\"font-weight: 400;\">emit_prologue()</span><span style=\"font-weight: 400;\"> ?</span><span style=\"font-weight: 400;\"><br /></span></a><span style=\"font-weight: 400;\"> &emsp;&emsp;</span><a href=\"https://elixir.bootlin.com/linux/v5.19.12/source/arch/x86/net/bpf_jit_comp.c#L257\"><span style=\"font-weight: 400;\">push_callee_regs()</span><span style=\"font-weight: 400;\"> ?</span><span style=\"font-weight: 400;\"><br /></span></a><span style=\"font-weight: 400;\"> &emsp;&emsp;</span><span style=\"font-weight: 400;\">for (i = 1; i &lt;= insn_cnt; i++, insn++) {</span><span style=\"font-weight: 400;\"><br /></span><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;</span><span style=\"font-weight: 400;\">switch (insn-&gt;code) {</span><span style=\"font-weight: 400;\"><br /></span><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;</span><span style=\"font-weight: 400;\">case BPF_JMP | BPF_CALL:</span><span style=\"font-weight: 400;\"><br /></span><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</span><a href=\"https://elixir.bootlin.com/linux/v5.19.12/source/arch/x86/net/bpf_jit_comp.c#L1434\"><span style=\"font-weight: 400;\">/* emit function call */</span><span style=\"font-weight: 400;\"> ?</span><span style=\"font-weight: 400;\"><br /></span></a><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;</span><span style=\"font-weight: 400;\">case BPF_JMP | BPF_TAIL_CALL:</span><span style=\"font-weight: 400;\"><br /></span><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</span><a href=\"https://elixir.bootlin.com/linux/v5.19.12/source/arch/x86/net/bpf_jit_comp.c#L531\"><span style=\"font-weight: 400;\">emit_bpf_tail_call_direct()</span><span style=\"font-weight: 400;\"> ?</span><span style=\"font-weight: 400;\"><br /></span></a><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;</span><span style=\"font-weight: 400;\">case BPF_JMP | BPF_EXIT:</span><span style=\"font-weight: 400;\"><br /></span><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</span><a href=\"https://elixir.bootlin.com/linux/v5.19.12/source/arch/x86/net/bpf_jit_comp.c#L1693\"><span style=\"font-weight: 400;\">/* emit epilogue */</span><span style=\"font-weight: 400;\"> ?</span><span style=\"font-weight: 400;\"><br /></span></a><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;</span><span style=\"font-weight: 400;\">}</span> <span style=\"font-weight: 400;\"><br /></span><span style=\"font-weight: 400;\">&emsp;&emsp;</span><span style=\"font-weight: 400;\">}</span></p><!--kg-card-end: html--><p>It is sometimes hard to visualize the generated instruction stream just from reading the compiler code. Hence, we will also want to inspect the input - BPF instructions - and the output - x86-64 instructions - of the JIT compiler.</p><p>To inspect BPF and x86-64 instructions of a loaded BPF program, we can use <code>bpftool prog dump</code>. However, first we must populate the BPF map used as the tail call jump table. Otherwise, we might not be able to see the tail call jump!</p><p>This is due to <a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=428d5df1fa4f28daf622c48dd19da35585c9053c\">optimizations</a> that use instruction patching when the index into the program array is known at load time.</p>\n            <pre class=\"language-shell\"><code class=\"language-shell\"># bpftool prog loadall ./tail_call_ex1.o /sys/fs/bpf pinmaps /sys/fs/bpf\n# bpftool map update pinned /sys/fs/bpf/jmp_table key 0 0 0 0 value pinned /sys/fs/bpf/target_prog\n# bpftool prog dump xlated pinned /sys/fs/bpf/entry_prog\nint entry_prog(struct __sk_buff * skb):\n; bpf_tail_call(skb, &amp;jmp_table, 0);\n   0: (18) r2 = map[id:24]\n   2: (b7) r3 = 0\n   3: (85) call bpf_tail_call#12\n; return 0xf00d;\n   4: (b7) r0 = 61453\n   5: (95) exit\n# bpftool prog dump jited pinned /sys/fs/bpf/entry_prog\nint entry_prog(struct __sk_buff * skb):\nbpf_prog_4f697d723aa87765_entry_prog:\n; bpf_tail_call(skb, &amp;jmp_table, 0);\n   0:   nopl   0x0(%rax,%rax,1)\n   5:   xor    %eax,%eax\n   7:   push   %rbp\n   8:   mov    %rsp,%rbp\n   b:   push   %rax\n   c:   movabs $0xffff888102764800,%rsi\n  16:   xor    %edx,%edx\n  18:   mov    -0x4(%rbp),%eax\n  1e:   cmp    $0x21,%eax\n  21:   jae    0x0000000000000037\n  23:   add    $0x1,%eax\n  26:   mov    %eax,-0x4(%rbp)\n  2c:   nopl   0x0(%rax,%rax,1)\n  31:   pop    %rax\n  32:   jmp    0xffffffffffffffe3   // bug? ?\n; return 0xf00d;\n  37:   mov    $0xf00d,%eax\n  3c:   leave\n  3d:   ret</pre></code>\n            <p>There is a caveat. The target addresses for tail call jumps in <code>bpftool prog dump jited</code> output will not make any sense. To discover the real jump targets, we have to peek into the kernel memory. That can be done with <code>gdb</code> after we find the address of our JIT’ed BPF programs in <code>/proc/kallsyms</code>:</p>\n            <pre class=\"language-shell\"><code class=\"language-shell\"># tail -2 /proc/kallsyms\nffffffffa0000720 t bpf_prog_f85b2547b00cbbe9_target_prog        [bpf]\nffffffffa0000748 t bpf_prog_4f697d723aa87765_entry_prog [bpf]\n# gdb -q -c /proc/kcore -ex &#039;x/18i 0xffffffffa0000748&#039; -ex &#039;quit&#039;\n[New process 1]\nCore was generated by `earlyprintk=serial,ttyS0,115200 console=ttyS0 psmouse.proto=exps &quot;virtme_stty_c&#039;.\n#0  0x0000000000000000 in ?? ()\n   0xffffffffa0000748:  nopl   0x0(%rax,%rax,1)\n   0xffffffffa000074d:  xor    %eax,%eax\n   0xffffffffa000074f:  push   %rbp\n   0xffffffffa0000750:  mov    %rsp,%rbp\n   0xffffffffa0000753:  push   %rax\n   0xffffffffa0000754:  movabs $0xffff888102764800,%rsi\n   0xffffffffa000075e:  xor    %edx,%edx\n   0xffffffffa0000760:  mov    -0x4(%rbp),%eax\n   0xffffffffa0000766:  cmp    $0x21,%eax\n   0xffffffffa0000769:  jae    0xffffffffa000077f\n   0xffffffffa000076b:  add    $0x1,%eax\n   0xffffffffa000076e:  mov    %eax,-0x4(%rbp)\n   0xffffffffa0000774:  nopl   0x0(%rax,%rax,1)\n   0xffffffffa0000779:  pop    %rax\n   0xffffffffa000077a:  jmp    0xffffffffa000072b\n   0xffffffffa000077f:  mov    $0xf00d,%eax\n   0xffffffffa0000784:  leave\n   0xffffffffa0000785:  ret\n# gdb -q -c /proc/kcore -ex &#039;x/7i 0xffffffffa0000720&#039; -ex &#039;quit&#039;\n[New process 1]\nCore was generated by `earlyprintk=serial,ttyS0,115200 console=ttyS0 psmouse.proto=exps &quot;virtme_stty_c&#039;.\n#0  0x0000000000000000 in ?? ()\n   0xffffffffa0000720:  nopl   0x0(%rax,%rax,1)\n   0xffffffffa0000725:  xchg   %ax,%ax\n   0xffffffffa0000727:  push   %rbp\n   0xffffffffa0000728:  mov    %rsp,%rbp\n   0xffffffffa000072b:  mov    $0xcafe,%eax\n   0xffffffffa0000730:  leave\n   0xffffffffa0000731:  ret\n#</pre></code>\n            <p>Lastly, it will be handy to have a cheat sheet of <a href=\"https://elixir.bootlin.com/linux/v5.15.63/source/arch/x86/net/bpf_jit_comp.c#L104\">mapping</a> between BPF registers (<code>r0</code>, <code>r1</code>, …) to hardware registers (<code>rax</code>, <code>rdi</code>, …) that the JIT compiler uses.</p><!--kg-card-begin: html--><style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-tpes{background-color:#FFF;border-color:inherit;color:#36393A;text-align:center;vertical-align:middle}\n.tg .tg-yb3f{background-color:#FFF;border-color:inherit;color:#36393A;font-weight:bold;text-align:center;vertical-align:middle}\n</style>\n<table class=\"tg\" width=\"100%\">\n<thead>\n  <tr>\n    <th class=\"tg-yb3f\">BPF</th>\n    <th class=\"tg-yb3f\">x86-64</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td class=\"tg-tpes\">r0</td>\n    <td class=\"tg-tpes\">rax</td>\n  </tr>\n  <tr>\n    <td class=\"tg-tpes\">r1</td>\n    <td class=\"tg-tpes\">rdi</td>\n  </tr>\n  <tr>\n    <td class=\"tg-tpes\">r2</td>\n    <td class=\"tg-tpes\">rsi</td>\n  </tr>\n  <tr>\n    <td class=\"tg-tpes\">r3</td>\n    <td class=\"tg-tpes\">rdx</td>\n  </tr>\n  <tr>\n    <td class=\"tg-tpes\">r4</td>\n    <td class=\"tg-tpes\">rcx</td>\n  </tr>\n  <tr>\n    <td class=\"tg-tpes\">r5</td>\n    <td class=\"tg-tpes\">r8</td>\n  </tr>\n  <tr>\n    <td class=\"tg-tpes\">r6</td>\n    <td class=\"tg-tpes\">rbx</td>\n  </tr>\n  <tr>\n    <td class=\"tg-tpes\">r7</td>\n    <td class=\"tg-tpes\">r13</td>\n  </tr>\n  <tr>\n    <td class=\"tg-tpes\">r8</td>\n    <td class=\"tg-tpes\">r14</td>\n  </tr>\n  <tr>\n    <td class=\"tg-tpes\">r9</td>\n    <td class=\"tg-tpes\">r15</td>\n  </tr>\n  <tr>\n    <td class=\"tg-tpes\">r10</td>\n    <td class=\"tg-tpes\">rbp</td>\n  </tr>\n  <tr>\n    <td class=\"tg-tpes\">internal</td>\n    <td class=\"tg-tpes\">r9-r12</td>\n  </tr>\n</tbody>\n</table><!--kg-card-end: html--><p>Now we are prepared to work out what happens when we use a BPF tail call.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3cyhfC6M0zUcXpRmaGDf6b/26595d9ce05e788d01a23fc0c6836d96/image9.png\" alt=\"\" class=\"kg-image\" width=\"1999\" height=\"1235\" loading=\"lazy\"/>\n            \n            </figure><p>In essence, <code>bpf_tail_call()</code> emits a jump into another function, reusing the current stack frame. It is just like a regular optimized tail call, but with a twist.</p><p>Because of the BPF security guarantees - execution terminates, no stack overflows - there is a limit on the number of tail calls we can have (<a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ebf7f6f0a6cdcc17a3da52b81e4b3a98c4005028\"><code>MAX_TAIL_CALL_CNT = 33</code></a>).</p><p>Counting the tail calls across BPF programs is not something we can do at load-time. The jump table (BPF program array) contents can change after the program has been verified. Our only option is to keep track of tail calls at run-time. That is why the JIT’ed code for the <code>bpf_tail_call()</code> helper checks and updates the <code>tail_call_cnt</code> counter.</p><p>The updated count is then passed from one BPF program to another, and from one BPF function to another, as we will see, through the <code>rax register</code> (<code>r0</code> in BPF).</p><p>Luckily for us, the x86-64 calling convention dictates that the <code>rax</code> register does not partake in passing function arguments, but rather holds the function return value. The JIT can repurpose it to pass an additional - hidden - argument.</p><p>The function body is, however, free to make use of the <code>r0/rax</code> register in any way it pleases. This explains why we want to save the <code>tail_call_cnt</code> passed via <code>rax</code> onto stack right after we jump to another program. <code>bpf_tail_call()</code> can later load the value from a known location on the stack.</p><p>This way, the <a href=\"https://elixir.bootlin.com/linux/v5.15.63/source/arch/x86/net/bpf_jit_comp.c#L1437\">code emitted</a> for each <code>bpf_tail_call()</code> invocation, and the <a href=\"https://elixir.bootlin.com/linux/v5.15.63/source/arch/x86/net/bpf_jit_comp.c#L281\">BPF function prologue</a> work in tandem, keeping track of tail call count across BPF program boundaries.</p><p>But what if our BPF program is split up into several BPF functions, each with its own stack frame? What if these functions perform BPF tail calls? How is the tail call count tracked then?</p>\n    <div class=\"flex anchor relative\">\n      <h3 id=\"mixing-bpf-function-calls-with-bpf-tail-calls\">Mixing BPF function calls with BPF tail calls</h3>\n      <a href=\"#mixing-bpf-function-calls-with-bpf-tail-calls\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>BPF has its own terminology when it comes to functions and calling them, which is influenced by the internal implementation. Function calls are referred to as <a href=\"https://docs.cilium.io/en/stable/bpf/#bpf-to-bpf-calls\">BPF to BPF calls</a>. Also, the main/entry function in your BPF code is called “the program”, while all other functions are known as “subprograms”.</p><p>Each call to subprogram allocates a stack frame for local state, which persists until the function returns. Naturally, BPF subprogram calls can be nested creating a call chain. Just like nested function calls in user-space.</p><p>BPF subprograms are also allowed to make BPF tail calls. This, effectively, is a mechanism for extending the call chain to another BPF program and its subprograms.</p><p>If we cannot track how long the call chain can be, and how much stack space each function uses, we put ourselves at risk of <a href=\"https://en.wikipedia.org/wiki/Stack_overflow\">overflowing the stack</a>. We cannot let this happen, so BPF enforces limitations on <a href=\"https://elixir.bootlin.com/linux/v5.15.62/source/kernel/bpf/verifier.c#L3600\">when and how many BPF tail calls can be done</a>:</p>\n            <pre class=\"language-c\"><code class=\"language-c\">static int check_max_stack_depth(struct bpf_verifier_env *env)\n{\n        …\n        /* protect against potential stack overflow that might happen when\n         * bpf2bpf calls get combined with tailcalls. Limit the caller&#039;s stack\n         * depth for such case down to 256 so that the worst case scenario\n         * would result in 8k stack size (32 which is tailcall limit * 256 =\n         * 8k).\n         *\n         * To get the idea what might happen, see an example:\n         * func1 -&gt; sub rsp, 128\n         *  subfunc1 -&gt; sub rsp, 256\n         *  tailcall1 -&gt; add rsp, 256\n         *   func2 -&gt; sub rsp, 192 (total stack size = 128 + 192 = 320)\n         *   subfunc2 -&gt; sub rsp, 64\n         *   subfunc22 -&gt; sub rsp, 128\n         *   tailcall2 -&gt; add rsp, 128\n         *    func3 -&gt; sub rsp, 32 (total stack size 128 + 192 + 64 + 32 = 416)\n         *\n         * tailcall will unwind the current stack frame but it will not get rid\n         * of caller&#039;s stack as shown on the example above.\n         */\n        if (idx &amp;&amp; subprog[idx].has_tail_call &amp;&amp; depth &gt;= 256) {\n                verbose(env,\n                        &quot;tail_calls are not allowed when call stack of previous frames is %d bytes. Too large\\n&quot;,\n                        depth);\n                return -EACCES;\n        }\n        …\n}</pre></code>\n            <p>While the stack depth can be calculated by the BPF verifier at load-time, we still need to keep count of tail call jumps at run-time. Even when subprograms are involved.</p><p>This means that we have to pass the tail call count from one BPF subprogram to another, just like we did when making a BPF tail call, so we yet again turn to value passing through the <code>rax register</code>.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3cRz7vr40Hl4l65tgG15gV/09d1d3980f2f4c3e61ed2ff5cb5021f0/image1-11.png\" alt=\"\" class=\"kg-image\" width=\"1999\" height=\"1030\" loading=\"lazy\"/>\n            \n            </figure><p>Control flow in a BPF program with a function call followed by a tail call.</p><p>? To keep things simple, BPF code in our examples does not allocate anything on stack. I encourage you to check how the JIT’ed code changes when you <a href=\"https://elixir.bootlin.com/linux/v5.19.11/source/tools/testing/selftests/bpf/progs/tailcall_bpf2bpf6.c#L37\">add some local variables</a>. Just make sure the compiler does not optimize them out.</p><p>To make it work, we need to:</p><p>① load the tail call count saved on stack into <code>rax</code> before <code>call</code>’ing the subprogram,② adjust the subprogram prologue, so that it does not reset the <code>rax</code> like the main program does,③ save the passed tail call count on subprogram’s stack for the <code>bpf_tail_call()</code> helper to consume it.</p><p>A <code>bpf_tail_call()</code> within our suprogram will then:</p><p>④ load the tail call count from stack,⑤ unwind the BPF stack, but keep the current subprogram’s stack frame in tact, and⑥ jump to the target BPF program.</p><p>Now we have seen how all the pieces of the puzzle fit together to make BPF tail work on x86-64 safely. The only open question is does it work the same way on other platforms like arm64? Time to shift gears and dive into a completely different BPF JIT implementation.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4WJ7PZxCCS8jaahx6fGfu/a3c1568774c9c47fbf902f1959b3ec17/image10.jpg\" alt=\"\" class=\"kg-image\" width=\"1999\" height=\"1501\" loading=\"lazy\"/>\n            \n            </figure><p>Based on an image by <a href=\"https://www.flickr.com/photos/pockethifi/48303582037/\">Wutthichai Charoenburi</a>, <a href=\"https://creativecommons.org/licenses/by/2.0/\">CC BY 2.0</a></p>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"tail-calls-on-arm64\">Tail calls on arm64</h2>\n      <a href=\"#tail-calls-on-arm64\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>If you try loading a BPF program that uses both BPF function calls (aka BPF to BPF calls) and BPF tail calls on an arm64 machine running the latest 5.15 LTS kernel, or even the latest 5.19 stable kernel, the BPF verifier will kindly ask you to reconsider your choice:</p>\n            <pre class=\"language-shell\"><code class=\"language-shell\"># uname -rm\n5.19.12 aarch64\n# bpftool prog loadall tail_call_ex2.o /sys/fs/bpf\nlibbpf: prog &#039;entry_prog&#039;: BPF program load failed: Invalid argument\nlibbpf: prog &#039;entry_prog&#039;: -- BEGIN PROG LOAD LOG --\n0: R1=ctx(off=0,imm=0) R10=fp0\n; __attribute__((musttail)) return sub_func(skb);\n0: (85) call pc+1\ncaller:\n R10=fp0\ncallee:\n frame1: R1=ctx(off=0,imm=0) R10=fp0\n; bpf_tail_call(skb, &amp;jmp_table, 0);\n2: (18) r2 = 0xffffff80c38c7200       ; frame1: R2_w=map_ptr(off=0,ks=4,vs=4,imm=0)\n4: (b7) r3 = 0                        ; frame1: R3_w=P0\n5: (85) call bpf_tail_call#12\ntail_calls are not allowed in non-JITed programs with bpf-to-bpf calls\nprocessed 4 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0\n-- END PROG LOAD LOG --\n…\n#</pre></code>\n            <p>That is a pity! We have been looking forward to reaping the benefits of code sharing with BPF to BPF calls in our lengthy machine generated BPF programs. So we asked - how hard could it be to make it work?</p><p>After all, BPF <a href=\"https://elixir.bootlin.com/linux/v5.15.70/source/arch/arm64/net/bpf_jit_comp.c\">JIT for arm64</a> already can handle BPF tail calls and BPF to BPF calls, when used in isolation.</p><p>It is “just” a matter of understanding the existing JIT implementation, which lives in <code>arch/arm64/net/bpf_jit_comp.c</code>, and identifying the missing pieces.</p><p>To understand how BPF JIT for arm64 works, we will use the same method as before - look at its code together with sample input (BPF instructions) and output (arm64 instructions).</p><p>We don’t have to read the whole source code. It is enough to zero in on a few particular code paths:</p><!--kg-card-begin: html--><p><a href=\"https://elixir.bootlin.com/linux/v5.19.12/source/arch/arm64/net/bpf_jit_comp.c#L1356\"><span style=\"font-weight: 400;\">bpf_int_jit_compile()</span><span style=\"font-weight: 400;\"> ?</span><span style=\"font-weight: 400;\"><br /></span></a><span style=\"font-weight: 400;\"> &emsp;&emsp;</span><a href=\"https://elixir.bootlin.com/linux/v5.19.12/source/arch/arm64/net/bpf_jit_comp.c#L246\"><span style=\"font-weight: 400;\">build_prologue()</span><span style=\"font-weight: 400;\"> ?</span><span style=\"font-weight: 400;\"><br /></span></a><span style=\"font-weight: 400;\"> &emsp;&emsp;</span><a href=\"https://elixir.bootlin.com/linux/v5.19.12/source/arch/arm64/net/bpf_jit_comp.c#L1287\"><span style=\"font-weight: 400;\">build_body()</span><span style=\"font-weight: 400;\"> ?</span><span style=\"font-weight: 400;\"><br /></span></a><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;</span><span style=\"font-weight: 400;\">for (i = 0; i &lt; prog-&gt;len; i++) {</span><span style=\"font-weight: 400;\"><br /></span><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</span><a href=\"https://elixir.bootlin.com/linux/v5.19.12/source/arch/arm64/net/bpf_jit_comp.c#L663\"><span style=\"font-weight: 400;\">build_insn()</span><span style=\"font-weight: 400;\"> ?</span><span style=\"font-weight: 400;\"><br /></span></a><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</span><span style=\"font-weight: 400;\">switch (code) {</span><span style=\"font-weight: 400;\"><br /></span><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</span><span style=\"font-weight: 400;\">case BPF_JMP | BPF_CALL:</span><span style=\"font-weight: 400;\"><br /></span><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</span><a href=\"https://elixir.bootlin.com/linux/v5.19.12/source/arch/arm64/net/bpf_jit_comp.c#L983\"><span style=\"font-weight: 400;\">/* emit function call */</span><span style=\"font-weight: 400;\"> ?</span><span style=\"font-weight: 400;\"><br /></span></a><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</span><span style=\"font-weight: 400;\">case BPF_JMP | BPF_TAIL_CALL:</span><span style=\"font-weight: 400;\"><br /></span><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</span><a href=\"https://elixir.bootlin.com/linux/v5.19.12/source/arch/arm64/net/bpf_jit_comp.c#L329\"><span style=\"font-weight: 400;\">emit_bpf_tail_call()</span><span style=\"font-weight: 400;\"> ?</span><span style=\"font-weight: 400;\"><br /></span></a><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</span><span style=\"font-weight: 400;\">}</span><span style=\"font-weight: 400;\"><br /></span><span style=\"font-weight: 400;\"> &emsp;&emsp;&emsp;&emsp;</span><span style=\"font-weight: 400;\">}</span><span style=\"font-weight: 400;\"><br /></span><span style=\"font-weight: 400;\"> &emsp;&emsp;</span><a href=\"https://elixir.bootlin.com/linux/v5.19.12/source/arch/arm64/net/bpf_jit_comp.c#L559\"><span style=\"font-weight: 400;\">build_epilogue()</span><span style=\"font-weight: 400;\"> ?</span></a></p><!--kg-card-end: html--><p>One thing that the arm64 architecture, and RISC architectures in general, are known for is that it has a plethora of general purpose registers (<code>x0-x30</code>). This is a good thing. We have more registers to allocate to JIT internal state, like the tail call count. A cheat sheet of what <a href=\"https://elixir.bootlin.com/linux/v5.19.12/source/arch/arm64/net/bpf_jit_comp.c#L42\">roles</a> the hardware registers play in the BPF JIT will be helpful:</p><!--kg-card-begin: html--><style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:center;vertical-align:top}\n</style>\n<table class=\"tg\" width=\"100%\">\n<thead>\n  <tr>\n    <th class=\"tg-c3ow\">BPF</th>\n    <th class=\"tg-c3ow\">arm64</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td class=\"tg-0pky\">r0</td>\n    <td class=\"tg-0pky\">x7</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">r1</td>\n    <td class=\"tg-0pky\">x0</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">r2</td>\n    <td class=\"tg-0pky\">x1</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">r3</td>\n    <td class=\"tg-0pky\">x2</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">r4</td>\n    <td class=\"tg-0pky\">x3</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">r5</td>\n    <td class=\"tg-0pky\">x4</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">r6</td>\n    <td class=\"tg-0pky\">x19</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">r7</td>\n    <td class=\"tg-0pky\">x20</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">r8</td>\n    <td class=\"tg-0pky\">x21</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">r9</td>\n    <td class=\"tg-0pky\">x22</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">r10</td>\n    <td class=\"tg-0pky\">x25</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">internal</td>\n    <td class=\"tg-0pky\">x9-x12, x26 (tail_call_cnt), x27</td>\n  </tr>\n</tbody>\n</table><!--kg-card-end: html--><p>Now let’s try to understand the state of things by looking at the JIT’s input and output for two particular scenarios: (1) a BPF tail call, and (2) a BPF to BPF call.</p><p>It is hard to read assembly code selectively. We will have to go through all instructions one by one, and understand what each one is doing.</p><p>⚠ Brace yourself. Time to decipher a bit of ARM64 assembly. If this will be your first time reading ARM64 assembly, you might want to at least skim through this <a href=\"https://modexp.wordpress.com/2018/10/30/arm64-assembly/\">Guide to ARM64 / AArch64 Assembly on Linux</a> before diving in.</p><p>Scenario #1: A single BPF tail call - <a href=\"https://github.com/jsitnicki/cloudflare-blog/blob/jakub/2022-10-bpf-tail-calls/2022-10-bpf-tail-call/tail_call_ex1.bpf.c\"><code>tail_call_ex1.bpf.c</code></a></p><p>Input: BPF assembly (<code>bpftool prog dump xlated</code>)</p>\n            <pre class=\"language-txt\"><code class=\"language-txt\">   0: (18) r2 = map[id:4]           // jmp_table map\n   2: (b7) r3 = 0\n   3: (85) call bpf_tail_call#12\n   4: (b7) r0 = 61453               // 0xf00d\n   5: (95) exit</pre></code>\n            <p>Output: ARM64 assembly (<code>bpftool prog dump jited</code>)</p>\n            <pre class=\"language-txt\"><code class=\"language-txt\"> 0:   paciasp                            // Sign LR (ROP protection) ①\n 4:   stp     x29, x30, [sp, #-16]!      // Save FP and LR registers ②\n 8:   mov     x29, sp                    // Set up Frame Pointer\n c:   stp     x19, x20, [sp, #-16]!      // Save callee-saved registers ③\n10:   stp     x21, x22, [sp, #-16]!      // ⋮ \n14:   stp     x25, x26, [sp, #-16]!      // ⋮ \n18:   stp     x27, x28, [sp, #-16]!      // ⋮ \n1c:   mov     x25, sp                    // Set up BPF stack base register (r10)\n20:   mov     x26, #0x0                  // Initialize tail_call_cnt ④\n24:   sub     x27, x25, #0x0             // Calculate FP bottom ⑤\n28:   sub     sp, sp, #0x200             // Set up BPF program stack ⑥\n2c:   mov     x1, #0xffffff80ffffffff    // r2 = map[id:4] ⑦\n30:   movk    x1, #0xc38c, lsl #16       // ⋮ \n34:   movk    x1, #0x7200                // ⋮\n38:   mov     x2, #0x0                   // r3 = 0\n3c:   mov     w10, #0x24                 // = offsetof(struct bpf_array, map.max_entries) ⑧\n40:   ldr     w10, [x1, x10]             // Load array-&gt;map.max_entries\n44:   add     w2, w2, #0x0               // = index (0)\n48:   cmp     w2, w10                    // if (index &gt;= array-&gt;map.max_entries)\n4c:   b.cs    0x0000000000000088         //     goto out;\n50:   mov     w10, #0x21                 // = MAX_TAIL_CALL_CNT (33)\n54:   cmp     x26, x10                   // if (tail_call_cnt &gt;= MAX_TAIL_CALL_CNT)\n58:   b.cs    0x0000000000000088         //     goto out;\n5c:   add     x26, x26, #0x1             // tail_call_cnt++;\n60:   mov     w10, #0x110                // = offsetof(struct bpf_array, ptrs)\n64:   add     x10, x1, x10               // = &amp;array-&gt;ptrs\n68:   lsl     x11, x2, #3                // = index * sizeof(array-&gt;ptrs[0])\n6c:   ldr     x11, [x10, x11]            // prog = array-&gt;ptrs[index];\n70:   cbz     x11, 0x0000000000000088    // if (prog == NULL) goto out;\n74:   mov     w10, #0x30                 // = offsetof(struct bpf_prog, bpf_func)\n78:   ldr     x10, [x11, x10]            // Load prog-&gt;bpf_func\n7c:   add     x10, x10, #0x24            // += PROLOGUE_OFFSET * AARCH64_INSN_SIZE (4)\n80:   add     sp, sp, #0x200             // Unwind BPF stack\n84:   br      x10                        // goto *(prog-&gt;bpf_func + prologue_offset)\n88:   mov     x7, #0xf00d                // r0 = 0xf00d\n8c:   add     sp, sp, #0x200             // Unwind BPF stack ⑨\n90:   ldp     x27, x28, [sp], #16        // Restore used callee-saved registers\n94:   ldp     x25, x26, [sp], #16        // ⋮\n98:   ldp     x21, x22, [sp], #16        // ⋮\n9c:   ldp     x19, x20, [sp], #16        // ⋮\na0:   ldp     x29, x30, [sp], #16        // ⋮\na4:   add     x0, x7, #0x0               // Set return value\na8:   autiasp                            // Authenticate LR\nac:   ret                                // Return to caller</pre></code>\n            <p>① BPF program prologue starts with Pointer Authentication Code (PAC), which protects against Return <a href=\"https://developer.arm.com/documentation/102433/0100/Return-oriented-programming\">Oriented Programming attacks</a>. PAC instructions are emitted by JIT only if CONFIG_ARM64_PTR_AUTH_KERNEL is enabled.</p><p>② <a href=\"https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst\">Arm 64 Architecture Procedure Call Standard</a> <a href=\"https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst#the-frame-pointer\">mandates</a> that the Frame Pointer (register X29) and the Link Register (register X30), aka the return address, of the caller should be recorded onto the stack.</p><p>③ Registers X19 to X28, and X29 (FP) plus X30 (LR), are callee saved. ARM64 BPF JIT does not use registers X23 and X24 currently, so they are not saved.</p><p>④ We track the tail call depth in X26. No need to save it onto stack since we use a register dedicated just for this purpose.</p><p>⑤ FP bottom is an optimization that allows store/loads to BPF stack <a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5b3d19b9bd4080d7f5e260f91ce8f639e19eb499\">with a single instruction and an immediate offset value</a>.</p><p>⑥ Reserve space for the BPF program stack. The stack layout is now as shown in a <a href=\"https://elixir.bootlin.com/linux/v5.19.12/source/arch/arm64/net/bpf_jit_comp.c#L260\">diagram in <code>build_prologue()</code></a> source code.</p><p>⑦ The BPF function body starts here.</p><p>⑧ <code>bpf_tail_call()</code> instructions start here.</p><p>⑨ The epilogue starts here.</p><p>Whew! That was a handful ?.</p><p>Notice that the BPF tail call implementation on arm64 is not as optimized as on x86-64. There is no code patching to make direct jumps when the target program index is known at the JIT-compilation time. Instead, the target address is always loaded from the BPF program array.</p><p>Ready for the second scenario? I promise it will be shorter. Function prologue and epilogue instructions will look familiar, so we are going to keep annotations down to a minimum.</p><p>Scenario #2: A BPF to BPF call - <a href=\"https://github.com/jsitnicki/cloudflare-blog/blob/jakub/2022-10-bpf-tail-calls/2022-10-bpf-tail-call/sub_call_ex1.bpf.c\"><code>sub_call_ex1.bpf.c</code></a></p><p>Input: BPF assembly (<code>bpftool prog dump xlated</code>)</p>\n            <pre class=\"language-txt\"><code class=\"language-txt\">int entry_prog(struct __sk_buff * skb):\n   0: (85) call pc+1#bpf_prog_a84919ecd878b8f3_sub_func\n   1: (95) exit\nint sub_func(struct __sk_buff * skb):\n   2: (b7) r0 = 61453                   // 0xf00d\n   3: (95) exit</pre></code>\n            <p>Output: ARM64 assembly</p>\n            <pre class=\"language-txt\"><code class=\"language-txt\">int entry_prog(struct __sk_buff * skb):\nbpf_prog_163e74e7188910f2_entry_prog:\n   0:   paciasp                                 // Begin prologue\n   4:   stp     x29, x30, [sp, #-16]!           // ⋮\n   8:   mov     x29, sp                         // ⋮\n   c:   stp     x19, x20, [sp, #-16]!           // ⋮\n  10:   stp     x21, x22, [sp, #-16]!           // ⋮\n  14:   stp     x25, x26, [sp, #-16]!           // ⋮\n  18:   stp     x27, x28, [sp, #-16]!           // ⋮\n  1c:   mov     x25, sp                         // ⋮\n  20:   mov     x26, #0x0                       // ⋮\n  24:   sub     x27, x25, #0x0                  // ⋮\n  28:   sub     sp, sp, #0x0                    // End prologue\n  2c:   mov     x10, #0xffffffffffff5420        // Build sub_func()+0x0 address\n  30:   movk    x10, #0x8ff, lsl #16            // ⋮\n  34:   movk    x10, #0xffc0, lsl #32           // ⋮\n  38:   blr     x10 ------------------.         // Call sub_func()+0x0 \n  3c:   add     x7, x0, #0x0 &lt;----------.       // r0 = sub_func()\n  40:   mov     sp, sp                | |       // Begin epilogue\n  44:   ldp     x27, x28, [sp], #16   | |       // ⋮\n  48:   ldp     x25, x26, [sp], #16   | |       // ⋮\n  4c:   ldp     x21, x22, [sp], #16   | |       // ⋮\n  50:   ldp     x19, x20, [sp], #16   | |       // ⋮\n  54:   ldp     x29, x30, [sp], #16   | |       // ⋮\n  58:   add     x0, x7, #0x0          | |       // ⋮\n  5c:   autiasp                       | |       // ⋮\n  60:   ret                           | |       // End epilogue\n                                      | |\nint sub_func(struct __sk_buff * skb): | |\nbpf_prog_a84919ecd878b8f3_sub_func:   | |\n   0:   paciasp &lt;---------------------&#039; |       // Begin prologue\n   4:   stp     x29, x30, [sp, #-16]!   |       // ⋮\n   8:   mov     x29, sp                 |       // ⋮\n   c:   stp     x19, x20, [sp, #-16]!   |       // ⋮\n  10:   stp     x21, x22, [sp, #-16]!   |       // ⋮\n  14:   stp     x25, x26, [sp, #-16]!   |       // ⋮\n  18:   stp     x27, x28, [sp, #-16]!   |       // ⋮\n  1c:   mov     x25, sp                 |       // ⋮\n  20:   mov     x26, #0x0               |       // ⋮\n  24:   sub     x27, x25, #0x0          |       // ⋮\n  28:   sub     sp, sp, #0x0            |       // End prologue\n  2c:   mov     x7, #0xf00d             |       // r0 = 0xf00d\n  30:   mov     sp, sp                  |       // Begin epilogue\n  34:   ldp     x27, x28, [sp], #16     |       // ⋮\n  38:   ldp     x25, x26, [sp], #16     |       // ⋮\n  3c:   ldp     x21, x22, [sp], #16     |       // ⋮\n  40:   ldp     x19, x20, [sp], #16     |       // ⋮\n  44:   ldp     x29, x30, [sp], #16     |       // ⋮\n  48:   add     x0, x7, #0x0            |       // ⋮\n  4c:   autiasp                         |       // ⋮\n  50:   ret ----------------------------&#039;       // End epilogue</pre></code>\n            <p>We have now seen what a BPF tail call and a BPF function/subprogram call compiles down to. Can you already spot what would go wrong if mixing the two was allowed?</p><p>That’s right! Every time we enter a BPF subprogram, we reset the X26 register, which holds the tail call count, to zero (<code>mov x26</code>, <code>#0x0</code>). This is bad. It would let users create program chains longer than the <code>MAX_TAIL_CALL_CNT</code> limit.</p><p>How about we just skip this step when emitting the prologue for BPF subprograms?</p>\n            <pre class=\"language-diff\"><code class=\"language-diff\">@@ -246,6 +246,7 @@ static bool is_lsi_offset(int offset, int scale)\n static int build_prologue(struct jit_ctx *ctx, bool ebpf_from_cbpf)\n {\n        const struct bpf_prog *prog = ctx-&gt;prog;\n+       const bool is_main_prog = prog-&gt;aux-&gt;func_idx == 0;\n        const u8 r6 = bpf2a64[BPF_REG_6];\n        const u8 r7 = bpf2a64[BPF_REG_7];\n        const u8 r8 = bpf2a64[BPF_REG_8];\n@@ -299,7 +300,7 @@ static int build_prologue(struct jit_ctx *ctx, bool ebpf_from_cbpf)\n        /* Set up BPF prog stack base register */\n        emit(A64_MOV(1, fp, A64_SP), ctx);\n\n-       if (!ebpf_from_cbpf) {\n+       if (!ebpf_from_cbpf &amp;&amp; is_main_prog) {\n                /* Initialize tail_call_cnt */\n                emit(A64_MOVZ(1, tcc, 0, 0), ctx);</pre></code>\n            <p>Believe it or not. This is everything that <a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d4609a5d8c70d21b4a3f801cf896a3c16c613fe1\">was missing</a> to get BPF tail calls working with function calls on arm64. The feature will be enabled in the upcoming Linux 6.0 release.</p>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"outro\">Outro</h2>\n      <a href=\"#outro\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>From recursion to tweaking the BPF JIT. How did we get here? Not important. It’s all about the journey.</p><p>Along the way we have unveiled a few secrets behind BPF tails calls, and hopefully quenched your thirst for low-level programming. At least for today.</p><p>All that is left is to sit back and watch the fruits of our work. With GDB hooked up to a VM, we can observe how a BPF program calls into a BPF function, and from there tail calls to another BPF program:</p><p><a href=\"https://demo-gdb-step-thru-bpf.pages.dev/\">https://demo-gdb-step-thru-bpf.pages.dev/</a></p><p>Until next time ?.</p>",
		"id": "2mPM5QrHXSfrNhO9mxBcWD",
		"localeList": {
			"name": "Assembly within! BPF tail calls on x86 and ARM Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "We have first adopted the BPF tail calls when building our XDP-based packet processing pipeline. BPF tail calls have served us well since then. But they do have their caveats.",
		"metadata": {
			"title": "Assembly within! BPF tail calls on x86 and ARM",
			"description": "We have first adopted the BPF tail calls when building our XDP-based packet processing pipeline. BPF tail calls have served us well since then. But they do have their caveats.",
			"imgPreview": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6YlaQWvTb2DXn5dXB2kkSk/357804d4bd48ec2395d5fc41be04349f/assembly-within-bpf-tail-calls-on-x86-and-arm-VRgzlV.png"
		},
		"primary_author": {},
		"publicly_index": true,
		"published_at": "2022-10-10T14:00:00.000+01:00",
		"slug": "assembly-within-bpf-tail-calls-on-x86-and-arm",
		"tags": [
			{
				"id": "73alK6sbtKLS6uB7ZrYrjj",
				"name": "Kernel",
				"slug": "kernel"
			},
			{
				"id": "2UVIYusJwlvsmPYl2AvSuR",
				"name": "Deep Dive",
				"slug": "deep-dive"
			}
		],
		"title": "Assembly within! BPF tail calls on x86 and ARM",
		"updated_at": "2025-10-03T19:10:55.940Z",
		"url": "https://blog.cloudflare.com/assembly-within-bpf-tail-calls-on-x86-and-arm"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.icon_aria_label": "Search",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"search.result_stat_empty": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong>",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"search.autocomplete_title": "Insert a query. Press enter to send",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}