{
	"initialReadingTime": "9",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Christopher Wood",
				"slug": "christopher",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/EAlXDk7jyC8y5YJUgvUmR/e016ca1de813f9dd1426366287f90fcf/christopher.png",
				"location": null,
				"website": null,
				"twitter": null,
				"facebook": null
			}
		],
		"excerpt": "HPKE (RFC 9180) was made to be simple, reusable, and future-proof by building upon knowledge from prior PKE schemes and software implementations. This article provides an overview of this new standard, going back to discuss its motivation, design goals, and development process",
		"feature_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/4NSxUaxAmzc8ORPh7vUIfY/9dc75597acc391fbdf662499ee0bce8c/hybrid-public-key-encryption.png",
		"featured": false,
		"html": "<p>For the last three years, the <a href=\"https://irtf.org/cfrg\">Crypto Forum Research Group</a> of the <a href=\"https://irtf.org/\">Internet Research Task Force (IRTF)</a> has been working on specifying the next generation of (hybrid) public-key encryption (PKE) for Internet protocols and applications. The result is Hybrid Public Key Encryption (HPKE), published today as <a href=\"https://www.rfc-editor.org/rfc/rfc9180.html\">RFC 9180</a>.</p><p>HPKE was made to be simple, reusable, and future-proof by building upon knowledge from prior PKE schemes and software implementations. It is already in use in a large assortment of emerging Internet standards, including TLS <a href=\"https://datatracker.ietf.org/doc/draft-ietf-tls-esni/\">Encrypted Client Hello</a> and <a href=\"https://datatracker.ietf.org/doc/draft-pauly-dprive-oblivious-doh/\">Oblivious DNS-over-HTTPS</a>, and has a large assortment of interoperable implementations, including one in <a href=\"https://github.com/cloudflare/circl/tree/master/hpke\">CIRCL</a>. This article provides an overview of this new standard, going back to discuss its motivation, design goals, and development process.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"a-primer-on-public-key-encryption\">A primer on public-key encryption</h3>\n            <a href=\"#a-primer-on-public-key-encryption\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>Public-key cryptography is decades old, with its roots going back to the seminal work of Diffie and Hellman in 1976, entitled “<a href=\"https://ee.stanford.edu/~hellman/publications/24.pdf\">New Directions in Cryptography</a>.” Their proposal – today called Diffie-Hellman key exchange – was a breakthrough. It allowed one to transform small secrets into big secrets for cryptographic applications and protocols. For example, one can bootstrap a secure channel for exchanging messages with confidentiality and integrity using a key exchange protocol.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/49zWFnGoaVQPUcKjDT52uO/1f2425f5f9ce81f631c74aec57a0c5e8/Screen-Shot-2022-02-24-at-11.09.26-AM.png\" alt=\"Unauthenticated Diffie-Hellman key exchange\" class=\"kg-image\" width=\"1528\" height=\"742\" loading=\"lazy\"/>\n            \n            </figure><p>Unauthenticated Diffie-Hellman key exchange</p><p>In this example, Sender and Receiver exchange freshly generated public keys with each other, and then combine their own secret key with their peer’s public key. Algebraically, this yields the same value \\(g^{xy} = (g^x)^y = (g^y)^x\\). Both parties can then use this as a <i>shared secret</i> for performing other tasks, such as encrypting messages to and from one another.</p><p>The <a href=\"https://datatracker.ietf.org/doc/html/rfc8446\">Transport Layer Security</a> (TLS) protocol is one such application of this concept. Shortly after Diffie-Hellman was unveiled to the world, RSA came into the fold. The RSA cryptosystem is another public key algorithm that has been used to build digital signature schemes, PKE algorithms, and key transport protocols. A key transport protocol is similar to a key exchange algorithm in that the sender, Alice, generates a random symmetric key and then encrypts it under the receiver’s public key. Upon successful decryption, both parties then share this secret key. (This fundamental technique, known as static RSA, was used pervasively in the context of TLS. See <a href=\"/rfc-8446-aka-tls-1-3/\">this post</a> for details about this old technique in TLS 1.2 and prior versions.)</p><p>At a high level, PKE between a sender and receiver is a protocol for encrypting messages under the receiver’s public key. One way to do this is via a so-called non-interactive key exchange protocol.</p><p>To illustrate how this might work, let \\(g^y\\) be the receiver’s public key, and let \\(m\\) be a message that one wants to send to this receiver. The flow looks like this:</p><ol><li><p>The sender generates a fresh private and public key pair, \\((x, g^x)\\).</p></li><li><p>The sender computes \\(g^{xy} = (g^y)^x\\), which can be done without involvement from the receiver, that is, non-interactively.</p></li><li><p>The sender then uses this shared secret to derive an encryption key, and uses this key to encrypt m.</p></li><li><p>The sender packages up \\(g^x\\) and the encryption of \\(m\\), and sends both to the receiver.</p></li></ol><p>The general paradigm here is called &quot;hybrid public-key encryption&quot; because it combines a non-interactive key exchange based on public-key cryptography for establishing a shared secret, and a symmetric encryption scheme for the actual encryption. To decrypt \\(m\\), the receiver computes the same shared secret \\(g^{xy} = (g^x)^y\\), derives the same encryption key, and then decrypts the ciphertext.</p><p>Conceptually, PKE of this form is quite simple. General designs of this form date back for many years and include the <a href=\"https://www.cs.ucdavis.edu/~rogaway/papers/dhies.pdf\">Diffie-Hellman Integrated Encryption System</a> (DHIES) and ElGamal encryption. However, despite this apparent simplicity, there are numerous subtle design decisions one has to make in designing this type of protocol, including:</p><ul><li><p>What type of key exchange protocol should be used for computing the shared secret? Should this protocol be based on modern elliptic curve groups like Curve25519? Should it support future post-quantum algorithms?</p></li><li><p>How should encryption keys be derived? Are there other keys that should be derived? How should additional application information be included in the encryption key derivation, if at all?</p></li><li><p>What type of encryption algorithm should be used? What types of messages should be encrypted?</p></li><li><p>How should sender and receiver encode and exchange public keys?</p></li></ul><p>These and other questions are important for a protocol, since they are required for interoperability. That is, senders and receivers should be able to communicate without having to use the same source code.</p><p>There have been a number of efforts in the past to standardize PKE, most of which focus on elliptic curve cryptography. Some examples of past standards include: ANSI X9.63 (ECIES), IEEE 1363a, ISO/IEC 18033-2, and SECG SEC 1.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/85SKzkEqGOEuyw4brVcak/bd64a14da34e1ec375cb117438dbe7b3/Screen-Shot-2022-02-24-at-11.09.53-AM.png\" alt=\"Timeline of related standards and software\" class=\"kg-image\" width=\"2000\" height=\"739\" loading=\"lazy\"/>\n            \n            </figure><p>Timeline of related standards and software</p><p>A paper by <a href=\"https://ieeexplore.ieee.org/abstract/document/5604194/\">Martinez et al.</a> provides a thorough and technical comparison of these different standards. The key points are that all these existing schemes have shortcomings. They either rely on outdated or not-commonly-used primitives such as <a href=\"https://en.wikipedia.org/wiki/RIPEMD\">RIPEMD</a> and CMAC-AES, lack accommodations for moving to modern primitives (e.g., <a href=\"https://datatracker.ietf.org/doc/html/rfc5116\">AEAD</a> algorithms), lack proofs of <a href=\"https://link.springer.com/chapter/10.1007/BFb0055718\">IND-CCA2</a> security, or, importantly, fail to provide test vectors and interoperable implementations.</p><p>The lack of a single standard for public-key encryption has led to inconsistent and often non-interoperable support across libraries. In particular, hybrid PKE implementation support is fractured across the community, ranging from the hugely popular and simple-to-use <a href=\"https://nacl.cr.yp.to/box.html\">NaCl box</a> and <a href=\"https://libsodium.gitbook.io/doc/public-key_cryptography/sealed_boxes\">libsodium box seal</a> implementations based on modern algorithm variants like X-SalsaPoly1305 for authenticated encryption, to <a href=\"https://www.bouncycastle.org/specifications.html\">BouncyCastle</a> implementations based on “classical” algorithms like AES and elliptic curves.</p><p>Despite the lack of a single standard, this hasn’t stopped the adoption of ECIES instantiations for widespread and critical applications. For example, the Apple and Google <a href=\"https://covid19-static.cdn-apple.com/applications/covid19/current/static/contact-tracing/pdf/ENPA_White_Paper.pdf\">Exposure Notification Privacy-preserving Analytics</a> (ENPA) platform uses ECIES for public-key encryption.</p><p>When designing protocols and applications that need a simple, reusable, and agile abstraction for public-key encryption, existing standards are not fit for purpose. That’s where HPKE comes into play.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"construction-and-design-goals\">Construction and design goals</h3>\n            <a href=\"#construction-and-design-goals\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>HPKE is a public-key encryption construction that is designed from the outset to be simple, reusable, and future-proof. It lets a sender encrypt arbitrary-length messages under a receiver’s public key, as shown below. You can try this out in the browser at <a href=\"https://www.franziskuskiefer.de/p/tldr-hybrid-public-key-encryption/\">Franziskus Kiefer’s blog post on HPKE</a>!</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/2QjgXQ7cSPcN5kLUpdpYEO/1d9a944dcccf8d0a1bbf85c18d97a9e9/image5-2.png\" alt=\"HPKE overview\" class=\"kg-image\" width=\"1338\" height=\"632\" loading=\"lazy\"/>\n            \n            </figure><p>HPKE overview</p><p>HPKE is built in stages. It starts with a Key Encapsulation Mechanism (KEM), which is similar to the key transport protocol described earlier and, in fact, can be constructed from the Diffie-Hellman key agreement protocol. A KEM has two algorithms: Encapsulation and Decapsulation, or Encap and Decap for short. The Encap algorithm creates a symmetric secret and wraps it for a public key such that only the holder of the corresponding private key can unwrap it. An attacker knowing this encapsulated key cannot recover even a single bit of the shared secret. Decap takes the encapsulated key and the private key associated with the public key, and computes the original shared secret. From this shared secret, HPKE computes a series of derived keys that are then used to encrypt and authenticate plaintext messages between sender and receiver.</p><p>This simple construction was driven by several high-level design goals and principles. We will discuss these goals and how they were met below.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"algorithm-agility\">Algorithm agility</h3>\n            <a href=\"#algorithm-agility\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>Different applications, protocols, and deployments have different constraints, and locking any single use case into a specific (set of) algorithm(s) would be overly restrictive. For example, some applications may wish to use post-quantum algorithms when available, whereas others may wish to use different authenticated encryption algorithms for symmetric-key encryption. To accomplish this goal, HPKE is designed as a composition of a Key Encapsulation Mechanism (KEM), Key Derivation Function (KDF), and Authenticated Encryption Algorithm (AEAD). Any combination of the three algorithms yields a valid instantiation of HPKE, subject to certain security constraints about the choice of algorithm.</p><p>One important point worth noting here is that HPKE is not a <i>protocol</i>, and therefore does nothing to ensure that sender and receiver agree on the HPKE ciphersuite or shared context information. Applications and protocols that use HPKE are responsible for choosing or negotiating a specific HPKE ciphersuite that fits their purpose. This allows applications to be opinionated about their choice of algorithms to simplify implementation and analysis, as is common with protocols like <a href=\"https://www.wireguard.com/\">WireGuard</a>, or be flexible enough to support choice and agility, as is the approach taken with TLS.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"authentication-modes\">Authentication modes</h3>\n            <a href=\"#authentication-modes\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>At a high level, public-key encryption ensures that only the holder of the private key can decrypt messages encrypted for the corresponding public key (being able to decrypt the message is an implicit authentication of the receiver.) However, there are other ways in which applications may wish to authenticate messages from sender to receiver. For example, if both parties have a pre-shared key, they may wish to ensure that both can demonstrate possession of this pre-shared key as well. It may also be desirable for senders to demonstrate knowledge of their own private key in order for recipients to decrypt the message (this functionally is similar to signing an encryption, but has some <a href=\"https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hpke-12#section-9.1.1\">subtle and important differences</a>).</p><p>To support these various use cases, HPKE admits different modes of authentication, allowing various combinations of pre-shared key and sender private key authentication. The additional private key contributes to the shared secret between the sender and receiver, and the pre-shared key contributes to the derivation of the application data encryption secrets. This process is referred to as the “key schedule”, and a simplified version of it is shown below.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/3kF11CKLHDthJSduTAD10i/e84555b4ad02be6a9cb6e3263eb48f26/image2-11.png\" alt=\"Simplified HPKE key schedule\" class=\"kg-image\" width=\"876\" height=\"500\" loading=\"lazy\"/>\n            \n            </figure><p>Simplified HPKE key schedule</p><p>These modes come at a price, however: not all KEM algorithms will work with all authentication modes. For example, for most post-quantum KEM algorithms there isn’t a private key authentication variant known.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"reusability\">Reusability</h3>\n            <a href=\"#reusability\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>The core of HPKE’s construction is its key schedule. It allows secrets produced and shared with KEMs and pre-shared keys to be mixed together to produce additional shared secrets between sender and receiver for performing authenticated encryption and decryption. HPKE allows applications to build on this key schedule without using the corresponding AEAD functionality, for example, by <a href=\"https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hpke-12#section-5.3\">exporting a shared application-specific secret</a>. Using HPKE in an “export-only” fashion allows applications to use other, non-standard AEAD algorithms for encryption, should that be desired. It also allows applications to use a KEM different from those specified in the standard, as is done in the proposed <a href=\"https://claucece.github.io/draft-celi-wiggers-tls-authkem/draft-celi-wiggers-tls-authkem.html\">TLS AuthKEM draft</a>.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"interface-simplicity\">Interface simplicity</h3>\n            <a href=\"#interface-simplicity\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>HPKE hides the complexity of message encryption from callers. Encrypting a message with additional authenticated data from sender to receiver for their public key is as simple as the following two calls:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">// Create an HPKE context to send messages to the receiver\nencapsulatedKey, senderContext = SetupBaseS(receiverPublicKey, ”shared application info”)\n\n// AEAD encrypt the message using the context\nciphertext = senderContext.Seal(aad, message)</pre></code>\n            <p>In fact, many implementations are likely to offer a simplified <a href=\"https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hpke-12#section-6\">“single-shot” interface</a> that does context creation and message encryption with one function call.</p><p>Notice that this interface does not expose anything like nonce (&quot;number used once&quot;) or sequence numbers to the callers. The HPKE context manages nonce and sequence numbers internally, which means the application is responsible for message ordering and delivery. This was an important design decision done to hedge against key and nonce reuse, <a href=\"https://fahrplan.events.ccc.de/congress/2010/Fahrplan/events/4087.en.html\">which</a> <a href=\"https://link.springer.com/chapter/10.1007/978-3-662-45611-8_14\">can</a> <a href=\"https://eprint.iacr.org/2014/161\">be</a> <a href=\"https://eprint.iacr.org/2019/023.pdf\">catastrophic</a> for <a href=\"https://eprint.iacr.org/2020/615\">security</a>.</p><p>Consider what would be necessary if HPKE delegated nonce management to the application. The sending application using HPKE would need to communicate the nonce along with each ciphertext value for the receiver to successfully decrypt the message. If this nonce was ever reused, then security of the <a href=\"https://eprint.iacr.org/2016/475\">AEAD may fall apart</a>. Thus, a sending application would necessarily need some way to ensure that nonces were never reused. Moreover, by sending the nonce to the receiver, the application is effectively implementing a message sequencer. The application could just as easily implement and use this sequencer to ensure in-order message delivery and processing. Thus, at the end of the day, exposing the nonce seemed both harmful and, ultimately, redundant.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"wire-format\">Wire format</h3>\n            <a href=\"#wire-format\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>Another hallmark of HPKE is that all messages that do not contain application data are fixed length. This means that serializing and deserializing HPKE messages is trivial and there is no room for application choice. In contrast, some implementations of hybrid PKE deferred choice of wire format details, such as whether to use elliptic curve point compression, to applications. HPKE handles this under the KEM abstraction.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"development-process\">Development process</h3>\n            <a href=\"#development-process\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>HPKE is the result of a three-year development cycle between industry practitioners, protocol designers, and academic cryptographers. In particular, HPKE built upon prior art relating to public-key encryption, iterated on a design and specification in a tight specification, implementation, experimentation, and analysis loop, with an ultimate goal towards real world use.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/11GwbhP4mtylFViu3VGoqP/056a2e2128feb4f414a455093d50bd12/image3-15.png\" alt=\"HPKE development process\" class=\"kg-image\" width=\"1010\" height=\"292\" loading=\"lazy\"/>\n            \n            </figure><p>HPKE development process</p><p>This process isn’t new. TLS 1.3 and QUIC famously demonstrated this as an effective way of producing high quality technical specifications that are maximally useful for their consumers.</p><p>One particular point worth highlighting in this process is the value of interoperability and analysis. From the very first draft, interop between multiple, independent implementations was a goal. And since then, every revision was carefully checked by multiple library maintainers for soundness and correctness. This helped catch a number of mistakes and improved overall clarity of the technical specification.</p><p>From a formal analysis perspective, HPKE brought novel work to the community. Unlike protocol design efforts like those around TLS and QUIC, HPKE was simpler, but still came with plenty of sharp edges. As a new cryptographic construction, analysis was needed to ensure that it was sound and, importantly, to understand its limits. This analysis led to a number of important contributions to the community, including a <a href=\"https://eprint.iacr.org/2020/1499.pdf\">formal analysis of HPKE</a>, new understanding of the <a href=\"https://dl.acm.org/doi/abs/10.1145/3460120.3484814\">limits of ChaChaPoly1305 in a multi-user security setting</a>, as well as a new CFRG specification documenting <a href=\"https://datatracker.ietf.org/doc/draft-irtf-cfrg-aead-limits/\">limits for AEAD algorithms</a>. For more information about the analysis effort that went into HPKE, check out this <a href=\"https://www.benjaminlipp.de/p/hpke-cryptographic-standard/\">companion blog</a> by Benjamin Lipp, an HPKE co-author.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"hpkes-future\">HPKE’s future</h3>\n            <a href=\"#hpkes-future\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>While HPKE may be a new standard, it has already seen a tremendous amount of adoption in the industry. As mentioned earlier, it’s an essential part of the TLS Encrypted Client Hello and Oblivious DoH standards, both of which are deployed protocols on the Internet today. Looking ahead, it’s also been integrated as part of the emerging <a href=\"https://datatracker.ietf.org/doc/charter-ietf-ohai/\">Oblivious HTTP</a>, <a href=\"https://datatracker.ietf.org/wg/mls/about/\">Message Layer Security</a>, and <a href=\"https://www.ietf.org/id/draft-gpew-priv-ppm-00.html\">Privacy Preserving Measurement</a> standards. HPKE’s hallmark is its generic construction that lets it adapt to a wide variety of application requirements. If an application needs public-key encryption with a <a href=\"https://eprint.iacr.org/2020/1153.pdf\">key-committing AEAD</a>, one can simply instantiate HPKE using a key-committing AEAD.</p><p>Moreover, there exists a huge assortment of interoperable implementations built on popular cryptographic libraries, including <a href=\"https://github.com/cisco/mlspp/tree/main/lib/hpke\">OpenSSL</a>, <a href=\"https://boringssl.googlesource.com/boringssl/+/refs/heads/master/include/openssl/hpke.h\">BoringSSL</a>, <a href=\"https://hg.mozilla.org/projects/nss/file/tip/lib/pk11wrap\">NSS</a>, and <a href=\"https://github.com/cloudflare/circl/tree/master/hpke\">CIRCL</a>. There are also formally verified implementations in <a href=\"https://www.franziskuskiefer.de/p/an-executable-hpke-specification/\">hacspec and F*</a>; check out this <a href=\"https://tech.cryspen.com/hpke-spec\">blog post</a> for more details. The complete set of known implementations is tracked <a href=\"https://github.com/cfrg/draft-irtf-cfrg-hpke#existing-hpke-implementations\">here</a>. More implementations will undoubtedly follow in their footsteps.</p><p>HPKE is ready for prime time. I look forward to seeing how it simplifies protocol design and development in the future. Welcome, <a href=\"https://www.rfc-editor.org/rfc/rfc9180.html\">RFC 9180</a>.</p>",
		"id": "2y7fDoXJoE5tJvjDMO7kap",
		"localeList": {
			"name": "HPKE: Standardizing public-key encryption (finally!) Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "HPKE (RFC 9180) was made to be simple, reusable, and future-proof by building upon knowledge from prior PKE schemes and software implementations. It is already in use in a large assortment of emerging Internet standards and has a large assortment of interoperable implementations. This article provides an overview of this new standard, going back to discuss its motivation, design goals, and development process.",
		"metadata": {
			"title": "HPKE: Standardizing public-key encryption (finally!)",
			"description": "HPKE (RFC 9180) was made to be simple, reusable, and future-proof by building upon knowledge from prior PKE schemes and software implementations. It is already in use in a large assortment of emerging Internet standards and has a large assortment of interoperable implementations. This article provides an overview of this new standard, going back to discuss its motivation, design goals, and development process.",
			"imgPreview": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/5FY8duUyCk18qVYEROC4W/5d69307fa2045c0e75a695bb321802b6/hybrid-public-key-encryption-upNOIp.png"
		},
		"primary_author": {},
		"published_at": "2022-02-24T23:12:36.000+00:00",
		"slug": "hybrid-public-key-encryption",
		"tags": [
			{
				"id": "1x7tpPmKIUCt19EDgM1Tsl",
				"name": "Research",
				"slug": "research"
			},
			{
				"id": "SSoBzzf0KiZJPco6VApIL",
				"name": "IETF",
				"slug": "ietf"
			},
			{
				"id": "1QsJUMpv0QBSLiVZLLQJ3V",
				"name": "Cryptography",
				"slug": "cryptography"
			},
			{
				"id": "iiynSxxhE6dlxRhbsXqc4",
				"name": "Standards",
				"slug": "standards"
			}
		],
		"title": "HPKE: Standardizing public-key encryption (finally!)",
		"updated_at": "2024-08-27T01:36:00.136Z",
		"url": "https://blog.cloudflare.com/hybrid-public-key-encryption"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.blurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}