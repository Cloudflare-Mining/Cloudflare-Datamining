{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "8",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Chris Bell (Guest author)",
				"slug": "Chris Bell (Guest author)",
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1oACtpoGbOmqrsRXMO0Mgu/913b30bfa207cac04efee1e17df60d6e/Chris_Bell.png",
				"twitter": "cjbell_",
				"publiclyIndex": true
			}
		],
		"excerpt": "How Knock shipped an AI Agent with human-in-the-loop capabilities with Cloudflare’s Agents SDK and Cloudflare Workers.",
		"feature_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4QDMGATQYFYtzw9CfEpZeA/b850ebb2dd2b22fd415807c4a7a09cf2/hero-knock-cloudflare-agents.png",
		"featured": false,
		"html": "<p><sub><i>This is a guest post by Chris Bell, CTO of </i></sub><a href=\"https://knock.app/\"><sub><i><u>Knock</u></i></sub></a></p><p>There’s a lot of talk right now about building AI agents, but not a lot out there about what it takes to make those agents truly <i>useful</i>.</p><p>An Agent is an autonomous system designed to make decisions and perform actions to achieve a specific goal or set of goals, without human input.</p><p>No matter how good your agent is at making decisions, you will need a person to provide guidance or input on the agent’s path towards its goal. After all, an agent that cannot interact or respond to the outside world and the systems that govern it will be limited in the problems it can solve.</p><p>That’s where the “human-in-the-loop” interaction pattern comes in. You&#39;re bringing a human <i>into</i> the agent&#39;s loop and requiring an input from that human before the agent can continue on its task.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6dhEhrOtwdaWOjJqhrzmMw/cc8576e7ccce43e2df1bacfd91b125ff/image3.png\" alt=\"\" class=\"kg-image\" width=\"625\" height=\"565\" loading=\"lazy\"/>\n          </figure><p>In this blog post, we&#39;ll use<a href=\"https://knock.app/\"> <u>Knock</u></a> and the Cloudflare<a href=\"https://developers.cloudflare.com/agents/\"> <u>Agents SDK</u></a> to build an AI Agent for a virtual card issuing workflow that requires human approval when a new card is requested.</p><p>You can find the complete code for this example<a href=\"https://github.com/knocklabs/ai-agent-examples/tree/main/card-issue-agent\"> <u>in the repository</u></a>.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"what-is-knock\">What is Knock?</h2>\n            <a href=\"#what-is-knock\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p><a href=\"https://knock.app/\"><u>Knock</u></a> is messaging infrastructure you can use to send multi-channel messages across in-app, email, SMS, push, and Slack, without writing any integration code.</p><p>With Knock, you gain complete visibility into the messages being sent to your users while also handling reliable delivery, user notification preferences, and more.</p><p>You can use Knock to power human-in-the-loop flows for your agents using Knock’s<a href=\"https://docs.knock.app/developer-tools/agent-toolkit/overview\"> <u>Agent Toolkit</u></a>, which is a set of tools that expose Knock’s APIs and messaging capabilities to your AI agents.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"using-the-agent-sdk-as-the-foundation-of-our-ai-agent\">Using the Agent SDK as the foundation of our AI Agent</h2>\n            <a href=\"#using-the-agent-sdk-as-the-foundation-of-our-ai-agent\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>The Agents SDK provides an abstraction for building stateful, real-time agents on top of <a href=\"https://developers.cloudflare.com/durable-objects/\"><u>Durable Objects</u></a> that are globally addressable and persist state using an embedded, <a href=\"https://blog.cloudflare.com/sqlite-in-durable-objects/\"><u>zero-latency</u></a> SQLite database.</p><p>Building an AI agent outside of using the Agents SDK and the Cloudflare platform means we need to consider WebSocket servers, state persistence, and how to scale our service horizontally. Because a Durable Object backs the Agents SDK, we receive these benefits for free, while having a globally addressable piece of compute with built-in storage, that’s completely serverless and scales to zero.</p><p>In the example, we’ll use these features to build an agent that users interact with in real-time via chat, and that can be paused and resumed as needed. The Agents SDK is the ideal platform for powering asynchronous agentic workflows, such as those required in human-in-the-loop interactions.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"setting-up-our-knock-messaging-workflow\">Setting up our Knock messaging workflow</h2>\n            <a href=\"#setting-up-our-knock-messaging-workflow\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Within Knock, we design our approval workflow using the visual workflow builder to create the cross-channel messaging logic. We then make the notification templates associated with each channel to which we want to send messages.</p><p>Knock will automatically apply the<a href=\"https://docs.knock.app/concepts/preferences\"> <u>user’s preferences</u></a> as part of the workflow execution, ensuring that your user’s notification settings are respected.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5f1hOpKg3xTxZwYuJYmUAl/83088b52e8cb26aaed561d00733fd2e1/image1.png\" alt=\"\" class=\"kg-image\" width=\"1999\" height=\"1299\" loading=\"lazy\"/>\n          </figure><p>You can find an example workflow that we’ve already created for this demo in the repository. You can use this workflow template via the<a href=\"https://docs.knock.app/cli\"> <u>Knock CLI</u></a> to import it into your account.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"building-our-chat-ui\">Building our chat UI</h2>\n            <a href=\"#building-our-chat-ui\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>We’ve built the AI Agent as a chat interface on top of the <code>AIChatAgent</code> abstraction from Cloudflare’s Agents SDK (<a href=\"https://developers.cloudflare.com/agents/api-reference/agents-api/#chat-agent\"><u>docs</u></a>). The Agents SDK here takes care of the bulk of the complexity, and we’re left to implement our LLM calling code with our system prompt.</p>\n            <pre class=\"language-TypeScript\"><code class=\"language-TypeScript\">// src/index.ts\n\nimport { AIChatAgent } from &quot;agents/ai-chat-agent&quot;;\nimport { openai } from &quot;@ai-sdk/openai&quot;;\nimport { createDataStreamResponse, streamText } from &quot;ai&quot;;\n\nexport class AIAgent extends AIChatAgent {\n  async onChatMessage(onFinish) {\n    return createDataStreamResponse({\n      execute: async (dataStream) =&gt; {\n        try {\n          const stream = streamText({\n            model: openai(&quot;gpt-4o-mini&quot;),\n            system: `You are a helpful assistant for a financial services company. You help customers with credit card issuing.`,\n            messages: this.messages,\n            onFinish,\n            maxSteps: 5,\n          });\n\n          stream.mergeIntoDataStream(dataStream);\n        } catch (error) {\n          console.error(error);\n        }\n      },\n    });\n  }\n}</pre></code>\n            <p>On the client side, we’re using the <code>useAgentChat</code> hook from the <code>agents/ai-react</code> package to power the real-time user-to-agent chat.</p><p>We’ve modeled our agent as a chat per user, which we set up using the <code>useAgent</code> hook by specifying the name of the process as the <code>userId</code>.</p>\n            <pre class=\"language-TypeScript\"><code class=\"language-TypeScript\">// src/index.ts\n\nimport { useAgent } from &quot;agents/react&quot;;\nimport { useAgentChat } from &quot;agents/ai-react&quot;;\n\nfunction Chat({ userId }: { userId: string }) {\n  const agent = useAgent({ agent: &quot;AIAgent&quot;, name: userId });\n  const { messages, input, handleInputChange, handleSubmit, isLoading } = useAgentChat({ agent });\n  // ... \n}</pre></code>\n            <p>This means we have an agent process, and therefore a durable object, per-user. For our human-in-the-loop use case, this becomes important later on as we talk about resuming our deferred tool call.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"deferring-the-tool-call-to-knock\">Deferring the tool call to Knock</h2>\n            <a href=\"#deferring-the-tool-call-to-knock\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>We give the agent our card issuing capability through exposing an <code>issueCard</code> tool. However, instead of writing the approval flow and cross-channel logic ourselves, we delegate it entirely to Knock by wrapping the issue card tool in our <code>requireHumanInput</code> method.</p><p>Now when the user asks to request a new card, we make a call out to Knock to initiate our card request, which will notify the appropriate admins in the organization to request an approval.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3siyPnpYiEmoNIQ7eNCRP/13bd33905cfb5c7ad6812a4359d35627/image2.png\" alt=\"\" class=\"kg-image\" width=\"1999\" height=\"664\" loading=\"lazy\"/>\n          </figure><p>To set this up, we need to use Knock’s Agent Toolkit, which exposes methods to work with Knock in our AI agent and power cross-channel messaging.</p>\n            <pre class=\"language-TypeScript\"><code class=\"language-TypeScript\">import { createKnockToolkit } from &quot;@knocklabs/agent-toolkit/ai-sdk&quot;;\nimport { tool } from &quot;ai&quot;;\nimport { z } from &quot;zod&quot;;\n\nimport { AIAgent } from &quot;./index&quot;;\nimport { issueCard } from &quot;./api&quot;;\nimport { BASE_URL } from &quot;./constants&quot;;\n\nasync function initializeToolkit(agent: AIAgent) {\n  const toolkit = await createKnockToolkit({ serviceToken: agent.env.KNOCK_SERVICE_TOKEN });\n\n  const issueCardTool = tool({\n    description: &quot;Issue a new credit card to a customer.&quot;,\n    parameters: z.object({\n      customerId: z.string(),\n    }),\n    execute: async ({ customerId }) =&gt; {\n      return await issueCard(customerId);\n    },\n  });\n\n  const { issueCard } = toolkit.requireHumanInput(\n    { issueCard: issueCardTool },\n    {\n      workflow: &quot;approve-issued-card&quot;,\n      actor: agent.name,\n      recipients: [&quot;admin_user_1&quot;],\n      metadata: {\n        approve_url: `${BASE_URL}/card-issued/approve`,\n        reject_url: `${BASE_URL}/card-issued/reject`,\n      },\n    }\n  );\n  \n  return { toolkit, tools: { issueCard } };  \n}</pre></code>\n            <p>There’s a lot going on here, so let’s walk through the key parts:</p><ul><li><p>We wrap our <code>issueCard</code> tool in the <code>requireHumanInput</code> method, exposed from the Knock Agent Toolkit</p></li><li><p>We want the messaging workflow to be invoked to be our <code>approve-issued-card</code> workflow</p></li><li><p>We pass the agent.name as the <code>actor</code> of the request, which translates to the user ID</p></li><li><p>We set the recipient of this workflow to be the user <code>admin_user_1</code></p></li><li><p>We pass the approve and reject URLs so that they can be used in our message templates</p></li><li><p>The wrapped tool is then returned as <code>issueCard</code></p></li></ul><p>Under the hood, these options are passed to the<a href=\"https://docs.knock.app/api-reference/workflows/trigger\"> <u>Knock workflow trigger API</u></a> to invoke a workflow per-recipient. The set of the recipients listed here could be dynamic, or go to a group of users through<a href=\"https://docs.knock.app/concepts/subscriptions\"> <u>Knock’s subscriptions API</u></a>.</p><p>We can then pass the wrapped issue card tool to our LLM call in the <code>onChatMessage</code> method on the agent so that the tool call can be called as part of the interaction with the agent.</p>\n            <pre class=\"language-TypeScript\"><code class=\"language-TypeScript\">export class AIAgent extends AIChatAgent {\n  // ... other methods\n\n  async onChatMessage(onFinish) {\n    const { tools } = await initializeToolkit(this);\n\n    return createDataStreamResponse({\n      execute: async (dataStream) =&gt; {\n        const stream = streamText({\n          model: openai(&quot;gpt-4o-mini&quot;),\n          system: &quot;You are a helpful assistant for a financial services company. You help customers with credit card issuing.&quot;,\n          messages: this.messages,\n          onFinish,\n          tools,\n          maxSteps: 5,\n        });\n\n        stream.mergeIntoDataStream(dataStream);\n      },\n    });\n  }\n}</pre></code>\n            <p>Now when the agent calls the <code>issueCardTool</code>, we invoke Knock to send our approval notifications, deferring the tool call to issue the card until we receive an approval. Knock’s workflows take care of sending out the message to the set of recipient’s specified, generating and delivering messages according to each user’s preferences.</p><p>Using Knock<a href=\"https://docs.knock.app/concepts/workflows\"> <u>workflows</u></a> for our approval message makes it easy to build cross-channel messaging to reach the user according to their communication<a href=\"https://docs.knock.app/concepts/preferences\"> <u>preferences</u></a>. We can also leverage<a href=\"https://docs.knock.app/designing-workflows/delay-function\"> <u>delays</u></a>,<a href=\"https://docs.knock.app/designing-workflows/throttle-function\"> <u>throttles</u></a>,<a href=\"https://docs.knock.app/designing-workflows/batch-function\"> <u>batching</u></a>, and<a href=\"https://docs.knock.app/designing-workflows/step-conditions\"> <u>conditions</u></a> to orchestrate more complex messaging.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"handling-the-approval\">Handling the approval</h2>\n            <a href=\"#handling-the-approval\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Once the message has been sent to our approvers, the next step is to handle the approval coming back, bringing the human into the agent’s loop.</p><p>The approval request is asynchronous, meaning that the response can come at any point in the future. Fortunately, Knock takes care of the heavy lifting here for you, routing the event to the agent worker via a<a href=\"https://docs.knock.app/developer-tools/outbound-webhooks/overview\"> <u>webhook</u></a> that tracks the interaction with the underlying message. In our case, that’s a click to the &quot;approve&quot; or &quot;reject&quot; button.</p><p>First, we set up a <code>message.interacted</code> webhook handler within the Knock dashboard to forward the interactions to our worker, and ultimately to our agent process.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5CZkwJmmOw09FNmhRUqFrC/7e7d195276331b42778518b821f7707f/image4.png\" alt=\"\" class=\"kg-image\" width=\"1999\" height=\"1299\" loading=\"lazy\"/>\n          </figure><p>In our example here, we route the approval click back to the worker to handle, appending a Knock message ID to the end of the <code>approve_url</code> and <code>reject_url</code> to track engagement against the specific message sent. We do this via liquid inside of our message templates in Knock: <code>{{ data.approve_url }}?messageId={{ current_message.id }} </code>. One caveat here is that if this were a production application, we’re likely going to handle our approval click in a different application than this agent is running. We co-located it here for the purposes of this demo only.</p><p>Once the link is clicked, we have a handler in our worker to mark the message as interacted using Knock’s<a href=\"https://docs.knock.app/api-reference/messages/mark_as_interacted\"> <u>message interaction API</u></a>, passing through the status as metadata so that it can be used later.</p>\n            <pre class=\"language-TypeScript\"><code class=\"language-TypeScript\">import Knock from &#039;@knocklabs/node&#039;;\nimport { Hono } from &quot;hono&quot;;\n\nconst app = new Hono();\nconst client = new Knock();\n\napp.get(&quot;/card-issued/approve&quot;, async (c) =&gt; {\n  const { messageId } = c.req.query();\n  \n  if (!messageId) return c.text(&quot;No message ID found&quot;, { status: 400 });\n\n  await client.messages.markAsInteracted(messageId, {\n    status: &quot;approved&quot;,\n  });\n\n  return c.text(&quot;Approved&quot;);\n});</pre></code>\n            <p>The message interaction will flow from Knock to our worker via the webhook we set up, ensuring that the process is fully asynchronous. The payload of the webhook includes the full message, including metadata about the user that generated the original request, and keeps details about the request itself, which in our case contains the tool call.</p>\n            <pre class=\"language-TypeScript\"><code class=\"language-TypeScript\">import { getAgentByName, routeAgentRequest } from &quot;agents&quot;;\nimport { Hono } from &quot;hono&quot;;\n\nconst app = new Hono();\n\napp.post(&quot;/incoming/knock/webhook&quot;, async (c) =&gt; {\n  const body = await c.req.json();\n  const env = c.env as Env;\n\n  // Find the user ID from the tool call for the calling user\n  const userId = body?.data?.actors[0];\n\n  if (!userId) {\n    return c.text(&quot;No user ID found&quot;, { status: 400 });\n  }\n\n  // Find the agent DO for the user\n  const existingAgent = await getAgentByName(env.AIAgent, userId);\n\n  if (existingAgent) {\n    // Route the request to the agent DO to process\n    const result = await existingAgent.handleIncomingWebhook(body);\n\n    return c.json(result);\n  } else {\n    return c.text(&quot;Not found&quot;, { status: 404 });\n  }\n});</pre></code>\n            <p>We leverage the agent’s ability to be addressed by a named identifier to route the request from the worker to the agent. In our case, that’s the <code>userId</code>. Because the agent is backed by a durable object, this process of going from incoming worker request to finding and resuming the agent is trivial.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"resuming-the-deferred-tool-call\">Resuming the deferred tool call</h2>\n            <a href=\"#resuming-the-deferred-tool-call\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>We then use the context about the original tool call, passed through to Knock and round tripped back to the agent, to resume the tool execution and issue the card.</p>\n            <pre class=\"language-TypeScript\"><code class=\"language-TypeScript\">export class AIAgent extends AIChatAgent {\n  // ... other methods\n\n  async handleIncomingWebhook(body: any) {\n    const { toolkit } = await initializeToolkit(this);\n\n    const deferredToolCall = toolkit.handleMessageInteraction(body);\n\n    if (!deferredToolCall) {\n      return { error: &quot;No deferred tool call given&quot; };\n    }\n\n    // If we received an &quot;approved&quot; status then we know the call was approved \n    // so we can resume the deferred tool call execution\n    if (result.interaction.status === &quot;approved&quot;) {\n      const toolCallResult = \n\t      await toolkit.resumeToolExecution(result.toolCall);\n\n      const { response } = await generateText({\n        model: openai(&quot;gpt-4o-mini&quot;),\n        prompt: `You were asked to issue a card for a customer. The card is now approved. The result was: ${JSON.stringify(toolCallResult)}.`,\n      });\n\n      const message = responseToAssistantMessage(\n        response.messages[0],\n        result.toolCall,\n        toolCallResult\n      );\n\n      // Save the message so that it&#039;s displayed to the user\n      this.persistMessages([...this.messages, message]);\n    }\n\n    return { status: &quot;success&quot; };\n  }\n}</pre></code>\n            <p>Again, there’s a lot going on here, so let’s step through the important parts:</p><ul><li><p>We attempt to transform the body, which is the webhook payload from Knock, into a deferred tool call via the <code>handleMessageInteraction</code> method</p></li><li><p>If the metadata status we passed through to the interaction call earlier has an “approved” status then we resume the tool call via the <code>resumeToolExecution</code> method</p></li><li><p>Finally, we generate a message from the LLM and persist it, ensuring that the user is informed of the approved card</p></li></ul><p>With this last piece in place, we can now request a new card be issued, have an approval request be dispatched from the agent, send the approval messages, and route those approvals back to our agent to be processed. The agent will asynchronously process our card issue request and the deferred tool call will be resumed for us, with very little code.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"protecting-against-duplicate-approvals\">Protecting against duplicate approvals</h2>\n            <a href=\"#protecting-against-duplicate-approvals\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>One issue with the above implementation is that we’re prone to issuing multiple cards if someone clicks on the approve button more than once. To rectify this, we want to keep track of the tool calls being issued, and ensure that the call is processed at most once.</p><p>To power this we leverage the<a href=\"https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/\"> <u>agent’s built-in state</u></a>, which can be used to persist information without reaching for another persistence store like a database or Redis, although we could absolutely do so if we wished. We can track the tool calls by their ID and capture their current status, right inside the agent process.</p>\n            <pre class=\"language-TypeScript\"><code class=\"language-TypeScript\">type ToolCallStatus = &quot;requested&quot; | &quot;approved&quot; | &quot;rejected&quot;;\n\nexport interface AgentState {\n  toolCalls: Record&lt;string, ToolCallStatus&gt;;\n}\n\nclass AIAgent extends AIChatAgent&lt;Env, AgentState&gt; {\n  initialState: AgentState = {\n    toolCalls: {},\n  };\n  \n  setToolCallStatus(toolCallId: string, status: ToolCallStatus) {\n    this.setState({\n      ...this.state,\n      toolCalls: { ...this.state.toolCalls, [toolCallId]: status },\n    });\n  } \n  // ... \n}</pre></code>\n            <p>Here, we create the initial state for the tool calls as an empty object. We also add a quick setter helper method to make interactions easier.</p><p>Next up, we need to record the tool call being made. To do so, we can use the <code>onAfterCallKnock</code> option in the <code>requireHumanInput</code> helper to capture that the tool call has been requested for the user.</p>\n            <pre class=\"language-TypeScript\"><code class=\"language-TypeScript\">const { issueCard }  = toolkit.requireHumanInput(\n  { issueCard: issueCardTool },\n  {\n    // Keep track of the tool call state once it&#039;s been sent to Knock\n    onAfterCallKnock: async (toolCall) =&gt; \n      agent.setToolCallStatus(toolCall.id, &quot;requested&quot;),\n    // ... as before\n  }\n);</pre></code>\n            <p>Finally, we then need to check the state when we’re processing the incoming webhook, and mark the tool call as approved (some code omitted for brevity).</p>\n            <pre class=\"language-TypeScript\"><code class=\"language-TypeScript\">export class AIAgent extends AIChatAgent {\n  async handleIncomingWebhook(body: any) {\n    const { toolkit } = await initializeToolkit(this);\n    const deferredToolCall = toolkit.handleMessageInteraction(body);\n    const toolCallId = result.toolCall.id;\n\n    // Make sure this is a tool call that can be processed\n    if (this.state.toolCalls[toolCallId] !== &quot;requested&quot;) {\n      return { error: &quot;Tool call is not requested&quot; };\n    }\n\n    if (result.interaction.status === &quot;approved&quot;) {\n      const toolCallResult = await toolkit.resumeToolExecution(result.toolCall);\n      this.setToolCallStatus(toolCallId, &quot;approved&quot;);\n      // ... rest as before\n    }\n  }\n}</pre></code>\n            \n          <div class=\"flex anchor relative\">\n            <h2 id=\"conclusion\">Conclusion</h2>\n            <a href=\"#conclusion\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Using the Agents SDK and Knock, it’s easy to build advanced human-in-the-loop experiences that defer tool calls.</p><p>Knock’s workflow builder and notification engine gives you building blocks to create sophisticated cross-channel messaging for your agents. You can easily create escalation flows that send messages through SMS, push, email, or Slack that respect the notification preferences of your users. Knock also gives you complete visibility into the messages your users are receiving.</p><p>The Durable Object abstraction underneath the Agents SDK means that we get a globally addressable agent process that’s easy to yield and resume back to. The persistent storage in the Durable Object means we can retain the complete chat history per-user, and any other state that’s required in the agent process to resume the agent with (like our tool calls). Finally, the serverless nature of the underlying Durable Object means we’re able to horizontally scale to support a large number of users with no effort.</p><p>If you’re looking to build your own AI Agent chat experience with a multiplayer human-in-the-loop experience, you’ll find the complete code from this guide<a href=\"https://github.com/knocklabs/ai-agent-examples/tree/main/card-issue-agent\"> <u>available in GitHub</u></a>.</p>",
		"id": "3YwK1RRHXn4kGrNazu4AKd",
		"localeList": {
			"name": "blog-english-only",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "How Knock shipped an AI Agent with human-in-the-loop capabilities with Cloudflare’s Agents SDK and Cloudflare Workers.",
		"metadata": {
			"title": "Building an AI Agent that puts humans in the loop with Knock and Cloudflare’s Agents SDK",
			"description": "How Knock shipped an AI Agent with human-in-the-loop capabilities with Cloudflare’s Agents SDK and Cloudflare Workers.",
			"imgPreview": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4QDMGATQYFYtzw9CfEpZeA/b850ebb2dd2b22fd415807c4a7a09cf2/hero-knock-cloudflare-agents.png"
		},
		"primary_author": {},
		"publicly_index": true,
		"published_at": "2025-06-03T14:00+01:00",
		"slug": "building-agents-at-knock-agents-sdk",
		"tags": [
			{
				"id": "6Foe3R8of95cWVnQwe5Toi",
				"name": "AI",
				"slug": "ai"
			},
			{
				"id": "22RkiaggH3NV4u6qyMmC42",
				"name": "Agents",
				"slug": "agents"
			},
			{
				"id": "6hbkItfupogJP3aRDAq6v8",
				"name": "Cloudflare Workers",
				"slug": "workers"
			},
			{
				"id": "5v2UZdTRX1Rw9akmhexnxs",
				"name": "Durable Objects",
				"slug": "durable-objects"
			},
			{
				"id": "3JAY3z7p7An94s6ScuSQPf",
				"name": "Developer Platform",
				"slug": "developer-platform"
			},
			{
				"id": "4HIPcb68qM0e26fIxyfzwQ",
				"name": "Developers",
				"slug": "developers"
			}
		],
		"title": "Building an AI Agent that puts humans in the loop with Knock and Cloudflare’s Agents SDK",
		"updated_at": "2025-06-11T14:09:01.698Z",
		"url": "https://blog.cloudflare.com/building-agents-at-knock-agents-sdk"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.icon_aria_label": "Search",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"search.result_stat_empty": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong>",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"search.autocomplete_title": "Insert a query. Press enter to send",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}