{
	"initialReadingTime": "11",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Nick Sullivan",
				"slug": "nick-sullivan",
				"bio": "Nick Sullivan was Head of Research (& Cryptography) at Cloudflare until 2023. He is passionate about improving security and privacy through cutting-edge research and the development of open standards.",
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/1awsFzXodRY6h5BEcWKcCE/85e0d04bb0360398b832e6476173945e/nick-sullivan.jpg",
				"location": "San Francisco",
				"website": "https://crypto.dance",
				"twitter": "@grittygrease",
				"facebook": null
			}
		],
		"excerpt": "A major part of securing a network as geographically diverse as CloudFlare’s is protecting data as it travels between datacenters. Customer data and logs are important to protect but so is all the control data that our applications use to communicate with each other. ",
		"feature_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/5LC1p6PrWu7qrgu2PA716i/92ab2a1eae4a5516c1d50c0c80a2e493/how-to-build-your-own-public-key-infrastructure.jpg",
		"featured": false,
		"html": "<p>A major part of securing a network as geographically diverse as CloudFlare’s is protecting data as it travels between datacenters. Customer data and logs are important to protect but so is all the control data that our applications use to communicate with each other. For example, our application servers need to securely communicate with our new datacenter in <a href=\"/osaka-data-center/\">Osaka, Japan</a>.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/4LLkau2uBvAD4G7wNt1wWt/1ece2f89c361b5a57f94dc5250108f7b/23390123_b6caaefc16_z.jpg\" alt=\"\" class=\"kg-image\" width=\"640\" height=\"429\" loading=\"lazy\"/>\n            \n            </figure><p><a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC BY-SA 2.0</a> <a href=\"https://www.flickr.com/photos/kk/23390123/in/photolist-34T4Z-eCaWn2-98sYER-7Hx7ig-ejcw3L-n7qDvJ-dYj3cw-ayZi8V-8qi3MQ-8vR8W5-73xSvY-ehPXNM-oaLWEs-qKGKFC-29GeC-7oEdaD-dAFKPa-az45tU-hjsKL-bikriH-dCz8na-6UKyJq-cJLzGh-drbr3g-5ru4oK-9gGswk-dU3PK3-edjQhq-d7exeW-cdBJCm-9XE9R5-62J5N-brKi7f-4uwyQL-6u3Npt-ccX3-qixk9G-2vj3k2-4DjUnW-cXXqXy-92Cgam-cv6bco-dA29Tj-87az7W-98P4W5-9AipNF-buwS46-9nKh7L-69WpZo-evqszn\">image</a> by <a href=\"https://www.flickr.com/photos/kk/\">kris krüg</a></p><p>Great security architecture requires a defense system with multiple layers of protection. As CloudFlare’s services have grown, the need to secure application-to-application communication has grown with it. As a result, we needed a simple and maintainable way to ensure that all communication between CloudFlare’s internal services stay protected, so we built one based on known and reliable protocols.</p><p>Our system of trust is based on a Public Key Infrastructure (PKI) using internally-hosted Certificate Authorities (CAs). In this post we will describe how we built our PKI, how we use it internally, and how to run your own with our open source software. This is a long post with lots of information, grab a coffee!</p><h2>Protection at the application layer</h2><p>Most reasonably complex modern web services are not made up of one monolithic application. In order to handle complex operations, an application is often split up into multiple “services” that handle different portions of the business logic or data storage. Each of these services may live on different machines or even in different datacenters.</p><p>The software stacks of large service providers are made up of many components. For CloudFlare, this includes a web application to handle user actions, a main database to maintain DNS records and user rules, a data pipeline to distribute these rules to the edge network, services for caching, a log transport pipeline, data analysis services and much, much more.</p><p>Some service-to-service communication can happen within a machine, some within a datacenter and some across a broader network like the Internet. Managing which communications should use which type of network in our evolving services is not a simple task. A single accidental configuration change could result in messages that are supposed to never leave a machine going through an untrusted connection on the Internet. The system should be designed so that these messages are secure even if they go over the wrong network.</p><h2>Enter TLS</h2><p>One approach to mitigate the risks posed by attackers is to encrypt and authenticate data in transit. Our approach is to require that all new services use an encrypted protocol, Transport Layer Security (TLS), to keep inter-service communication protected. It was a natural choice: TLS is the “S” in HTTPS and is the foundation of the encrypted web. Furthermore, modern web services and <a href=\"https://www.cloudflare.com/learning/security/api/what-is-an-api/\">APIs</a> have embraced TLS as the de-facto standard for application layer encryption. It works seamlessly with RESTful services, is supported in <a href=\"/kyoto-tycoon-secure-replication/\">Kyoto Tycoon</a>, <a href=\"http://www.postgresql.org/docs/8.3/static/libpq-ssl.html\">PostgreSQL</a>, and the Go standard library.</p><p>As we have described in <a href=\"/an-introduction-to-javascript-based-ddos/\">previous blog posts</a>, unauthenticated encryption can be foiled by <a href=\"/introducing-strict-ssl-protecting-against-a-man-in-the-middle-attack-on-origin-traffic/\">on-path attackers</a>. Encryption without authentication does not protect data in transit. For connections to be safe, each party needs to prove their identity to the other. Public key cryptography provides many mechanisms for trust, including PGP’s “web of trust” and HTTPS’s public key infrastructure (PKI) model. We chose the PKI model because of ease of use and deployment. TLS with PKI provides trusted communication.</p><h2>Be picky with your PKI</h2><p>Trust is the bedrock of secure communication. For two parties to securely exchange information, they need to know that the other party is legitimate. PKI provides just that: a mechanism for trusting identities online.</p><p>The tools that enable this are digital certificates and public key cryptography. A certificate lets a website or service prove its identity. Practically speaking, a certificate is a file with some identity information about the owner, a public key, and a signature from a certificate authority (CA). Each certificate also contains a public key. Each public key has an associated private key, which is kept securely under the certificate owner’s control. The private key can be used to create digital signatures that can be verified by the associated public key.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/4zk0sFLWqQIg6Fh9Qc5kPU/975ffd286ca5d33611a8a56f80e70229/anatomy-of-a-certificate.png\" alt=\"\" class=\"kg-image\" width=\"645\" height=\"595\" loading=\"lazy\"/>\n            \n            </figure><p>A certificate typically contains</p><ul><li><p>Information about the organization that the certificate is issued to</p></li><li><p>A public key</p></li><li><p>Information about the organization that issued the certificate</p></li><li><p>The rights granted by the issuer</p></li><li><p>The validity period for the certificate</p></li><li><p>Which hostnames the certificate is valid for</p></li><li><p>The allowed uses (client authentication, server authentication)</p></li><li><p>A digital signature by the issuer certificate’s private key</p></li></ul><p>A certificate is a powerful tool for proving your identity online. The owner of a certificate can digitally sign data, and a verifier can use the public key from the certificate to verify it. The fact that the certificate is itself digitally signed by a third party CA means that if the verifier trusts the third party, they have assurances that the certificate is legitimate. The CA can give a certificate certain rights, such as a period of time in which the identity of the certificate should be trusted.</p><p>Sometimes certificates are signed by what’s called an intermediate CA, which is itself signed by a different CA. In this case, a certificate verifier can follow the chain until they find a certificate that they trust — the root.</p><p>This chain of trust model can be very useful for the CA. It allows the root certificate’s private key to be kept offline and only used for signing intermediate certificates. Intermediate CA certificates can be shorter lived and be used to sign endpoint certificates on demand. Shorter-lived online intermediates are easier to manage and revoke if compromised.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/1mgZiSD0E5rW6KjaGEFPa0/c2e8d7024c0e790836c63641071de8e5/certificate-chain-of-trust.png\" alt=\"\" class=\"kg-image\" width=\"645\" height=\"541\" loading=\"lazy\"/>\n            \n            </figure><p>This is the same system used for HTTPS on the web. For example, cloudflare.com has a certificate signed by Comodo’s Intermediate certificate, which is in turn signed by the Comodo offline root. Browsers trust the Comodo root, and therefore also trust the intermediate and web site certificate.</p><p>This model works for the web because browsers only trust a small set of certificate authorities, who each have stringent requirements to only issue certificates after validating the ownership of a website. For internal services that are not accessed via browsers, there is *no need * to go through a third party certificate authority. Trusted certificates do not have to be from Globalsign, Comodo, Verisign or any other CA — they can be from a CA you operate yourself.</p><h2>Building your own CA</h2><p>The most painful part of getting a certificate for a website is going through the process of obtaining it. For websites, we eliminated this pain by launching <a href=\"/introducing-universal-ssl/\">Universal SSL</a>. The most painful part of running a CA is the administration. When we decided to build our internal CA, we sought to make both obtaining certificates and operating the CA painless and even fun.</p><p>The software we are using is <a href=\"https://github.com/cloudflare/cfssl\">CFSSL</a>, CloudFlare’s open source PKI toolkit. This tool was open sourced last year and has all the capabilities needed to run a certificate authority. Although CFSSL was built for an internal CA, it’s robust enough to be use a publicly trusted CA; in fact, the <a href=\"https://letsencrypt.org\">Let’s Encrypt</a> project is using CFSSL as a core part of their CA infrastructure.</p><h3>Key protection</h3><p>To run a CA, you need the CA certificate and corresponding private key. This private key is extremely sensitive. Any person who knows the value of the key can act as the CA and issue certificates. Browser-trusted certificate authorities are required to keep their private keys inside of specialized hardware known as Hardware Security Modules (HSMs). The requirements for protecting private keys for corporate infrastructures are not necessarily as stringent, so we provided several mechanisms to protect keys.</p><p>CFSSL supports three different modes of protection for private keys:</p><ol><li><p><i>Hardware Security Module (HSM)</i>CFSSL allows the CA server to use an HSM to compute digital signatures. Most HSMs use an interface called PKCS#11 to interact with them, and CFSSL natively supports this interface. Using an HSM ensures that private keys do not live in memory and it provides tamper protection against physical adversaries.</p></li><li><p><i>Red October</i>Private Keys can be encrypted using <a href=\"/red-october-cloudflares-open-source-implementation-of-the-two-man-rule/\">Red October</a> (another open source CloudFlare project). A key protected with Red October can only be decrypted with the permission of multiple key owners. In order to use CFSSL with a Red October key, the key owners need to authorize the use of the private key. This ensures that the CA key is never unencrypted on disk, in source control, or in configuration management. Note: Red October support in CFSSL is experimental and subject to change.</p></li><li><p><i>Plaintext</i>CFSSL accepts plain unencrypted private keys. This works well when the private key is generated on the machine running CFSSL or by another program. If the machine that is running the CA is highly secure, this mode is a compromise between security, cost, and usability. This is also useful in development mode, allowing users to test changes to their infrastructure designs.</p></li></ol><p>Next I’ll show you how to quickly configure an internal CA using plaintext private keys. Note: The following expects <a href=\"https://github.com/cloudflare/cfssl#readme\">CFSSL to be installed</a>.</p><h3>Generating a CA key and certificate</h3><p>To start, you need some information about what metadata you want to include in your certificate. Start by creating a file called <code>csr_ca.json</code> containing this basic information (feel free to fill in your own organization&#39;s details):</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">{\n  &quot;CN&quot;: &quot;My Awesome CA&quot;,\n  &quot;key&quot;: {\n    &quot;algo&quot;: &quot;rsa&quot;,\n    &quot;size&quot;: 2048\n  },\n    &quot;names&quot;: [\n       {\n         &quot;C&quot;: &quot;US&quot;,\n         &quot;L&quot;: &quot;San Francisco&quot;,\n         &quot;O&quot;: &quot;My Awesome Company&quot;,\n         &quot;OU&quot;: &quot;CA Services&quot;,\n         &quot;ST&quot;: &quot;California&quot;\n       }\n    ]\n}</pre></code>\n            <p>With this you can create your CA with a single call&quot;<code>$ cfssl gencert -initca csr_ca.json | cfssljson -bare ca</code></p><p>This generates the two files you need to start your CA:</p><ul><li><p><code>ca-key.pem</code>: your private key</p></li><li><p><code>ca.pem</code>: your certificate</p></li><li><p><code>ca.csr</code>: your certificate signing request (needed to get your CA cross-signed by another CA)</p></li></ul><p>The key and certificate are the bare minimum you need to start running a CA.</p><h3>Policy</h3><p>Once the CA certificate and key are created, the CA software needs to know what kind of certificates it will issue. This is determined in the CFSSL configuration file’s signing policy section.</p><p>Here’s an example of a simple policy for a CA that can issue certificates that are valid for a year and can be used for server authentication.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">config_ca.json\n{\n  &quot;signing&quot;: {\n    &quot;default&quot;: {\n      &quot;auth_key&quot;: &quot;key1&quot;,\n      &quot;expiry&quot;: &quot;8760h&quot;,\n      &quot;usages&quot;: [\n         &quot;signing&quot;,\n         &quot;key encipherment&quot;,\n         &quot;server auth&quot;\n       ]\n     }\n  },\n  &quot;auth_keys&quot;: {\n    &quot;key1&quot;: {\n      &quot;key&quot;: &lt;16 byte hex API key here&gt;,\n      &quot;type&quot;: &quot;standard&quot;\n    }\n  }\n}</pre></code>\n            <p>We also added an authentication key to this signing policy. This authentication key should be randomly generated and kept private. The API key is a basic authentication mechanism that prevents unauthorized parties from requesting certificates. There are several other features you can use for the CA (subject name allowlisting, etc.), <a href=\"https://github.com/cloudflare/cfssl/tree/master/doc\">CFSSL documentation</a> for more information.</p><p>To run the service, call<code>$ cfssl serve -ca-key ca-key.pem -ca ca.pem -config config_ca.json</code></p><p>This opens up a CA service listening on port 8888.</p><h3>Issuing certificates</h3><p>Certificate authorities do not just create certificates out of a private key and thin air, they need a public key and metadata to populate the certificate’s data fields. This information is typically communicated to a CA via a certificate signing request (CSR).</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/1XFNOUGDbNZ98c8QiaJ8hA/f66994b74341c8fc824eb1b15a3cb944/illustrations-ssl-blog-june-2015-03.png\" alt=\"\" class=\"kg-image\" width=\"2688\" height=\"1080\" loading=\"lazy\"/>\n            \n            </figure><p>A CSR is very similar in structure to a certificate. The CSR contains:</p><ul><li><p>Information about the organization that is requesting the certificate</p></li><li><p>A public key</p></li><li><p>A digital signature by the requestor’s private key</p></li></ul><p>Given a CSR, a certificate authority can create a certificate. First, it verifies that the requestor has control over the associated private key. It does this by checking the CSR’s signature. Then the CA will check to see if the requesting party should be given a certificate and which domains/IPs it should be valid for. This can be done with a database lookup or through a registration authority. If everything checks out, the CA uses its private key to create and sign the certificate to send back to the requestor.</p><h3>Requesting Certificates</h3><p>Let’s say you have CFSSL set up as CA as described above and it’s running on a server called “ca1.mysite.com” with an authentication API key. How do you get this CA to issue a certificate? CFSSL provides two commands to help with that: <code>gencert</code> and <code>sign</code>. They are available as JSON API endpoints or command line options.</p><p>The <code>gencert</code> command will automatically handle the whole certificate generation process. It will create your private key, generate a CSR, send the CSR to the CA to be signed and return your signed certificate.</p><p>There are two configuration files needed for this. One to tell the local CFSSL client where the CA is and how to authenticate the request, and a CSR configuration used to populate the CSR.</p><p>Here’s an example for creating a certificate for a generic database server, db1.mysite.com.</p><p><code>csr_client.json</code></p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">{\n  &quot;hosts&quot;: [\n    \t&quot;db1.mysite.com&quot;\n  ],\n  &quot;key&quot;: {\n    &quot;algo&quot;: &quot;rsa&quot;,\n    &quot;size&quot;: 2048\n  },\n  &quot;names&quot;: [\n    {\n      &quot;C&quot;: &quot;US&quot;,\n      &quot;L&quot;: &quot;San Francisco&quot;,\n      &quot;O&quot;: “My Awesome Company&quot;,\n      &quot;OU&quot;: “Data Services&quot;,\n      &quot;ST&quot;: &quot;California&quot;\n    }\n  ]\n}</pre></code>\n            <p><code>config_client.json</code></p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">{\n  &quot;signing&quot;: {\n    &quot;default&quot;: {\n      &quot;auth_key&quot;: &quot;key1&quot;,\n      &quot;remote&quot;: &quot;caserver&quot;\n    }\n  },\n  &quot;auth_keys&quot;: {\n    &quot;key1&quot;: {\n    &quot;key&quot;: &lt;16 byte hex API key here&gt;,\n    &quot;type&quot;: &quot;standard&quot;\n    }\n  },\n  &quot;remotes&quot;: {\n    &quot;caserver&quot;: “ca1.mysite.com:8888&quot;\n  }\n}</pre></code>\n            <p>With these two configuration files set, you can create your certificate.<code>$ cfssl gencert -config config_client.json csr_client.json | cfssljson -bare db</code></p><p>This results in three files:</p><ul><li><p><code>db-key.pem</code>: your private key</p></li><li><p><code>db.pem</code>: your certificate</p></li><li><p><code>db.csr</code>: your CSR</p></li></ul><p>The CSR can be resubmitted to the CA to be signed again at any point with the <code>sign</code> command</p><p><code>$ cfssl sign -config config_client.json db.csr | cfssljson -bare db-new</code></p><p>resulting in:</p><ul><li><p><code>db-new.pem</code>: your re-signed certificate</p></li></ul><p>These two commands let you easily and conveniently set up a private PKI. As a startup or a growing business moving to a service-oriented or even a microservice architecture, having a PKI can be very convenient. Next we’ll describe how CloudFlare set up its own internal PKI to help make its services encrypted by default.</p><h2>Using a PKI for services</h2><p>So now you have a complex set of services that can all speak TLS, and a central certificate authority server that can issue certificates. What’s next? Getting certificates and keys for the applications. There are several ways to do this including a centrally managed way and a distributed way.</p><h3>Centralized distribution vs on demand</h3><p>One way to create certificates and keys for your applications is to create them all on a central provisioning server and then send them out to each of the servers. In this model, a central server creates certificates and keys and sends them over a secure tunnel to the application servers.</p><p>This model creates a sort of chicken and egg problem. How do you transport private keys if you need those private keys to encrypt your transport?</p><p>A distributed key management model fits better with the way modern services are typically deployed and run. The trick is creating the private keys directly in the application server. At install or run time, a service creates its own private key and sends a request to a certificate authority to issue a certificate. This can be repeated on demand if the current certificate is close to expiring.</p><p>For example, many companies are starting to use Docker, or other lightweight container technologies, to encapsulate and run individual services. Under load, services can be scaled up by automatically running new containers. In a centralized distribution model, certificates and keys for each container need to be created before the containers are deployed.</p><p>In the centralized distribution model, the provisioning service needs to create and manage a key and certificate for each service. Keeping this sort of central database in a complex and dynamic topology seems like the wrong approach. It would be preferable if the CA itself was stateless and generated a set of logs.</p><p>The idea that keys need to be transported to their destination instead of generated locally is also troubling. Transporting private keys introduces an unnecessary risk to the system. When a new service comes into being, it should generate its key locally and request a certificate for use.</p><h3>Trust across services</h3><p>Internal services need to trust each other. Browsers validate website certificates by checking the signature on the certificate and checking the hostname against the list of Subject Alternative Names (SANs) in the certificate. This type of explicit check is useful, but it has a record of <a href=\"https://cwe.mitre.org/data/definitions/297.html\">not working as expected</a>. Another way for services to trust each other is an implicit check based on per-service CAs.</p><p>The idea is simple: use a different CA for each set of services. Issue all database certificates from a database CA and all API servers from an API server CA.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/25QdARnmhs56cQyEzRWRZs/30270f0baab54534f5bc99a0503e5055/provisioning-app-certificates.png\" alt=\"\" class=\"kg-image\" width=\"645\" height=\"585\" loading=\"lazy\"/>\n            \n            </figure><p>When setting these services up to talk to each other with mutual TLS authentication configure the trust stores as follows:</p><ul><li><p>API server only trusts DB CA</p></li><li><p>DB only trusts API CA</p></li></ul><p>This approach is less fine-grained than an explicit check against a SAN, but it is more robust and easier to manage on the CA policy side. With an implicit trust system in place, you can guarantee that services of type A can only communicate with services of type B.</p><p>The following diagram describes how two applications can trust each other with mutually authenticated TLS.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/6zHWhhn4tWw94Y9yGmBFjy/bb64f835e62cc3fb56a8c738cc3b6112/service-to-service-communication.png\" alt=\"\" class=\"kg-image\" width=\"645\" height=\"837\" loading=\"lazy\"/>\n            \n            </figure><p>In this diagram, the API server trusts the DB CA (in red). It will therefore only accept certificates that are signed by the DB CA (i.e. with a red ribbon). Conversely, the database server only accepts certificates with a signature from the API CA (orange ribbon). To establish a trusted connection, each party sends a key share to the other, signed with their certificate’s private key. The key shares are combined to create a session key, with which both parties can encrypt their data. The chain of verification from key share to certificate to CA assure that the other party is authentic.</p><p>Establishing a mutually authenticated trusted tunnel between services prevents attackers from accessing or modifying data in transit and causing havoc on your services. With a strong PKI in place, every service can communicate securely and confidentially over any network, even the Internet.</p><h2>Using a PKI for remote services</h2><p>Internal PKIs are very flexible and can be used to issue certificates to third parties who are integrating with your network. For example, CloudFlare has a service called <a href=\"https://www.cloudflare.com/railgun\">Railgun</a> that can be used to optimize connections between CloudFlare and an origin server. Communication between Railgun and CloudFlare is done over an encrypted and authenticated channel using certificates from a CloudFlare certificate authority.</p><p>This ensures that data is secure in transit. When a new Railgun instance is set up on the origin server, it creates a private key and sends a CSR to CloudFlare, which then issues the appropriate certificate. The Railgun server keeps the private key in memory and deletes it when it shuts down, preventing other services from getting access to it.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/6MzHk6TL9t4sBWgQz4kEQ6/dce627ac9713100d0a0fdd7638eea0f2/illustrations-ssl-blog-june-2015-02-1.png\" alt=\"\" class=\"kg-image\" width=\"645\" height=\"263\" loading=\"lazy\"/>\n            \n            </figure><p>This model works great for not only Railgun, but several other initiatives at CloudFlare such as the <a href=\"/universal-ssl-encryption-all-the-way-to-the-origin-for-free/\">Origin CA</a> and <a href=\"/keyless-ssl-the-nitty-gritty-technical-details/\">Keyless SSL</a>.</p><h2>Conclusion</h2><p>Securing data at the application level is an important step for securing a distributed systems architecture, but is only truly effective with a strong PKI in place.</p>",
		"id": "71loFFBcz7GMVazjFt5flh",
		"localeList": {
			"name": "How to build your own public key infrastructure Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": null,
		"metadata": {
			"imgPreview": ""
		},
		"primary_author": {},
		"published_at": "2015-06-24T14:57:30.000+01:00",
		"slug": "how-to-build-your-own-public-key-infrastructure",
		"tags": [
			{
				"id": "56vA0Z6hqev6QaJBQmO2J8",
				"name": "TLS",
				"slug": "tls"
			},
			{
				"id": "5US4l4wdDysuDpZ4ktL3yP",
				"name": "HTTPS",
				"slug": "https"
			},
			{
				"id": "3q9cXaNFwBlNyWjukkAveR",
				"name": "Encryption",
				"slug": "encryption"
			},
			{
				"id": "5mF77yuu0VzwzCJToktxrf",
				"name": "Certificate Authority",
				"slug": "certificate-authority"
			},
			{
				"id": "1HblPaFreDjetoJDJPjTAi",
				"name": "SSL",
				"slug": "ssl"
			},
			{
				"id": "69yyDmudu4iDKKgO1DdrBm",
				"name": "CFSSL",
				"slug": "cfssl"
			},
			{
				"id": "6Mp7ouACN2rT3YjL1xaXJx",
				"name": "Security",
				"slug": "security"
			}
		],
		"title": "How to build your own public key infrastructure",
		"updated_at": "2024-08-27T02:38:58.939Z",
		"url": "https://blog.cloudflare.com/how-to-build-your-own-public-key-infrastructure"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.blurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}