<div class="mb2 gray5">4 min read</div>
<div class="post-content lh-copy gray1">
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/4xLEZHTIoo7Jt24CSWtqk8/ca7d7704b9c9006409ce6f2e2fd354d3/image2-4.png" alt="Experiment with post-quantum cryptography today" class="kg-image" width="1600" height="900" loading="lazy">

	</figure>
	<p>Practically all data sent over the Internet today is at <a href="https://blog.cloudflare.com/the-quantum-menace">risk</a> in the future if a sufficiently large and stable quantum computer is created. Anyone who captures data now could decrypt it.</p>
	<p>Luckily, there is a solution: we can switch to so-called <i>post-quantum (</i><b><i>PQ</i></b><i>) cryptography</i>, which is designed to be secure against attacks of quantum computers. After a six-year worldwide selection process, in July 2022, NIST <a href="https://blog.cloudflare.com/nist-post-quantum-surprise">announced</a> they will standardize <a href="https://pq-crystals.org/kyber/index.shtml">Kyber</a>, a post-quantum key agreement scheme. The standard will be ready in 2024, but we want to help drive the adoption of post-quantum cryptography.</p>
	<p>Today we have added support for the <i>X25519Kyber512Draft00</i> and <i>X25519Kyber768Draft00</i> hybrid post-quantum key agreements to a number of test domains, including <a href="https://pq.cloudflareresearch.com">pq.cloudflareresearch.com</a>.</p>
	<p><i>Do you want to experiment with post-quantum on your test website for free? Mail</i> <a href="mailto:ask-research@cloudflare.com"><i>ask-research@cloudflare.com</i></a> <i>to enroll your test website, but read the fine-print below.</i></p>
	<h2>What does it mean to enable post-quantum on your website?</h2>
	<p>If you enroll your website to the post-quantum beta, we will add support for these two extra key agreements <b>alongside</b> the existing classical encryption schemes such as X25519. If your browser doesn’t support these post-quantum key agreements (and none at the time of writing do), then your browser will continue working with a classically secure, but not quantum-resistant, connection.</p>
	<h3>Then how to test it?</h3>
	<p>We have open-sourced a fork of <a href="https://github.com/cloudflare/boringssl-pq">BoringSSL</a> and <a href="https://github.com/cloudflare/go">Go</a> that has support for these post-quantum key agreements. With those and an enrolled test domain, you can check how your application performs with post-quantum key exchanges. We are working on support for more libraries and languages.</p>
	<h3>What to look for?</h3>
	<p>Kyber and classical key agreements such as X25519 have different performance characteristics: Kyber requires less computation, but has bigger keys and requires a bit more RAM to compute. It could very well make the connection faster if used on its own.</p>
	<p>We are not using Kyber on its own though, but are using <b>hybrids</b>. That means we are doing both an X25519 <i>and</i> Kyber key agreement such that the connection is still classically secure if either is broken. That also means that connections will be a bit slower. In our experiments, the difference is <a href="https://blog.cloudflare.com/the-tls-post-quantum-experiment">very</a> <a href="https://blog.cloudflare.com/post-quantumify-cloudflare">small</a>, but it’s best to check for yourself.</p>
	<h2>The fine-print</h2>
	<p>Cloudflare’s post-quantum cryptography support is a beta service for experimental use only. Enabling post-quantum on your website will subject the website to Cloudflare’s Beta Services terms and will impact other Cloudflare services on the website as described below.</p>
	<h3>No stability or support guarantees</h3>
	<p>Over the coming months, both Kyber and the way it’s integrated into <a href="https://www.cloudflare.com/learning/ssl/transport-layer-security-tls">TLS</a> will change for several reasons, including:</p>
	<ol>
		<li>
			<p>Kyber will see small, but backward-incompatible changes in the coming months.</p>
		</li>
		<li>
			<p>We want to be compatible with other early adopters and will change our integration accordingly.</p>
		</li>
		<li>
			<p>As, together with the cryptography community, we find issues, we will add workarounds in our integration.</p>
		</li>
	</ol>
	<p>We will update our forks accordingly, but cannot guarantee any long-term stability or continued support. PQ support may become unavailable at any moment. We will post updates on <a href="https://pq.cloudflareresearch.com">pq.cloudflareresearch.com</a>.</p>
	<h3>Features in enrolled domains</h3>
	<p>For the moment, we are running enrolled zones on a slightly different infrastructure for which not all features, notably QUIC, are available.</p>
	<p>With that out of the way, it’s…</p>
	<h2>Demo time!</h2>
	<h3>BoringSSL</h3>
	<p>With the following commands build our <a href="https://github.com/cloudflare/boringssl-pq">fork of BoringSSL</a> and create a TLS connection with pq.cloudflareresearch.com using the compiled <code>bssl</code> tool. Note that we do not enable the post-quantum key agreements by default, so you have to pass the <code>-curves</code> flag.</p>
	<pre class="language-bash"><code class="language-bash">$ git clone https://github.com/cloudflare/boringssl-pq
[snip]
$ cd boringssl-pq &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; cmake .. -GNinja &amp;&amp; ninja 
[snip]
$ ./tool/bssl client -connect pq.cloudflareresearch.com -server-name pq.cloudflareresearch.com -curves Xyber512D00
	Connecting to [2606:4700:7::a29f:8a55]:443
Connected.
  Version: TLSv1.3
  Resumed session: no
  Cipher: TLS_AES_128_GCM_SHA256
  ECDHE curve: X25519Kyber512Draft00
  Signature algorithm: ecdsa_secp256r1_sha256
  Secure renegotiation: yes
  Extended master secret: yes
  Next protocol negotiated: 
  ALPN protocol: 
  OCSP staple: no
  SCT list: no
  Early data: no
  Encrypted ClientHello: no
  Cert subject: CN = *.pq.cloudflareresearch.com
  Cert issuer: C = US, O = Let's Encrypt, CN = E1</code></pre>
	<h3>Go</h3>
	<p>Our <a href="https://github.com/cloudflare/go">Go fork</a> doesn’t enable the post-quantum key agreement by default. The following simple Go program enables PQ by default for the http package and GETs pq.cloudflareresearch.com.</p>
	<pre class="language-go"><code class="language-go">package main

import (
    "context"
    "crypto/tls"
    "fmt"
    "net/http"
)

func main() {
    req, err := http.NewRequestWithContext(
        context.WithValue(
            context.Background(),
            tls.CFEventHandlerContextKey{},
            func(ev tls.CFEvent) {
                switch e := ev.(type) {
                case tls.CFEventTLS13HRR:
                    fmt.Printf("HelloRetryRequest\n")
                case tls.CFEventTLS13NegotiatedKEX:
                    switch e.KEX {
                    case tls.X25519Kyber512Draft00:
                        fmt.Printf("Used X25519Kyber512Draft00\n")
                    default:
                        fmt.Printf("Used %d\n", e.KEX)
                    }
                }
            },
        ),
        "GET",
        "https://pq.cloudflareresearch.com",
        nil,
    )
    if err != nil {
        panic(err)
    }

    http.DefaultTransport.(*http.Transport).TLSClientConfig = &amp;tls.Config{
        CurvePreferences: []tls.CurveID{tls.X25519Kyber512Draft00, tls.X25519},
    }

    if _, err = (&amp;http.Client{}).Do(req); err != nil {
        fmt.Println(err)
    }
}</code></pre>
	<p>To run we need to compile our <a href="https://github.com/cloudflare/go">Go fork</a>:</p>
	<pre class="language-bash"><code class="language-bash">$ git clone https://github.com/cloudflare/go
[snip]
$ cd go/src &amp;&amp; ./all.bash
[snip]
$ ../bin/go run path/to/example.go
Used X25519Kyber512Draft00</code></pre>
	<h3>On the wire</h3>
	<p>So what does this look like on the wire? With <a href="https://www.wireshark.org">Wireshark</a> we can capture the packet flow. First a non-post quantum HTTP/2 connection with X25519:</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/4xAkcteIQZp4rEkXNhJpEb/ae34924fccaa74cd1da8d82a541a23d4/image1-8.png" alt="" class="kg-image" width="1999" height="1694" loading="lazy">

	</figure>
	<p>This is a normal <a href="https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake">TLS 1.3 handshake</a>: the client sends a ClientHello with an X25519 keyshare, which fits in a single packet. In return, the server sends its own 32 byte X25519 keyshare. It also sends various other messages, such as the certificate chain, which requires two packets in total.</p>
	<p>Let’s check out Kyber:</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/4tczvgQiEaYXtanEjGy6Wb/dacfafd93383dd227c4d61fe41e8ddb6/image3-2.png" alt="" class="kg-image" width="1999" height="1694" loading="lazy">

	</figure>
	<p>As you can see the ClientHello is a bit bigger, but still fits within a single packet. The response takes three packets now, instead of two, because of the larger server keyshare.</p>
	<h2>Under the hood</h2>
	<p>Want to add client support yourself? We are using a <a href="https://www.ietf.org/archive/id/draft-ietf-tls-hybrid-design-04.txt">hybrid</a> of <a href="https://datatracker.ietf.org/doc/html/rfc7748">X25519</a> and Kyber <a href="https://pq-crystals.org/kyber/data/kyber-specification-round3-20210804.pdf">version 3.02</a>. We are writing out the details of the latter in <a href="https://github.com/bwesterb/draft-schwabe-cfrg-kyber">version 00 of this CRFG IETF draft</a>, hence the name. We are using TLS <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-8">group identifiers</a> <code>0xfe30</code> and <code>0xfe31</code> for <i>X25519Kyber512Draft00</i> and <i>X25519Kyber768Draft00</i> respectively.</p>
	<p>There are some differences between our Go and BoringSSL forks that are interesting to compare.</p>
	<ul>
		<li>
			<p>Our <a href="https://github.com/cloudflare/go">Go fork</a> uses our fast <a href="https://github.com/cloudflare/circl/tree/main/kem/kyber">AVX2 optimized implementation of Kyber</a> from <a href="https://blog.cloudflare.com/introducing-circl">CIRCL</a>. In contrast, our BoringSSL fork uses the simpler <a href="https://github.com/pq-crystals/kyber/tree/master/ref">portable reference implementation</a>. Without the AVX2 optimisations it’s easier to evaluate. The downside is that it’s slower. Don’t be mistaken: it is still very fast, but you can check yourself.</p>
		</li>
		<li>
			<p>Our Go fork only sends one keyshare. If the server doesn’t support it, it will respond with a HelloRetryRequest message and the client will fallback to one the server does support. This adds a roundtrip.Our BoringSSL fork, on the other hand, will send two keyshares: the post-quantum hybrid and a classical one (if a classical key agreement is still enabled). If the server doesn’t recognize the first, it will be able to use the second. In this way we avoid a roundtrip if the server does not support the post-quantum key agreement.</p>
		</li>
	</ul>
	<h2>Looking ahead</h2>
	<p>The quantum future is here. In the coming years the Internet will move to post-quantum cryptography. Today we are offering our customers the tools to get a headstart and test post-quantum key agreements. We love to hear your feedback: e-mail it to <a href="mailto:ask-research@cloudflare.com">ask-research@cloudflare.com</a>.</p>
	<p>This is just a small, but important first step. We will continue our efforts to move towards a secure and private quantum-secure Internet. Much more to come — watch this space.</p>
</div>