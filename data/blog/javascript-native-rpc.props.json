{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "9",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Kenton Varda",
				"slug": "kenton-varda",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/1FFs4T2j1RyvxasKOkkdtP/15df5db7be969ea8a89e68491f6f67f6/kenton-varda.jpg",
				"location": null,
				"website": null,
				"twitter": "@kentonvarda",
				"facebook": null
			}
		],
		"excerpt": "Cloudflare Workers now features a built-in RPC (Remote Procedure Call) system for use in Worker-to-Worker and Worker-to-Durable Object communication, with absolutely minimal boilerplate. We've designed an RPC system so expressive that calling a remote service can feel like using a library",
		"feature_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/7izSj6onMLY7ATpxblm17r/121a08c71291d14d162858b750d46025/javascript-native-rpc.png",
		"featured": false,
		"html": "\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/5MWuJSbUVoY5MZTRFmRd9i/b7f7420b3ed12f299c157d66b22c7f89/image2-12.png\" alt=\"We've added JavaScript-native RPC to Cloudflare Workers\" class=\"kg-image\" width=\"1999\" height=\"1125\" loading=\"lazy\"/>\n            \n            </figure><p>Cloudflare Workers now features a built-in RPC (Remote Procedure Call) system enabling seamless Worker-to-Worker and Worker-to-Durable Object communication, with almost no boilerplate. You just define a class:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">export class MyService extends WorkerEntrypoint {\n  sum(a, b) {\n    return a + b;\n  }\n}</pre></code>\n            <p>And then you call it:</p>\n            <pre class=\"language-java\"><code class=\"language-java\">let three = await env.MY_SERVICE.sum(1, 2);</pre></code>\n            <p>No schemas. No routers. Just define methods of a class. Then call them. That&#39;s it.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"but-thats-not-it\">But that's not it</h2>\n            <a href=\"#but-thats-not-it\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>This isn&#39;t just any old RPC. We&#39;ve designed an RPC system so expressive that calling a remote service can feel like using a library – without any need to actually import a library! This is important not just for ease of use, but also security: fewer dependencies means fewer critical security updates and less exposure to supply-chain attacks.</p><p>To this end, here are some of the features of Workers RPC:</p><ul><li><p>For starters, you can pass <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types\"><b>Structured Clonable</b></a> <b>types</b> as the params or return value of an RPC. (That means that, unlike JSON, Dates just work, and you can even have cycles.)</p></li><li><p>You can additionally pass <b>functions</b> in the params or return value of other functions. When the other side calls the function you passed to it, they make a new RPC back to you.</p></li><li><p>Similarly, you can pass <b>objects with methods</b>. Method calls become further RPCs.</p></li><li><p>RPC to another Worker (over a Service Binding) usually does not even cross a network. In fact, the other Worker usually runs in the very same thread as the caller, <b>reducing latency to zero</b>. Performance-wise, it’s almost as fast as an actual function call.</p></li><li><p>When RPC does cross a network (e.g. to a Durable Object), you can invoke a method and then speculatively invoke further methods on the result in a <b>single network round trip</b>.</p></li><li><p>You can send a <b>byte stream over RPC</b>, and the system will automatically stream the bytes with proper flow control.</p></li><li><p>All of this is <i>secure</i>, based on the <b>object-capability model</b>.</p></li><li><p>The <a href=\"https://github.com/cloudflare/workerd/blob/03629a6553751d3614a8b91926e380213e100d94/src/workerd/io/worker-interface.capnp#L302\">protocol</a> and <a href=\"https://github.com/cloudflare/workerd/blob/03629a6553751d3614a8b91926e380213e100d94/src/workerd/api/worker-rpc.c++\">implementation</a> are fully open source as part of <a href=\"https://github.com/cloudflare/workerd/\">workerd</a>.</p></li></ul><p>Workers RPC is a JavaScript-native RPC system. Under the hood, it is built on <a href=\"https://capnproto.org/rpc.html\">Cap&#39;n Proto</a>. However, unlike Cap&#39;n Proto, Workers RPC does not require you to write a schema. (Of course, you can use TypeScript if you like, and we provide tools to help with this.)</p><p>In general, Workers RPC is designed to &quot;just work&quot; using idiomatic JavaScript code, so you shouldn&#39;t have to spend too much time looking at docs. We&#39;ll give you an overview in this blog post. But if you want to understand the full feature set, <a href=\"https://developers.cloudflare.com/workers/runtime-apis/rpc/\">check out the documentation</a>.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"why-rpc-and-what-is-rpc-anyway\">Why RPC? (And what is RPC anyway?)</h2>\n            <a href=\"#why-rpc-and-what-is-rpc-anyway\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Remote Procedure Calls (RPC) are a way of expressing communications between two programs over a network. Without RPC, you might communicate using a protocol like HTTP. With HTTP, though, you must format and parse your communications as an HTTP request and response, perhaps designed in <a href=\"https://en.wikipedia.org/wiki/REST\">REST</a> style. RPC systems try to make communications look like a regular function call instead, as if you were calling a library rather than a remote service. The RPC system provides a &quot;stub&quot; object on the client side which stands in for the real server-side object. When a method is called on the stub, the RPC system figures out how to serialize and transmit the parameters to the server, invoke the method on the server, and then transmit the return value back.</p><p>The merits of RPC have been subject to a great deal of debate. RPC is often accused of committing many of the <a href=\"https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing\">fallacies of distributed computing</a>.</p><p>But this reputation is outdated. When RPC was first invented some 40 years ago, async programming barely existed. We did not have Promises, much less async and await. Early RPC was synchronous: calls would block the calling thread waiting for a reply. At best, latency made the program slow. At worst, network failures would hang or crash the program. No wonder it was deemed &quot;broken&quot;.</p><p>Things are different today. We have Promise and async and await, and we can throw exceptions on network failures. We even understand how RPCs can be pipelined so that a chain of calls takes only one network round trip. Many large distributed systems you likely use every day are built on RPC. It works.</p><p>The fact is, RPC fits the programming model we&#39;re used to. Every programmer is trained to think in terms of APIs composed of function calls, not in terms of byte stream protocols nor even REST. Using RPC frees you from the need to constantly translate between mental models, allowing you to move faster.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"example-authentication-service\">Example: Authentication Service</h2>\n            <a href=\"#example-authentication-service\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Here&#39;s a common scenario: You have one Worker that implements an application, and another Worker that is responsible for authenticating user credentials. The app Worker needs to call the auth Worker on each request to check the user&#39;s cookie.</p><p>This example uses a <b>Service Binding</b>, which is a way of configuring one Worker with a private channel to talk to another, without going through a public URL. Here, we have an application Worker that has been configured with a service binding to the Auth worker.</p><p>Before RPC, all communications between Workers needed to use HTTP. So, you might write code like this:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">// OLD STYLE: HTTP-based service bindings.\nexport default {\n  async fetch(req, env, ctx) {\n    // Call the auth service to authenticate the user&#039;s cookie.\n    // We send it an HTTP request using a service binding.\n\n    // Construct a JSON request to the auth service.\n    let authRequest = {\n      cookie: req.headers.get(&quot;Cookie&quot;)\n    };\n\n    // Send it to env.AUTH_SERVICE, which is our service binding\n    // to the auth worker.\n    let resp = await env.AUTH_SERVICE.fetch(\n        &quot;https://auth/check-cookie&quot;, {\n      method: &quot;POST&quot;,\n      headers: {\n        &quot;Content-Type&quot;: &quot;application/json; charset=utf-8&quot;,\n      },\n      body: JSON.stringify(authRequest)\n    });\n\n    if (!resp.ok) {\n      return new Response(&quot;Internal Server Error&quot;, {status: 500});\n    }\n\n    // Parse the JSON result.\n    let authResult = await resp.json();\n\n    // Use the result.\n    if (!authResult.authorized) {\n      return new Response(&quot;Not authorized&quot;, {status: 403});\n    }\n    let username = authResult.username;\n\n    return new Response(`Hello, ${username}!`);\n  }\n}</pre></code>\n            <p>Meanwhile, your auth server might look like:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">// OLD STYLE: HTTP-based auth server.\nexport default {\n  async fetch(req, env, ctx) {\n    // Parse URL to decide what endpoint is being called.\n    let url = new URL(req.url);\n    if (url.pathname == &quot;/check-cookie&quot;) {\n      // Parse the request.\n      let authRequest = await req.json();\n\n      // Look up cookie in Workers KV.\n      let cookieInfo = await env.COOKIE_MAP.get(\n          hash(authRequest.cookie), &quot;json&quot;);\n\n      // Construct the response.\n      let result;\n      if (cookieInfo) {\n        result = {\n          authorized: true,\n          username: cookieInfo.username\n        };\n      } else {\n        result = { authorized: false };\n      }\n\n      return Response.json(result);\n    } else {\n      return new Response(&quot;Not found&quot;, {status: 404});\n    }\n  }\n}</pre></code>\n            <p>This code has a lot of boilerplate involved in setting up an HTTP request to the auth service. With RPC, we can instead express this as a function call:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">// NEW STYLE: RPC-based service bindings\nexport default {\n  async fetch(req, env, ctx) {\n    // Call the auth service to authenticate the user&#039;s cookie.\n    // We invoke it using a service binding.\n    let authResult = await env.AUTH_SERVICE.checkCookie(\n        req.headers.get(&quot;Cookie&quot;));\n\n    // Use the result.\n    if (!authResult.authorized) {\n      return new Response(&quot;Not authorized&quot;, {status: 403});\n    }\n    let username = authResult.username;\n\n    return new Response(`Hello, ${username}!`);\n  }\n}</pre></code>\n            <p>And the server side becomes:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">// NEW STYLE: RPC-based auth server.\nimport { WorkerEntrypoint } from &quot;cloudflare:workers&quot;;\n\nexport class AuthService extends WorkerEntrypoint {\n  async checkCookie(cookie) {\n    // Look up cookie in Workers KV.\n    let cookieInfo = await this.env.COOKIE_MAP.get(\n        hash(cookie), &quot;json&quot;);\n\n    // Return result.\n    if (cookieInfo) {\n      return {\n        authorized: true,\n        username: cookieInfo.username\n      };\n    } else {\n      return { authorized: false };\n    }\n  }\n}</pre></code>\n            <p>This is a pretty nice simplification… but we can do much more!</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"lets-get-fancy-or-should-i-say-classy\">Let's get fancy! Or should I say… classy?</h3>\n            <a href=\"#lets-get-fancy-or-should-i-say-classy\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>Let&#39;s say we want our auth service to do a little more. Instead of just checking cookies, it provides a whole API around user accounts. In particular, it should let you:</p><ul><li><p>Get or update the user&#39;s profile info.</p></li><li><p>Send the user an email notification.</p></li><li><p>Append to the user&#39;s activity log.</p></li></ul><p>But, these operations should only be allowed after presenting the user&#39;s credentials.</p><p>Here&#39;s what the server might look like:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">import { WorkerEntrypoint, RpcTarget } from &quot;cloudflare:workers&quot;;\n\n// `User` is an RPC interface to perform operations on a particular\n// user. This class is NOT exported as an entrypoint; it must be\n// received as the result of the checkCookie() RPC.\nclass User extends RpcTarget {\n  constructor(uid, env) {\n    super();\n\n    // Note: Instance members like these are NOT exposed over RPC.\n    // Only class (prototype) methods and properties are exposed.\n    this.uid = uid;\n    this.env = env;\n  }\n\n  // Get/set user profile, backed by Worker KV.\n  async getProfile() {\n    return await this.env.PROFILES.get(this.uid, &quot;json&quot;);\n  }\n  async setProfile(profile) {\n    await this.env.PROFILES.put(this.uid, JSON.stringify(profile));\n  }\n\n  // Send the user a notification email.\n  async sendNotification(message) {\n    let addr = await this.env.EMAILS.get(this.uid);\n    await this.env.EMAIL_SERVICE.send(addr, message);\n  }\n\n  // Append to the user&#039;s activity log.\n  async logActivity(description) {\n    // (Please excuse this somewhat problematic implementation,\n    // this is just a dumb example.)\n    let timestamp = new Date().toISOString();\n    await this.env.ACTIVITY.put(\n        `${this.uid}/${timestamp}`, description);\n  }\n}\n\n// Now we define the entrypoint service, which can be used to\n// get User instances -- but only by presenting the cookie.\nexport class AuthService extends WorkerEntrypoint {\n  async checkCookie(cookie) {\n    // Look up cookie in Workers KV.\n    let cookieInfo = await this.env.COOKIE_MAP.get(\n        hash(cookie), &quot;json&quot;);\n\n    if (cookieInfo) {\n      return {\n        authorized: true,\n        user: new User(cookieInfo.uid, this.env),\n      };\n    } else {\n      return { authorized: false };\n    }\n  }\n}</pre></code>\n            <p>Now we can write a Worker that uses this API while displaying a web page:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">export default {\n  async fetch(req, env, ctx) {\n    // `using` is a new JavaScript feature. Check out the\n    // docs for more on this:\n    // https://developers.cloudflare.com/workers/runtime-apis/rpc/lifecycle/\n    using authResult = await env.AUTH_SERVICE.checkCookie(\n        req.headers.get(&quot;Cookie&quot;));\n    if (!authResult.authorized) {\n      return new Response(&quot;Not authorized&quot;, {status: 403});\n    }\n\n    let user = authResult.user;\n    let profile = await user.getProfile();\n\n    await user.logActivity(&quot;You visited the site!&quot;);\n    await user.sendNotification(\n        `Thanks for visiting, ${profile.name}!`);\n\n    return new Response(`Hello, ${profile.name}!`);\n  }\n}</pre></code>\n            <p>Finally, this worker needs to be configured with a service binding pointing at the AuthService class. Its wrangler.toml may look like:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">name = &quot;app-worker&quot;\nmain = &quot;./src/app.js&quot;\n\n# Declare a service binding to the auth service.\n[[services]]\nbinding = &quot;AUTH_SERVICE&quot;    # name of the binding in `env`\nservice = &quot;auth-service&quot;    # name of the worker in the dashboard\nentrypoint = &quot;AuthService&quot;  # name of the exported RPC class</pre></code>\n            \n          <div class=\"flex anchor relative\">\n            <h3 id=\"wait-how\">Wait, how?</h3>\n            <a href=\"#wait-how\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>What exactly happened here? The Server created an instance of the class User and returned it to the client. It has methods that the client can then just call? Are we somehow transferring code over the wire?</p><p>No, absolutely not! All code runs strictly in the <a href=\"https://developers.cloudflare.com/workers/reference/how-workers-works/#isolates\">isolate</a> where it was originally loaded. What actually happens is, when the return value is passed over RPC, all class instances are replaced with RPC stubs. The stub, when called, makes a new RPC back to the server, where it calls the method on the original User object that was created there:</p>\n            <figure class=\"kg-card kg-image-card kg-width-wide\">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/3npoG6d0ArXOiSEtHb9uhx/5a753b9a09662981f7f83990092647d2/image1-8.png\" alt=\"\" class=\"kg-image\" width=\"1999\" height=\"1000\" loading=\"lazy\"/>\n            \n            </figure><p>But then you might ask: how does the RPC stub know what methods are available? Is a list of methods passed over the wire?</p><p>In fact, no. The RPC stub is a special object called a &quot;<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a>&quot;. It implements a &quot;wildcard method&quot;, that is, it appears to have an infinite number of methods of every possible name. When you try to call a method, the name you called is sent to the server. If the original object has no such method, an exception is thrown.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"did-you-spot-the-security\">Did you spot the security?</h3>\n            <a href=\"#did-you-spot-the-security\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>In the above example, we see that RPC is easy to use. We made an object! We called it! It all just felt natural, like calling a local API! Hooray!</p><p>But there&#39;s another extremely important property that the AuthService API has which you may have missed: <b>As designed, you cannot perform any operation on a user without first checking the cookie.</b> This is true despite the fact that the individual method calls do not require sending the cookie again, and the User object itself doesn&#39;t store the cookie.</p><p>The trick is, the initial checkCookie() RPC is what returns a User object in the first place. The AuthService API does not provide any other way to obtain a User instance. The RPC client cannot create a User object out of thin air, and cannot call methods of an object without first explicitly receiving a reference to it.</p><p>This is called capability-based security: we say that the User reference received by the client is a &quot;capability&quot;, because receiving it grants the client the ability to perform operations on the user. The getProfile() method grants this capability only when the client has presented the correct cookie.</p><p>Capability-based security is often like this: security can be woven naturally into your APIs, rather than feel like an additional concern bolted on top.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"more-security-named-entrypoints\">More security: Named entrypoints</h3>\n            <a href=\"#more-security-named-entrypoints\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>Another subtle but important detail to call out: in the above example, the auth service&#39;s RPC API is exported as a named class:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">export class AuthService extends WorkerEntrypoint {</pre></code>\n            <p>And in our wrangler.toml for the calling worker, we had to specify an &quot;entrypoint&quot;, matching the class name:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">entrypoint = &quot;AuthService&quot;  # name of the exported RPC class</pre></code>\n            <p>In the past, service bindings would bind to the &quot;default&quot; entrypoint, declared with export default {. But, the default entrypoint is also typically exposed to the Internet, e.g. automatically mapped to a hostname under workers.dev (unless you explicitly turn that off). It can be tricky to safely assume that requests arriving at this entrypoint are in any way trusted.</p><p>With named entrypoints, this all changes. A named entrypoint is only accessible to Workers which have explicitly declared a binding to it. By default, only Workers on your own account can declare such bindings. Moreover, the binding must be declared at deploy time; a Worker cannot create new service bindings at runtime.</p><p>Thus, you can trust that requests arriving at a named entrypoint can only have come from Workers on your account and for which you explicitly created a service binding. In the future, we plan to extend this pattern further with the ability to lock down entrypoints, audit which Workers have bindings to them, tell the callee information about who is calling at runtime, and so on. With these tools, there is no need to write code in your app itself to authenticate access to internal APIs; the system does it for you.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"what-about-type-safety\">What about type safety?</h3>\n            <a href=\"#what-about-type-safety\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>Workers RPC works in an entirely dynamically-typed way, just as JavaScript itself does. But just as you can apply TypeScript on top of JavaScript in general, you can apply it to Workers RPC.</p><p>The <a href=\"https://www.npmjs.com/package/@cloudflare/workers-types\"><code>@cloudflare/workers-types package</code></a> defines the type <code>Service&lt;MyEntrypointType&gt;</code>, which describes the type of a service binding. <code>MyEntrypointType</code> is the type of your server-side interface. <code>Service&lt;MyEntrypointType&gt;</code> applies all the necessary transformations to turn this into a client-side type, such as converting all methods to async, replacing functions and <code>RpcTargets</code> with (properly-typed) stubs, and so on.</p><p>It is up to you to share the definition of <code>MyEntrypointType</code> between your server app and its clients. You might do this by defining the interface in a separate shared TypeScript file, or by extracting a <code>.d.ts</code> type declaration file from your server code using <a href=\"https://www.typescriptlang.org/tsconfig/#declaration\"><code>tsc --declaration</code></a>.</p><p>With that done, you can apply types to your client:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">import { WorkerEntrypoint } from &quot;cloudflare:workers&quot;;\n\n// The interface that your server-side entrypoint implements.\n// (This would probably be imported from a .d.ts file generated\n// from your server code.)\ndeclare class MyEntrypointType extends WorkerEntrypoint {\n  sum(a: number, b: number): number;\n}\n\n// Define an interface Env specifying the bindings your client-side\n// worker expects.\ninterface Env {\n  MY_SERVICE: Service&lt;MyEntrypointType&gt;;\n}\n\n// Define the client worker&#039;s fetch handler with typed Env.\nexport default &lt;ExportedHandler&lt;Env&gt;&gt; {\n  async fetch(req, env, ctx) {\n    // Now env.MY_SERVICE is properly typed!\n    const result = await env.MY_SERVICE.sum(1, 2);\n    return new Response(result.toString());\n  }\n}</pre></code>\n            \n          <div class=\"flex anchor relative\">\n            <h2 id=\"rpc-to-durable-objects\">RPC to Durable Objects</h2>\n            <a href=\"#rpc-to-durable-objects\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p><a href=\"https://developers.cloudflare.com/durable-objects/\">Durable Objects</a> allow you to create a &quot;named&quot; worker instance somewhere on the network that multiple other workers can then talk to, in order to coordinate between them. Each Durable Object also has its own private on-disk storage where it can store state long-term.</p><p>Previously, communications with a Durable Object had to take the form of HTTP requests and responses. With RPC, you can now just declare methods on your Durable Object class, and call them on the stub. One catch: to opt into RPC, you must declare your Durable Object class with extends DurableObject, like so:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">import { DurableObject } from &quot;cloudflare:workers&quot;;\n\nexport class Counter extends DurableObject {\n  async increment() {\n    // Increment our stored value and return it.\n    let value = await this.ctx.storage.get(&quot;value&quot;);\n    value = (value || 0) + 1;\n    this.ctx.storage.put(&quot;value&quot;, value);\n    return value;\n  }\n}</pre></code>\n            <p>Now we can call it like:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">let stub = env.COUNTER_NAMESPACE.get(id);\nlet value = await stub.increment();</pre></code>\n            <p><code>TypeScript</code> is supported here too, by defining your binding with type <code>DurableObjectNamespace&lt;ServerType&gt;</code>:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">interface Env {\n  COUNTER_NAMESPACE: DurableObjectNamespace&lt;Counter&gt;;\n}</pre></code>\n            \n          <div class=\"flex anchor relative\">\n            <h3 id=\"eliding-awaits-with-speculative-calls\">Eliding awaits with speculative calls</h3>\n            <a href=\"#eliding-awaits-with-speculative-calls\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>When talking to a Durable Object, the object may be somewhere else in the world from the caller. RPCs must cross the network. This takes time: despite our best efforts, we still haven&#39;t figured out how to make information travel faster than the speed of light.</p><p>When you have a complex RPC interface where one call returns an object on which you wish to make further method calls, it&#39;s easy to end up with slow code that makes too many round trips over the network.</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">// Makes three round trips.\nlet foo = await stub.foo();\nlet baz = await foo.bar.baz();\nlet corge = await baz.qux[3].corge();</pre></code>\n            <p>Workers RPC features a way to avoid this: If you know that a call will return a value containing a stub, and all you want to do with it is invoke a method on that stub, you can <i>skip awaiting it</i>:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">// Same thing, only one round trip.\nlet foo = stub.foo();\nlet baz = foo.bar.baz();\nlet corge = await baz.qux[3].corge();</pre></code>\n            <p>Whoa! How does this work?</p><p>RPC methods do not return normal promises. Instead, they return special RPC promises. These objects are &quot;<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#thenables\">custom thenables</a>&quot;, which means you can use them in all the ways you&#39;d use a regular Promise, like awaiting it or calling .then() on it.</p><p>But an RPC promise is more than just a thenable. It is also a proxy. Like an RPC stub, it has a wildcard property. You can use this to express speculative RPC calls on the eventual result, before it has actually resolved. These speculative calls will be sent to the server immediately, so that they can begin executing as soon as the first RPC has finished there, before the result has actually made its way back over the network to the client.</p><p>This feature is also known as &quot;Promise Pipelining&quot;. Although it isn&#39;t explicitly a security feature, it is commonly provided by object-capability RPC systems like Cap&#39;n Proto.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"the-future-custom-bindings-marketplace\">The future: Custom Bindings Marketplace?</h2>\n            <a href=\"#the-future-custom-bindings-marketplace\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>For now, Service Bindings and Durable Objects only allow communication between Workers running on the same account. So, RPC can only be used to talk between your own Workers.</p><p>But we&#39;d like to take it further.</p><p>We have previously explained <a href=\"/workers-environment-live-object-bindings\">why Workers environments contain live objects</a>, also known as &quot;bindings&quot;. But today, only Cloudflare can add new binding types to the Workers platform – like Queues, KV, or D1. But what if <i>anyone</i> could invent their own binding type, and give it to other people?</p><p>Previously, we thought this would require creating a way to automatically load client libraries into the calling Workers. That seemed scary: it meant using someone&#39;s binding would require trusting their code to run inside your isolate. With RPC, there&#39;s no such trust. The binding only sees exactly what you explicitly pass to it. It cannot compromise the rest of your Worker.</p><p>Could Workers RPC provide the basis for a &quot;bindings marketplace&quot;, where people can offer rich JavaScript APIs to each other in an easy and secure way? We&#39;re excited to explore and find out.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"try-it-now\">Try it now</h2>\n            <a href=\"#try-it-now\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Workers RPC is available today for all Workers users. To get started, <a href=\"https://developers.cloudflare.com/workers/runtime-apis/rpc/\">check out the docs</a>.</p>",
		"id": "7gv73eZlGWczMqEnCIHuVh",
		"localeList": {
			"name": "We've added JavaScript-native RPC to Cloudflare Workers Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "Cloudflare Workers now features a built-in RPC (Remote Procedure Call) system for use in Worker-to-Worker and Worker-to-Durable Object communication, with absolutely minimal boilerplate. We've designed an RPC system so expressive that calling a remote service can feel like using a library.",
		"metadata": {
			"title": "We've added JavaScript-native RPC to Cloudflare Workers",
			"description": "Cloudflare Workers now features a built-in RPC (Remote Procedure Call) system for use in Worker-to-Worker and Worker-to-Durable Object communication, with absolutely minimal boilerplate. We've designed an RPC system so expressive that calling a remote service can feel like using a library.",
			"imgPreview": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/4fXNCU891mDbYBJFqCH4Q4/b4de81260586e064ade2d283a0ff62e4/javascript-native-rpc-WoJtIe.png"
		},
		"primary_author": {},
		"published_at": "2024-04-05T14:00:38.000+01:00",
		"slug": "javascript-native-rpc",
		"tags": [
			{
				"id": "2xCnBweKwOI3VXdYsGVbMe",
				"name": "Developer Week",
				"slug": "developer-week"
			},
			{
				"id": "4HIPcb68qM0e26fIxyfzwQ",
				"name": "Developers",
				"slug": "developers"
			},
			{
				"id": "6hbkItfupogJP3aRDAq6v8",
				"name": "Cloudflare Workers",
				"slug": "workers"
			}
		],
		"title": "We've added JavaScript-native RPC to Cloudflare Workers",
		"updated_at": "2024-08-27T00:58:04.803Z",
		"url": "https://blog.cloudflare.com/javascript-native-rpc"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}