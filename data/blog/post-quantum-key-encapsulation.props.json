{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "12",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Goutam Tamvada",
				"slug": "goutam-tamvada",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/79UwIJZF6oQoK9k7epS0jB/e2d9ece602d938ff1605b14b4880e552/goutam-tamvada.jpg",
				"location": null,
				"website": null,
				"twitter": null,
				"facebook": null
			},
			{
				"name": "Sofía Celi",
				"slug": "sofia",
				"bio": "Cryptography researcher and implementer at Cloudflare.",
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2waJR10lPQ4007cOdOJQ5P/b525f38d9cf9e9d7df248f7134f31add/sofia.jpg",
				"location": "Lisbon",
				"website": "http://claucece.github.io/",
				"twitter": "@claucece",
				"facebook": null
			}
		],
		"excerpt": "In this blog post, we will look at what Key Encapsulation Mechanisms are and why they matter in a post-quantum world",
		"feature_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1yF4wbvgNEpx8ROF2qYT3r/17486f895d9f69610eac858106bb9399/post-quantum-key-encapsulation.png",
		"featured": false,
		"html": "\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1Xf41q44DF2aceTz1qvh7L/d0e00bff1e8959ab4d497761697c9434/image4-12.png\" alt=\"Blogpost about what is a Post-Quantum Key Encapsulation Mechanism (KEM).\" class=\"kg-image\" width=\"1800\" height=\"1013\" loading=\"lazy\"/>\n            \n            </figure><p>The Internet is accustomed to the fact that any two parties can exchange information securely without ever having to meet in advance. This magic is made possible by key exchange algorithms, which are core to certain protocols, such as the Transport Layer Security (TLS) protocol, that are used widely across the Internet.</p><p>Key exchange algorithms are an elegant solution to a vexing, seemingly impossible problem. Imagine a scenario where keys are transmitted in person: if <a href=\"https://en.wikipedia.org/wiki/Persephone\">Persephone</a> wishes to send her mother <a href=\"https://en.wikipedia.org/wiki/Demeter\">Demeter</a> a secret message, she can first generate a key, write it on a piece of paper and hand that paper to her mother, Demeter. Later, she can scramble the message with the key, and send the scrambled result to her mother, knowing that her mother will be able to unscramble the message since she is also in possession of the same key.</p><p>But what if Persephone is kidnapped (as <a href=\"https://www.perseus.tufts.edu/hopper/text?doc=HH+2+4\">the story goes</a>) and cannot deliver this key in person? What if she can no longer write it on a piece of paper because someone (by chance <a href=\"https://en.wikipedia.org/wiki/Hades\">Hades</a>, the kidnapper) might read that paper and use the key to decrypt any messages between them? Key exchange algorithms come to the rescue: Persephone can run a key exchange algorithm with Demeter, giving both Persephone and Demeter a <i>secret value</i> that is known only to them (no one else knows it) <i>even if</i> Hades is eavesdropping. This secret value can be used to encrypt messages that Hades cannot read.</p><p>The most widely used key exchange algorithms today are based on hard mathematical problems, such as <a href=\"https://en.wikipedia.org/wiki/Integer_factorization\">integer factorization</a> and the <a href=\"https://crypto.stanford.edu/pbc/notes/crypto/factoring.html\">discrete logarithm problem</a>. But these problems can be efficiently solved by a quantum computer, as we have <a href=\"/quantum-solace-and-spectre\">previously learned</a>, breaking the secrecy of the communication.</p><p>There are other mathematical problems that are hard even for quantum computers to solve, such as those based on lattices or isogenies. These problems can be used to build key exchange algorithms that are secure even in the face of quantum computers. Before we dive into this matter, we have to first look at one algorithm that can be used for Key Exchange: Key Encapsulation Mechanisms (KEMs).</p><p>Two people could agree on a <i>secret value</i> if one of them could send the secret in an encrypted form to the other one, such that only the other one could decrypt and use it. This is what a KEM makes possible, through a collection of three algorithms:</p><ul><li><p>A key generation algorithm, <i>Generate</i>, which generates a public key and a private key (a keypair).</p></li><li><p>An encapsulation algorithm, <i>Encapsulate,</i> which takes as input a public key, and outputs a shared secret value and an “encapsulation” (a ciphertext) of this secret value.</p></li><li><p>A decapsulation algorithm, <i>Decapsulate</i>, which takes as input the encapsulation and the private key, and outputs the shared secret value.</p></li></ul><p>A KEM can be seen as similar to a Public Key Encryption (PKE) scheme, since both use a combination of public and private keys. In a PKE, one encrypts a message using the public key and decrypts using the private key. In a KEM, one uses the public key to create an “encapsulation” — giving a randomly chosen shared key — and one decrypts this “encapsulation” with the private key. The reason why KEMs exist is that PKE schemes are usually less efficient than <a href=\"https://en.wikipedia.org/wiki/Symmetric-key_algorithm\">symmetric encryption schemes</a>; one can use a KEM to only transmit the shared/symmetric key, and later use it in a symmetric algorithm to efficiently encrypt data.</p><p>Nowadays, in most of our connections, we do not use KEMs or PKEs per se. We either use Key Exchanges (KEXs) or Authenticated Key Exchanges (AKE). The reason for this is that a KEX allows us to use public keys (solving the <i>key exchange problem</i> of how to securely transmit keys) in order to generate a shared/symmetric key which, in turn, will be used in a symmetric encryption algorithm to encrypt data efficiently. A famous KEX algorithm is <a href=\"https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange\">Diffie-Hellman</a>, but classical Diffie-Hellman based mechanisms do not provide security against a quantum adversary; post-quantum KEMs do.</p><p>When using a KEM, Persephone would run <i>Generate</i> and publish the public key. Demeter takes this public key, runs <i>Encapsulate</i>, keeps the generated secret to herself, and sends the encapsulation (the ciphertext) to Persephone. Persephone then runs <i>Decapsulate</i> on this encapsulation and, with it, arrives at the same shared secret that Demeter holds. Hades will not be able to guess even a bit of this secret value even if he sees the ciphertext.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/7bbaBxcIILEzrNhIFZNb6p/11e6723fc4c28fdfa43009db7892e9a3/image3-21.png\" alt=\"The encapsulation and decapsulation procedure\" class=\"kg-image\" width=\"901\" height=\"360\" loading=\"lazy\"/>\n            \n            </figure><p>In this post, we go over the construction of one particular post-quantum KEM, called <i>FrodoKEM</i>. Its design is simple, which makes it a good choice to illustrate how a KEM can be constructed. We will look at it from two perspectives:</p><ul><li><p>The underlying mathematics: a cryptographic algorithm is built as a Matryoshka doll. The first doll is, most of the time, the mathematical base, which hardness should be strong so that security is maintained. In the post-quantum world, this is usually the hardness of some lattice problems (more on this in the next section).</p></li><li><p>The algorithmic construction : these are all the subsequent dolls that take the mathematical base and construct an algorithm out of it. In the case of a KEM, first you construct a Public Key Encryption (PKE) scheme and transform it (putting another doll on top) to make a KEM, so better security properties are attained, as we will see.</p></li></ul>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6EAd5Cm1yP22B42GNMq19P/39d0e79590bb89c001e1d792df8130ac/image7-3.png\" alt=\"The different dolls of a post-quantum algorithm.\" class=\"kg-image\" width=\"1801\" height=\"750\" loading=\"lazy\"/>\n            \n            </figure><p>The core of <i>FrodoKEM</i> is a public-key encryption scheme called <i>FrodoPKE</i>, whose security is based on the hardness of the “Learning with Errors” (LWE) problem over lattices. Let us look now at the first doll of a KEM.</p><p><b>Note to the reader:</b> Some mathematics is coming in the next sections, but do not worry, we will guide you through it.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"the-learning-with-errors-problem\">The Learning With Errors Problem</h3>\n            <a href=\"#the-learning-with-errors-problem\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>The security (and mathematical foundation) of <i>FrodoKEM</i> relies on the hardness of the Learning With Errors (LWE) problem, a generalization of the classic Learning Parities with Noise <a href=\"https://cims.nyu.edu/~regev/papers/qcrypto.pdf\">problem, first defined by Regev</a>.</p><p>In cryptography, specifically in the mathematics underlying it, we often use sets to define our operations. A set is a collection of any element, in this case, we will refer to collections of numbers. In cryptography textbooks and articles, one can often read:</p><p>Let $Z_q$ denote the set of integers $\\{0, …, q-1\\}$ where $(q &gt; 2)$,</p><p>which means that we have a collection of integers from 0 to a number <i>q</i> (which has to be bigger than 2. It is assumed that <i>q</i>, in a cryptographic application, is a prime. In the main theorem, it is an arbitrary integer).</p><p>Let $\\{Z^n\\}_q$ denote a vector $(v1, v2, …, vn)$ of <i>n</i> elements, each of which belongs to $Z_q$.</p><p>The LWE problem asks to recover a secret vector $s = (s1, s2, …, sn)$ in $\\{Z^n\\}_q$ given a sequence of random, “approximate” linear equations on <i>s</i>. For instance, if $(q = 23)$ the equations might be:</p><p>[s1 + s2 + s3 + s4 ≈ 30 (mod 23)</p><p>2s1 + s3 + s5 + … + sn ≈ 40 (mod 23)</p><p>10s2 + 13s3 + 1s4 ≈ 50 (mod 23)</p><p>…]</p><p>We see the left-hand sides of the equations above are not exactly equal to the right-hand side (the equality sign is not used but rather the “≈” sign: approximately equal to); they are off by an introduced slight “error”, (which will be defined as the variable <i>e</i>. In the equations above, the error is, for example, the number 10). If the error was a known, public value, recovering <i>s</i> (the hidden variable) would be easy: after about <i>n</i> equations, we can recover <i>s</i> in a reasonable time using <a href=\"https://en.wikipedia.org/wiki/Gaussian_elimination\">Gaussian elimination</a>. Introducing this unknown error makes the problem difficult to solve (it is difficult with accuracy to find <i>s</i>), even for quantum computers.</p><p>An equivalent formulation of the LWE problem is:</p><ol><li><p>There exists a vector <i>s</i> in $\\{Z^n\\}_q$, called the secret (the hidden variable).</p></li><li><p>There exists random variables <i>a</i>.</p></li><li><p>χ is a distribution, <i>e</i> is the integer error introduced from the distribution χ.</p></li><li><p>You have: (a, ⟨a, s⟩ + e). ⟨a, s⟩ is the inner product modulo <i>q</i> of <i>s</i> and <i>a</i>.</p></li><li><p>Given ⟨a, s⟩ + e ≈ b, the input to the problem is <i>a</i> and <i>b,</i> the goal is to output a guess for <i>s</i> which is very hard to achieve with accuracy.</p></li></ol><p>Blum, Kalai and Wasserman <a href=\"https://arxiv.org/abs/cs/0010022\">provided the first subexponetial algorithm</a> for solving this problem. It requires 2<sup>O(n /log n)</sup> equations/time.</p><p>There are two main kinds of computational LWE problems that are difficult to solve for quantum computers (given certain choices of both <i>q</i> and χ):</p><ol><li><p>Search, which is to recover the secret/hidden variable <i>s</i> by only being given a certain number of samples drawn from the distribution χ.</p></li><li><p>Decision, which is to distinguish a certain number of samples drawn from the distribution (a, ⟨a, s⟩ + e) from random samples.</p></li></ol>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3FTWefsA5VM4m5OetAKHJQ/533bee8f2eb83b992ac6a5cbfd117e14/image5-7.png\" alt=\"Image of the LWE problem: search and decision.\" class=\"kg-image\" width=\"1564\" height=\"536\" loading=\"lazy\"/>\n            \n            </figure><p>The LWE problem: search and decision.</p><p>LWE is just noisy linear algebra, and yet it seems to be a very hard problem to solve. In fact, there are many reasons to believe that the LWE problem is hard: the best algorithms for solving it run in exponential time. It also is closely related to the <a href=\"https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.724.4038&rep=rep1&type=pdf\">Learning Parity with Noise (LPN)</a> problem, which is extensively studied in learning theory, and it is believed to be hard to solve (any progress in breaking LPN will potentially lead to a breakthrough in coding theory). How does it relate to building cryptography? LWE is applied to the cryptographic applications of the type of public-key. In this case, the secret value s becomes the private key, and the values b<sub>i</sub> and e<sub>i</sub> are the public key.</p><p>So, why is this problem related to lattices? In <a href=\"/quantum-solace-and-spectre\">other blog posts</a>, we have seen that certain algorithms of <a href=\"https://www.cloudflare.com/learning/ssl/quantum/what-is-post-quantum-cryptography/\">post-quantum cryptography</a> are based on lattices. So, how does LWE relate to them? One can view LWE as the problem of decoding from random linear codes, or reduce it to lattices, in particular to problems such as the Short Vector Problem (SVP) or the Shortest independent vectors problem (SIVP): an efficient solution to LWE implies a quantum algorithm to SVP and SIVP. In <a href=\"/post-quantum-signatures\">other blog posts</a>, we talk about SVP, so, in this one, we will focus on the random bounded distance decoding problem on lattices.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6xOnjfYoHaqK06BOZuobgw/caaacc6a318bffe35af6f5c63b9dbd07/image1-18.png\" alt=\"Image of a lattice.\" class=\"kg-image\" width=\"1200\" height=\"300\" loading=\"lazy\"/>\n            \n            </figure><p>Lattices (as seen in the image), as a regular and periodic arrangement of points in space, have emerged as a foundation of cryptography in the face of quantum adversaries; one modern problem in which they rely on is the Bounded Distance Decoding (BDD) problem. In the BDD problem, you are given a lattice with an arbitrary basis (a basis is a list of vectors that generate all the other points in a lattice. In the case of the image, it is the pair of vectors b<sub>1</sub> and b<sub>2</sub>). You are then given a vector b<sub>3</sub> on it. You then perturb the lattice point b<sub>3</sub> by adding some noise (or error) to give <i>x</i>. Given <i>x</i>, the goal is to find the nearest lattice point (in this case b<sub>3</sub>), as seen in the image. In this case, LWE is an average-case form of BDD (Regev also gave a worst-case to average-case reduction from BDD to LWE: the security of a cryptographic system is related to the worst-case complexity of BDD).</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5q6amGgRvbV2qDx82I0HbF/4a19e3224d839860af5a0107f0484f26/image2-19.png\" alt=\"The learning with errors problems (as BDD) in a 2 dimensions lattice. The red oval is only used for clarity.\" class=\"kg-image\" width=\"786\" height=\"678\" loading=\"lazy\"/>\n            \n            </figure><p>The first doll is built. Now, how do we build encryption from this mathematical base? From LWE, we can build a public key encryption algorithm (PKE), as we will see next with <i>FrodoPKE</i> as an example.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/51MCMCJSxznDdeKsLjSs5j/a8f7e494c928c05ae76a0faf62f0efac/image6-7.png\" alt=\"\" class=\"kg-image\" width=\"1200\" height=\"500\" loading=\"lazy\"/>\n            \n            </figure>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"public-key-encryption-frodopke\">Public Key Encryption: FrodoPKE</h3>\n            <a href=\"#public-key-encryption-frodopke\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>The second doll of the Matryoshka is using a mathematical base to build a Public Key Encryption algorithm from it. Let’s look at <i>FrodoPKE</i>. <i>FrodoPKE</i> is a public-key encryption scheme which is the building block for <i>FrodoKEM</i>. It is made up of three components: <a href=\"https://www.esat.kuleuven.be/cosic/blog/introduction-to-lattice-based-cryptography-part-2-lwe-encryption/\">key generation, encryption, and decryption</a>. Let’s say again that Persephone wants to communicate with Demeter. They will run the following operations:</p><ol><li><p><i>Generation</i>: Generate a key pair by taking a LWE sample (like <i>(A, B = As + e mod q)</i>). The public key is <i>A, B</i> and the private key is <i>s</i>. Persephone sends this public key to Demeter.</p></li><li><p><i>Encryption</i>: Demeter receives this public key and wants to send a private message with it, something like “come back”. She generates two secret vectors (<i>(s1, e1)</i> and <i>(e2)</i>). She then:</p></li><li><p>Makes the sample <i>(b1 = As1 + e1 mod q)</i>.</p></li><li><p>Makes the sample <i>(v1 = Bs1 + e2 mod q)</i>.</p></li><li><p>Adds the message <i>m</i> to the most significant bit of <i>v1</i>.</p></li><li><p>Sends <i>b1</i> and <i>v1</i> to Persephone (this is the ciphertext).</p></li><li><p>Decryption: Persephone receives the ciphertext and proceeds to:</p></li><li><p>Calculate <i>m = v1 - b1  *  s</i> and is able to recover the message, and she proceeds to leave to meet her mother.</p></li></ol><p>Notice that computing <i>v = v1- b1  * s</i> gives us <i>m + e2</i> (the message plus the error matrix sampled during encryption). The decryption process performs rounding, which will output the original message <i>m</i> if the error matrix <i>e2</i> is carefully chosen. If not, notice that there is the potential of decryption failure.</p><p>What kind of security does this algorithm give? In cryptography, we design algorithms with security notions in mind, notions they have to attain. This algorithm, <i>FrodoPKE</i> (as with other PKEs), satisfies only <i>IND-CPA</i> (<i>Indistinguishability under chosen-plaintext attack</i>) security. Intuitively, this notion means that a passive eavesdropper listening in can get no information about a message from a ciphertext. Even if the eavesdropper knows that a ciphertext is an encryption of just one of two messages of their choice, looking at the ciphertext should not tell the adversary which one was encrypted. We can also think of it as a game:</p><blockquote><p>A gnome can be sitting inside a box. This box takes a message and produces a ciphertext. All the gnome has to do is record each message and the ciphertext they see generated. An outside-of-the-box adversary, like a troll, wants to beat this game and know what the gnome knows: what ciphertext is produced if a certain message is given. The troll chooses two messages (m1 and m2) of the same length and sends them to the box. The gnome records the box operations and flips a coin. If the coin lands on its face, then they send the ciphertext (c1) corresponding to m1. Otherwise, they send c2 corresponding to m2. The troll, knowing the messages and the ciphertext, has to guess which message was encrypted.</p></blockquote><p>IND-CPA security is not enough for all secure communication on the Internet. Adversaries can not only passively eavesdrop, but also mount <i>chosen-ciphertext attacks</i> (<i>CCA</i>): they can actively modify messages in transit and trick the communicating parties into decrypting these modified messages, thereby obtaining a <i>decryption oracle</i>. They can use this decryption oracle to gain information about a desired ciphertext, and so compromise confidentiality. Such attacks are practical and all that an attacker has to do is, for example, ​​send several million test ciphertexts to a decryption oracle, see <a href=\"https://medium.com/@c0D3M/bleichenbacher-attack-explained-bc630f88ff25\">Bleichenbacher’s attack</a> and the <a href=\"https://www.robotattack.org/\">ROBOT attack</a>, for example.</p><p>Without CCA security, in the case of Demeter and Persephone, what this security means is that Hades can generate and send several million test ciphertexts to the decryption oracle and eventually reveal the content of a valid ciphertext that Hades did not generate. Demeter and Persephone then might not want to use this scheme.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"key-encapsulation-mechanisms-frodokem\">Key Encapsulation Mechanisms: FrodoKEM</h3>\n            <a href=\"#key-encapsulation-mechanisms-frodokem\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>The last figure of the Matryoshka doll is taking a secure-against-CPA scheme and making it secure against CCA. A secure-against-CCA scheme must not leak information about its private key, even when decrypting arbitrarily chosen ciphertexts. It must also be the case that an adversary cannot craft valid ciphertexts without knowing what the plaintext message is; suppose, again, that the adversary knows the messages encrypted could only be either <i>m0</i> or <i>m1</i>. If the attacker can craft another valid ciphertext, for example, by flipping a bit of the ciphertext in transit, they can send this modified ciphertext, and see whether a message close to <i>m1</i> or <i>m0</i> is returned.</p><p>To make a CPA scheme secure against CCA, one can use the <a href=\"https://eprint.iacr.org/2017/604.pdf\">Hofheinz, Hovelmanns, and Kiltz (HHK) transformations</a> (see this <a href=\"https://hss-opus.ub.ruhr-uni-bochum.de/opus4/frontdoor/deliver/index/docId/7758/file/diss.pdf\">thesis</a> for more information). The HHK transformation constructs an IND-CCA-secure KEM from both an IND-CPA PKE and three hash functions. In the case of the algorithm we are exploring, FrodoKEM, it uses a slightly tweaked version of the HHK transform. It has, again, three functions (some parts of this description are simplified):</p><p><i>Generation</i>:</p><ol><li><p>We need a hash function <i>G1</i>.</p></li><li><p>We need a PKE scheme, such as FrodoPKE.</p></li><li><p>We call the <i>Generation</i> function of FrodoPKE, which returns a public (pk) and private key (sk).</p></li><li><p>We hash the public key <i>pkh ← G1(pk)</i>.</p></li><li><p>We chose a value <i>s</i> at random.</p></li><li><p>The public key is <i>pk</i> and the private key <i>sk1</i> is <i>(sk, s, pk, pkh)</i>.</p></li></ol><p><i>Encapsulate</i>:</p><ol><li><p>We need two hash functions: <i>G2</i> and <i>F</i>.</p></li><li><p>We generate a random message <i>u.</i></p></li><li><p>We hash the received public key <i>pkh</i> with the random message <i>(r, k) ← G2(pkh || u)</i>.</p></li><li><p>We call the <i>Encryption</i> function of FrodoPKE: <i>ciphertext ← Encrypt(u, pk, r)</i>.</p></li><li><p>We hash: <i>shared secret ← F(c || k)</i>.</p></li><li><p>We send the ciphertext and the shared secret.</p></li></ol><p><i>Decapsulate</i>:</p><ol><li><p>We need two hash functions (<i>G2</i> and <i>F</i>) and we have <i>(sk, s, pk, pkh)</i>.</p></li><li><p>We receive the ciphertext and the shared secret.</p></li><li><p>We call the decryption function of FrodoPKE: <i>message ← Decrypt(shared secret, ciphertext)</i>.</p></li><li><p>We hash: <i>(r , k) ← G2(pkh || message)</i>.</p></li><li><p>We call the <i>Encryption</i> function of FrodoPKE: <i>ciphertext1 ← Encrypt(message, pk, r)</i>.</p></li><li><p>If <i>ciphertext1 == ciphertext</i>, <i>k = k0</i>; else, <i>k = s</i>.</p></li><li><p>We hash: <i>ss ← F(ciphertext || k)</i>.</p></li><li><p>We return the shared secret <i>ss</i>.</p></li></ol><p>What this algorithm achieves is the generation of a shared secret and ciphertext which can be used to establish a secure channel. It also means that no matter how many ciphertexts Hades sends to the decryption oracle, they will never reveal the content of a valid ciphertext that Hades himself did not generate. This is ensured when we run the encryption process again in <i>Decapsulate</i> to check if the ciphertext was computed correctly, which ensures that an adversary cannot craft valid ciphertexts simply by modifying them.</p><p>With this last doll, the algorithm has been created, and it is safe in the face of a quantum adversary.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"other-kems-beyond-frodo\">Other KEMs beyond Frodo</h3>\n            <a href=\"#other-kems-beyond-frodo\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>While the <a href=\"https://en.wikipedia.org/wiki/Frodo_Baggins\">ring bearer,</a> Frodo, wanders around and transforms, he was not alone in his journey.  FrodoKEM is currently designated as an alternative candidate for standardization as part of the post-quantum NIST process. But, there are others:</p><ul><li><p>Kyber, NTRU, Saber: which are based on variants of the LWE problem over lattices and,</p></li><li><p>Classic McEliece: which is based on error correcting codes.</p></li></ul><p>The lattice-based variants have the advantage of being fast, while producing relatively small keys and ciphertexts. There are concerns about <a href=\"https://www.youtube.com/watch?v=iAjkEF0x5qw&ab_channel=SimonsInstitute\">their</a> <a href=\"https://www.youtube.com/watch?v=K5Apl_qCnDA&ab_channel=SimonsInstitute\">security</a>, which need to be properly verified, however. More confidence is found in the security of the Classic McEliece scheme, as its underlying problem has been studied for longer (It is only one year older than RSA!). It has a disadvantage: it produces extremely large public keys. Classic-McEliece-348864 for example, produces public keys of size 261,120 bytes, whereas Kyber512, which claims comparable security, produces public keys of size 800 bytes.</p><p>They are all Matryoshka dolls (including sometimes non-post-quantum ones). They are all algorithms that are placed one inside the other. They all start with a small but powerful idea: a mathematical problem whose solution is hard to find in an efficient time. They then take the algorithm approach and achieve one cryptographic security. And, by the magic of hashes and length preservation, they achieve more cryptographic security. This just goes to show that cryptographic algorithms are not perfect in themselves; they stack on top of each other to get the best of each one. Facing quantum adversaries with them is the same, not a process of isolation but rather a process of stacking and creating the big picture from the smallest one.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"references\">References:</h3>\n            <a href=\"#references\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <ul><li><p>NIST Post-Quantum Cryptography process FAQ: <a href=\"https://csrc.nist.gov/Projects/post-quantum-cryptography/faqs\">https://csrc.nist.gov/Projects/post-quantum-cryptography/faqs</a></p></li><li><p>“A Decade of Lattice Cryptography” by Chris Peikert: <a href=\"https://eprint.iacr.org/2015/939.pdf\">https://eprint.iacr.org/2015/939.pdf</a></p></li><li><p>“FrodoKEM: Learning With Errors Key Encapsulation Algorithm Specifications and Supporting Documentation” by Erdem Alkim, Joppe W. Bos, Léo Ducas, Patrick Longa, Ilya Mironov, Michael Naehrig, Valeria Nikolaenko, Chris Peikert, Ananth Raghunathan and Douglas Stebila: <a href=\"https://frodokem.org/files/FrodoKEM-specification-20171130.pdf\">https://frodokem.org/files/FrodoKEM-specification-20171130.pdf</a></p></li><li><p>“The Learning with Errors Problem” by Oded Regev: <a href=\"https://cims.nyu.edu/~regev/papers/lwesurvey.pdf\">https://cims.nyu.edu/~regev/papers/lwesurvey.pdf</a></p></li><li><p>“Wonk post: chosen ciphertext security in public-key encryption” by Matthew Green: <a href=\"https://blog.cryptographyengineering.com/2018/07/20/wonk-post-chosen-ciphertext-security-in-public-key-encryption-part-2/\">https://blog.cryptographyengineering.com/2018/07/20/wonk-post-chosen-ciphertext-security-in-public-key-encryption-part-2/</a></p></li><li><p>“A Designer&#39;s Guide to KEMs” by Alexander W. Dent: <a href=\"https://eprint.iacr.org/2002/174\">https://eprint.iacr.org/2002/174</a></p></li><li><p>“A Modular Analysis of the Fujisaki-Okamoto Transformation” by Dennis Hofheinz, Kathrin Hövelmanns and Eike Kiltz: <a href=\"https://eprint.iacr.org/2017/604.pdf\">https://eprint.iacr.org/2017/604.pdf</a></p></li></ul><p></p>",
		"id": "49wRKGXrzIHjgTPhrb6x4w",
		"localeList": {
			"name": "Deep dive into a post-quantum key encapsulation algorithm Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "In this blog post, we will look at what Key Encapsulation Mechanisms are and why they matter in a post-quantum world.",
		"metadata": {
			"title": "Deep dive into a post-quantum key encapsulation algorithm",
			"description": "In this blog post, we will look at what Key Encapsulation Mechanisms are and why they matter in a post-quantum world.",
			"imgPreview": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1BSaZucGrlqwvz7Dvj1g4W/8ed299a1793d787c193aa9f289b4318b/post-quantum-key-encapsulation-SGKleA.png"
		},
		"primary_author": {},
		"published_at": "2022-02-22T13:59:26.000+00:00",
		"slug": "post-quantum-key-encapsulation",
		"tags": [
			{
				"id": "1x7tpPmKIUCt19EDgM1Tsl",
				"name": "Research",
				"slug": "research"
			},
			{
				"id": "1QsJUMpv0QBSLiVZLLQJ3V",
				"name": "Cryptography",
				"slug": "cryptography"
			},
			{
				"id": "6bIo7ayy56Fzdrtf9z2EWy",
				"name": "Post-Quantum",
				"slug": "post-quantum"
			}
		],
		"title": "Deep dive into a post-quantum key encapsulation algorithm",
		"updated_at": "2025-03-31T15:29:42.224Z",
		"url": "https://blog.cloudflare.com/post-quantum-key-encapsulation"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.icon_aria_label": "Search",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"search.result_stat_empty": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong>",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"search.autocomplete_title": "Insert a query. Press enter to send",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}