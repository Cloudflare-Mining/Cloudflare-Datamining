{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "17",
	"locale": "en-us",
	"localesAvailable": [
		"zh-cn",
		"fr-fr",
		"de-de",
		"ja-jp"
	],
	"post": {
		"authors": [
			{
				"name": "James Culveyhouse",
				"slug": "james-culveyhouse",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2IAt8Eb4CKZMgvCvxHdNM/2f6ec2bf2bf318993e9d2f6727dbba60/james-culveyhouse.jpg",
				"location": "San Francisco, CA",
				"website": null,
				"twitter": null,
				"facebook": null,
				"publiclyIndex": true
			}
		],
		"excerpt": "Cloudflare’s dashboard now supports four new language: Spanish (with country-specific locales: Chile, Ecuador, Mexico, Peru, and Spain), Brazilian Portuguese, Korean, and Traditional Chinese. ",
		"feature_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/51fZziOS1hvKKIdS4QBCTp/becca5657be9bec4adcbb80469f4764a/internationalizing-the-cloudflare-dashboard.png",
		"featured": false,
		"html": "<p><a href=\"https://dash.cloudflare.com/sign-up\">Cloudflare’s dashboard</a> now supports four new languages (and multiple locales): Spanish (with country-specific locales: Chile, Ecuador, Mexico, Peru, and Spain), Brazilian Portuguese, Korean, and Traditional Chinese. Our customers are global and diverse, so in helping build a better Internet for everyone, it is imperative that we bring our products and services to customers in their native language.</p><p>Since last year Cloudflare has been hard at work internationalizing our dashboard. At the end of 2019, we launched our first language other than US English: German. At the end of March 2020, we released three additional languages: French, Japanese, and Simplified Chinese. If you want to start using the dashboard in any of these languages, you can change your language preference in the top right of the Cloudflare dashboard. The preference selected will be saved and used across all sessions.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6bPkaBuSElf3KVstMxueBb/96fe21b0b376c22d3ebdaa8395bf4e5e/image1-13.png\" alt=\"\" class=\"kg-image\" width=\"937\" height=\"829\" loading=\"lazy\"/>\n            \n            </figure><p>In this blog post, I want to help those unfamiliar with internationalization and localization to better understand how it works. I also would like to tell the story of how we made internationalizing and localizing our application a standard and repeatable process along with sharing a few tips that may help you as you do the same.</p>\n    <div class=\"flex anchor relative\">\n      <h3 id=\"beginning-the-journey\">Beginning the journey</h3>\n      <a href=\"#beginning-the-journey\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>The first step in internationalization is externalizing all the strings in your application. In concrete terms this means taking any text that could be read by a user and extracting it from your application code into separate, stand-alone files. This needs to be done for a few reasons:</p><ul><li><p>It enables translation teams to work on translating these strings without needing to view or change any application code.</p></li><li><p>Most translators typically use Translation Management applications which automate aspects of the workflow and provide them with useful utilities (like translation memory, change tracking, and a number of useful parsing and formatting tools). These applications expect standardized text formats (such as JSON, XML, MD, or CSV files).</p></li></ul><p>From an engineering perspective, separating application code from translations allows for making changes to strings without re-compiling and/or re-deploying code. In our React based application, externalizing most of our strings boiled down to changing blocks of code like this:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">&lt;Button&gt;Cancel&lt;/Button&gt;\n&lt;Button&gt;Next&lt;/Button&gt;</pre></code>\n            <p>Into this:</p>\n            <pre class=\"language-jsx\"><code class=\"language-jsx\">&lt;Button&gt;&lt;Trans id=&quot;signup.cancel&quot; /&gt;&lt;/Button&gt;\n&lt;Button&gt;&lt;Trans id=&quot;signup.next&quot; /&gt;&lt;/Button&gt;\n \n// And in a separate catalog.json file for en_US:\n{\n &quot;signup.cancel&quot;: &quot;Cancel&quot;,\n &quot;signup.next&quot;: &quot;Next&quot;,\n // ...many more keys\n}</pre></code>\n            <p>The <code>&lt;Trans&gt;</code> component shown above is the fundamental i18n building block in our application. In this scheme, translated strings are kept in large dictionaries keyed by a translation ID. We call these dictionaries “translation catalogs”, and there are a set of translation catalogs for each language that we support.</p><p>At runtime, the <code>&lt;Trans&gt;</code> component looks up the translation in the correct catalog for the provided key and then inserts this translation into the page (via the DOM). All of an application&#39;s static text can be externalized with simple transformations like these.</p><p>However, when dynamic data needs to be intermixed with static text, the solution becomes a little more complicated. Consider the following seemingly straightforward example which is riddled with i18n landmines:</p>\n            <pre class=\"language-jsx\"><code class=\"language-jsx\">&lt;span&gt;You&#039;ve selected { totalSelected } Page Rules.&lt;/span&gt;</pre></code>\n            <p>It may be tempting to externalize this sentence by chopping it up into a few parts, like so:</p>\n            <pre class=\"language-jsx\"><code class=\"language-jsx\">&lt;span&gt;\n &lt;Trans id=&quot;selected.prefix&quot; /&gt; {totalSelected } &lt;Trans id=&quot;pageRules&quot; /&gt;\n&lt;/span&gt;\n \n// English catalog.json\n{\n &quot;selected.prefix&quot;: &quot;You&#039;ve selected&quot;,\n &quot;pageRules&quot;: &quot;Page Rules&quot;,\n // ...\n}\n \n// Japanese catalog.json\n{\n &quot;selected.prefix&quot;: &quot;選択しました&quot;,\n &quot;pageRules&quot;: &quot;ページ ルール&quot;,\n // ...\n}\n \n// German catalog.json\n{\n &quot;selected.prefix&quot;: &quot;Sie haben ausgewählt&quot;,\n &quot;pageRules&quot;: &quot;Page Rules&quot;,\n // ...\n}\n \n// Portuguese (Brazil) catalog.json\n{\n &quot;selected.prefix&quot;: &quot;Você selecionou&quot;,\n &quot;pageRules&quot;: &quot;Page Rules&quot;,\n // ...\n}\n</pre></code>\n            <p>This gets the job done and may even seem like an elegant solution. After all, both the <code>selected.prefix</code> and <code>pageRules.suffix</code> strings seem like they are destined to be reused. Unfortunately, chopping sentences up and then concatenating translated bits back together like this turns out to be the single largest pitfall when externalizing strings for internationalization.</p><p>The problem is that when translated, the various words that make up a sentence can be <a href=\"https://en.wikipedia.org/wiki/Inflection\">morphed in different ways</a> based on context (singular vs plural contexts, due to word gender, subject/verb agreement, etc). This varies significantly from language to language, as does <a href=\"https://en.wikipedia.org/wiki/Word_order\">word order</a>. For example in English, the sentence “We like them” follows a subject-verb-object order, while other languages might follow subject-object-verb (We them like), verb-subject-object (Like we them), or even other orderings. Because of these nuanced differences between languages, concatenating translated phrases into a sentence will almost always lead to localization errors.</p><p>The code example above contains actual translations we got back from our translation teams when we supplied them with “You’ve selected” and “Page Rules” as separate strings. Here’s how this sentence would look when rendered in the different languages:</p><table><tr><td><p><b>Language</b></p></td><td><p><b>Translation</b></p></td></tr><tr><td><p>Japanese</p></td><td><p>選択しました { totalSelected } ページ ルール。</p></td></tr><tr><td><p>German</p></td><td><p>Sie haben ausgewählt { totalSelected } Page Rules</p></td></tr><tr><td><p>Portuguese (Brazil)</p></td><td><p>Você selecionou { totalSelected } Page Rules.</p></td></tr></table><p>To compare, we also gave them the sentence as a single string using a placeholder for the variable, and here’s the result:</p><table><tr><td><p><b>Language</b></p></td><td><p><b>Translation</b></p></td></tr><tr><td><p>Japanese</p></td><td><p>%{ totalSelected } 件のページ ルールを選択しました。</p></td></tr><tr><td><p>German</p></td><td><p>Sie haben %{ totalSelected } Page Rules ausgewählt.</p></td></tr><tr><td><p>Portuguese (Brazil)</p></td><td><p>Você selecionou %{ totalSelected } Page Rules.</p></td></tr></table><p>As you can see, the translations differ for Japanese and German. We’ve got a localization bug on our hands.</p><p>So, In order to guarantee that translators will be able to convey the true meaning of your text with fidelity, it&#39;s important to keep each sentence intact as a single externalized string. Our <code>&lt;Trans&gt;</code> component allows for easy injection of values into template strings which allows us to do exactly that:</p>\n            <pre class=\"language-jsx\"><code class=\"language-jsx\">&lt;span&gt;\n  &lt;Trans id=&quot;pageRules.selectedForDeletion&quot; values={{ count: totalSelected }} /&gt;\n&lt;/span&gt;\n\n// English catalog.json\n{\n  &quot;pageRules.selected&quot;: &quot;You&#039;ve selected %{ count } Page Rules.&quot;,\n  // ...\n}\n\n// Japanese catalog.json\n{\n  &quot;pageRules.selected&quot;: &quot;%{ count } 件のページ ルールを選択しました。&quot;,\n  // ...\n}\n\n// German catalog.json\n{\n  &quot;pageRules.selected&quot;: &quot;Sie haben %{ count } Page Rules ausgewählt.&quot;,\n  // ...\n}\n\n// Portuguese(Brazil) catalog.json\n{\n  &quot;pageRules.selected&quot;: &quot;Você selecionou %{ count } Page Rules.&quot;,\n  // ...\n}</pre></code>\n            <p>This allows translators to have the full context of the sentence, ensuring that all words will be translated with the correct inflection.</p><p>You may have noticed another potential issue. What happens in this example when <code>totalSelected</code> is just 1? With the above code, the user would see “You&#39;ve selected 1-Page Rules for deletion”. We need to conditionally pluralize the sentence based on the value of our dynamic data. This turns out to be a fairly common use case, and our <code>&lt;Trans&gt;</code> component handles this automatically via the <code>smart_count</code> feature:</p>\n            <pre class=\"language-jsx\"><code class=\"language-jsx\">&lt;span&gt;\n  &lt;Trans id=&quot;pageRules.selectedForDeletion&quot; values={{ smart_count: totalSelected }} /&gt;\n&lt;/span&gt;\n\n// English catalog.json\n{\n  &quot;pageRules.selected&quot;: &quot;You&#039;ve selected %{ smart_count } Page Rule. |||| You&#039;ve selected %{ smart_count } Page Rules.&quot;,\n}\n\n// Japanese catalog.json\n{\n  &quot;pageRules.selected&quot;: &quot;%{ smart_count } 件のページ ルールを選択しました。 |||| %{ smart_count } 件のページ ルールを選択しました。&quot;,\n}\n\n// German catalog.json\n{\n  &quot;pageRules.selected&quot;: &quot;Sie haben %{ smart_count } Page Rule ausgewählt. |||| Sie haben %{ smart_count } Page Rules ausgewählt.&quot;,\n}\n\n// Portuguese (Brazil) catalog.json\n{\n  &quot;pageRules.selected&quot;: &quot;Você selecionou %{ smart_count } Page Rule. |||| Você selecionou %{ smart_count } Page Rules.&quot;,\n}</pre></code>\n            <p>Here, the singular and plural versions are delimited by <code>||||</code>. <code>&lt;Trans&gt;</code> will automatically select the right translation to use depending on the value of the passed in <code>totalSelected</code> variable.</p><p>Yet another stumbling block occurs when markup is mixed in with a block of text we&#39;d like to externalize as a single string. For example, what if you need some phrase in your sentence to be a link to another page?</p>\n            <pre class=\"language-jsx\"><code class=\"language-jsx\">&lt;VerificationReminder&gt;\n  Don&#039;t forget to &lt;Link&gt;verify your email address.&lt;/Link&gt;\n&lt;/VerificationReminder&gt;</pre></code>\n            <p>To solve for this use case, the <code>&lt;Trans&gt;</code> component allows for arbitrary elements to be injected into placeholders in a translation string, like so:</p>\n            <pre class=\"language-jsx\"><code class=\"language-jsx\">&lt;VerificationReminder&gt;\n  &lt;Trans id=&quot;notification.email_verification&quot; Components={[Link]} componentProps={[{ to: &#039;/profile&#039; }]} /&gt;\n&lt;/VerificationReminder&gt;\n\n// catalog.json\n{\n  &quot;notification.email_verification&quot;: &quot;Don&#039;t forget to &lt;0&gt;verify your email address.&lt;/0&gt;&quot;,\n  // ...\n}</pre></code>\n            <p>In this example, the <code>&lt;Trans&gt;</code> component will replace placeholder elements (&lt;0&gt;, &lt;1&gt;, etc.) with instances of the component type located at that index in the <code>Components</code> array. It also passes along any data specified in <code>componentProps</code> to that instance. The example above would boil down to the following in React:</p>\n            <pre class=\"language-jsx\"><code class=\"language-jsx\">// en-US\n&lt;VerificationReminder&gt;\n  Don&#039;t forget to &lt;Link to=&quot;/profile&quot;&gt;verify your email address.&lt;/Link&gt;\n&lt;/VerificationReminder&gt;\n\n// es-ES\n&lt;VerificationReminder&gt;\n  No olvide &lt;Link to=&quot;/profile&quot;&gt;verificar la dirección de correo electrónico.&lt;/Link&gt;\n&lt;/VerificationReminder&gt;</pre></code>\n            \n    <div class=\"flex anchor relative\">\n      <h3 id=\"safety-third\">Safety third!</h3>\n      <a href=\"#safety-third\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>The functionality outlined above was enough for us to externalize our strings. However, it did at times result in bulky, repetitive code that was easy to mess up. A couple of pitfalls quickly became apparent.</p><p>The first was that small hard-coded strings were now easier to hide in plain sight, and because they weren&#39;t glaringly obvious to a developer until the rest of the page had been translated, the feedback loop in finding these was often days or weeks. A common solution to surfacing these issues is introducing a pseudo-localization mode into your application during development which will transform all properly internationalized strings by replacing each character with a similar looking unicode character.</p><p>For example <code>You&#39;ve selected 3 Page Rules.</code> might be transformed to <code>Ýôú&#39;Ʋè ƨèℓèçƭèδ 3 Þáϱè Rúℓèƨ</code>.</p><p>Another handy feature at your disposal in a pseudolocalization mode is the ability to shrink or lengthen all strings by a fixed amount in order to plan for content width differences. Here&#39;s the same pseudo-localized sentence increased in length by 50%: <code>Ýôú&#39;Ʋè ƨèℓèçƭèδ 3 Þáϱè Rúℓèƨ. ℓôřè₥ ïƥƨú₥ δô.</code> This is useful in helping both engineers and designers spot places where content length could potentially be an issue. We first recognized this problem when rolling out support for German, which at times tends to have somewhat longer words than English.</p><p>This meant that in a lot of places the text in page elements would overflow, such as in this &quot;Add&quot; button:</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2DcZK0IiIXGAW4naCbxqCr/b60a50a967f9eec972dc0bb9da72e181/image4-7.png\" alt=\"\" class=\"kg-image\" width=\"1002\" height=\"392\" loading=\"lazy\"/>\n            \n            </figure><p>There aren&#39;t a lot of easy fixes for these types of problems that don&#39;t compromise the user experience.</p><p>For best results, variable content width needs to be baked into the design itself. Since fixing these bugs often means sending it back upstream to request a new design, the process tends to be time-consuming. If you haven&#39;t given much thought to content design in general, an internationalization effort can be a good time to start. Having standards and consistency around the copy used for various elements in your app can not only cut down on the number of words that need translating, but also eliminate the need to think through the content length pitfalls of using a novel phrase.</p><p>The other pitfall we ran into was that the translation IDs — especially long and repetitive ones — are highly susceptible to typos.</p><p>Pop quiz, which of these translation keys will break our app: <code>traffic.load_balancing.analytics.filters.origin_health_title</code> or <code>traffic.load_balancing.analytics.filters.origin_heath_title</code>?</p><p>Nestled among hundreds of other lines of changes, these are hard to spot in code review. Most apps have a fallback so missing translations don&#39;t result in a page breaking error. As a result a bug like this might go unnoticed entirely if it&#39;s hidden well enough (in say, a help text fly out).</p><p>Fortunately, with a growing percentage of our codebase in TypeScript, we were able to leverage the type-checker to give developers feedback as they wrote the code. Here’s an example where our code editor is helpfully showing us a red underline to indicate that the ID property is invalid (due to the missing “l”):</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2W5zNv5D1bIaPGPGjiDpE0/a9abde771093fb812573a2c7fb3d58ea/image5-4.png\" alt=\"\" class=\"kg-image\" width=\"1496\" height=\"176\" loading=\"lazy\"/>\n            \n            </figure><p>Not only did it make the problems more obvious, but it also meant that violations would cause builds to fail, preventing bad code from entering the codebase.</p>\n    <div class=\"flex anchor relative\">\n      <h3 id=\"scaling-locale-files\">Scaling locale files</h3>\n      <a href=\"#scaling-locale-files\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>In the beginning, you&#39;ll probably start out with one translation file per locale that you support. In addition, the naming scheme you use for your keys can remain somewhat simple. As your app scales, your translation file will grow too large and need to be broken up into separate files. Files that are too large will overwhelm Translation Management applications, or if left unchecked, your code editor. All of our translation strings (not including keys), when lumped together into a single file, is around 50,000 words. For comparison, that&#39;s roughly the same size as a copy of &quot;The Hitchhiker&#39;s Guide to the Galaxy&quot; or &quot;Slaughterhouse Five&quot;.</p><p>We break up our translations into a number of &quot;catalog&quot; files roughly corresponding to feature verticals (like Firewall or Cloudflare Workers). This works out well for our developers since it provides a predictable place to find strings, and keeps the line count of a translation catalog down to a manageable length. It also works out well for the outside translation teams since a single feature vertical is a good unit of work for a translator (or small team).</p><p>In addition to per-feature catalogs, we have a common catalog file to hold strings that are re-used throughout the application. It allows us to keep IDs short (<code>common.delete</code> vs <code>some_page.some_tab.some_feature.thing.delete</code>) and lowers the likelihood of duplication since developers habitually check the common catalog before adding new strings.</p>\n    <div class=\"flex anchor relative\">\n      <h3 id=\"libraries\">Libraries</h3>\n      <a href=\"#libraries\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>So far we&#39;ve talked at length about our <code>&lt;Trans&gt;</code> component and what it can do. Now, let&#39;s talk about how it&#39;s built.</p><p>Perhaps unsurprisingly, we didn&#39;t want to reinvent the wheel and come up with a base i18n library from scratch. Due to prior efforts to internationalize the legacy parts of our application written in Backbone, we were already using Airbnb&#39;s <a href=\"https://airbnb.io/polyglot.js/\">Polyglot library</a>, a &quot;tiny I18n helper library written in JavaScript&quot; which, among other things, &quot;provides a simple solution for interpolation and pluralization, based off of Airbnb’s experience adding I18n functionality to its Backbone.js and Node apps&quot;.</p><p>We took a look at a few of the most popular libraries that had been purpose-built for internationalizing React applications, but ultimately decided to stick with Polyglot. We created our <code>&lt;Trans&gt;</code> component to bridge the gap to React. We chose this direction for a few reasons:</p><ul><li><p>We didn&#39;t want to re-internationalize the legacy code in our application in order to migrate to a new i18n support library.</p></li><li><p>We also didn&#39;t want the combined overhead of supporting 2 different i18n schemes for new vs legacy code.</p></li><li><p>Writing our own trans component gave us the flexibility to write the interface we wanted. Since Trans is used just about everywhere, we wanted to make sure it was as ergonomic as possible to developers.</p></li></ul><p>If you&#39;re just getting started with i18n in a new React based web-app, react-intl and i18n-next are 2 popular libraries that supply a component similar to <code>&lt;Trans&gt;</code> described above.</p><p>The biggest pain point of the <code>&lt;Trans&gt;</code> component as outlined is that strings have to be kept in a separate file from your source code. Switching between multiple files as you author new code or modify existing features is just plain annoying. It&#39;s even more annoying if the translation files are kept far away in the directory structure, as they often need to be.</p><p>There are some new i18n libraries such as <a href=\"https://github.com/lingui/js-lingui\">jslingui</a> that obviate this problem by taking an extraction based approach to handling translation catalogs. In this scheme, you still use a <code>&lt;Trans&gt;</code>component, but you keep your strings in the component itself, not a separate catalog:</p>\n            <pre class=\"language-jsx\"><code class=\"language-jsx\">&lt;span&gt;\n  &lt;Trans&gt;Hmm... We couldn&#039;t find any matching websites.&lt;/Trans&gt;\n&lt;/span&gt;</pre></code>\n            <p>A tool that you run at build time then does the work of finding all of these strings and extracting then into catalogs for you. For example, the above would result in the following generated catalogs:</p>\n            <pre class=\"language-json\"><code class=\"language-json\">// locales/en_US.json\n{\n  &quot;Hmm... We couldn&#039;t find any matching websites.&quot;: &quot;Hmm... We couldn&#039;t find any matching websites.&quot;,\n}\n\n// locales/de_DE.json\n{\n  &quot;Hmm... We couldn&#039;t find any matching websites.&quot;: &quot;Hmm... Wir konnten keine übereinstimmenden Websites finden.&quot;\n}</pre></code>\n            <p>The obvious advantage to this approach is that we no longer have separate files! The other advantage is that there&#39;s no longer any need for type checking IDs since typos can&#39;t happen anymore.</p><p>However, at least for our use case, there were a few downsides.</p><p>First, human translators sometimes appreciate the context of the translation keys. It helps with organization, and it gives some clues about the string&#39;s purpose.</p><p>And although we no longer have to worry about typos in translation IDs, we&#39;re just as susceptible to slight copy mismatches (ex. &quot;Verify your email&quot; vs &quot;Verify your e-mail&quot;). This is almost worse, since in this case it would introduce a near duplication which would be hard to detect. We&#39;d also have to pay for it.</p><p>Whichever tech stack you&#39;re working with, there are likely a few i18n libraries that can help you out. Which one to pick is highly dependent on technical constraints of your application and the context of your team&#39;s goals and culture.</p>\n    <div class=\"flex anchor relative\">\n      <h3 id=\"numbers-dates-and-times\">Numbers, Dates, and Times</h3>\n      <a href=\"#numbers-dates-and-times\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>Earlier when we talked about injecting data translated strings, we glossed over a major issue: the data we&#39;re injecting may also need to be formatted to conform to the user&#39;s local customs. This is true for dates, times, numbers, currencies and some other types of data.</p><p>Let&#39;s take our simple example from earlier:</p>\n            <pre class=\"language-jsx\"><code class=\"language-jsx\">&lt;span&gt;You&#039;ve selected { totalSelected } Page Rules.&lt;/span&gt;</pre></code>\n            <p>Without proper formatting, this will appear correct for small numbers, but as soon as things get into the thousands, localization problems will arise, since the way that digits are grouped and separated with symbols <a href=\"https://en.wikipedia.org/wiki/Decimal_separator\">varies by culture</a>. Here&#39;s how three-hundred thousand and three hundredths is formatted in a few different locales:</p><table><tr><td><p><b>Language (Country)</b></p></td><td><p><b>Code</b></p></td><td><p><b>Formatted Date</b></p></td></tr><tr><td><p>German (Germany)</p></td><td><p>de-DE</p></td><td><p>300.000,03</p></td></tr><tr><td><p>English (US)</p></td><td><p>en-US</p></td><td><p>300,000.03</p></td></tr><tr><td><p>English (UK)</p></td><td><p>en-GB</p></td><td><p>300,000.03</p></td></tr><tr><td><p>Spanish (Spain)</p></td><td><p>es-ES</p></td><td><p>300.000,03</p></td></tr><tr><td><p>Spanish (Chile)</p></td><td><p>es-CL</p></td><td><p>300.000,03</p></td></tr><tr><td><p>French (France)</p></td><td><p>fr-FR</p></td><td><p>300 000,03</p></td></tr><tr><td><p>Hindi (India)</p></td><td><p>hi-IN</p></td><td><p>3,00,000.03</p></td></tr><tr><td><p>Indonesian (Indonesia)</p></td><td><p>in-ID</p></td><td><p>300.000,03</p></td></tr><tr><td><p>Japanese (Japan)</p></td><td><p>ja-JP</p></td><td><p>300,000.03</p></td></tr><tr><td><p>Korean (South Korea)</p></td><td><p>ko-KR</p></td><td><p>300,000.03</p></td></tr><tr><td><p>Portuguese (Brazil)</p></td><td><p>pt-BR</p></td><td><p>300.000,03</p></td></tr><tr><td><p>Portuguese (Portugal)</p></td><td><p>pt-PT</p></td><td><p>300 000,03</p></td></tr><tr><td><p>Russian (Russia)</p></td><td><p>ru-RU</p></td><td><p>300 000,03</p></td></tr></table><p>The way that dates are formatted <a href=\"https://en.wikipedia.org/wiki/Date_format_by_country\">varies significantly from country to country</a>. If you&#39;ve developed your UI mainly with a US audience in mind, you&#39;re probably displaying dates in a way that will feel foreign and perhaps unintuitive to users from just about any other place in the world. Among other things, date formatting can vary in terms of separator choice, whether single digits are zero padded, and in the way that the day, month, and year portions are ordered. Here&#39;s how the March 4th of the current year is formatted in a few different locales:</p><table><tr><td><p><b>Language (Country)</b></p></td><td><p><b>Code</b></p></td><td><p><b>Formatted Date</b></p></td></tr><tr><td><p>German (Germany)</p></td><td><p>de-DE</p></td><td><p>4.3.2020</p></td></tr><tr><td><p>English (US)</p></td><td><p>en-US</p></td><td><p>3/4/2020</p></td></tr><tr><td><p>English (UK)</p></td><td><p>en-GB</p></td><td><p>04/03/2020</p></td></tr><tr><td><p>Spanish (Spain)</p></td><td><p>es-ES</p></td><td><p>4/3/2020</p></td></tr><tr><td><p>Spanish (Chile)</p></td><td><p>es-CL</p></td><td><p>04-03-2020</p></td></tr><tr><td><p>French (France)</p></td><td><p>fr-FR</p></td><td><p>04/03/2020</p></td></tr><tr><td><p>Hindi (India)</p></td><td><p>hi-IN</p></td><td><p>4/3/2020</p></td></tr><tr><td><p>Indonesian (Indonesia)</p></td><td><p>in-ID</p></td><td><p>4/3/2020</p></td></tr><tr><td><p>Japanese (Japan)</p></td><td><p>ja-JP</p></td><td><p>2020/3/4</p></td></tr><tr><td><p>Korean (South Korea)</p></td><td><p>ko-KR</p></td><td><p>2020. 3. 4.</p></td></tr><tr><td><p>Portuguese (Brazil)</p></td><td><p>pt-BR</p></td><td><p>04/03/2020</p></td></tr><tr><td><p>Portuguese (Portugal)</p></td><td><p>pt-PT</p></td><td><p>04/03/2020</p></td></tr><tr><td><p>Russian (Russia)</p></td><td><p>ru-RU</p></td><td><p>04.03.2020</p></td></tr></table><p>Time format varies significantly as well. Here&#39;s how time is formatted in a few selected locales:</p><table><tr><td><p><b>Language (Country)</b></p></td><td><p><b>Code</b></p></td><td><p><b>Formatted Date</b></p></td></tr><tr><td><p>German (Germany)</p></td><td><p>de-DE</p></td><td><p>14:02:37</p></td></tr><tr><td><p>English (US)</p></td><td><p>en-US</p></td><td><p>2:02:37 PM</p></td></tr><tr><td><p>English (UK)</p></td><td><p>en-GB</p></td><td><p>14:02:37</p></td></tr><tr><td><p>Spanish (Spain)</p></td><td><p>es-ES</p></td><td><p>14:02:37</p></td></tr><tr><td><p>Spanish (Chile)</p></td><td><p>es-CL</p></td><td><p>14:02:37</p></td></tr><tr><td><p>French (France)</p></td><td><p>fr-FR</p></td><td><p>14:02:37</p></td></tr><tr><td><p>Hindi (India)</p></td><td><p>hi-IN</p></td><td><p>2:02:37 pm</p></td></tr><tr><td><p>Indonesian (Indonesia)</p></td><td><p>in-ID</p></td><td><p>14.02.37</p></td></tr><tr><td><p>Japanese (Japan)</p></td><td><p>ja-JP</p></td><td><p>14:02:37</p></td></tr><tr><td><p>Korean (South Korea)</p></td><td><p>ko-KR</p></td><td><p>오후 2:02:37</p></td></tr><tr><td><p>Portuguese (Brazil)</p></td><td><p>pt-BR</p></td><td><p>14:02:37</p></td></tr><tr><td><p>Portuguese (Portugal)</p></td><td><p>pt-PT</p></td><td><p>14:02:37</p></td></tr><tr><td><p>Russian (Russia)</p></td><td><p>ru-RU</p></td><td><p>14:02:37</p></td></tr></table>\n    <div class=\"flex anchor relative\">\n      <h3 id=\"libraries-for-handling-numbers-dates-and-times\">Libraries for Handling Numbers, Dates, and Times</h3>\n      <a href=\"#libraries-for-handling-numbers-dates-and-times\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>Ensuring the correct format for all these types of data for all supported locales is no easy task. Fortunately, there are a number of mature, battle-tested libraries that can help you out.</p><p>When we kicked off our project, we were using the <a href=\"https://momentjs.com/\">Moment.js</a> library extensively for date and time formatting. This handy library abstracts away the details of formatting dates to different lengths (&quot;Jul 9th 20&quot;, &quot;July 9th 2020&quot;, vs &quot;Thursday&quot;), displaying relative dates (&quot;2 days ago&quot;), amongst many other things. Since almost all of our dates were already being formatted via Moment.js for readability, and since Moment.js already has i18n support for numerous locales, it meant that we were able to flip a couple of switches and have properly localized dates with very little effort.</p><p>There are some strong criticisms of Moment.js (mainly bloat), but ultimately the benefits realized from switching to a lower footprint alternative when compared to the cost it would take to redo every date and time didn&#39;t add up.</p><p>Numbers were a very different story. We had, as you might imagine, thousands of raw, unformatted numbers being displayed throughout the dashboard. Hunting them down was a laborious and often manual process.</p><p>To handle the actual formatting of numbers, we used the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl\">Intl API</a> (the Internationalization library defined by the ECMAScript standard):</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">var number = 300000.03;\nvar formatted = number.toLocaleString(&#039;hi-IN&#039;); // 3,00,000.03\n// This probably works in the browser you&#039;re using right now!</pre></code>\n            <p>Fortunately, browser support for Intl has come quite a long way in recent years, with all modern browsers having full support.</p><p>Some modern JavaScript engines like V8 have even moved away from self-hosted JavaScript implementations of these libraries in favor of C++ based builtins, <a href=\"https://v8.dev/blog/intl\">resulting in significant speedup</a>.</p><p>Support for older browsers can be somewhat lacking, however. Here&#39;s a <a href=\"https://intl-formatting.jculvey.workers.dev/\">simple demo site</a> (<a href=\"https://github.com/jculvey/intl-formatting-worker\">source code</a>) that’s built with <a href=\"https://workers.cloudflare.com/\">Cloudflare Workers</a> that shows how dates, times, and numbers are rendered in a hand-full of locales.</p><p>Some combinations of old browsers and OS&#39;s will yield less than ideal results. For example, here&#39;s how the same dates and times from above are rendered on Windows 8 with IE 10:</p><!--kg-card-begin: html--><table>\n<tbody>\n<tr>\n<td><img style=\"border-width: 0px; margin: 5px;\" src=\"/content/images/2020/07/image3-10.png\" alt=\"\" width=\"307\" height=\"370\" /></td>\n<td><img style=\"border-width: 0px; margin: 5px;\" src=\"/content/images/2020/07/image2-7.png\" alt=\"\" width=\"283\" height=\"343\" /></td>\n</tr>\n</tbody>\n</table><!--kg-card-end: html--><p>If you need to support older browsers, this can be solved with a polyfill.</p>\n    <div class=\"flex anchor relative\">\n      <h3 id=\"translating\">Translating</h3>\n      <a href=\"#translating\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>With all strings externalized, and all injected data being carefully formatted to locale specific standards, the bulk of the engineering work is complete. At this point, we can now claim that we’ve <b>internationalized</b> our application, since we’ve adapted it in a way that makes it easy to localize.</p><p>Next comes the process of <b>localization</b> where we actually create varying content based on the user’s language and cultural norms.</p><p>This is no small feat. Like we mentioned before, the strings in our application added together are the size of a small novel. It takes a significant amount of coordination and human expertise to create a translated copy that both captures the information with fidelity and speaks to the user in a familiar way.</p><p>There are many ways to handle the translation work: leveraging multilingual staff members, contracting the work-out to individual translators, agencies, or even going all in and hiring teams of in-house translators. Whatever the case may be, there needs to be a smooth process for both workflow signalling and moving assets between the translation and development teams.</p><p>A healthy i18n program will provide developers with black-box interface with the process — they put new strings in a translation catalog file and commit the change, and without any more effort on their part, the feature code they wrote is available in production for all supported locales a few days later. Similarly, in a well run process translators will remain blissfully unaware of the particulars of the development process and application architecture. They receive files that easily load in their tools and clearly indicate what translation work needs to be done.</p><p>So, how does it actually work in practice?</p><p>We have a set of automated scripts that can be run on-demand by the localization team to package up a snapshot of our localization catalogs for all supported languages. During this process, a few things happen:</p><ul><li><p>JSON files are generated from catalog files authored in TypeScript</p></li><li><p>If any new catalog files were added in English, placeholder copies are created for all other supported languages.</p></li><li><p>Placeholder strings are added for all languages when new strings are added to our base catalog</p></li></ul><p>From there, the translation catalogs are uploaded to the Translation Management system via the UI or automated calls to the API. Before handing it off to translators, the files are pre-processed by comparing each new string against a Translation Memory (a cache of previously translated strings and substrings). If a match is found, the existing translation is used. Not only does this save cost by not re-translating strings, but it improves quality by ensuring that previously reviewed and approved translations are used when possible.</p><p>Suppose your locale files end up looking something like this:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">{\n &quot;verify.button&quot;: &quot;Verify Email&quot;,\n &quot;other.verify.button&quot;: &quot;Verify Email&quot;,\n &quot;verify.proceed.link&quot;: &quot;Verify Email to proceed&quot;,\n // ...\n}</pre></code>\n            <p>Here, we have strings that are duplicated verbatim, as well as sub-strings that are copied. Translation services are billed by the word — you don’t want to pay for something twice and run the risk of a consistency issue arising. To this end, having a well-maintained Translation Memory will ensure that these strings are taken care of in the pre-translation steps before translators even see the file.</p><p>Once the translation job is marked as ready, it can take translation teams anywhere from hours to weeks to complete return translated copies depending on a number of factors such as the size of the job, the availability of translators, and the contract terms. The concerns of this phase could constitute another blog article of similar length: sourcing the right translation team, controlling costs, ensuring quality and consistency, making sure the company’s brand is properly conveyed, etc. Since the focus of this article is largely technical, we’ll gloss over the details here, but make no mistake -- getting this part wrong will tank your entire effort, even if you’ve achieved your technical objectives.</p><p>After translation teams signal that new files are ready for pickup, the assets are pulled from the server and unpacked into their correct locations in the application code. We then run a suite of automated checks to make sure that all files are valid and free of any formatting issues.</p><p>An optional (but highly recommended) step takes place at this stage — in-context review. A team of translation reviewers then look at the translated output in context to make sure everything looks perfect in its finalized state. Having support staff that are both highly proficient with the product and fluent in the target language are especially useful in this effort. Shoutout to all our team members from around the company that have taken the time and effort to do this. To make this possible for outside contractors, we prepare special preview versions of our app that allow them to test with development mode locales enabled.</p><p>And there you have it, everything it takes to deliver a localized version of your application to your users all around the world.</p>\n    <div class=\"flex anchor relative\">\n      <h3 id=\"continual-localization\">Continual Localization</h3>\n      <a href=\"#continual-localization\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>It would be great to stop here, but what we’ve discussed up until this point is the effort required to do it once. As we all know, code changes. New strings will be gradually added, modified, and deleted over the course of ti me as new features are launched and tweaked.</p><p>Since translation is a highly human process that often involves effort from people in different corners of the world, there is a lower bound to the timeframe in which turnover is possible. Since our release cadence (daily) is often faster than this turnover rate (2-5 days), it means that developers making changes to features have to make a choice: slow down to match this cadence, or ship slightly ahead of the localization schedule without full coverage.</p><p>In order to ensure that features shipping ahead of translations don’t cause application-breaking errors, we fall back to our base locale (en_US) if a string doesn’t exist for the configured language.</p><p>Some applications have a slightly different fallback behavior: displaying raw translation keys (perhaps you&#39;ve seen <i>some.funny.dot.delimited.string</i> in an app you&#39;re using). There&#39;s a tradeoff between velocity and correctness here, and we chose to optimize for velocity and minimal overhead. In some apps correctness is important enough to slow down cadence for i18n. In our case it wasn&#39;t.</p>\n    <div class=\"flex anchor relative\">\n      <h3 id=\"finishing-touches\">Finishing Touches</h3>\n      <a href=\"#finishing-touches\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>There are a few more things we can do to optimize the user experience in our newly localized application.</p><p>First, we want to make sure there isn’t any performance degradation. If our application made the user fetch all of its translated strings before rendering the page, this would surely happen. So, in order to keep everything running smoothly, the translation catalogs are fetched asynchronously and only as the application needs them to render some content on the page. This is easy to accomplish nowadays with the code splitting features available in module bundlers that support dynamic import statements such as <a href=\"https://parceljs.org/code_splitting.html\">Parcel</a> or <a href=\"https://webpack.js.org/guides/code-splitting/\">Webpack</a>.</p><p>We also want to eliminate any friction the user might experience with needing to constantly select their desired language when visiting different Cloudflare properties. To this end, we made sure that any language preference a user selects on our <a href=\"https://www.cloudflare.com/fr-fr/\">marketing site</a> or our <a href=\"https://support.cloudflare.com/hc/fr-fr\">support site</a> persists as they navigate to and from our <a href=\"https://dash.cloudflare.com/login?lang=fr-fr\">dashboard</a> (all links are in French to belabor the point).</p>\n    <div class=\"flex anchor relative\">\n      <h3 id=\"whats-next\">What’s next?</h3>\n      <a href=\"#whats-next\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>It’s been an exciting journey, and we’ve learned a lot from the process. It’s difficult (perhaps impossible) to call an i18n project truly complete.  Expanding into new languages will surface slippery bugs and expose new challenges. Budget pressure will challenge you to find ways of cutting costs and increasing efficiency. In addition, you will discover ways in which you can enhance the localized experience even more for users.</p><p>There’s a long list of things we’d like to improve upon, but here are some of the highlights:</p><ul><li><p>Collation. String comparison is language sensitive, and as such, the code you’ve written to lexicographically sort lists and tables of data in your app is probably doing the wrong thing for some of your users. This is especially apparent in languages that use logo graphic writing systems (such as Chinese or Japanese) as opposed to languages that use alphabets (like English or Spanish).</p></li><li><p>Support for <a href=\"https://en.wikipedia.org/wiki/Right-to-left\">right-to-left languages</a> like Arabic and Hebrew.</p></li><li><p>Localizing API responses is harder than localizing static copy in your user interface, as it takes a coordinated effort between teams. In the age of microservices, finding a solution that works well across the myriad of tech stacks that power each service can be very challenging.</p></li><li><p>Localizing maps. We’ll be working on making sure all content in our map-based visualizations is translated.</p></li><li><p>Machine translation has come a long way in recent years, but not far enough to churn our translations unsupervised. We would however like to experiment more with using machine translation as a first pass that translation reviewers then edit for correctness and tone.</p></li></ul><p>I hope you have enjoyed this overview of how Cloudflare internationalized and localized our dashboard.  Check out <a href=\"https://www.cloudflare.com/careers/jobs/\">our careers page</a> for more information on full-time positions and internship roles across the globe.</p>",
		"id": "7MdK7VijKW2yLm60JTPzvN",
		"localeList": {
			"name": "Internationalizing the Cloudflare Dashboard Config",
			"enUS": "English for Locale",
			"zhCN": "Translated for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "Translated for Locale",
			"deDE": "Translated for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "Translated for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "Cloudflare’s dashboard now supports Spanish, Brazilian Portuguese, Korean, and Traditional Chinese. Learn how we made internationalizing and localizing our application a standard and repeatable process.",
		"metadata": {
			"imgPreview": ""
		},
		"primary_author": {},
		"publicly_index": true,
		"published_at": "2020-07-23T12:00:00.000+01:00",
		"slug": "internationalizing-the-cloudflare-dashboard",
		"tags": [
			{
				"id": "uegedi11MDlivX9pYn2ri",
				"name": "Dashboard",
				"slug": "dashboard-tag"
			},
			{
				"id": "6QktrXeEFcl4e2dZUTZVGl",
				"name": "Product News",
				"slug": "product-news"
			}
		],
		"title": "Internationalizing the Cloudflare Dashboard",
		"updated_at": "2025-10-03T17:36:18.323Z",
		"url": "https://blog.cloudflare.com/internationalizing-the-cloudflare-dashboard"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.icon_aria_label": "Search",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"search.result_stat_empty": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong>",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"search.autocomplete_title": "Insert a query. Press enter to send",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}