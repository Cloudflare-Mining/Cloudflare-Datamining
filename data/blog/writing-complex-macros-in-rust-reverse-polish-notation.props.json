{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "6",
	"locale": "en-us",
	"localesAvailable": [
		"zh-cn",
		"fr-fr",
		"de-de",
		"ko-kr",
		"es-es"
	],
	"post": {
		"authors": [
			{
				"name": "Ingvar Stepanyan",
				"slug": "ingvar-stepanyan",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4BKdOuvjE4f1xTbCxX2vth/4d30adabbef166d68ab084cc1343a5c5/ingvar-stepanyan.jpg",
				"location": null,
				"website": null,
				"twitter": null,
				"facebook": null,
				"publiclyIndex": true
			}
		],
		"excerpt": "Among other interesting features, Rust has a powerful macro system. Unfortunately, even after reading The Book and various tutorials, when it came to trying to implement a macro which involved processing complex lists of different elements, I still struggled to understand how it should be done.",
		"feature_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/h3wCLjNTENCZVHI6KdhyH/c327f25eb625503e02975979a2628940/writing-complex-macros-in-rust-reverse-polish-notation.jpg",
		"featured": false,
		"html": "<p>(<i>This is a crosspost of a tutorial </i><a href=\"https://rreverser.com/writing-complex-macros-in-rust/\"><i>originally published</i></a><i> on my personal blog</i>)</p><p>Among other interesting features, Rust has a powerful macro system. Unfortunately, even after reading The Book and various tutorials, when it came to trying to implement a macro which involved processing complex lists of different elements, I still struggled to understand how it should be done, and it took some time till I got to that &quot;ding&quot; moment and started misusing macros for everything :) <i>(ok, not everything as in the i-am-using-macros-because-i-dont-want-to-use-functions-and-specify-types-and-lifetimes everything like I&#39;ve seen some people do, but anywhere it&#39;s actually useful)</i></p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5H983fEVulWNryLr4wz4Al/cb9ff5c7818560c6dd186183a2c6270a/25057125240_939a41249f_z.jpg\" alt=\"Rust with a macro lens\" class=\"kg-image\" width=\"640\" height=\"427\" loading=\"lazy\"/>\n            \n            </figure><p><a href=\"https://creativecommons.org/licenses/by/2.0/\">CC BY 2.0</a> <a href=\"https://www.flickr.com/photos/conchur/25057125240/in/photolist-EbdjmG-8NSN1q-qXhueG-YTYnm3-odaneQ-DxCKQA-228jg4t-DU8Axz-XTQfdD-4p6nJk-UKVzbn-YFeKcW-osZ2XM-e6qefx-Tb3a6Q-dCw1zk-Et3kKh-dbAR9x-zHP8TR-a9cqw4-9JQHRy-Et1Ag5-PqFtx1-7x3Ukq-67VJc6-cvoKSo-qH2S9L-zHJAr9-XmCLsL-8AMWXX-ZV2hHh-XGPiHq-ZKpFSB-yqd2P1-23hMiaC-zETYYa-Wj7BVi-PNP4YA-LCNm6c-8AnkrZ-KA7qmt-KjYPxC-SzQsZD-Cxwvqg-GuZ3nn-J4jBaA-TzyjpB-DcYJA1-YQYNA3-My1uu8\">image</a> by <a href=\"https://www.flickr.com/photos/conchur/\">Conor Lawless</a></p><p>So, here is my take on describing the principles behind writing such macros. It assumes you have read the <a href=\"https://doc.rust-lang.org/book/first-edition/macros.html\">Macros</a> section from The Book and are familiar with basic macros definitions and token types.</p><p>I&#39;ll take a <a href=\"https://en.wikipedia.org/wiki/Reverse_Polish_notation\">Reverse Polish Notation</a> as an example for this tutorial. It&#39;s interesting because it&#39;s simple enough, you might be already familiar with it from school, and yet to implement it statically at compile time, you already need to use a recursive macros approach.</p><p>Reverse Polish Notation (also called postfix notation) uses a stack for all its operations, so that any operand is pushed onto the stack, and any <i>[binary]</i> operator takes two operands from the stack, evaluates the result and puts it back. So an expression like following:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">2 3 + 4 *</pre></code>\n            <p>translates into:</p><ol><li><p>Put <code>2</code> onto the stack.</p></li><li><p>Put <code>3</code> onto the stack.</p></li><li><p>Take two last values from the stack (<code>3</code> and <code>2</code>), apply operator <code>+</code> and put the result (<code>5</code>) back onto the stack.</p></li><li><p>Put <code>4</code> onto the stack.</p></li><li><p>Take two last values from the stack (<code>4</code> and <code>5</code>), apply operator <code>*</code> (<code>4 * 5</code>) and put the result (<code>20</code>) back onto the stack.</p></li><li><p>End of expression, the single value on the stack is the result (<code>20</code>).</p></li></ol><p>In a more common infix notation, used in math and most modern programming languages, the expression would look like <code>(2 + 3) * 4</code>.</p><p>So let&#39;s write a macro that would evaluate RPN at compile-time by converting it into an infix notation that Rust understands.</p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">macro_rules! rpn {\n  // TODO\n}\n\nprintln!(&quot;{}&quot;, rpn!(2 3 + 4 *)); // 20</pre></code>\n            <p>Let&#39;s start with pushing numbers onto the stack.</p><p>Macros currently don&#39;t allow matching literals, and <code>expr</code> won&#39;t work for us because it can accidentally match sequence like <code>2 + 3 ...</code> instead of taking just a single number, so we&#39;ll resort to <code>tt</code> - a generic token matcher that matches only one token tree (whether it&#39;s a primitive token like literal/identifier/lifetime/etc. or a <code>()</code>/<code>[]</code>/<code>{}</code>-parenthesized expression containing more tokens):</p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">macro_rules! rpn {\n  ($num:tt) =&gt; {\n    // TODO\n  };\n}</pre></code>\n            <p>Now, we&#39;ll need a variable for the stack.</p><p>Macros can&#39;t use real variables, because we want this stack to exist only at compile time. So, instead, the trick is to have a separate token sequence that can be passed around, and so used as kind of an accumulator.</p><p>In our case, let&#39;s represent it as a comma-separated sequence of <code>expr</code> (since we will be using it not only for simple numbers but also for intermediate infix expressions) and wrap it into brackets to separate from the rest of the input:</p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">macro_rules! rpn {\n  ([ $($stack:expr),* ] $num:tt) =&gt; {\n    // TODO\n  };\n}</pre></code>\n            <p>Now, a token sequence is not really a variable - you can&#39;t modify it in-place and do something afterwards. Instead, you can create a new copy of this token sequence with necessary modifications, and recursively call same macro again.</p><p>If you are coming from functional language background or worked with any library providing immutable data before, both of these approaches - mutating data by creating a modified copy and processing lists with a recursion - are likely already familiar to you:</p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">macro_rules! rpn {\n  ([ $($stack:expr),* ] $num:tt) =&gt; {\n    rpn!([ $num $(, $stack)* ])\n  };\n}</pre></code>\n            <p>Now, obviously, the case with just a single number is rather unlikely and not very interesting to us, so we&#39;ll need to match anything else after that number as a sequence of zero or more <code>tt</code> tokens, which can be passed to next invocation of our macro for further matching and processing:</p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">macro_rules! rpn {\n  ([ $($stack:expr),* ] $num:tt $($rest:tt)*) =&gt; {\n      rpn!([ $num $(, $stack)* ] $($rest)*)\n  };\n}</pre></code>\n            <p>At this point we&#39;re still missing operator support. How do we match operators?</p><p>If our RPN would be a sequence of tokens that we would want to process in an exactly same way, we could simply use a list like <code>$($token:tt)*</code>. Unfortunately, that wouldn&#39;t give us an ability to go through list and either push an operand or apply an operator depending on each token.</p><p>The Book says that &quot;macro system does not deal with parse ambiguity at all&quot;, and that&#39;s true for a single macros branch - we can&#39;t match a sequence of numbers followed by an operator like <code>$($num:tt)* +</code> because <code>+</code> is also a valid token and could be matched by the <code>tt</code> group, but this is where recursive macros helps again.</p><p>If you have different branches in your macro definition, Rust will try them one by one, so we can put our operator branches before the numeric one and, this way, avoid any conflict:</p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">macro_rules! rpn {\n  ([ $($stack:expr),* ] + $($rest:tt)*) =&gt; {\n    // TODO\n  };\n  \n  ([ $($stack:expr),* ] - $($rest:tt)*) =&gt; {\n    // TODO\n  };\n  \n  ([ $($stack:expr),* ] * $($rest:tt)*) =&gt; {\n    // TODO\n  };\n  \n  ([ $($stack:expr),* ] / $($rest:tt)*) =&gt; {\n    // TODO\n  };\n\n  ([ $($stack:expr),* ] $num:tt $($rest:tt)*) =&gt; {\n    rpn!([ $num $(, $stack)* ] $($rest)*)\n  };\n}</pre></code>\n            <p>As I said earlier, operators are applied to the last two numbers on the stack, so we&#39;ll need to match them separately, &quot;evaluate&quot; the result (construct a regular infix expression) and put it back:</p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">macro_rules! rpn {\n  ([ $b:expr, $a:expr $(, $stack:expr)* ] + $($rest:tt)*) =&gt; {\n    rpn!([ $a + $b $(, $stack)* ] $($rest)*)\n  };\n\n  ([ $b:expr, $a:expr $(, $stack:expr)* ] - $($rest:tt)*) =&gt; {\n    rpn!([ $a - $b $(, $stack)* ] $($rest)*)\n  };\n\n  ([ $b:expr, $a:expr $(, $stack:expr)* ] * $($rest:tt)*) =&gt; {\n    rpn!([ $a * $b $(,$stack)* ] $($rest)*)\n  };\n\n  ([ $b:expr, $a:expr $(, $stack:expr)* ] / $($rest:tt)*) =&gt; {\n    rpn!([ $a / $b $(,$stack)* ] $($rest)*)\n  };\n\n  ([ $($stack:expr),* ] $num:tt $($rest:tt)*) =&gt; {\n    rpn!([ $num $(, $stack)* ] $($rest)*)\n  };\n}</pre></code>\n            <p>I&#39;m not really fan of such obvious repetitions, but, just like with literals, there is no special token type to match operators.</p><p>What we can do, however, is add a helper that would be responsible for the evaluation, and delegate any explicit operator branch to it.</p><p>In macros, you can&#39;t really use an external helper, but the only thing you can be sure about is that your macros is already in scope, so the usual trick is to have a branch in the same macro &quot;marked&quot; with some unique token sequence, and call it recursively like we did in regular branches.</p><p>Let&#39;s use <code>@op</code> as such marker, and accept any operator via <code>tt</code> inside it (<code>tt</code> would be unambiguous in such context because we&#39;ll be passing only operators to this helper).</p><p>And the stack does not need to be expanded in each separate branch anymore - since we wrapped it into <code>[]</code> brackets earlier, it can be matched as any another token tree (<code>tt</code>), and then passed into our helper:</p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">macro_rules! rpn {\n  (@op [ $b:expr, $a:expr $(, $stack:expr)* ] $op:tt $($rest:tt)*) =&gt; {\n    rpn!([ $a $op $b $(, $stack)* ] $($rest)*)\n  };\n\n  ($stack:tt + $($rest:tt)*) =&gt; {\n    rpn!(@op $stack + $($rest)*)\n  };\n  \n  ($stack:tt - $($rest:tt)*) =&gt; {\n    rpn!(@op $stack - $($rest)*)\n  };\n\n  ($stack:tt * $($rest:tt)*) =&gt; {\n    rpn!(@op $stack * $($rest)*)\n  };\n  \n  ($stack:tt / $($rest:tt)*) =&gt; {\n    rpn!(@op $stack / $($rest)*)\n  };\n\n  ([ $($stack:expr),* ] $num:tt $($rest:tt)*) =&gt; {\n    rpn!([ $num $(, $stack)* ] $($rest)*)\n  };\n}</pre></code>\n            <p>Now any tokens are processed by corresponding branches, and we need to just handle final case when stack contains a single item, and no more tokens are left:</p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">macro_rules! rpn {\n  // ...\n  \n  ([ $result:expr ]) =&gt; {\n    $result\n  };\n}</pre></code>\n            <p>At this point, if you invoke this macro with an empty stack and RPN expression, it will already produce a correct result:</p><p><a href=\"https://play.rust-lang.org/?gist=cd56f6d7335e2d27c05e7fa89545b2cd&version=stable\">Playground</a></p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">println!(&quot;{}&quot;, rpn!([] 2 3 + 4 *)); // 20</pre></code>\n            <p>However, our stack is an implementation detail and we really wouldn&#39;t want every consumer to pass an empty stack in, so let&#39;s add another catch-all branch in the end that would serve as an entry point and add <code>[]</code> automatically:</p><p><a href=\"https://play.rust-lang.org/?gist=d94abc0e20aa5c7f689706af06fd1923&version=stable\">Playground</a></p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">macro_rules! rpn {\n  // ...\n\n  ($($tokens:tt)*) =&gt; {\n    rpn!([] $($tokens)*)\n  };\n}\n\nprintln!(&quot;{}&quot;, rpn!(2 3 + 4 *)); // 20</pre></code>\n            <p>Our macro even works for more complex expressions, like the one <a href=\"https://en.wikipedia.org/wiki/Reverse_Polish_notation#Example\">from Wikipedia page about RPN</a>!</p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">println!(&quot;{}&quot;, rpn!(15 7 1 1 + - / 3 * 2 1 1 + + -)); // 5</pre></code>\n            \n    <div class=\"flex anchor relative\">\n      <h3 id=\"error-handling\">Error handling</h3>\n      <a href=\"#error-handling\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>Now everything seems to work smoothly for correct RPN expressions, but for a macros to be production-ready we need to be sure that it can handle invalid input as well, with a reasonable error message.</p><p>First, let&#39;s try to insert another number in the middle and see what happens:</p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">println!(&quot;{}&quot;, rpn!(2 3 7 + 4 *));</pre></code>\n            <p>Output:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">error[E0277]: the trait bound `[{integer}; 2]: std::fmt::Display` is not satisfied\n  --&gt; src/main.rs:36:20\n   |\n36 |     println!(&quot;{}&quot;, rpn!(2 3 7 + 4 *));\n   |                    ^^^^^^^^^^^^^^^^^ `[{integer}; 2]` cannot be formatted with the default formatter; try using `:?` instead if you are using a format string\n   |\n   = help: the trait `std::fmt::Display` is not implemented for `[{integer}; 2]`\n   = note: required by `std::fmt::Display::fmt`</pre></code>\n            <p>Okay, that definitely doesn&#39;t look helpful as it doesn&#39;t provide any information relevant to the actual mistake in the expression.</p><p>In order to figure out what happened, we will need to debug our macros. For that, we&#39;ll use a <a href=\"https://doc.rust-lang.org/unstable-book/language-features/trace-macros.html\"><code>trace_macros</code></a> feature (and, like for any other optional compiler feature, you&#39;ll need a nightly version of Rust). We don&#39;t want to trace <code>println!</code> call, so we&#39;ll separate our RPN calculation to a variable:</p><p><a href=\"https://play.rust-lang.org/?gist=610bc0c241aacda3d30a916f89b244cd&version=nightly\">Playground</a></p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">#![feature(trace_macros)]\n\nmacro_rules! rpn { /* ... */ }\n\nfn main() {\n  trace_macros!(true);\n  let e = rpn!(2 3 7 + 4 *);\n  trace_macros!(false);\n  println!(&quot;{}&quot;, e);\n}</pre></code>\n            <p>In the output we&#39;ll now see how our macro is being recursively evaluated step by step:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">note: trace_macro\n  --&gt; src/main.rs:39:13\n   |\n39 |     let e = rpn!(2 3 7 + 4 *);\n   |             ^^^^^^^^^^^^^^^^^\n   |\n   = note: expanding `rpn! { 2 3 7 + 4 * }`\n   = note: to `rpn ! ( [  ] 2 3 7 + 4 * )`\n   = note: expanding `rpn! { [  ] 2 3 7 + 4 * }`\n   = note: to `rpn ! ( [ 2 ] 3 7 + 4 * )`\n   = note: expanding `rpn! { [ 2 ] 3 7 + 4 * }`\n   = note: to `rpn ! ( [ 3 , 2 ] 7 + 4 * )`\n   = note: expanding `rpn! { [ 3 , 2 ] 7 + 4 * }`\n   = note: to `rpn ! ( [ 7 , 3 , 2 ] + 4 * )`\n   = note: expanding `rpn! { [ 7 , 3 , 2 ] + 4 * }`\n   = note: to `rpn ! ( @ op [ 7 , 3 , 2 ] + 4 * )`\n   = note: expanding `rpn! { @ op [ 7 , 3 , 2 ] + 4 * }`\n   = note: to `rpn ! ( [ 3 + 7 , 2 ] 4 * )`\n   = note: expanding `rpn! { [ 3 + 7 , 2 ] 4 * }`\n   = note: to `rpn ! ( [ 4 , 3 + 7 , 2 ] * )`\n   = note: expanding `rpn! { [ 4 , 3 + 7 , 2 ] * }`\n   = note: to `rpn ! ( @ op [ 4 , 3 + 7 , 2 ] * )`\n   = note: expanding `rpn! { @ op [ 4 , 3 + 7 , 2 ] * }`\n   = note: to `rpn ! ( [ 3 + 7 * 4 , 2 ] )`\n   = note: expanding `rpn! { [ 3 + 7 * 4 , 2 ] }`\n   = note: to `rpn ! ( [  ] [ 3 + 7 * 4 , 2 ] )`\n   = note: expanding `rpn! { [  ] [ 3 + 7 * 4 , 2 ] }`\n   = note: to `rpn ! ( [ [ 3 + 7 * 4 , 2 ] ] )`\n   = note: expanding `rpn! { [ [ 3 + 7 * 4 , 2 ] ] }`\n   = note: to `[(3 + 7) * 4, 2]`</pre></code>\n            <p>If we carefully look through the trace, we&#39;ll notice that the problem originates in these steps:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">   = note: expanding `rpn! { [ 3 + 7 * 4 , 2 ] }`\n   = note: to `rpn ! ( [  ] [ 3 + 7 * 4 , 2 ] )`</pre></code>\n            <p>Since <code>[ 3 + 7 * 4 , 2 ]</code> was not matched by <code>([$result:expr]) =&gt; ...</code> branch as a final expression, it was caught by our final catch-all <code>($($tokens:tt)*) =&gt; ...</code> branch instead, prepended with an empty stack <code>[]</code> and then the original <code>[ 3 + 7 * 4 , 2 ]</code> was matched by generic <code>$num:tt</code> and pushed onto the stack as a single final value.</p><p>In order to prevent this from happening, let&#39;s insert another branch between these last two that would match any stack.</p><p>It would be hit only when we ran out of tokens, but stack didn&#39;t have exactly one final value, so we can treat it as a compile error and produce a more helpful error message using a built-in <a href=\"https://doc.rust-lang.org/std/macro.compile_error.html\"><code>compile_error!</code></a> macro.</p><p>Note that we can&#39;t use <code>format!</code> in this context since it uses runtime APIs to format a string, and instead we&#39;ll have to limit ourselves to built-in <code>concat!</code> and <code>stringify!</code> macros to format a message:</p><p><a href=\"https://play.rust-lang.org/?gist=e56be9422387bcae54aab3b8405a11e7&version=stable\">Playground</a></p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">macro_rules! rpn {\n  // ...\n\n  ([ $result:expr ]) =&gt; {\n    $result\n  };\n\n  ([ $($stack:expr),* ]) =&gt; {\n    compile_error!(concat!(\n      &quot;Could not find final value for the expression, perhaps you missed an operator? Final stack: &quot;,\n      stringify!([ $($stack),* ])\n    ))\n  };\n\n  ($($tokens:tt)*) =&gt; {\n    rpn!([] $($tokens)*)\n  };\n}</pre></code>\n            <p>The error message is now more meaningful and contains at least some details about current state of evaluation:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">error: Could not find final value for the expression, perhaps you missed an operator? Final stack: [ (3 + 7) * 4 , 2 ]\n  --&gt; src/main.rs:31:9\n   |\n31 |         compile_error!(concat!(&quot;Could not find final value for the expression, perhaps you missed an operator? Final stack: &quot;, stringify!([$($stack),*])))\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n40 |     println!(&quot;{}&quot;, rpn!(2 3 7 + 4 *));\n   |                    ----------------- in this macro invocation</pre></code>\n            <p>But what if, instead, we miss some number?</p><p><a href=\"https://play.rust-lang.org/?gist=ce40630b8c1aa610c46b94557fdc9905&version=stable\">Playground</a></p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">println!(&quot;{}&quot;, rpn!(2 3 + *));</pre></code>\n            <p>Unfortunately, this one is still not too helpful:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">error: expected expression, found `@`\n  --&gt; src/main.rs:15:14\n   |\n15 |         rpn!(@op $stack * $($rest)*)\n   |              ^\n...\n40 |     println!(&quot;{}&quot;, rpn!(2 3 + *));\n   |                    ------------- in this macro invocation</pre></code>\n            <p>If you try to use <code>trace_macros</code>, even it won&#39;t expand the stack here for some reason, but, luckily, it&#39;s relatively clear what&#39;s going on - <code>@op</code> has very specific conditions as to what should be matched (it expects at least two values on the stack), and, when it can&#39;t, <code>@</code> gets matched by the same way-too-greedy <code>$num:tt</code> and pushed onto the stack.</p><p>To avoid this, again, we&#39;ll add another branch to match anything starting with <code>@op</code> that wasn&#39;t matched already, and produce a compile error:</p><p><a href=\"https://play.rust-lang.org/?gist=8729a8f3c96fa58ed62d35804c48782d&version=stable\">Playground</a></p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">macro_rules! rpn {\n  (@op [ $b:expr, $a:expr $(, $stack:expr)* ] $op:tt $($rest:tt)*) =&gt; {\n    rpn!([ $a $op $b $(, $stack)* ] $($rest)*)\n  };\n\n  (@op $stack:tt $op:tt $($rest:tt)*) =&gt; {\n    compile_error!(concat!(\n      &quot;Could not apply operator `&quot;,\n      stringify!($op),\n      &quot;` to the current stack: &quot;,\n      stringify!($stack)\n    ))\n  };\n\n  // ...\n}</pre></code>\n            <p>Let&#39;s try again:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">error: Could not apply operator `*` to the current stack: [ 2 + 3 ]\n  --&gt; src/main.rs:9:9\n   |\n9  |         compile_error!(concat!(&quot;Could not apply operator &quot;, stringify!($op), &quot; to current stack: &quot;, stringify!($stack)))\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n46 |     println!(&quot;{}&quot;, rpn!(2 3 + *));\n   |                    ------------- in this macro invocation</pre></code>\n            <p>Much better! Now our macro can evaluate any RPN expression at compile-time, and gracefully handles most common mistakes, so let&#39;s call it a day and say it&#39;s production-ready :)</p><p>There are many more small improvements we could add, but I&#39;d like to leave them outside this demonstration tutorial.</p><p>Feel free to let me know if this has been useful and/or what topics you&#39;d like to see better covered <a href=\"https://twitter.com/RReverser\">on Twitter</a>!</p>",
		"id": "57apSexjoH5EJBBcLZNqv4",
		"localeList": {
			"name": "Writing complex macros in Rust: Reverse Polish Notation Config",
			"enUS": "English for Locale",
			"zhCN": "Translated for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "Translated for Locale",
			"deDE": "Translated for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "Translated for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "Translated for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": null,
		"metadata": {
			"imgPreview": ""
		},
		"primary_author": {},
		"publicly_index": true,
		"published_at": "2018-01-31T12:11:15.000+00:00",
		"slug": "writing-complex-macros-in-rust-reverse-polish-notation",
		"tags": [
			{
				"id": "w4e8pkoz9c8xNDVhy9eNe",
				"name": "Rust",
				"slug": "rust"
			},
			{
				"id": "4HIPcb68qM0e26fIxyfzwQ",
				"name": "Developers",
				"slug": "developers"
			},
			{
				"id": "6lhzEBz2B56RKa4nUEAGYJ",
				"name": "Programming",
				"slug": "programming"
			},
			{
				"id": "2jYw9pi6oazGHSQscQtBh4",
				"name": "Cloudflare Polish",
				"slug": "cloudflare-polish"
			}
		],
		"title": "Writing complex macros in Rust: Reverse Polish Notation",
		"updated_at": "2025-10-03T18:01:57.587Z",
		"url": "https://blog.cloudflare.com/writing-complex-macros-in-rust-reverse-polish-notation"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.icon_aria_label": "Search",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"search.result_stat_empty": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong>",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"search.autocomplete_title": "Insert a query. Press enter to send",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}