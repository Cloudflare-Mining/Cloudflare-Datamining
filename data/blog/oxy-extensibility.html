<div class="mb2 gray5">9 min read</div>
<div class="post-content lh-copy gray1">
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/16Q4cxV2IcM6peqmR9uf5M/ed19c065a314e3a377531de61923753c/image4-2-1.png" alt="How Oxy uses hooks for maximum extensibility" class="kg-image" width="1999" height="1125" loading="lazy">

	</figure>
	<p>We recently <a href="https://blog.cloudflare.com/introducing-oxy">introduced Oxy</a>, our Rust framework for building proxies. Through a YAML file, Oxy allows applications to easily configure listeners (e.g. IP, <a href="https://blog.cloudflare.com/unlocking-quic-proxying-potential">MASQUE</a>, HTTP/1), telemetry, and much more. However, when it comes to application logic, a programming language is often a better tool for the job. That’s why in this post we’re introducing Oxy’s rich <a href="https://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a> capabilities for programmatically modifying all aspects of a proxy.</p>
	<p>The idea of extending proxies with scripting is well established: we've had great past success with <a href="https://blog.cloudflare.com/pushing-nginx-to-its-limit-with-lua">Lua in our OpenResty/NGINX deployments</a> and there are numerous web frameworks (e.g. <a href="https://expressjs.com/en/guide/using-middleware.html">Express</a>) with middleware patterns. While Oxy is geared towards the development of <a href="https://www.cloudflare.com/learning/cdn/glossary/reverse-proxy">forward proxies</a>, they all share the model of a pre-existing request pipeline with a mechanism for integrating custom application logic. However, the use of Rust greatly helps developer productivity when compared to embedded scripting languages. Having confidence in the types and mutability of objects being passed to and returned from callbacks is wonderful.</p>
	<p>Oxy exports a series of hook traits that “hook” into the lifecycle of a <i>connection</i>, not just a request. Oxy applications need to control almost every layer of the <a href="https://www.cloudflare.com/learning/ddos/glossary/open-systems-interconnection-model-osi">OSI model</a>: how packets are received and sent, what tunneling protocols they could be using, what HTTP version they are using (if any), and even <a href="https://www.cloudflare.com/learning/dns/what-is-dns">how DNS resolution is performed</a>. With these hooks you can extend Oxy in any way possible in a safe and performant way.</p>
	<p>First, let's take a look from the perspective of an Oxy application developer, and then we can discuss the implementation of the framework and some of the interesting design decisions we made.</p>
	<h2>Adding functionality with hooks</h2>
	<p>Oxy’s dependency injection is a barebones version of what Java or C# developers might be accustomed to. Applications simply implement the start method and return a struct with their hook implementations:</p>
	<pre class="language-rust"><code class="language-rust">async fn start(
    _settings: ServerSettings&lt;(), ()&gt;,
    _parent_state: Metadata,
) -&gt; anyhow::Result&lt;Hooks&lt;Self&gt;&gt; {
    Ok(Hooks {
        ..Default::default()
    })
}</code></pre>
	<p>We can define a simple callback, <code>EgressHook::handle_connection</code>, that will forward all connections to the upstream requested by the client. Oxy calls this function before attempting to make an upstream connection.</p>
	<pre class="language-rust"><code class="language-rust">#[async_trait]
impl&lt;Ext&gt; EgressHook&lt;Ext&gt; for MyEgressHook
where
    Ext: OxyExt,
{
    async fn handle_connection(
        &amp;self,
        upstream_addr: SocketAddr,
        _egress_ctx: EgressConnectionContext&lt;Ext&gt;,
    ) -&gt; ProxyResult&lt;EgressDecision&gt; {
        Ok(EgressDecision::ExternalDirect(upstream_addr))
    }
}

async fn start(
    _settings: ServerSettings&lt;(), ()&gt;,
    _parent_state: Metadata,
) -&gt; anyhow::Result&lt;Hooks&lt;Self&gt;&gt; {
    Ok(Hooks {
        egress: Some(Arc::new(MyEgressHook)),
        ..Default::default()
    })
}</code></pre>
	<p>Oxy simply proxies the connection, but we might want to consider restricting which upstream IPs our clients are allowed to connect to. The implementation above allows everything, but maybe we have internal services that we wish to prevent proxy users from accessing.</p>
	<pre class="language-rust"><code class="language-rust">#[async_trait]
impl&lt;Ext&gt; EgressHook&lt;Ext&gt; for MyEgressHook
where
    Ext: OxyExt,
{
    async fn handle_connection(
        &amp;self,
        upstream_addr: SocketAddr,
        _egress_ctx: EgressConnectionContext&lt;Ext&gt;,
    ) -&gt; ProxyResult&lt;EgressDecision&gt; {
        if self.private_cidrs.find(upstream_addr).is_some() {
            return Ok(EgressDecision::Block);
        }

        Ok(EgressDecision::ExternalDirect(upstream_addr))
    }
}</code></pre>
	<p>This blocking strategy is crude. Sometimes it’s useful to allow certain clients to connect to internal services – a <a href="https://prometheus.io/docs/introduction/overview">Prometheus</a> scraper is a good example. To authorize these connections, we’ll implement a simple Pre-Shared Key (PSK) authorization scheme – if the client sends the header <code>Proxy-Authorization: Preshared oxy-is-a-proxy</code>, then we’ll let them connect to private addresses via the proxy.</p>
	<p>To do this, we need to attach some state to the connection as it passes through Oxy. Client headers only exist in the HTTP CONNECT phase, but we need access to the PSK during the egress phase. With Oxy, this can be done by leveraging its Opaque Extensions to attach arbitrary (yet fully typed) context data to a connection. Oxy initializes the data and passes it to each hook. We can mutate this data when we read headers from the client, and read it later during egress.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/6bUwt3l14VvDFGgFI2WK31/d641094ef1590e2c742ab75f0bb62c33/download-18.png" alt="" class="kg-image" width="1600" height="900" loading="lazy">

	</figure>
	<pre class="language-rust"><code class="language-rust">#[derive(Default)]
struct AuthorizationResult {
    can_access_private_cidrs: Arc&lt;AtomicBool&gt;,
}

#[async_trait]
impl&lt;Ext&gt; HttpRequestHook&lt;Ext&gt; for MyHttpHook
where
    Ext: OxyExt&lt;IngressConnectionContext = AuthorizationResult&gt;,
{
    async fn handle_proxy_connect_request(
        self: Arc&lt;Self&gt;,
        connect_req_head: &amp;Parts,
        req_ctx: RequestContext&lt;Ext&gt;,
    ) -&gt; ConnectDirective {
        const PSK_HEADER: &amp;str = "Preshared oxy-is-a-proxy";

        // Grab the authorization header and update 
        // the ingress_ctx if the preshared key matches.
        if let Some(authorization_header) = 
          connect_req_head.headers.get("Proxy-Authorization") {
            if authorization_header.to_str().unwrap() == PSK_HEADER {
                req_ctx
                    .ingress_ctx()
                    .ext()
                    .can_access_private_cidrs
                    .store(true, Ordering::SeqCst);
            }
        }

        ConnectDirective::Allow
    }
}</code></pre>
	<p>From here, any hook in the pipeline can access this data. For our purposes, we can just update our existing <code>handle_connection</code> callback:</p>
	<pre class="language-rust"><code class="language-rust">#[async_trait]
impl&lt;Ext&gt; EgressHook&lt;Ext&gt; for MyEgressHook
where
    Ext: OxyExt&lt;IngressConnectionContext = AuthorizationResult&gt;,
{
    async fn handle_connection(
        &amp;self,
        upstream_addr: SocketAddr,
        egress_ctx: EgressConnectionContext&lt;Ext&gt;,
    ) -&gt; ProxyResult&lt;EgressDecision&gt; {
        if self.private_cidrs.find(upstream_addr).is_some() {
            if !egress_ctx
                .ingress_ctx()
                .ext()
                .can_access_private_cidrs
                .load(Ordering::SeqCst)
            {
                return Ok(EgressDecision::Block);
            }
        }

        Ok(EgressDecision::ExternalDirect(upstream_addr))
    }
}</code></pre>
	<p>This is a somewhat contrived example, but in practice hooks and their extension types allow Oxy apps to fully customize all aspects of proxied traffic.</p>
	<p>A real world example would be implementing the RFC 9209 <a href="https://www.rfc-editor.org/rfc/rfc9209.html#name-next-hop">next-hop</a> Proxy-Status header. This involves setting a header containing the IP address we connected to on behalf of the client. We can do this with two pre-existing callbacks and a little bit of state: first we save the upstream passed to <code>EgressHook::handle_connection_established</code> and then read the value in the <code>HttpRequestHook:handle_proxy_connect_response</code> in order to set the header on the CONNECT response.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/1PMF1dZjgYHNplkhvsVLvv/20cad90615c9b5ef6e70c2fbd9ae3a94/download--1--12.png" alt="" class="kg-image" width="1600" height="900" loading="lazy">

	</figure>
	<pre class="language-rust"><code class="language-rust">#[derive(Default)]
struct ConnectProxyConnectionContext {
    upstream_addr: OnceCell&lt;SocketAddr&gt;,
}

#[async_trait]
impl&lt;Ext&gt; EgressHook&lt;Ext&gt; for MyEgressHook
where
    Ext: OxyExt&lt;IngressConnectionContext = ConnectProxyConnectionContext&gt;,
{
    fn handle_connection_established(
        &amp;self,
        upstream_addr: SocketAddr,
        egress_ctx: EgressConnectionContext&lt;Ext&gt;,
    ) {
        egress_ctx
            .ingress_ctx()
            .ext()
            .upstream_addr
            .set(upstream_addr);
    }
}

#[async_trait]
impl&lt;Ext&gt; HttpRequestHook&lt;Ext&gt; for MyHttpRequestHook
where
    Ext: OxyExt&lt;IngressConnectionContext = ConnectProxyConnectionContext&gt;,
{
    async fn handle_proxy_connect_response(
        self: Arc&lt;Self&gt;,
        mut res: Response&lt;OxyBody&gt;,
        req_ctx: RequestContext&lt;Ext&gt;,
    ) -&gt; ProxyConnectResponseHandlingOutcome {
        let ingress = req_ctx.ingress_ctx();
        let ingress_ext = ingress.ext();

        if let Some(upstream_addr) = ingress_ext.upstream_addr.get() {
            res.headers_mut().insert(
                "Proxy-Status",
                HeaderValue::from_str(&amp;format!("next-hop=\"{upstream_addr}\"")).unwrap(),
            );
        }

        res.into()
    }
}</code></pre>
	<p>These examples only consider a few of the hooks along the HTTP CONNECT pipeline, but many real Oxy applications don’t even have L7 ingress! We will talk about the abundance of hooks later, but for now let’s look at their implementation.</p>
	<h2>Hook implementation</h2>
	<p>Oxy exists to be used by multiple teams, all with different needs and requirements. It needs a pragmatic solution to extensibility that allows one team to be productive without incurring too much of a cost on others. Hooks and their Opaque Extensions provide effectively limitless customization to applications via a clean, strongly typed interface.</p>
	<p>The implementation of hooks within Oxy is relatively simple – throughout the code there are invocations of hook callbacks:</p>
	<pre class="language-rust"><code class="language-rust">if let Some(ref hook) = self.hook {
    hook.handle_connection_established(upstream_addr, &amp;egress_ctx)
        .await;
}</code></pre>
	<p>If a user-provided hook exists, we call it. Some hooks are more like events (e.g. <code>handle_connection_established</code>), and others have return values (e.g. <code>handle_connection</code>) which are matched on by Oxy for control flow. If a callback isn’t implemented, the default trait implementation is used. If a hook isn’t implemented at all, Oxy’s business logic just executes its default functionality. These levels of default behavior enable the minimal example we started with earlier.</p>
	<p>While hooks solve the problem of integrating app logic into the framework, there is invariably a need to pass custom state around as we demonstrated in our PSK example. Oxy manages this custom state, passing it to hook invocations. As it is generic over the type defined by the application, this is where things get more interesting.</p>
	<h3>Generics and opaque types</h3>
	<p>Every team that works with Oxy has unique business needs, so it is important that one team’s changes don’t cause a cascade of refactoring for the others. Given that these context fields are of a user-defined type, you might expect heavy usage of generics. With Oxy we took a different approach: a generic interface is presented to application developers, but within the framework the type is erased. Keeping generics out of the internal code means adding new extension types to the framework is painless.</p>
	<p>Our implementation relies on the <a href="https://doc.rust-lang.org/std/any/index.html"><code>Any</code></a> trait. The framework treats the data as an opaque blob, but when it traverses the public API, the wrapped Any object is downcast into the concrete type defined by the user. The public API layer enforces that the user type must implement <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a>, which allows Oxy to be wholly responsible for creating and managing instances of the type. Mutations are then done by users of the framework through <a href="https://doc.rust-lang.org/reference/interior-mutability.html">interior mutability</a>, usually with atomics and locks.</p>
	<p>Crates like <a href="https://docs.rs/reqwest-middleware/latest/reqwest_middleware">reqwest_middleware</a>, <a href="https://crates.io/crates/tracing">tracing</a> and <a href="https://crates.io/crates/http">http</a> have a similar extension mechanism.</p>
	<h3>There’s a hook for that</h3>
	<p>As you might have gathered, Oxy cares a lot about the productivity of Oxy app developers. The plethora of injection points lets users quickly add features and functionality without worrying about “irrelevant” proxy logic. Sane defaults help balance customizability with complexity.</p>
	<p>Only a subset of callbacks will be invoked for a given packet: applications operating purely at L3 will see different hook callbacks fired compared to one operating at L7. This again is customizable – if desired, <a href="https://blog.cloudflare.com/introducing-oxy/#on-ramps">Oxy’s design</a> allows connections to be upgraded (or downgraded) &nbsp;which would cause a different set of callbacks to be invoked.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/1gEBrgeFRuB3Nz5D78E1yJ/9caa1d5b8f0433959ee58e54a7e19755/download--2--10.png" alt="" class="kg-image" width="1070" height="1600" loading="lazy">

	</figure>
	<p>The ingress phase is where the hooks controlling the upgrading of L3 and decapsulation of specific L4 protocols reside. For our L3 IP Tunnel, Oxy has powerful callbacks like <code>IpFlowHook::handle_flow</code> which allow applications to drop, upgrade or redirect flows. <code>IpFlowHook::handle_packet</code> gives that same level of control at the packet level – even allowing us to modify the byte array as it passes through.</p>
	<p>Let’s consider the H2 <a href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt">Proxy Protocol</a> example in the above diagram. After Oxy has accepted the Proxy Protocol connection it fires <code>ProxyProtocolConnectionHook::handle_connection</code> with the parsed header, allowing applications to handle any <a href="https://en.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value">TLVs</a> of interest. Hook like these are common – Oxy handles the heavy lifting and then passes the application some useful information.</p>
	<p>From here, L4 connections are funneled through the <code>IngressHook</code> which contains a callback we saw in our initial example: <code>IngressHook::handle_connection</code>. This works as you might expect, allowing applications to control whether to <code>Allow</code> or <code>Block</code> a connection as it ingresses. There is a counterpart: <code>IngressHook::handle_connection_close</code>, which when called gives applications insight into ingress connection statistics like loss, retransmissions, bytes transferred, etc.</p>
	<p>Next up is the transformation phase, where we start to see some of our more powerful hooks. Oxy invokes <code>TunnelHook::should_intercept_https</code>, passing the <a href="https://en.wikipedia.org/wiki/Server_Name_Indication">SNI</a> along with the usual connection context. This enables applications to easily configure HTTPS interception based on hostname and any custom context data (e.g. ACLs). By default, Oxy effectively <a href="https://blog.cloudflare.com/oxy-fish-bumblebee-splicer-subsystems-to-improve-reliability">splices</a> the ingress and egress sockets, but if applications wish to have complete control over the tunneling, that is possible with <code>TunnelHook::get_app_tunnel_pipeline</code>, where applications are simply provided the two sockets and can implement whatever interception capabilities they wish.</p>
	<p>Of particular interest to those wishing to implement L7 firewalls, the <code>HttpRequestHookPipeline</code> has two very powerful callbacks: &nbsp;<code>handle_request</code> and <code>handle_response</code>. Both of these offer a similar high level interface for streaming rewrites or scanning of HTTP bodies.</p>
	<p>The <code>EgressHook</code> has the most callbacks, including some of the most powerful ones. For situations where hostnames are provided, DNS resolution must occur. At its simplest, Oxy allows applications to specify the nameservers used in resolution. If more control is required, Oxy provides a callback – <code>EgressHook::handle_upstream_ips</code> – which gives applications an opportunity to mutate the resolved IP addresses before Oxy connects. If applications want absolute control, they can turn to <code>EgressHook::dns_resolve_override</code> which is invoked with a hostname and expects a <code>Vec&lt;IpAddr&gt;</code> to be returned.</p>
	<p>Much like the <code>IngressHook</code>, there is an <code>EgressHook::handle_connection</code> hook, but rather than just <code>Allow</code> or <code>Block</code>, applications can instruct Oxy to egress their connection externally, internally within Cloudflare, or even downgrade to IP packets. While it’s often best to defer to the framework for connection establishment, Oxy again offers complete control to those who want it with a few override callbacks, e.g. <code>tcp_connect_override</code>, <code>udp_connect_override</code>. This functionality is mainly leveraged by <a href="https://blog.cloudflare.com/cloudflare-servers-dont-own-ips-anymore">our egress service</a>, but available to all Oxy applications if they need it.</p>
	<p>Lastly, one of the newest additions, the <code>AppLifecycleHook</code>. Hopefully this sees orders of magnitude fewer invocations than the rest. The <code>AppLifecycleHook::state_for_restart</code> callback is invoked by Oxy during a graceful shutdown. Applications are then given the opportunity to serialize their state which will be passed to the child process. Graceful restarts are <a href="https://blog.cloudflare.com/graceful-upgrades-in-go">a little more nuanced</a>, but this hook cleanly solves the problem of passing application state between releases of the application.</p>
	<p>Right now we have around 64 public facing hooks and we keep adding more. The above diagram is (largely) accurate at time of writing but if a team needs a hook and there can be a sensible default for it, then it might as well be added. One of the primary drivers of the hook architecture for Oxy is that different teams can work on and implement the hooks that they need. Business logic is kept outside Oxy, so teams can readily leverage each other's work.</p>
	<p>We would be remiss not to mention the issue of discoverability. For most cases, it isn’t an issue, however application developers may find when developing certain features that a more holistic understanding is necessary. This inevitably means looking into the Oxy source to fully understand when and where certain hook callbacks will be invoked. Reasoning about the order callbacks will be invoked is even thornier. Many of the hooks alter control flow significantly, so there’s always some risk that a change in Oxy could mean a change in the semantics of the applications built on top of it. To solve this, we’re experimenting with different ways to record hook execution orders when running integration tests, maybe through a <a href="https://doc.rust-lang.org/reference/procedural-macros.html">proc-macro</a> or compiler tooling.</p>
	<h2>Conclusion</h2>
	<p>In this post we’ve just scratched the surface of what’s possible with hooks in Oxy. In our example we saw a glimpse of their power: just two simple hooks and a few lines of code, and we have a forward proxy with built-in metrics, tracing, graceful restarts and much, much more.</p>
	<p>Oxy’s extensibility with hooks is “only” dependency injection, but we’ve found this to be an extremely powerful way to build proxies. It’s dependency injection at all layers of the networking stack, from IP packets and tunnels all the way up to proxied UDP streams over QUIC. The shared core with hooks approach has been a terrific way to build a proxy framework. Teams add generic code to the framework, such as new Opaque Extensions in specific code paths, and then use those injection points to implement the logic for everything from <a href="https://blog.cloudflare.com/icloud-private-relay">iCloud Private Relay</a> to <a href="https://blog.cloudflare.com/warp-to-warp">Cloudflare Zero Trust</a>. The generic capabilities are there for all teams to use, and there’s very little to no cost if you decide not to use them. We can’t wait to see what the future holds and for Oxy’s further adoption within Cloudflare.</p>
</div>