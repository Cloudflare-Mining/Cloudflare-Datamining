{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "11",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Juan Miguel Cejuela",
				"slug": "juan-miguel-cejuela",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/7xNmoPH4z9aRMGppMiktnI/fd1eb08762fb7187ff475d3b34d4d6c5/juan-miguel-cejuela.jpg",
				"location": null,
				"website": null,
				"twitter": "@juanmirocks",
				"facebook": null
			},
			{
				"name": "Zhiyuan Zheng",
				"slug": "xmflsct",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1P7uGGL8VL5tDIimsTxWo1/5a08bf32629b5bab2ecee50b73ba8c61/xmflsct.jpg",
				"location": "Netherlands",
				"website": "https://xmflsct.com",
				"twitter": null,
				"facebook": null
			}
		],
		"excerpt": "Learn more about how Cloudflare developed an AI model to uncover malicious JavaScript intent using a Graph Neural Network, from pre-processing data to inferencing at scale. ",
		"feature_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1o9yaTNN9SM62ZTRbuG5VG/c6d53aa5ea8fad514d392c3d6c05f4d1/Feature_Image.png",
		"featured": false,
		"html": "<p>Modern websites <a href=\"https://blog.cloudflare.com/application-security-report-2024-update/#enterprise-applications-use-47-third-party-scripts-on-average\"><u>rely heavily</u></a> on JavaScript. Leveraging third-party scripts accelerates web app development, enabling organizations to deploy new features faster without building everything from scratch. However, supply chain attacks targeting third-party JavaScript are no longer just a theoretical concern — they have become a reality, as <a href=\"https://blog.cloudflare.com/polyfill-io-now-available-on-cdnjs-reduce-your-supply-chain-risk/\"><u>recent incidents</u></a> have shown. Given the vast number of scripts and the rapid pace of updates, manually reviewing each one is not a scalable security strategy.</p><p>Cloudflare provides automated client-side protection through <a href=\"https://developers.cloudflare.com/page-shield/\"><u>Page Shield</u></a>. Until now, Page Shield could scan JavaScript dependencies on a web page, flagging obfuscated script content which also exfiltrates data. However, these are only indirect indicators of compromise or malicious intent. Our original approach didn’t provide clear insights into a script’s specific malicious objectives or the type of attack it was designed to execute.</p><p>Taking things a step further, we have developed a new AI model that allows us to detect the exact malicious intent behind each script. This intelligence is now integrated into Page Shield, available to all Page Shield <a href=\"https://developers.cloudflare.com/page-shield/#availability\"><u>add-on</u></a> customers. We are starting with three key threat categories: <a href=\"https://en.wikipedia.org/wiki/Web_skimming\"><u>Magecart</u></a>, crypto mining, and malware.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6EefJpCcho3DIjbVbQIjuz/68852b905955065e48ec2aa4648621cd/1.png\" alt=\"\" class=\"kg-image\" width=\"1999\" height=\"371\" loading=\"lazy\"/>\n          </figure><p><sup><i>Screenshot of Page Shield dashboard showing results of three types of analysis.</i></sup></p><p>With these improvements, Page Shield provides deeper visibility into client-side threats, empowering organizations to better protect their users from evolving security risks. This new capability is available to all Page Shield customers with the <a href=\"https://developers.cloudflare.com/page-shield/#availability\"><u>add-on</u></a>. Head over <a href=\"https://dash.cloudflare.com/?to=/:account/:zone/security/page-shield\"><u>to the dashboard</u></a>, and you can find the new malicious code analysis for each of the scripts monitored.</p><p>In the following sections, we take a deep dive into how we developed this model.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"training-the-model-to-detect-hidden-malicious-intent\">Training the model to detect hidden malicious intent</h3>\n            <a href=\"#training-the-model-to-detect-hidden-malicious-intent\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>We built this new Page Shield AI model to detect the intent of JavaScript threats at scale. Training such a model for JavaScript comes with unique challenges, including dealing with web code written in many different styles, often obfuscated yet benign. For instance, the following three snippets serve the same function.</p>\n            <pre class=\"language-JavaScript\"><code class=\"language-JavaScript\">//Readable, plain code\nfunction sayHi(name) {\n  console.log(\n    `Hello ${\n      name ?? \n      &quot;World&quot; //default\n    }!`\n  );\n}\nsayHi(&quot;Internet&quot;);\n\n//Minified\nfunction sayHi(l){console.log(`Hello ${l??&quot;World&quot;}!`)}sayHi(&quot;Internet&quot;);\n\n//Obfuscated\nvar h=Q;(function(V,A){var J=Q,p=V();while(!![]){try{var b=-parseInt(J(&#039;0x79&#039;))/0x1*(-parseInt(J(&#039;0x6e&#039;))/0x2)+-parseInt(J(&#039;0x80&#039;))/0x3+parseInt(J(&#039;0x76&#039;))/0x4*(-parseInt(J(&#039;0x72&#039;))/0x5)+parseInt(J(&#039;0x6a&#039;))/0x6+parseInt(J(&#039;0x84&#039;))/0x7+-parseInt(J(&#039;0x6d&#039;))/0x8*(-parseInt(J(&#039;0x7d&#039;))/0x9)+parseInt(J(&#039;0x73&#039;))/0xa*(-parseInt(J(&#039;0x7c&#039;))/0xb);if(b===A)break;else p[&#039;push&#039;](p[&#039;shift&#039;]());}catch(U){p[&#039;push&#039;](p[&#039;shift&#039;]());}}}(S,0x22097));function sayHi(p){var Y=Q,b=(function(){var W=!![];return function(e,x){var B=W?function(){var m=Q;if(x){var G=x[m(&#039;0x71&#039;)](e,arguments);return x=null,G;}}:function(){};return W=![],B;};}()),U=b(this,function(){var s=Q,W=typeof window!==s(&#039;0x6b&#039;)?window:typeof process===s(&#039;0x6c&#039;)&amp;&amp;typeof require===s(&#039;0x7b&#039;)&amp;&amp;typeof global===&#039;object&#039;?global:this,e=W[&#039;console&#039;]=W[&#039;console&#039;]||{},x=[s(&#039;0x78&#039;),s(&#039;0x70&#039;),&#039;info&#039;,s(&#039;0x69&#039;),s(&#039;0x77&#039;),&#039;table&#039;,s(&#039;0x7f&#039;)];for(var B=0x0;B&lt;x[s(&#039;0x83&#039;)];B++){var G=b[s(&#039;0x75&#039;)][s(&#039;0x6f&#039;)][s(&#039;0x74&#039;)](b),t=x[B],X=e[t]||G;G[&#039;__proto__&#039;]=b[s(&#039;0x74&#039;)](b),G[&#039;toString&#039;]=X[s(&#039;0x7e&#039;)][&#039;bind&#039;](X),e[t]=G;}});U(),console[&#039;log&#039;](Y(&#039;0x81&#039;)+(p??Y(&#039;0x7a&#039;))+&#039;!&#039;);}sayHi(h(&#039;0x82&#039;));function Q(V,A){var p=S();return Q=function(b,U){b=b-0x69;var W=p[b];return W;},Q(V,A);}function S(){var v=[&#039;Internet&#039;,&#039;length&#039;,&#039;77966Hcxgji&#039;,&#039;error&#039;,&#039;1078032RtaGFM&#039;,&#039;undefined&#039;,&#039;object&#039;,&#039;8zrzBEk&#039;,&#039;244xEPFaR&#039;,&#039;prototype&#039;,&#039;warn&#039;,&#039;apply&#039;,&#039;10LQgYRU&#039;,&#039;400TNVOzq&#039;,&#039;bind&#039;,&#039;constructor&#039;,&#039;146612cfnkCX&#039;,&#039;exception&#039;,&#039;log&#039;,&#039;1513TBJIGL&#039;,&#039;World&#039;,&#039;function&#039;,&#039;57541MkoqrR&#039;,&#039;2362383dtBFrf&#039;,&#039;toString&#039;,&#039;trace&#039;,&#039;647766YvOJOm&#039;,&#039;Hello\\x20&#039;];S=function(){return v;};return S();}</pre></code>\n            <p>With such a variance of styles (and many more), our machine learning solution needs to balance precision (low false positive rate), recall (don’t miss an attack vector), and speed. Here’s how we do it:</p><h4>Using syntax trees to classify malicious code</h4><p>JavaScript files are parsed into <a href=\"https://en.wikipedia.org/wiki/Tree_(graph_theory)\"><u>syntax trees (connected acyclic graphs)</u></a>. These serve as the input to a <a href=\"https://en.wikipedia.org/wiki/Graph_neural_network\"><u>Graph Neural Network (GNN)</u></a>. GNNs are used because they effectively capture the interdependencies (relationships between nodes) in executing code, such as a function calling another function. This contrasts with treating the code as merely a sequence of words — something a code compiler, incidentally, does not do. Another motivation to use GNNs is the <a href=\"https://dl.acm.org/doi/10.1007/978-3-030-92270-2_57\"><u>insight</u></a> that the syntax trees of malicious versus benign JavaScript tend to be different. For example, it’s not rare to find attacks that consist of malicious snippets inserted into, but otherwise isolated from, the rest of a benign base code.</p><p>To parse the files, the <a href=\"https://tree-sitter.github.io/\"><u>tree-sitter library</u></a> was chosen for its speed. One peculiarity of this parser, specialized for text editors, is that it parses out <a href=\"https://en.wikipedia.org/wiki/Parse_tree\"><u>concrete syntax trees (CST)</u></a>. CSTs retain everything from the original text input, including spacing information, comments, and even nodes attempting to repair syntax errors. This differs from <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\"><u>abstract syntax trees (AST)</u></a>, the data structures used in compilers, which have just the essential information to execute the underlying code while ignoring the rest. One key reason for wanting to convert the CST to an AST-like structure, is that it reduces the tree size, which in turn reduces computation and memory usage. To do that, we abstract and filter out unnecessary nodes such as code comments. Consider for instance, how the following snippet</p>\n            <pre class=\"language-JavaScript\"><code class=\"language-JavaScript\">x = `result: ${(10+5) *   3}`;;; //this is a comment</pre></code>\n            <p>… gets converted to an AST-like representation:</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4KweWZ4yIzOTiIcYqHC682/56c059b38ad46949e7285d84438be4c9/2.png\" alt=\"\" class=\"kg-image\" width=\"1999\" height=\"1520\" loading=\"lazy\"/>\n          </figure><p><sup><i>Abstract Syntax Tree (AST) representation of the sample code above. Unnecessary elements get removed (e.g. comments, spacing) whereas others get encoded in the tree structure (order of operations due to parentheses).</i></sup></p><p>One benefit of working with parsed syntax trees is that <a href=\"https://huggingface.co/learn/nlp-course/en/chapter2/4\"><u>tokenization</u></a> comes for free! We collect and treat the node leaves’ text as our tokens, which will be used as features (inputs) for the machine learning model. Note that multiple characters in the original input, for instance backticks to form a template string, are not treated as tokens per se, but remain encoded in the graph structure given to the GNN. (Notice in the sample tree representations the different node types, such as “assignment_expression”). Moreover, some details in the exact text input become irrelevant in the executing AST, such as whether a string was originally written using double quotes vs. single quotes.</p><p>We encode the node tokens and node types into a matrix of counts. Currently, we lowercase the nodes&#39; text to reduce vocabulary size, improving efficiency and reducing sparsity. Note that JavaScript is a case-sensitive language, so this is a trade-off we continue to explore. This matrix and, importantly, the information about the node edges within the tree, is the input to the GNN.</p><p>How do we deal with obfuscated code? We don’t treat it specially. Rather, we always parse the JavaScript text as is, which incidentally unescapes <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Character_escape\"><u>escape characters</u></a> too. For instance, the resulting AST shown below for the following input exemplifies that:</p>\n            <pre class=\"language-JavaScript\"><code class=\"language-JavaScript\">atob(&#039;\\x55\\x32\\x56\\x75\\x5a\\x45\\x52\\x68\\x64\\x47\\x45\\x3d&#039;) == &quot;SendData&quot;</pre></code>\n            \n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/sV2qPtj8G30EFnW6rwCav/ef0a970e338e5610da08fa3ccbdeafcc/3.png\" alt=\"\" class=\"kg-image\" width=\"1999\" height=\"1080\" loading=\"lazy\"/>\n          </figure><p><sup><i>Abstract Syntax Tree (AST) representation of the sample code above. JavaScript escape characters are unescaped.</i></sup></p><p>Moreover, our vocabulary contains several tokens that are commonly used in obfuscated code, such as double escaped hexadecimal-encoded characters. That, together with the graph structure information, is giving us satisfying results — the model successfully classifies malicious code whether it&#39;s obfuscated or not. Analogously, our model’s scores remain stable when applied to plain benign scripts compared to obfuscating them in different ways. In other words, the model’s score on a script is similar to the score on an obfuscated version of the same script. Having said that, some of our model&#39;s false positives (FPs) originate from benign but obfuscated code, so we continue to investigate how we can improve our model&#39;s intelligence.</p><h4>Architecting the Graph Neural Network</h4><p>We train a <a href=\"https://mbernste.github.io/posts/gcn/\"><u>message-passing graph convolutional network (MPGCN)</u></a> that processes the input trees. The message-passing layers iteratively update each node’s internal representation, encoded in a matrix, by aggregating information from its neighbors (parent and child nodes in the tree). A pooling layer then condenses this matrix into a feature vector, discarding the explicit graph structure (edge connections between nodes). At this point, standard neural network layers, such as fully connected layers, can be applied to progressively refine the representation. Finally, a <a href=\"https://en.wikipedia.org/wiki/Softmax_function\"><u>softmax activation</u></a> layer produces a probability distribution over the four possible classes: benign, magecart, cryptomining, and malware.</p><p>We use the <a href=\"https://github.com/tensorflow/gnn\"><u>TF-GNN library</u></a> to implement graph neural networks, with <a href=\"https://keras.io/\"><u>Keras</u></a> serving as the high-level frontend for model building and training. This works well for us with one exception: <a href=\"https://github.com/tensorflow/gnn/issues/803#issue-2279602052\"><u>TF-GNN does not support sparse matrices / tensors</u></a>. (That lack of support increases memory consumption, which also adds some latency.) Because of this, we are considering switching to <a href=\"https://pytorch-geometric.readthedocs.io/\"><u>PyTorch Geometric</u></a> instead.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/79SbvJgWq3mwMks6Vtxpgs/5ab55f19b6cf90dc070b5f0d70abdde9/4.png\" alt=\"\" class=\"kg-image\" width=\"1999\" height=\"1228\" loading=\"lazy\"/>\n          </figure><p><sup><i>Graph neural network architecture, transforming the input tree with features down to the 4 classification probabilities.</i></sup></p><p>The model’s output probabilities are finally inverted and scaled into <a href=\"https://developers.cloudflare.com/page-shield/how-it-works/malicious-script-detection/#malicious-script-detection\"><u>scores</u></a> (ranging from 1 to 99). The “js_integrity” score aggregates the malicious classes (magecart, malware, cryptomining). A low score means likely malicious, and a high score means likely benign. We use this output format for consistency with other Cloudflare detection systems, such as <a href=\"https://developers.cloudflare.com/page-shield/how-it-works/malicious-script-detection/#malicious-script-detection\"><u>Bot Management</u></a> and the <a href=\"https://developers.cloudflare.com/waf/detections/attack-score/\"><u>WAF Attack Score</u></a>. The following diagram illustrates the preprocessing and feature analysis pipeline of the model down to the inference results.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/zLPW9kydBIJySfjaN2TTI/d7b9a7f51c1bb501aac2b7a724d62a1d/5.png\" alt=\"\" class=\"kg-image\" width=\"1999\" height=\"1347\" loading=\"lazy\"/>\n          </figure><p><sup><i>Model inference pipeline to sniff out and alert on malicious JavaScript.</i></sup></p><h4>Tackling unbalanced data: malicious scripts are the minority</h4><p>Finding malicious scripts is like finding a needle in a haystack; they are anomalies among plenty of otherwise benign JavaScript. This naturally results in a highly imbalanced dataset. For example, our Magecart-labeled scripts only account for ~6% of the total dataset.</p><p>Not only that, but the “benign” category contains an immense variance (and amount) of JavaScript to classify. The lengths of the scripts are highly diverse (ranging from just a few bytes to several megabytes), their coding styles vary widely, some are obfuscated whereas others are not, etc. To make matters worse, malicious payloads are often just small, carefully inserted fragments within an otherwise perfectly valid and functional benign script. This all creates a cacophony of token distributions for an ML model to make sense of.</p><p>Still, our biggest problem remains finding enough malevolent JavaScript to add to our training dataset. Thus, simplifying it, our strategy for data collection and annotation is two-fold:</p><ol><li><p>Malicious scripts are about quantity → the more, the merrier (for our model, that is 😉). Of course, we still care about quality and diversity. But because we have so few of them (in comparison to the number of benign scripts), we take what we can.</p></li><li><p>Benign scripts are about quality → the more <i>variance</i>, the merrier. Here we have the opposite situation. Because we can collect so many of them easily, the value is in adding differentiated scripts.</p></li></ol><h5>Learning key scripts only: reduce false positives with minimal annotation time</h5><p>To filter out semantically-similar scripts (mostly benign), we employed the latest advancements in LLM for generating code <a href=\"https://www.cloudflare.com/learning/ai/what-are-embeddings/\"><u>embeddings</u></a>. We added those scripts that are distant enough from each other to our dataset, as measured by <a href=\"https://developers.cloudflare.com/vectorize/best-practices/create-indexes/#distance-metrics\"><u>vector cosine similarity</u></a>. Our methodology is simple — for a batch of potentially new scripts:</p><ul><li><p>Initialize an empty <a href=\"https://www.cloudflare.com/learning/ai/what-is-vector-database/\"><u>vector database</u></a>. For local experimentation, we are fans of <a href=\"https://docs.trychroma.com/docs/overview/introduction\"><u>Chroma DB</u></a>.</p></li><li><p>For each script:</p><ul><li><p>Call an LLM to generate its embedding. We’ve had good results with <a href=\"https://github.com/bigcode-project/starcoder2\"><u>starcoder2</u></a>, and most recently <a href=\"https://huggingface.co/Qwen/Qwen2.5-Coder-32B\"><u>qwen2.5-coder</u></a>.</p></li><li><p>Search in the database for the top-1 closest other script’s vectors.</p></li><li><p>If the distance &gt; threshold (0.10), select it and add it to the database.</p></li><li><p>Else, discard the script (though we consider it for further validations and tests).</p></li></ul></li></ul><p>Although this methodology has an inherent bias in gradually favoring the first seen scripts, in practice we’ve used it for batches of newly and randomly sampled JavaScript only. To review the whole existing dataset, we could employ other but similar strategies, like applying <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.cluster.HDBSCAN.html\"><u>HDBSCAN</u></a> to identify an unknown number of clusters and then selecting the medoids, boundary, and anomaly data points.</p><p>We’ve successfully employed this strategy for pinpointing a few highly varied scripts that were relevant for the model to learn from. Our security researchers save a tremendous amount of time on manual annotation, while false positives are drastically reduced. For instance, in a large and unlabeled bucket of scripts, one of our early evaluation models identified ~3,000 of them as malicious. That’s too many to manually review! By removing near duplicates, we narrowed the need for annotation down to only 196 samples, less than 7% of the original amount (see the <a href=\"https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding\"><u>t-SNE</u></a> visualization below of selected points and clusters). Three of those scripts were actually malicious, one we could not fully determine, and the rest were benign. By just re-training with these new labeled scripts, a tiny fraction of our whole dataset, we reduced false positives by 50% (as gauged in the same bucket and in a controlled test set). We have consistently repeated this procedure to iteratively enhance successive model versions.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/hHw00ojXE4CdorMQI5b56/897e0e045230522478e0735c3e28ff12/6.png\" alt=\"\" class=\"kg-image\" width=\"1999\" height=\"1551\" loading=\"lazy\"/>\n          </figure><p><sup><i>2D visualization of scripts projected onto an embedding space, highlighting those sufficiently dissimilar from one another.</i></sup></p><h4>From the lab, to the real world</h4><p>Our latest model in evaluation has both a macro accuracy and an overall malicious precision nearing 99%(!) on our test dataset. So we are done, right? Wrong! The real world is not the same as the lab, where many more variances of benign JavaScript can be seen. To further assure minimum prediction changes between model releases, we follow these three anti-fool measures:</p><h5>Evaluate metrics uncertainty</h5><p>First, we thoroughly estimate the <i>uncertainty</i> of our offline evaluation metrics. How accurate are our accuracy metrics themselves? To gauge that, we calculate the <a href=\"https://en.wikipedia.org/wiki/Standard_error\"><u>standard error</u></a> and confidence intervals for our offline metrics (precision, recall, <a href=\"https://en.wikipedia.org/wiki/F-score\"><u>F1 measure</u></a>). To do that, we calculate the model’s predicted scores on the test set once (the original sample), and then generate bootstrapped resamples from it. We use simple random (re-)sampling as it offers us a more conservative estimate of error than stratified or balanced sampling.</p><p>We would generate 1,000 resamples, each a fraction of 15% resampled from the original test sample, then calculate the metrics for each individual resample. This results in a distribution of sampled data points. We measure its mean, the standard deviation (with <a href=\"https://en.wikipedia.org/wiki/Standard_deviation#Corrected_sample_standard_deviation\"><u>Bessel’s correction</u></a>), and finally the standard error and a <a href=\"https://en.wikipedia.org/wiki/Confidence_interval\"><u>confidence interval</u></a> (CI) (using the percentile method, such as the 2.5 and 97.5 percentiles for a 95% CI). See below for an example of a bootstrapped distribution for precision (P), illustrating that a model’s performance is a continuum rather than a fixed value, and that might exhibit subtly (left-)skewed tails. For some of our internally evaluated models, it can easily happen that some of the sub-sampled metrics decrease by up to 20 percentage points within a 95% confidence range. High standard errors and/or confidence ranges signal needs for model improvement and for improving and increasing our test set.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2x3X2oVv2EfIkLYFrcjLWK/985a685e565f759b7781821595ac4ff7/7.png\" alt=\"\" class=\"kg-image\" width=\"1999\" height=\"1279\" loading=\"lazy\"/>\n          </figure><p><sup><i>An evaluation metric, here precision (P), might change significantly depending on what’s exactly tested. We thoroughly estimate the metric’s standard error and confidence intervals.</i></sup></p><h5>Benchmark against massive offline unlabeled dataset</h5><p>We run our model on the entire corpus of scripts seen by Cloudflare&#39;s network and temporarily cached in the last 90 days. By the way, that’s nearly 1 TiB and 26 million different JavaScript files! With that, we can observe the model’s behavior against real traffic, yet completely offline (to ensure no impact to production). We check the malicious prediction rate, latency, throughput, etc. and sample some of the predictions for verification and annotation.</p><h5>Review in staging and shadow mode</h5><p>Only after all the previous checks were cleared, we then run this new tentative version in our staging environment. For major model upgrades, we also deploy them in <a href=\"https://cloud.google.com/architecture/guidelines-for-developing-high-quality-ml-solutions\"><u>shadow mode</u></a> (log-only mode) — running on production, alongside our existing model. We study the model’s behavior for a while before finally marking it as production ready, otherwise we go back to the drawing board.</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"ai-inference-at-scale\">AI inference at scale</h3>\n            <a href=\"#ai-inference-at-scale\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>At the time of writing, Page Shield sees an average of <i>40,000 scripts per second</i>. Many of those scripts are repeated, though. Everything on the Internet follows a <a href=\"https://blog.cloudflare.com/making-waf-ai-models-go-brr/#caching-inference-result\"><u>Zipf&#39;s law distribution</u></a>, and JavaScript seen on the Cloudflare network is no exception. For instance, it is estimated that different versions of the <a href=\"https://blog.cloudflare.com/page-shield-positive-blocking-policies/#client-side-libraries\"><u>Bootstrap library run on more than 20% of websites</u></a>. It would be a waste of computing resources if we repeatedly re-ran the AI model for the very same inputs — inference result caching is needed. Not to mention, GPU utilization is expensive!</p><p>The question is, what is the best way to cache the scripts? We could take an <a href=\"https://csrc.nist.gov/glossary/term/sha_256\"><u>SHA-256</u></a> hash of the plain content as is. However, any single change in the transmitted content (comments, spacing, or a different character set) changes the SHA-256 output hash.</p><p>A better caching approach? Since we need to parse the code into syntax trees for our GNN model anyway, this tree structure and content is what we use to hash the JavaScript. As described above, we filter out nodes in the syntax tree like comments or empty statements. In addition, some irrelevant details get abstracted out in the AST (escape sequences are unescaped, the way of writing strings is normalized, unnecessary parentheses are removed for the operations order is encoded in the tree, etc.).</p><p>Using such a tree-based approach to caching, we can conclude that at any moment over 99.9% of reported scripts have already been seen in our network! Unless we deploy a new model with significant improvements, we don’t re-score previously seen JavaScript but just return the cached score. As a result, the model only needs to be called <i>fewer than 10 times per minute</i>, even during peak times!</p>\n          <div class=\"flex anchor relative\">\n            <h3 id=\"let-ai-help-ease-pci-dss-v4-compliance\">Let AI help ease PCI DSS v4 compliance</h3>\n            <a href=\"#let-ai-help-ease-pci-dss-v4-compliance\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n        <p>One of the most popular use cases for deploying Page Shield is to help meet the two new client-side security requirements in PCI DSS v4 — <a href=\"https://assets.ctfassets.net/slt3lc6tev37/4HJex2kG7FCb1IJRC9rIhL/081fdd8b1a471def14cfd415f99e4b58/Evaluation_Page_Shield_091124_FINAL.pdf\"><u>6.4.3 and 11.6.1</u></a>. These requirements make companies responsible for approving scripts used in payment pages, where payment card data could be compromised by malicious JavaScript. Both of these requirements <a href=\"https://blog.pcisecuritystandards.org/countdown-to-pci-dss-v4.0\"><u>become effective</u></a> on March 31, 2025.</p><p>Page Shield with AI malicious JavaScript detection can be deployed with just a few clicks, especially if your website is already proxied through Cloudflare. <a href=\"https://www.cloudflare.com/page-shield/\"><u>Sign up here</u></a> to fast track your onboarding!</p>",
		"id": "3VQUOQBWzT8cc7oFFv003i",
		"localeList": {
			"name": "blog-english-only",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "Learn more about how Cloudflare developed an AI model to uncover malicious JavaScript intent using a Graph Neural Network, from pre-processing data to inferencing at scale. ",
		"metadata": {
			"title": "How we train AI to uncover malicious JavaScript intent and make web surfing safer",
			"description": "Learn more about how Cloudflare developed an AI model to uncover malicious JavaScript intent using a Graph Neural Network, from pre-processing data to inferencing at scale.This AI model is part of our Page Shield offering, helping make web surfing safer.",
			"imgPreview": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/22SXBNpNrhwPyjv2hag6Hv/613dc1d6884e90ec842d4ed7c09b0934/OG_Share_2024__16_.png"
		},
		"primary_author": {},
		"published_at": "2025-03-19T13:00+00:00",
		"slug": "how-we-train-ai-to-uncover-malicious-javascript-intent-and-make-web-surfing-safer",
		"tags": [
			{
				"id": "3DmitkNK6euuD5BlhuvOLW",
				"name": "Security Week",
				"slug": "security-week"
			},
			{
				"id": "6stQ7u3dAyBmZithR7rBBD",
				"name": "Page Shield",
				"slug": "page-shield"
			},
			{
				"id": "6Foe3R8of95cWVnQwe5Toi",
				"name": "AI",
				"slug": "ai"
			},
			{
				"id": "1HAYmR545ufVxM2rQzz0SE",
				"name": "Machine Learning",
				"slug": "machine-learning"
			},
			{
				"id": "7BhREQYSSCo9INFzIXH0G0",
				"name": "Malicious JavaScript",
				"slug": "malicious-javascript"
			},
			{
				"id": "78aSAeMjGNmCuetQ7B4OgU",
				"name": "JavaScript",
				"slug": "javascript"
			}
		],
		"title": "How we train AI to uncover malicious JavaScript intent and make web surfing safer",
		"updated_at": "2025-03-19T13:00:04.030Z",
		"url": "https://blog.cloudflare.com/how-we-train-ai-to-uncover-malicious-javascript-intent-and-make-web-surfing-safer"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.icon_aria_label": "Search",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"search.result_stat_empty": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong>",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"search.autocomplete_title": "Insert a query. Press enter to send",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}