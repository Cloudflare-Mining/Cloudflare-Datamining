{
	"initialReadingTime": "9",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Luke Edwards",
				"slug": "lukeed",
				"bio": "Developer Advocate for Cloudflare Workers. Probably building an example, a library, or a half-finished framework. ",
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/5JuHHFm6EOJc3LA6Odqu3F/a878aa70e3a022d6032fba1956d893c5/lukeed.jpg",
				"location": "San Francisco, CA",
				"website": "https://lukeed.com",
				"twitter": "@lukeed05",
				"facebook": null
			}
		],
		"excerpt": "If you haven’t already heard, we’re hosting the Cloudflare Summer Developer Challenge, a contest for the Cloudflare community at large. Anybody – yes, including you – can sign up for free and compete for a chance to win one of 300 available prizes. ",
		"feature_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/1bUxZIWjqUYMxuN7U1XILS/35531c757470adfdef140872e90b9814/building-the-cloudflare-summer-challenge-application.png",
		"featured": false,
		"html": "\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/5iFPcUKI0TUH6QFrr6P95R/146888091f8f77a1f3b6e4998731cccc/Developer-Challenge.png\" alt=\"\" class=\"kg-image\" width=\"1618\" height=\"800\" loading=\"lazy\"/>\n            \n            </figure><p>If you haven’t already heard, we’re hosting the <a href=\"/developer-summer-challenge\">Cloudflare Summer Developer Challenge</a>, a contest for the Cloudflare community at large. Anybody – yes, including you – can sign up for free and compete for a chance to win one of 300 available prizes. To submit you need to use  at least two products from the <a href=\"https://developers.cloudflare.com/\">Cloudflare developer platform</a> — which makes this contest a great opportunity to give them a try if you haven’t already! The top 300 submissions will receive a box of our most popular swag, so you should give it a go!</p><p>Coincidentally, the Cloudflare Summer Developer Challenge’s landing page and signup workflow qualifies as a valid project submission (so meta), so if you’re looking for some inspiration, this walkthrough will shed some light on how it was built.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"overview\">Overview</h2>\n            <a href=\"#overview\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>At its core, the application is a series of static HTML pages, most of which have a form to submit, with a backend API to handle those submissions, and a storage layer to persist the data. In a Cloudflare lens, this would point towards using Pages, a Worker, and Workers KV. And while this <i>should be</i> the preferred stack for a project like this, truthfully, this “application” was originally intended to be a single HTML page with a single form, but its list of requirements grew over time, as things tend to do. So instead, this project began as–and remains–a Workers Site project, comprised of a single Worker and a single Workers KV namespace.</p><p>Workers Sites, the precursor to our <a href=\"https://pages.dev/\">Pages</a> product, is a pattern where your Worker handles all the requests for your site’s assets. While doing this, your Worker Site can still include backend-y things, like offering a collection of JSON API endpoints. Basically, Workers Sites is a coined term for building monoliths within a Worker, but without the negative associations that the word “monolith” can bring. Given that a Workers Site is still a Worker, this means your monolith is deployed globally – tough to beat!</p><p>As with all Workers Sites, routing is the primary concern. For this, I used the <a href=\"https://github.com/lukeed/worktop\"><code>worktop</code></a> web framework, which includes a router among many other utilities. <i>(Disclosure: I am also the author of worktop.)</i> This allowed me to quickly structure the layout of the entire application:</p>\n            <pre class=\"language-ts\"><code class=\"language-ts\">import { Router } from &#039;worktop&#039;;\nimport * as Cache from &#039;worktop/cache&#039;;\n\nconst API = new Router;\n\nAPI.add(&#039;GET&#039;, &#039;/&#039;, (req, res) =&gt; {\n  res.send(200, &#039;TODO: send HTML for landing page&#039;);\n});\n\nAPI.add(&#039;GET&#039;, &#039;/rules&#039;, (req, res) =&gt; {\n  res.send(200, &#039;TODO: send HTML for terms &amp; conditions&#039;);\n});\n\nAPI.add(&#039;POST&#039;, &#039;/signup&#039;, (req, res) =&gt; {\n  res.send(201, &#039;TODO: parse &amp; save initial registration&#039;);\n});\n\nAPI.add(&#039;GET&#039;, &#039;/submit&#039;, (req, res) =&gt; {\n  res.send(200, &#039;TODO: render the unique submission form&#039;);\n});\n\nAPI.add(&#039;POST&#039;, &#039;/submit&#039;, (req, res) =&gt; {\n  res.send(201, &#039;TODO: parse, validate, save submission data&#039;);\n});\n\n// init; w/ Cache API\nCache.listen(API.run);</pre></code>\n            <p>At this point, nothing useful is happening, but having an application skeleton laid out like this is my preferred format for a TODO list. It’s very satisfying to go through and fill out the handler bodies as development progresses. Additionally, the <code>Cache.listen</code> helper at the bottom of the file integrates the entire application with the Cache API, which I know I’ll want since most of the requests will be for the static HTML pages anyway.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"building-and-optimizing-the-client-pages\">Building and Optimizing the Client pages</h2>\n            <a href=\"#building-and-optimizing-the-client-pages\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Historically, deploying a Workers Site meant uploading all of your assets into a KV namespace. Then you would include something like <a href=\"https://github.com/cloudflare/kv-asset-handler\"><code>@cloudflare/kv-asset-handler</code></a> into your Worker so that incoming requests would seamlessly route to keys within the namespace. However, I chose to go a different route.</p><p>Knowing that each of my static pages would – at most – have <i>one</i> CSS stylesheet and sometimes only <i>one</i> JavaScript file, I thought it would be pretty nifty to include a build system that would <i>inline</i> these assets into the built HTML page. This would mean that my static HTML pages would have <i>absolutely zero</i> network requests for additional resources, which is generally good news for performance.</p><blockquote><p><i>And while I would love to say that I did this purely for performance reasons, I must also admit that the lazy-me appreciated that I didn’t have to set up additional URL routing, deal with KV asset uploading, or deal with additional Cache lifespans. A win-win in this case!</i></p></blockquote><p>The trouble is: avoiding any external assets is not a common goal. In fact, this is very much a side quest I bestowed upon myself. And since no frameworks (that I know of, at least) can do this, I had to assemble my own miniature toolkit to accommodate my needs.</p><p>In the end, it proved to be a fun detour and didn’t take very long at all <a href=\"https://github.com/cloudflare/developer-summer-challenge/blob/master/bin/html.js\">to put together</a>. I incorporated <a href=\"https://stylus-lang.com/\">Stylus</a>, my preferred CSS preprocessor, and came up with a rather simple convention to inline CSS and/or JS files where needed. Instead of fancy AST parsers and transformers, I opted to simply read the HTML file contents as strings and search for HTML comments that matched the <code>&lt;!-- inject:(path) --&gt;</code> format:</p>\n            <pre class=\"language-html\"><code class=\"language-html\">&lt;!-- submit/index.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot;/&gt;\n    &lt;title&gt;Submit Project | Cloudflare Developer Summer Challenge&lt;/title&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;https://www.cloudflare.com/favicon-128.png&quot;&gt;\n    &lt;!-- inject:submit/index.styl --&gt;\n    &lt;!-- inject:index.js --&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- ... --&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre></code>\n            <p>In this example, the <code>submit/index.html</code> file is injecting the <code>submit/index.styl</code>, which is its own stylesheet, and the <code>index.js</code> script, which does not live within the `submit` directory because it’s used by other pages. The toolkit looks at both asset paths, converts the Stylus to plain CSS, and then embeds the contents into the appropriate <code>&lt;script&gt;</code> or <code>&lt;style&gt;</code> HTML tags.</p><p>Finally, for production builds, the setup will pass the final HTML source through a minifier, which compresses the entire document, including any CSS or JavaScript that was injected. This step is optional, but it never hurts to send fewer bytes down the wire.</p><p>Once these pages were built, I was satisfied with the Network Activity panel when loading the main page:</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/51lvxbE7cmM4R9fbrSheCC/6c5a5badb4293b3a767b1be85a42896b/network.png\" alt=\"The Network Activity in Chrome Developer Tools when loading the landing page. There is only one external asset request for the favicon, which is hosted elsewhere.\" class=\"kg-image\" width=\"874\" height=\"388\" loading=\"lazy\"/>\n            \n            </figure><p>You can see how the <code>localhost</code> document loads, only dispatching a single request for the <code>favicon-128.png</code> file, which is hosted externally. The three <code>data:image/*</code> requests are <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Blob\">Blob URLs</a> and don’t actually transfer network packets. All in all, this means that the HTML document is fully self-contained.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"including-html-into-the-worker\">Including HTML into the Worker</h2>\n            <a href=\"#including-html-into-the-worker\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Workers can send anything in a Response. Of course, this includes a HTML string. If I wanted to make things incredibly difficult for myself, I could have skipped the <code>/src</code> directory with its own build system, and instead written the HTML, CSS, and JS entirely within a JS string. This would certainly work, but it would be a nightmare to maintain and (for me, at least) be extremely error prone:</p>\n            <pre class=\"language-js\"><code class=\"language-js\">API.add(&#039;GET&#039;, &#039;/&#039;, (req, res) =&gt; {\n  // Note: Worktop APIs\n  res.setHeader(&#039;Content-Type&#039;, &#039;text/html;charset=utf-8&#039;);\n  res.send(200, `\n    &lt;!doctype html&gt;\n    &lt;html lang=&quot;en&quot;&gt;\n      &lt;head&gt;\n        &lt;title&gt;Demo | Insanity&lt;/title&gt;\n        &lt;style&gt;\n          body {\n            background: #fff;\n            color: #424242;\n          }\n          /* more */\n        &lt;/style&gt;\n        &lt;script&gt;\n          $(&#039;form&#039;).onsubmit = function (ev) {\n            ev.preventDefault();\n            // ...\n          });\n        &lt;/script&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;!-- my entire page content --&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  `);\n});</pre></code>\n            <p>Thankfully, I planned ahead and already have a build system that produces <i>better</i> HTML files anyway. So now I just needed a way to load those built outputs into my Worker code.</p><p>Now for the <i>second half</i> of this project’s toolkit; I find it perfectly acceptable to have a two-step build pipeline. Here, this means that the static site should be built first, followed by building the Worker. I was planning to use TypeScript to author my Worker anyway, which meant I was already going to need a build step – the only change here is that these build steps would now have to be sequential and ordered.</p><p>The Worker is built using <a href=\"https://esbuild.github.io/\">esbuild</a>, which is an extremely quick JavaScript bundler <i>and</i> compiler that is capable of translating TypeScript, too. It also has its own plugin system, which allowed me the opportunity to add the “inline my HTML files” behavior I needed. The Worker’s <a href=\"https://github.com/cloudflare/developer-summer-challenge/blob/master/bin/worker.js\">build script</a> actually isn’t too intimidating and allows the Worker to `import` HTML files directly. This allows the insanity from above can be safely replaced with this pattern:</p>\n            <pre class=\"language-js\"><code class=\"language-js\">import { Router } from &#039;worktop&#039;;\nimport * as Cache from &#039;worktop/cache&#039;;\n\n// loaded via esbuild plugin\nimport LANDING from &#039;index.html&#039;;\nimport RULES from &#039;rules/index.html&#039;;\n\nAPI.add(&#039;GET&#039;, &#039;/&#039;, (req, res) =&gt; {\n  res.setHeader(&#039;Content-Type&#039;, &#039;text/html;charset=utf-8&#039;);\n  res.setHeader(&#039;Cache-Control&#039;, &#039;public,max-age=60&#039;);\n  res.send(200, LANDING);\n});\n\nAPI.add(&#039;GET&#039;, &#039;/rulees&#039;, (req, res) =&gt; {\n  res.setHeader(&#039;Content-Type&#039;, &#039;text/html;charset=utf-8&#039;);\n  res.setHeader(&#039;Cache-Control&#039;, &#039;public,max-age=1800&#039;);\n  res.send(200, RULES);\n});\n\n// ...\n\n// init; w/ Cache API\nCache.listen(API.run);</pre></code>\n            <p>Of course, this is much cleaner and sensible in the long-run. Clarity makes it easier to identify and extract common patterns into utility functions. I took the opportunity to introduce a <code>render</code> function, the first of many reusable helpers this project would encounter:</p>\n            <pre class=\"language-ts\"><code class=\"language-ts\">// worker/utils.ts\nimport type { ServerResponse } from &#039;worktop/response&#039;;\n\nexport function render(res: ServerResponse, template: string) {\n  res.setHeader(&#039;Content-Type&#039;, &#039;text/html;charset=UTF-8&#039;);\n  res.send(200, template);\n}\n\n// worker/index.ts\nimport * as utils from &#039;./utils&#039;;\n\nAPI.add(&#039;GET&#039;, &#039;/&#039;, (req, res) =&gt; {\n  res.setHeader(&#039;Cache-Control&#039;, &#039;public,max-age=60&#039;);\n  return utils.render(res, LANDING);\n});\n\nAPI.add(&#039;GET&#039;, &#039;/rulees&#039;, (req, res) =&gt; {\n  res.setHeader(&#039;Cache-Control&#039;, &#039;public,max-age=1800&#039;);\n  return utils.render(res, RULES);\n});</pre></code>\n            <p>Finally, most of the pages need to dynamically insert values into the HTML markup. For example, the submission form should render with the participant’s name and email address and the landing page is required to reflect the current value of remaining prizes. Much like any other monolithic application, the Worker Site is fully aware – and capable – of injecting these values where needed.</p><p>To do this, I standardized the <code>{{ variable }}</code> syntax in my project’s HTML. Each of these variables would be replaced <i>during the Worker request</i> with the appropriate value. Of course, it also requires that each endpoint actually provide the correct information to make the substitutions. With this in mind, I modified the `render` utility and updated the landing page’s route handler:</p>\n            <pre class=\"language-ts\"><code class=\"language-ts\">// worker/utils.ts\nimport type { KV } from &#039;worktop/kv&#039;;\nimport type { ServerResponse } from &#039;worktop/response&#039;;\n\n// TypeScript placeholder\n// Defines the `DATA` KV binding\ndeclare const DATA: KV.Namespace;\n\nexport function render(res: ServerResponse, template: string, values: Record&lt;string, string&gt; = {}) {\n  for (let key in values) {\n    template = template.replace(&#039;{{ &#039; + key + &#039; }}&#039;, values[key]);\n  }\n  res.setHeader(&#039;Content-Type&#039;, &#039;text/html;charset=UTF-8&#039;);\n  res.send(200, template);\n}\n  \nexport function toCount(): Promise&lt;string&gt; {\n  return DATA.get(&#039;::remain&#039;, &#039;text&#039;).then(v =&gt; v || &#039;300+&#039;);\n}\n  \n// worker/index.ts\nimport * as utils from &#039;./utils&#039;;\n\nAPI.add(&#039;GET&#039;, &#039;/&#039;, async (req, res) =&gt; {\n  // Get the &quot;::remain&quot; count from KV\n  const count = await utils.toCount();\n  \n  // Short-term TTL for remaining swag updates\n  res.setHeader(&#039;Cache-Control&#039;, &#039;public,max-age=60&#039;);\n  \n  // Render the HTML, passing in `count` variable\n  return utils.render(res, LANDING, { count });\n});</pre></code>\n            <p>With these changes, the landing page will always check the KV namespace for the latest <code>::remain</code> value and inject it into the correct location. If you’re interested in checking out the project’s <a href=\"https://github.com/cloudflare/developer-summer-challenge/blob/master/worker/index.ts\">source code</a>, you’ll find that this pattern is used in nearly every HTML response.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"accepting-form-submissions\">Accepting Form Submissions</h2>\n            <a href=\"#accepting-form-submissions\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>As expected, this application made heavy use of form submissions. Luckily, the Fetch API offers a variety of <a href=\"https://fetch.spec.whatwg.org/#body\">built-in body parsers</a> to make retrieval of the data trivial. Additionally, <code>worktop</code> offers a convenience function that will automatically invoke the correct parser based on the request’s <code>Content-Type</code> header. It’s aptly named <code>req.body()</code>.</p><p>It’s easy to parse and retrieve user data, but it still has to be validated. There are a number of ways to do this, all of which boil down to an input object, a group of rules, and a loop through those rules, collecting any error messages into an <code>errors</code> object. This is precisely what my <code>utils.validate</code> helper does, allowing me to clearly define and manage my rules inline.</p><p>Let’s see how this looks within the <code>POST /submit</code> handler, which accepts the initial registration form:</p>\n            <pre class=\"language-ts\"><code class=\"language-ts\">// worker/index.ts\nimport * as utils from &#039;./utils&#039;;\n\nAPI.add(&#039;POST&#039;, &#039;/signup&#039;, async (req, res) =&gt; {\n  try {\n    var input = await req.body&lt;Entry&gt;();\n  } catch (err) {\n    return toError(res, 400, &#039;Error parsing input&#039;);\n  }\n\n  let { email, firstname, lastname } = input || {};\n  firstname = String(firstname||&#039;&#039;).trim();\n  lastname = String(lastname||&#039;&#039;).trim();\n  email = String(email||&#039;&#039;).trim();\n\n  let { errors, invalid } = utils.validate({\n    email, firstname, lastname\n  }, {\n    email(val: string) {\n      if (val.length &lt; 1) return &#039;Required&#039;;\n      return utils.isEmail(val) || &#039;Invalid email address&#039;;\n    },\n    firstname(val: string) {\n      return val.length &gt; 1 || &#039;Required&#039;;\n    },\n    lastname(val: string) {\n      return val.length &gt; 1 || &#039;Required&#039;;\n    }\n  });\n\n  if (invalid) {\n    return res.send(422, errors);\n  }\n      \n  // The `input` is valid!\n  \n  return res.send(200, &#039;TODO: finish me&#039;);\n});</pre></code>\n            <p>Only after the data is considered valid can data be stored into KV for future use. For the initial registration, a number of things need to happen:</p><ol><li><p>Ensure that the <code>input.email</code> hasn’t already been registered;</p></li><li><p>Persist the new registration using the `input` values, identifying each document with the <code>user:&lt;email&gt;</code> key;</p></li><li><p>Generate and save a unique code for the registration, which will be used later to ensure (a) that unregistered persons cannot submit projects and (b) that a registrant can only submit once;</p></li><li><p>Send the user an email, containing their unique submission link; and</p></li><li><p>Render a confirmation page, reminding the user to check their inbox for their link.</p></li></ol><p>It can seem like a lot, but after piecing together a few utility helpers and abstractions, it can actually feel quite approachable:</p>\n            <pre class=\"language-ts\"><code class=\"language-ts\">// worker/index.ts\nimport * as utils from &#039;./utils&#039;;\nimport * as Sparkpost from &#039;./emails&#039;;\nimport * as Signup from &#039;./signup&#039;;\nimport * as Code from &#039;./code&#039;;\n\nfunction toError(res: ServerResponse, status: number, reason: string) {\n  return res.send(status, { status, reason });\n}\n\nAPI.add(&#039;POST&#039;, &#039;/signup&#039;, async (req, res) =&gt; {\n  try {\n    var input = await req.body&lt;Entry&gt;();\n  } catch (err) {\n    return toError(res, 400, &#039;Error parsing input&#039;);\n  }\n  \n  let { email, firstname, lastname } = input || {};\n  firstname = String(firstname||&#039;&#039;).trim();\n  lastname = String(lastname||&#039;&#039;).trim();\n  email = String(email||&#039;&#039;).trim();\n  \n  // truncated: validation\n  \n  // Ensure email is not already in use\n  let exists = await Signup.find(email);\n  if (exists) return toError(res, 400, &#039;You have already signed up&#039;);\n\n  // Generate new `Entry` record\n  let entry = Signup.prepare({ email, firstname, lastname });\n\n  // create &quot;user:&lt;unique email&gt;&quot; document\n  let isOK = await Signup.save(entry);\n  if (!isOK) return toError(res, 500, &#039;Error persisting entry&#039;);\n\n  // create &quot;code:&lt;unique value&gt;&quot; document\n  isOK = await Code.save(entry);\n  if (!isOK) return toError(res, 500, &#039;Error saving unique code&#039;);\n\n  // dispatch &quot;We received your registration&quot; email\n  let sent = await Sparkpost.confirm(entry);\n  if (!sent) return toError(res, 500, &#039;Error sending confirmation email&#039;);\n\n  // render &quot;Thank you, check your {{ email }} for next steps&quot; page\n  return utils.render(res, CONFIRM, { email: entry.email });\n});</pre></code>\n            <p>A full HTML response is returned, which means that the client-side form handler should be able to see this content and render it directly in the browser window. This can be seen in the following <code>index.js</code> snippet, which was referenced earlier in the <code>submit/index.html</code> as an injected asset:</p>\n            <pre class=\"language-js\"><code class=\"language-js\">// (client) index.js\n\n$(&#039;form&#039;).onsubmit = async function (ev) {\n  ev.preventDefault();\n\n  var form = ev.target;\n  var res = await fetch(form.action, {\n    method: form.method || &#039;POST&#039;,\n    body: new FormData(form),\n  });\n\n  // truncate: clear existing errors\n\n  if (res.ok) {\n    form.reset();\n    // Receive HTML response\n    let html = await res.text();\n    // Force-write the new HTML into this window\n    document.documentElement.innerHTML = html;\n  } else {\n    // truncate: render errors\n  }\n};</pre></code>\n            <blockquote><p><b><i>BONUS:</i></b><i> Because a full HTML response is returned, and all the client-side </i><code><i>&lt;form&gt;</i></code><i> elements are semantically correct, the form submission workflow will work with JavaScript disabled! The client-side validation will remain functional, but be a degraded experience – the error dialog won’t popup and any error messages will not appear beneath their respective form inputs.</i></p></blockquote>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"sending-transactional-emails\">Sending Transactional Emails</h2>\n            <a href=\"#sending-transactional-emails\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>It should (hopefully) come as no surprise that programmatically sending an email is pretty straightforward these days. We chose to use SparkPost, but practically every service has the same API mechanics:</p><ul><li><p>Obtain an API Token</p></li><li><p>Send a POST request to an endpoint with:</p><ul><li><p>your API Token as an <code>Authorization</code> header</p></li><li><p>your recipient, sender identity, and text and/or HTML content as the POST body</p></li></ul></li><li><p>Wait for a 200-level response, or deal with any API errors</p></li></ul><p>Most email-as-a-service providers allow you to define templates, which allow you to replace variables with unique values per email – essentially the same thing our <code>utils.render</code> function is doing with our HTML contents. The benefit of this is that you only have to worry about writing your emails once; then you’re just POST’ing new values to the API endpoint.</p><p>SparkPost allows templates to be referenced by a custom name rather than a randomly generated identifier, which makes it easy to track and debug templates over time.</p>\n            <pre class=\"language-ts\"><code class=\"language-ts\">// worker/emails.ts\nimport type { Entry } from &#039;./signup&#039;;\n\n// wrangler secret\n// @see https://developers.sparkpost.com/api/#header-authentication\ndeclare const SPARKPOST_KEY: string;\n\n/**\n * Assemble the POST request for all SparkPost email triggers\n * @see https://developers.sparkpost.com/api/transmissions/#transmissions-post-send-a-template\n */\nasync function send(\n  templateid: string,\n  recipient: Entry,\n  values?: Record&lt;string, string&gt;\n): Promise&lt;boolean&gt; {\n  const res = await fetch(&#039;https://api.sparkpost.com/api/v1/transmissions&#039;, {\n    method: &#039;POST&#039;,\n    headers: {\n      &#039;Content-Type&#039;: &#039;application/json&#039;,\n      &#039;Authorization&#039;: SPARKPOST_KEY,\n    },\n    body: JSON.stringify({\n      content: {\n        template_id: templateid,\n      },\n      recipients: [{\n        address: {\n          email: recipient.email,\n          name: recipient.firstname + &#039; &#039; + recipient.lastname,\n        },\n        substitution_data: values || {},\n      }]\n    })\n  });\n\n  let data = await res.json() as {\n    results: {\n      id: string;\n      total_rejected_recipients: number;\n      total_accepted_recipients: number;\n    }\n  };\n\n  return res.ok &amp;&amp; data.results.total_accepted_recipients === 1;\n}\n    \n/**\n * Confirming user&#039;s signup\n * Sending unique submission form\n */\nexport function confirm(entry: Entry): Promise&lt;boolean&gt; {\n  return send(&#039;devchallenge-confirm&#039;, entry, {\n    firstname: entry.firstname,\n    code: entry.code,\n  });\n}</pre></code>\n            <p>The above snippet includes the <i>entire</i> <code>POST</code> request formatter – there’s nearly more type-hinting than there is code! Also shown is an example <code>confirm</code> method, which is responsible for sending the unique submission link to the newly-registered user. You’ll notice that <code>firstname</code> and <code>code</code> are the injected variables, required by the “devchallenge-confirm” template.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"overall-performance\">Overall Performance</h2>\n            <a href=\"#overall-performance\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>I’d call this a success!</p><p>Even though this certainly wasn’t my first Worker project – and definitely won’t be my last – I’m consistently amazed how much the Workers runtime lets me get away with. I mean, if you could only take away two points from this article, they should be:</p><ol><li><p>I was able to build a moderately complex application, from scratch, while incorporating a Cache layer, a globally-replicated storage layer, and a super-performant JS runtime, all of which live under the same roof.</p></li><li><p>I (probably) spent more time fussing with a custom client-side build pipeline than I did piecing together the mission-critical API form handlers.</p></li></ol><p>The cherry on top: Should this contest go viral and lure in millions of visitors, I’d only be paying a couple of dollars at the end of the month. Obviously I have a bias here, but it’s pretty amazing really.</p><p>Finally, performance-wise, this may justify the time spent fiddling with the HTML build output:</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/3irhqabprRjLez9WXuHyi6/da3465091ca6308804d140fd69218bcf/lighthouse.png\" alt=\"A Lighthouse report that grades the deployed landing page a perfect score for Performance and Best Practices. It’s also received a 98% for Accessibility and 99% for SEO health.\" class=\"kg-image\" width=\"1600\" height=\"1549\" loading=\"lazy\"/>\n            \n            </figure>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"lessons-learned\">Lessons Learned</h2>\n            <a href=\"#lessons-learned\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>As I alluded to earlier, if I were to rebuild this application, or if I were to add more to it down the road, I would replace the Workers Site architecture with a Pages project and deploy a Worker in front of it for my API requirements and dynamic KV injections.</p><p>Since the static assets would no longer be embedded into the Worker’s source, I would need to replace the `utils.render` approach for another utility that fetches the URL from Pages (which becomes my “origin server”) and then uses <a href=\"https://developers.cloudflare.com/workers/runtime-apis/html-rewriter\"><code>HTMLRewriter</code></a> to inject the variables. Also, not that I was anywhere near the 1MB size limit, the largest contributor to my Worker’s bytesize would disappear.</p><p>But, more significantly, this refactor would also reduce my total tooling since the <i>majority</i> of the project’s complexity lies in the custom build system for the frontend assets. In other words, the entire <code>/src</code> directory could have been built and deployed like a normal static website, which would allow me to make use of existing frameworks and/or toolkits instead of taking my self-imposed detour. There would have been no need to create a custom frontend toolkit <i>and</i> its bridge to get the static assets loaded into my Worker.</p><p>However, none of this is to say that Workers Sites was a bad approach for this application. It’s quite the contrary! This is all to highlight the flexibility of Worker Sites – and the Workers platform at large. Cloudflare Pages exists so that I, the developer, can lean into existing, well-traveled paths and let the experts worry about toolkits, build pipelines, and deployments… But that doesn’t prevent you, the resident expert, from customizing every aspect if that’s your desire.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"resources\">Resources</h2>\n            <a href=\"#resources\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <ul><li><p><a href=\"https://github.com/cloudflare/developer-summer-challenge\">Source Code on GitHub</a></p></li><li><p><a href=\"https://developers.cloudflare.com/workers/platform/sites\">Workers Site: Quickstarts</a></p></li><li><p><a href=\"https://developers.cloudflare.com/pages/get-started\">Pages: Get Started Guide</a></p></li></ul>",
		"id": "4DqYEgzFEeSL3YkaaYUcF3",
		"localeList": {
			"name": "Building the Cloudflare Summer Challenge Application Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "If you haven’t already heard, we’re hosting the Cloudflare Summer Developer Challenge, a contest for the Cloudflare community at large. Anybody – yes, including you – can sign up for free and compete for a chance to win one of 300 available prizes. ",
		"metadata": {
			"title": "Building the Cloudflare Summer Challenge Application",
			"description": "If you haven’t already heard, we’re hosting the Cloudflare Summer Developer Challenge, a contest for the Cloudflare community at large. Anybody – yes, including you – can sign up for free and compete for a chance to win one of 300 available prizes. ",
			"imgPreview": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/2YLrSRSiWBcR2qHGjLUOap/085329105510ca7de4b5309a5213d78a/building-the-cloudflare-summer-challenge-application-yj9227.png"
		},
		"primary_author": {},
		"published_at": "2021-08-13T13:59:56.000+01:00",
		"slug": "building-the-cloudflare-summer-challenge-application",
		"tags": [
			{
				"id": "6hbkItfupogJP3aRDAq6v8",
				"name": "Cloudflare Workers",
				"slug": "workers"
			},
			{
				"id": "5cye1Bh5KxFh3pKSnX8Dsy",
				"name": "Serverless",
				"slug": "serverless"
			},
			{
				"id": "4HIPcb68qM0e26fIxyfzwQ",
				"name": "Developers",
				"slug": "developers"
			}
		],
		"title": "Building the Cloudflare Summer Challenge Application",
		"updated_at": "2024-08-27T01:46:48.616Z",
		"url": "https://blog.cloudflare.com/building-the-cloudflare-summer-challenge-application"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.blurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}