<div class="mb2 gray5">15 min read</div><img class="mr2" src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4YQid9Rnb8i1HM0KZ5TzUG/36ba8b8fe3df9e8343e68ec29ab0b505/image3.png" alt="">
<div class="post-content lh-copy gray1">
	<p>Any public <a href="https://en.wikipedia.org/wiki/Certificate_authority"><u>certification authority (CA)</u></a> can issue a <a href="https://www.cloudflare.com/learning/ssl/what-is-an-ssl-certificate"><u>certificate</u></a> for any website on the Internet to allow a webserver to authenticate itself to connecting clients. Take a moment to scroll through the list of trusted CAs for your web browser (e.g., <a href="https://chromium.googlesource.com/chromium/src/+/main/net/data/ssl/chrome_root_store/test_store.certs"><u>Chrome</u></a>). You may recognize (and even trust) some of the names on that list, but it should make you uncomfortable that <i>any</i> CA on that list could issue a certificate for any website, and your browser would trust it. It’s a castle with 150 doors.</p>
	<p><a href="https://datatracker.ietf.org/doc/html/rfc6962"><u>Certificate Transparency (CT)</u></a> plays a vital role in the <a href="https://datatracker.ietf.org/wg/wpkops/about"><u>Web Public Key Infrastructure (WebPKI)</u></a>, the set of systems, policies, and procedures that help to establish trust on the Internet. CT ensures that all website certificates are <a href="https://crt.sh"><u>publicly visible</u></a> and <a href="https://developers.cloudflare.com/ssl/edge-certificates/additional-options/certificate-transparency-monitoring"><u>auditable</u></a>, helping to protect website operators from certificate mis-issuance by dishonest CAs, and helping honest CAs to detect key compromise and other failures.</p>
	<p>In this post, we’ll discuss the history, evolution, and future of the CT ecosystem. We’ll cover some of the challenges we and others have faced in operating CT logs, and how the new <a href="https://c2sp.org/static-ct-api"><u>static CT API</u></a> log design lowers the bar for operators, helping to ensure that this critical infrastructure keeps up with the fast growth and changing landscape of the Internet and WebPKI. We’re excited to open source our <a href="https://github.com/cloudflare/azul"><u>Rust implementation</u></a> of the new log design, built for deployment on Cloudflare’s Developer Platform, and to announce <a href="https://github.com/cloudflare/azul/tree/main/crates/ct_worker#test-logs"><u>test logs</u></a> deployed using this infrastructure.</p>
	<div class="flex anchor relative">
		<h2 id="what-is-certificate-transparency">What is Certificate Transparency?</h2>
		<a href="https://blog.cloudflare.com/#what-is-certificate-transparency" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>In 2011, the Dutch CA DigiNotar was <a href="https://threatpost.com/final-report-diginotar-hack-shows-total-compromise-ca-servers-103112/77170"><u>hacked</u></a>, allowing attackers to forge a certificate for *.google.com and use it to impersonate Gmail to targeted Iranian users in an attempt to compromise personal information. Google caught this because they used <a href="https://developers.cloudflare.com/ssl/reference/certificate-pinning"><u>certificate pinning</u></a>, but that technique <a href="https://blog.cloudflare.com/why-certificate-pinning-is-outdated"><u>doesn’t scale well</u></a> for the web. This, among other similar attacks, led a team at Google in 2013 to develop Certificate Transparency (CT) as a mechanism to catch mis-issued certificates. CT creates a public audit trail of all certificates issued by public CAs, helping to protect users and website owners by holding <a href="https://sslmate.com/resources/certificate_authority_failures"><u>CAs accountable</u></a> for the certificates they issue (even unwittingly, in the event of key compromise or software bugs). CT has been a great success: since 2013, over <a href="https://crt.sh/cert-populations"><u>17 billion</u></a> certificates have been logged, and CT was awarded the prestigious <a href="https://blog.transparency.dev/certificate-transparency-wins-the-levchin-prize"><u>Levchin Prize</u></a> in 2024 for its role as a critical safety mechanism for the Internet.</p>
	<p>Let’s take a brief look at the entities involved in the CT ecosystem. Cloudflare itself operates the <a href="https://blog.cloudflare.com/introducing-certificate-transparency-and-nimbus"><u>Nimbus CT logs</u></a> and the CT monitor powering the <a href="https://blog.cloudflare.com/a-tour-through-merkle-town-cloudflares-ct-ecosystem-dashboard"><u>Merkle Town</u></a> <a href="https://ct.cloudflare.com"><u>dashboard</u></a>.</p>
	<p><i>Certification Authorities (CAs)</i> are organizations entrusted to issue certificates on behalf of website operators, which in turn can use those certificates to authenticate themselves to connecting clients.</p>
	<p><i>CT-enforcing clients</i> like the <a href="https://googlechrome.github.io/CertificateTransparency/ct_policy.html"><u>Chrome</u></a>, <a href="https://support.apple.com/en-us/103214"><u>Safari</u></a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency"><u>Firefox</u></a> browsers are web clients that only accept certificates compliant with their CT policies. For example, a policy might require that a certificate includes proof that it has been submitted to at least two independently-operated public CT logs.</p>
	<p><i>Log operators</i> run CT logs, which are public, append-only lists of certificates. CAs and other clients can submit a certificate to a CT log to obtain a “promise” from the CT log that it will incorporate the entry into the append-only log within some grace period. CT logs periodically (every few seconds, typically) update their log state to incorporate batches of new entries, and publish a signed checkpoint that attests to the new state.</p>
	<p><i>Monitors</i> are third parties that continuously crawl CT logs and check that their behavior is correct. For instance, they verify that a log is self-consistent and append-only by ensuring that when new entries are added to the log, no previous entries are deleted or modified. Monitors may also examine logged certificates to help website operators detect mis-issuance.</p>
	<div class="flex anchor relative">
		<h2 id="challenges-in-operating-a-ct-log">Challenges in operating a CT log</h2>
		<a href="https://blog.cloudflare.com/#challenges-in-operating-a-ct-log" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Despite the success of CT, it is a less than perfect system. Eric Rescorla has an <a href="https://educatedguesswork.org/posts/transparency-part-2"><u>excellent writeup</u></a> on the many compromises made to make CT deployable on the Internet of 2013. We’ll focus on the operational complexities of running a CT log.</p>
	<p>Let’s look at the requirements for running a CT log from <a href="https://googlechrome.github.io/CertificateTransparency/log_policy.html#ongoing-requirements-of-included-logs"><u>Chrome’s CT log policy</u></a> (which are more or less mirrored by those of <a href="https://support.apple.com/en-us/103703"><u>Safari</u></a> and <a href="https://groups.google.com/a/mozilla.org/g/dev-security-policy/c/lypRGp4JGGE"><u>Firefox</u></a>), and what can go wrong. The requirements center around <b>integrity</b> and <b>availability</b>.</p>
	<p>To be considered a trusted auditing source, CT logs necessarily have stringent <b>integrity</b> requirements. Anything the log produces must be correct and self-consistent, meaning that a CT log cannot present two different views of the log to different clients, and must present a consistent history for its entire lifetime. Similarly, when a CT log accepts a certificate and promises to incorporate it by returning a Signed Certificate Timestamp (SCT) to the client, it must eventually incorporate that certificate into its append-only log.</p>
	<p>The integrity requirements are unforgiving. A single bit-flip due to a hardware failure or cosmic ray can (<a href="https://www.agwa.name/blog/post/how_ct_logs_fail"><u>and</u></a> <a href="https://groups.google.com/a/chromium.org/g/ct-policy/c/R27Zy9U5NjM"><u>has</u></a>) caused logs to produce incorrect results and thus be disqualified by CT programs. Even software updates to running logs can be fatal, as a change that causes a correctness violation cannot simply be rolled back. Perhaps the <a href="https://github.com/C2SP/C2SP/issues/79"><u>greatest risk</u></a> to individual log integrity is <a href="https://groups.google.com/a/chromium.org/g/ct-policy/c/W1Ty2gO0JNA"><u>failing to incorporate certificates</u></a> for which they issued SCTs, for example if they fail to commit those pending certificates to durable storage. See Andrew Ayer’s <a href="https://www.agwa.name/blog/post/how_ct_logs_fail"><u>great synopsis</u></a> for more examples of CT log failures (up to 2021).</p>
	<p>A CT log must also meet certain <b>availability</b> requirements to effectively provide its core functionality as a publicly auditable log. Clients must be able to reliably retrieve log data — Chrome’s policy requires a minimum of 99% average uptime over a 90-day rolling period for each API endpoint — and any entries for which an SCT has been issued must be incorporated into the log within the grace period, called the Maximum Merge Delay (MMD), 24 hours in Chrome’s policy.</p>
	<p>The design of the current CT log read APIs puts strain on the ability of log operators to meet uptime requirements. The API endpoints are <i>dynamic</i> and not easily cacheable without bespoke caching rules that are aware of the CT API. For instance, the <a href="https://datatracker.ietf.org/doc/html/rfc6962#section-4.6"><u>get-entries</u></a> endpoint allows a client to request arbitrary ranges of entries from a log, and the <a href="https://datatracker.ietf.org/doc/html/rfc6962#section-4.5"><u>get-proof-by-hash</u></a> requires the server to construct inclusion proofs for any certificate requested by the client. To serve these requests, CT log servers need to be backed by databases easily 5-10TB in size capable of serving tens of millions of requests per day. This increases operator complexity and expense, not to mention the high cost of bandwidth of serving these requests.</p>
	<p>MMD violations are unfortunately not uncommon. Cloudflare’s own Nimbus logs have experienced prolonged outages in the past, most recently in <a href="https://blog.cloudflare.com/post-mortem-on-cloudflare-control-plane-and-analytics-outage"><u>November 2023</u></a> due to complete power loss in the datacenter running the logs. During normal log operation, if the log accepts entries more quickly than it incorporates them, the backlog can grow to exceed the MMD. Log operators can remedy this by rate-limiting or temporarily disabling the write APIs, but this can in turn contribute to violations of the uptime requirements.</p>
	<p>The high bar for log operation has limited the organizations operating CT logs to only <a href="https://ct.cloudflare.com/logs"><u>Cloudflare and five others</u></a>! Losing one or two logs is enough to compromise the stability of the CT ecosystem. Clearly, a change is needed.</p>
	<div class="flex anchor relative">
		<h2 id="a-next-generation-ct-log-design">A next-generation CT log design</h2>
		<a href="https://blog.cloudflare.com/#a-next-generation-ct-log-design" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>In May 2024, Let’s Encrypt <a href="https://letsencrypt.org/2024/03/14/introducing-sunlight"><u>announced</u></a> <a href="https://github.com/FiloSottile/sunlight"><u>Sunlight</u></a>, an implementation of a next-generation CT log designed for the modern WebPKI, incorporating a decade of lessons learned from running CT and similar transparency systems. The new CT log design, called the <a href="https://c2sp.org/static-ct-api"><u>static CT API</u></a>, is partially based on the <a href="https://go.googlesource.com/proposal/+/master/design/25530-sumdb.md"><u>Go checksum database</u></a>, and organizes log data as a series of <a href="https://research.swtch.com/tlog#tiling_a_log"><u>tiles</u></a> that are easy to cache and serve. The new design provides efficiency improvements that cut operation costs, help logs to meet availability requirements, and reduce the risk of integrity violations.</p>
	<p>The static CT API is split into two parts, the <a href="https://github.com/C2SP/C2SP/blob/main/static-ct-api.md#monitoring-apis"><b><u>monitoring APIs</u></b></a> (so named because CT monitors are the primary clients), and the <a href="https://github.com/C2SP/C2SP/blob/main/static-ct-api.md#monitoring-apis"><b><u>submission APIs</u></b></a> for adding new certificates to the log.</p>
	<p>The <b>monitoring APIs</b> replace the dynamic read APIs of <a href="https://datatracker.ietf.org/doc/html/rfc6962#section-4"><u>RFC 6962</u></a>, and organize log data into static, cacheable tiles. (See <a href="https://research.swtch.com/tlog#tiling_a_log"><u>Russ Cox’s blog post</u></a> for an in-depth explanation of tiled logs.) CT log operators can efficiently serve static tiles from S3-compatible object storage buckets and cache them using CDN infrastructure, without needing dedicated API servers. Clients can then download the necessary tiles to retrieve specific log entries or reconstruct arbitrary proofs.</p>
	<p>The static CT API introduces another efficiency by deduplicating intermediate and root “issuer” certificates in a log entry’s certificate chain. The number of publicly-trusted issuer certificates is small (<a href="https://www.ccadb.org"><u>in the low thousands</u></a>), so instead of storing them repeatedly for each log entry, only the issuer hash is stored. Clients can look up issuer certificates by hash from a <a href="https://github.com/C2SP/C2SP/blob/main/static-ct-api.md#issuers"><u>separate endpoint</u></a>.</p>
	<p>The <b>submission APIs</b> remain backwards-compatible with <a href="https://datatracker.ietf.org/doc/html/rfc6962#section-4"><u>RFC 6962</u></a>, meaning that TLS clients and CAs can submit to them without any changes. However, there is one notable addition: the static CT specification requires logs to hold on to requests as it batches and sequences them, and responds with an SCT only after entries have been incorporated into the log. The specification defines a <a href="https://github.com/C2SP/C2SP/blob/main/static-ct-api.md#sct-extension"><u>required SCT extension</u></a> indicating the entry’s index in the log. At the cost of slightly delayed SCT issuance (on the order of seconds), this change eliminates one of the major pain points of operating a CT log (the Merge Delay).</p>
	<p>Having the log <i>index</i> of a certificate available in an SCT enables further efficiencies. <i>SCT auditing</i> refers to the process by which TLS clients or monitors can check if a log has fulfilled its promise to incorporate a certificate for which it has issued an SCT. In the RFC 6962 API, checking if a certificate is present in a log when you don’t already know the index requires using the <a href="https://datatracker.ietf.org/doc/html/rfc6962#section-4.5"><u>get-proof-by-hash</u></a> endpoint to look up the entry by the certificate hash (and the server needs to maintain a mapping from hash to index to efficiently serve these requests). Instead, with the index immediately available in the SCT, clients can directly retrieve the specific log data tile covering that index, even with <a href="https://transparency.dev/summit2024/sct-auditing.html"><u>efficient privacy-preserving techniques</u></a>.</p>
	<p>Since it was announced, the static CT API has taken the CT ecosystem by storm. Aside from <a href="https://github.com/FiloSottile/sunlight"><u>Sunlight</u></a> and our brand new <a href="https://github.com/cloudflare/azul"><u>Azul</u></a> (discussed below), there are at least two other independent implementations, <a href="https://blog.transparency.dev/i-built-a-new-certificate-transparency-log-in-2024-heres-what-i-learned"><u>Itko</u></a> and <a href="https://blog.transparency.dev/introducing-trillian-tessera"><u>Trillian Tessera</u></a>. Several CT monitors (including <a href="https://crt.sh"><u>crt.sh</u></a>, <a href="https://sslmate.com/certspotter"><u>certspotter</u></a>, <a href="https://censys.com"><u>Censys</u></a>, and our own <a href="https://ct.cloudflare.com"><u>Merkle Town</u></a>) have added support for the new log format, and as of April 1, 2025, Chrome has begun accepting submissions for <a href="https://groups.google.com/a/chromium.org/g/ct-policy/c/HBFZHG0TCsY/m/HAaVRK6MAAAJ"><u>static CT API logs</u></a> into their CT log program.</p>
	<div class="flex anchor relative">
		<h2 id="a-static-ct-api-implementation-on-workers">A static CT API implementation on Workers</h2>
		<a href="https://blog.cloudflare.com/#a-static-ct-api-implementation-on-workers" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>This section discusses how we designed and built our static CT log implementation, <a href="https://github.com/cloudflare/azul"><u>Azul</u></a> (short for <a href="https://en.wikipedia.org/wiki/Azulejo"><u>azulejos</u></a>, the colorful Portuguese and Spanish ceramic tiles). For curious readers and prospective CT log operators, we encourage you to follow the instructions in the repo to quickly set up your own static CT log. Questions and feedback in the form of GitHub issues are welcome!</p>
	<p>Our two prototype logs, <a href="https://static-ct.cloudflareresearch.com/logs/cftest2025h1a/metadata"><u>Cloudflare Research 2025h1a</u></a> and <a href="https://static-ct.cloudflareresearch.com/logs/cftest2025h2a/metadata"><u>Cloudflare Research 2025h2a</u></a> (accepting certificates expiring in the first and second half of 2025, respectively), are available for testing.</p>
	<div class="flex anchor relative">
		<h3 id="design-decisions-and-goals">Design decisions and goals</h3>
		<a href="https://blog.cloudflare.com/#design-decisions-and-goals" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>The advent of the static CT API gave us the perfect opportunity to rethink how we run our CT logs. There were a few design decisions we made early on to shape the project.</p>
	<p>First and foremost, we wanted to run our CT logs on our distributed global network. Especially after the <a href="https://blog.cloudflare.com/post-mortem-on-cloudflare-control-plane-and-analytics-outage"><u>painful November 2023 control plane outage</u></a>, there’s been a push to deploy services on our highly available and resilient network instead of running in centralized datacenters.</p>
	<p>Second, with Cloudflare’s deeply engrained culture of <a href="https://blog.cloudflare.com/tag/dogfooding"><u>dogfooding</u></a> (building Cloudflare on top of Cloudflare), we decided to implement the CT log on top of Cloudflare’s Developer Platform and <a href="https://workers.cloudflare.com"><u>Workers</u></a>.&nbsp;</p>
	<p>Dogfooding gives us an opportunity to find pain points in our product offerings, and to provide feedback to our development teams to improve the developer experience for everyone. We restricted ourselves to only features and default limits generally available to customers, so that we could have the same experience as an external Cloudflare developer, and would produce an implementation that anyone could deploy.</p>
	<p>Another major design decision was to implement the CT log in Rust, a modern systems programming language with static typing and built-in memory safety that is heavily used across Cloudflare, and which already has mature (if sometimes <a href="https://blog.cloudflare.com/#developing-a-workers-application-in-rust"><u>lacking full feature parity</u></a>) <a href="https://github.com/cloudflare/workers-rs"><u>Workers bindings</u></a> that we have used to build <a href="https://blog.cloudflare.com/wasm-coredumps"><u>several production services</u></a>. This also provided us with an opportunity to produce Rust crates porting <a href="https://pkg.go.dev/golang.org/x/mod/sumdb"><u>Go implementations</u></a> of various <a href="https://c2sp.org"><u>C2SP</u></a> specifications that can be reused across other projects.</p>
	<p>For the new logs to be deployable, they needed to be at least as performant as existing CT logs. As a point of reference, the <a href="https://ct.cloudflare.com/logs/nimbus2025"><u>Nimbus2025</u></a> log currently handles just over 33 million requests per day (~380/s) across the read APIs, and about 6 million per day (~70/s) across the write APIs.</p>
	<div class="flex anchor relative">
		<h3 id="implementation">Implementation&nbsp;</h3>
		<a href="https://blog.cloudflare.com/#implementation" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>We based Azul heavily on <a href="https://github.com/FiloSottile/sunlight"><u>Sunlight</u></a>, a Go application built for deployment as a standalone server. As such, this section serves as a reference for translating a traditional server to Cloudflare’s serverless platform.</p>
	<p>To start, let’s briefly review the Sunlight architecture (described in more detail in the <a href="https://github.com/FiloSottile/sunlight/blob/main/README.md"><u>README</u></a> and <a href="https://filippo.io/a-different-CT-log"><u>original design doc</u></a>). A Sunlight instance is a single Go process, serving one or multiple CT logs. It is backed by three different storage locations with different properties:</p>
	<ul>
		<li>
			<p>A “lock backend” which stores the current checkpoint for each log. This datastore needs to be strongly consistent, but only stores trivial amounts of data.</p>
		</li>
		<li>
			<p>A per-log object storage bucket from which to serve tiles, checkpoints, and issuers to CT clients. This datastore needs to be strongly consistent, and to handle multiple terabytes of data.</p>
		</li>
		<li>
			<p>A per-log deduplication cache, to return SCTs for previously-submitted (pre-)certificates. This datastore is best-effort (as duplicate entries are not fatal to log operation), and stores tens to hundreds of gigabytes of data.</p>
		</li>
	</ul>
	<p>Two major components handle the bulk of the CT log application logic:</p>
	<ul>
		<li>
			<p>A frontend HTTP server handles incoming requests to the submission APIs to add new certificates to the log, validates them, checks the deduplication cache, adds the certificate to a pool of entries to be sequenced, and waits for sequencing to complete before responding to the client.</p>
		</li>
		<li>
			<p>The sequencer periodically (every 1s, by default) sequences the pool of pending entries, writes new tiles to the object backend, persists the latest checkpoint covering the new log state to the lock and object backends, and signals to waiting requests that the pool has been sequenced.</p>
		</li>
	</ul>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6gLwzRo4Azbls2wvM12TJx/80d6f7aad1317f31dfe06a0c474ee93c/image5.png" alt="" class="kg-image" width="1054" height="627" loading="lazy">
	</figure>
	<p><sup><i>A static CT API log running on a traditional server using the Sunlight implementation.</i></sup></p>
	<p>Next, let’s look at how we can translate these components into ones suitable for deployment on Workers.</p>
	<div class="flex anchor relative">
		<h4 id="making-it-work">Making it work</h4>
		<a href="https://blog.cloudflare.com/#making-it-work" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Let’s start with the easy choices. The static CT <a href="https://github.com/C2SP/C2SP/blob/main/static-ct-api.md#monitoring-apis"><u>monitoring APIs</u></a> are designed to serve static, cacheable, compressible assets from object storage. The API should be highly available and have the capacity to serve any number of CT clients. The natural choice is <a href="https://developers.cloudflare.com/r2"><u>Cloudflare R2</u></a>, which provides globally consistent storage with capacity for <a href="https://developers.cloudflare.com/r2/platform/limits"><u>large data volumes</u></a>, customizability to configure caching and compression, and unbounded read operations.</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/qsC1dO8blS1eGOysu9WQa/75da37719be35824a7533dbbd62bede3/image4.png" alt="" class="kg-image" width="1032" height="606" loading="lazy">
	</figure>
	<p><sup><i>A static CT API log running on Workers using a preliminary version of the Azul implementation which ran into performance limitations.</i></sup></p>
	<p>The static CT <a href="https://github.com/C2SP/C2SP/blob/main/static-ct-api.md#submission-apis"><u>submission APIs</u></a> are where the real challenge lies. In particular, they allow CT clients to submit certificate chains to be incorporated into the append-only log. We used <a href="https://developers.cloudflare.com/learning-paths/workers/concepts/workers-concepts"><u>Workers</u></a> as the frontend for the CT log application. Workers run in data centers close to the client, scaling on demand to handle request load, making them the ideal place to run the majority of the heavyweight request handling logic, including validating requests, checking the deduplication cache (discussed below), and submitting the entry to be sequenced.</p>
	<p>The next question was where and how we’d run the backend to handle the CT log sequencing logic, which needs to be stateful and tightly coordinated. We chose <a href="https://developers.cloudflare.com/durable-objects"><u>Durable Objects (DOs)</u></a>, a special type of stateful Cloudflare Worker where each instance has persistent storage and a unique name which can be used to route requests to it from anywhere in the world. DOs are designed to scale effortlessly for applications that can be easily broken up into self-contained units that do not need a lot of coordination across units. For example, a <a href="https://blog.cloudflare.com/introducing-workers-durable-objects/#demo-chat"><u>chat application</u></a> can use one DO to control each chat room. In our model, then, each CT log is controlled by a single DO. This architecture allows us to easily run multiple CT logs within a single Workers application, but as we’ll see, the limitations of <i>individual</i> single-threaded DOs can easily become a bottleneck. More on this later.</p>
	<p>With the CT log backend as a Durable Object, several other components fell into place: Durable Objects’ <a href="https://developers.cloudflare.com/durable-objects/api/storage-api"><u>strongly-consistent transactional storage</u></a> neatly fit the requirements for the “lock backend” to persist the log’s latest checkpoint, and we can use an <a href="https://developers.cloudflare.com/durable-objects/api/alarms"><u>alarm</u></a> to trigger the log sequencing every second. We can also use <a href="https://developers.cloudflare.com/durable-objects/reference/data-location/#provide-a-location-hint"><u>location hints</u></a> to place CT logs in locations geographically close to clients for reduced latency, similar to <a href="https://groups.google.com/g/certificate-transparency/c/I74Wp-KdWHc"><u>Google’s Argon and Xenon logs</u></a>.</p>
	<p>The <a href="https://developers.cloudflare.com/workers/platform/storage-options"><u>choice of datastore</u></a> for the deduplication cache proved to be non-obvious. The cache is best-effort, and intended to avoid re-sequencing entries that are already present in the log. The cache key is computed by hashing certain fields of the <code>add-[pre-]chain</code> request, and the cache value consists of the entry’s index in the log and the timestamp at which it was sequenced. At current log submission rates, the deduplication cache could grow in excess of <a href="https://github.com/FiloSottile/sunlight/tree/main?tab=readme-ov-file#operating-a-sunlight-log"><u>50 GB for 6 months of log data</u></a>. In the Sunlight implementation, the deduplication cache is implemented as a local SQLite database, where checks against it are tightly coupled with sequencing, which ensures that duplicates from in-flight requests are correctly accounted for. However, this architecture did not translate well to Cloudflare's architecture. The data size doesn’t comfortably fit within <a href="https://developers.cloudflare.com/durable-objects/platform/limits"><u>Durable Object Storage</u></a> or <a href="https://developers.cloudflare.com/d1/platform/limits"><u>single-database D1</u></a> limits, and it was too slow to directly read and write to remote storage from within the sequencing loop. Ultimately, we split the deduplication cache into two components: a local fixed-size in-memory cache for fast deduplication over short periods of time (on the order of minutes), and the other a long-term deduplication cache built on <a href="https://developers.cloudflare.com/kv"><u>Cloudflare Workers KV</u></a> a global, low-latency, <a href="https://developers.cloudflare.com/kv/reference/faq/#is-workers-kv-eventually-consistent-or-strongly-consistent"><u>eventually-consistent</u></a> key-value store <a href="https://developers.cloudflare.com/kv/platform/limits"><u>without storage limitations</u></a>.</p>
	<p>With this architecture, it was <a href="https://blog.cloudflare.com/#developing-a-workers-application-in-rust"><u>relatively straightforward</u></a> to port the Go code to Rust, and to bring up a functional static CT log up on Workers. We’re done then, right? Not quite. Performance tests showed that the log was only capable of sequencing 20-30 new entries per second, well under the 70 per second target of existing logs. We could work around this by simply <a href="https://letsencrypt.org/2024/03/14/introducing-sunlight/#running-more-logs"><u>running more logs</u></a>, but that puts strain on other parts of the CT ecosystem — namely on TLS clients and monitors, which need to keep state for each log. Additionally, the alarm used to trigger sequencing would often be delayed by multiple seconds, meaning that the log was failing to produce new tree heads at consistent intervals. Time to go back to the drawing board.</p>
	<div class="flex anchor relative">
		<h4 id="making-it-fast">Making it fast</h4>
		<a href="https://blog.cloudflare.com/#making-it-fast" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>In the design thus far, we’re asking a single-threaded Durable Object instance to do a lot of multi-tasking. The DO processes incoming requests from the Frontend Worker to add entries to the sequencing pool, and must periodically sequence the pool and write state to the various storage backends. A log handling 100 requests per second needs to switch between 101 running tasks (the extra one for the sequencing), plus any async tasks like writing to remote storage — usually 10+ writes to object storage and one write to the long-term deduplication cache per sequenced entry. No wonder the sequencing task was getting delayed!</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/7BCidjDyYw2YS1Ot84LHdk/240ce935eb4e36c82255d846d964fdff/image2.png" alt="BLOG-2633 Image 3" class="kg-image" width="1224" height="606" loading="lazy">
	</figure>
	<p><sup><i>A static CT API log running on Workers using the Azul implementation with batching to improve performance.</i></sup></p>
	<p>We were able to work around these issues by adding an additional layer of DOs between the Frontend Worker and the Sequencer, which we call Batchers. The Frontend Worker uses <a href="https://en.wikipedia.org/wiki/Consistent_hashing"><u>consistent hashing</u></a> on the cache key to determine which of several Batchers to submit the entry to, and the Batcher helps to reduce the number of requests to the Sequencer by buffering requests and sending them together in batches. When the batch is sequenced, the Batcher distributes the responses back to the Frontend Workers that submitted the request. The Batcher also handles writing updates to the deduplication cache, further freeing up resources for the Sequencer.</p>
	<p>By limiting the scope of the critical block of code that needed to be run synchronously in a single DO, and leaning on the strengths of DOs by scaling horizontally where the workload allows it, we were able to drastically improve application performance. With this new architecture, the CT log application can handle upwards of 500 requests per second to the submission APIs to add new log entries, while maintaining a consistent sequencing tempo to keep per-request latency low (typically 1-2 seconds).</p>
	<div class="flex anchor relative">
		<h3 id="developing-a-workers-application-in-rust">Developing a Workers application in Rust</h3>
		<a href="https://blog.cloudflare.com/#developing-a-workers-application-in-rust" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>One of the reasons I was excited to work on this project is that it gave me an opportunity to implement a Workers application in Rust, which I’d never done from scratch before. Not everything was smooth, but overall I would recommend the experience.</p>
	<p>The <a href="https://github.com/cloudflare/workers-rs"><u>Rust bindings to Cloudflare Workers</u></a> are an open source project that aims to bring support for all of the features you know and love from the <a href="https://developers.cloudflare.com/workers/languages/javascript"><u>JavaScript APIs</u></a> to the Rust language. However, there is some lag in terms of feature parity. Often when working on this project, I’d read about a particular Workers feature in the <a href="https://developers.cloudflare.com"><u>developer docs</u></a>, only to find that support had <a href="https://github.com/cloudflare/workers-rs/issues/645"><u>not yet</u></a> <a href="https://github.com/cloudflare/workers-rs/issues/716"><u>been added</u></a>, or was only <a href="https://github.com/cloudflare/workers-rs?tab=readme-ov-file#rpc-support"><u>partially supported</u></a>, for the Rust bindings. I came across some <a href="https://github.com/cloudflare/workers-rs/issues/432"><u>surprising gotchas</u></a> (not all bad, like <a href="https://docs.rs/tokio/1.44.1/tokio/sync/watch/index.html"><u>tokio::sync::watch</u></a> channels <a href="https://github.com/cloudflare/workers-rs/pull/719"><u>working seamlessly</u></a>, despite <a href="https://github.com/cloudflare/workers-rs?tab=readme-ov-file#faq"><u>this warning</u></a>). Documentation about <a href="https://developers.cloudflare.com/workers/observability/dev-tools/breakpoints"><u>debugging</u></a> and <a href="https://developers.cloudflare.com/workers/observability/dev-tools/cpu-usage"><u>profiling</u></a> Rust Workers was also not clear (e.g., how to <a href="https://github.com/cloudflare/cloudflare-docs/pull/21347"><u>preserve debug symbols</u></a>), but it does in fact work!</p>
	<p>To be clear, these rough edges are expected! The Workers platform is continuously gaining new features, and it’s natural that the Rust bindings would fall behind. As more developers rely on (and contribute to, <i>hint hint</i>) the Rust bindings, the developer experience will continue to improve.</p>
	<div class="flex anchor relative">
		<h2 id="what-is-next-for-certificate-transparency">What is next for Certificate Transparency</h2>
		<a href="https://blog.cloudflare.com/#what-is-next-for-certificate-transparency" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>The WebPKI is constantly evolving and growing, and upcoming changes, in particular shorter certificate lifetimes and larger post-quantum certificates, are going to place significantly more load on the CT ecosystem.</p>
	<p>The <a href="https://cabforum.org"><u>CA/Browser Forum</u></a> defines a set of <a href="https://cabforum.org/working-groups/server/baseline-requirements/documents/TLSBRv2.0.4.pdf"><u>Baseline Requirements</u></a> for publicly-trusted TLS server certificates.&nbsp; As of 2020, the maximum certificate lifetime for publicly-trusted certificates is 398 days. However, there is a <a href="https://github.com/cabforum/servercert/pull/553"><u>ballot measure</u></a> to reduce that period to as low as 47 days by March 2029. Let’s Encrypt is going even further, and at the <a href="https://letsencrypt.org/2024/12/11/eoy-letter-2024"><u>end of 2024 announced</u></a> that they will be offering short-lived certificates with a lifetime of only <a href="https://letsencrypt.org/2025/01/16/6-day-and-ip-certs"><u>six days</u></a> by the end of 2025. Based on some back-of-the-envelope calculations using statistics from <a href="https://ct.cloudflare.com"><u>Merkle Town</u></a>, these changes could increase the number of logged entries in the CT ecosystem by <b>16-20x</b>.</p>
	<p>If you’ve been keeping up with this blog, you’ll also know that <a href="https://blog.cloudflare.com/another-look-at-pq-signatures"><u>post-quantum certificates</u></a> are on the horizon, bringing with them larger signature and public key sizes. Today, a <a href="https://crt.sh/?id=17119212878"><u>certificate</u></a> with an P-256 ECDSA public key and issuer signature can be less than 1kB. Dropping in a ML-DSA<sub>44</sub> public key and signature brings the same certificate size to 4.6 kB, assuming the SCTs use 96-byte <a href="https://blog.cloudflare.com/another-look-at-pq-signatures"><u>UOV</u><u><sub>ls-pkc</sub></u></a> signatures. With these choices, post-quantum certificates could require CT logs to store <b>4x</b> the amount of data per log entry.</p>
	<p>The static CT API design helps to ensure that CT logs are much better equipped to handle this increased load, especially if the load is distributed across <a href="https://letsencrypt.org/2024/03/14/introducing-sunlight/#running-more-logs"><u>multiple logs</u></a> per operator. Our <a href="https://github.com/cloudflare/azul"><u>new implementation</u></a> makes it easy for log operators to run CT logs on top of Cloudflare’s infrastructure, adding more operational diversity and robustness to the CT ecosystem. We welcome feedback on the design and implementation as <a href="https://github.com/cloudflare/azul/issues"><u>GitHub issues</u></a>, and encourage CAs and other interested parties to start submitting to and consuming from our <a href="https://github.com/cloudflare/azul/tree/main/crates/ct_worker#test-logs"><u>test logs</u></a>.</p>
</div>