<div class="mb2 gray5">8 min read</div><img class="mr2" src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/01zugo4vFijAmQS86pVIrN/d8652b4a3204427301d08d4d2185a4d7/introducing-0-rtt.jpg" alt="">
<div class="post-content lh-copy gray1">
	<p><sub><i></i></sub></p>
	<blockquote>
		<p><sub><i>NOTE: This post has been updated to reflect that the feature is no longer enabled by default. Further details </i></sub><a href="https://developers.cloudflare.com/speed/optimization/protocol/0-rtt-connection-resumption"><sub><i>outlined here</i></sub></a><sub><i>.</i></sub></p>
	</blockquote>
	<p>Cloudflare’s mission is to help build a faster and more secure Internet. Over the last several years, the Internet Engineering Task Force (IETF) has been working on a new version of TLS, the protocol that powers the secure web. <a href="https://blog.cloudflare.com/introducing-tls-1-3">Last September</a>, Cloudflare was the first service provider to enable people to use this new version of the protocol, <a href="https://blog.cloudflare.com/tag/tls%201.3">TLS 1.3</a>, improving security and performance for millions of customers.</p>
	<p>Today we are introducing another performance-enhancing feature: zero <a href="https://www.cloudflare.com/learning/cdn/glossary/round-trip-time-rtt">round trip</a> time resumption, abbreviated as <i>0-RTT</i>. About 60% of the connections we see are from people who are visiting a site for the first time or revisiting after an extended period of time. TLS 1.3 speeds up these connections significantly. The remaining 40% of connections are from visitors who have recently visited a site and are resuming a previous connection. For these resumed connections, standard TLS 1.3 is safer but no faster than any previous version of TLS. 0-RTT changes this. It dramatically speeds up resumed connections, leading to a faster and smoother web experience for web sites that you visit regularly. This speed boost is especially noticeable on mobile networks.</p>
	<p>We’re happy to announce that 0-RTT is <b>NOT</b> enabled by default for all sites on Cloudflare’s free service. For paid customers, it can be enabled in the Crypto app in the Cloudflare dashboard. </p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/7jnAtBFcCo19Qvyjxa2aVI/fe6a5395324791599304b84c0d5baa38/image05.jpg" alt="" class="kg-image" width="1960" height="342" loading="lazy">

	</figure>
	<p>This is an experimental feature, and therefore subject to change.</p>
	<p>If you're just looking for a live demo, click <a href="https://blog.cloudflare.com/#demo">here</a>.</p>
	<div class="flex anchor relative">
		<h3 id="the-cost-of-latency">The cost of latency</h3>
		<a href="https://blog.cloudflare.com/#the-cost-of-latency" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>A big component of web performance is transmission latency. Simply put, transmission latency is the amount of time it takes for a message to get from one party to another over a network. Lower latency means snappier web pages and more responsive APIs; when it comes to responsiveness, every millisecond counts.</p>
	<p>The diagram below comes from a recent latency test of Cloudflare’s network using the RIPE Atlas project. In the experiment, hundreds of probes from around the world sent a single <a href="https://en.wikipedia.org/wiki/Ping_(networking_utility)">“ping”</a> message to Cloudflare and measured the time it took to get an answer in reply. This time is a good approximation of how long it takes for data to make the round trip from the probe to the server and back, so-called <i>round-trip latency</i>.</p>
	<figure class="kg-card kg-image-card ">
		<a href="https://atlas.ripe.net/measurements/7883648">
			<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3eiU71K5ZPEX2slK1J1mYb/68441b9ae1d68d8cb9ef7579e84625fc/image03.png" alt="https://atlas.ripe.net/measurements/7883648/" class="kg-image" width="895" height="525" loading="lazy">
		</a>
	</figure>
	<p>Latency is usually measured in milliseconds or thousandths of a second. A thousandth of a second may not seem like a long time, but they can add up quickly. It’s <a href="https://www.nngroup.com/articles/response-times-3-important-limits">generally accepted</a> that the threshold over which humans no longer perceive something as instantaneous is 100ms. Anything above 100ms will seem fast, but not immediate. For example, Usain Bolt’s reaction time out of the starting blocks in the hundred meter sprint is around <a href="https://www.nytimes.com/interactive/2016/08/13/sports/olympics/can-you-beat-usain-bolt-out-of-the-blocks.html">155ms</a>, a good reference point for thinking about latency. Let’s use 155ms, a fast but human perceptible amount of time, as a unit of time measurement. Call 155ms “one Bolt.”</p>
	<p>The map above shows that most probes have very low round-trip latency (&lt;20ms) to Cloudflare’s global network. However, for a percentage of probes, the time it takes to reach the nearest Cloudflare data center is much longer, in some cases exceeding 300ms (or two bolts!).</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/59Z9OOkEOcRLQzaJM6A2ZB/4ee8f0a294467572f88e092df1dffbc9/image01.jpg" alt="200ms into the 200m" class="kg-image" width="1280" height="850" loading="lazy">

	</figure>
	<p><sub>Creative Commons Attribution 2.0 Generic [</sub><a href="https://commons.wikimedia.org/wiki/File:London/_2012/_200m/_heat/_1/_start.jpg"><sub>Nick J. Webb</sub></a><sub>]</sub></p>
	<p>Connections that travel over longer distances have higher latency. Data travel speed is limited by the speed of light. When Cloudflare opens a new datacenter in a <a href="https://blog.cloudflare.com/panama-expands-cloudflare-network-to-50-countries">new city</a>, latency is reduced for people in the surrounding areas when visiting sites that use Cloudflare. This improvement is often simply because data has a shorter distance to travel.</p>
	<p>Geographic proximity is not the only contributor to latency. WiFi and cellular networks can add <a href="https://hpbn.co/wifi/#measuring-your-wifi-first-hop-latency">tens</a> or even <a href="https://opensignal.com/blog/2014/03/10/lte-latency-how-does-it-compare-to-other-technologies">hundreds</a> of milliseconds to transmission latency. For example, using a 3G cellular network adds around 1.5 bolts to every transmission. Satellite Internet connections are even worse, adding up to <a href="https://arstechnica.com/information-technology/2013/02/satellite-internet-faster-than-advertised-but-latency-still-awful">4 bolts to every transmission</a>.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1wIWoXVW0V1AugzJb4lVoh/3269fe660fdf6bebaa8577de42d98432/boltchart.jpg" alt="" class="kg-image" width="1028" height="612" loading="lazy">

	</figure>
	<p>Round-trip latency makes an especially big difference for HTTPS. When making a secure connection to a server, there is an additional set-up phase that can require up to three messages to make the round trip between the client and the server before the first request can even be sent. For a visitor 250ms away, this can result in an excruciating one second (1000ms) delay before a site starts loading. During this time Usain Bolt has run 10 meters and you’re still waiting for a web page. TLS 1.3 and 0-RTT can’t reduce the round trip latency of a transmission, but it can reduce the number of round trips required for setting up an HTTPS connection.</p>
	<div class="flex anchor relative">
		<h3 id="https-round-trips">HTTPS round trips</h3>
		<a href="https://blog.cloudflare.com/#https-round-trips" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>For a browser to download a web page over HTTPS, there is a some setup that goes on behind the scenes. Here are the 4 phases that need to happen the first time your browser tries to access a site.</p>
	<div class="flex anchor relative">
		<h4 id="phase-1-dns-lookup">Phase 1: DNS Lookup</h4>
		<a href="https://blog.cloudflare.com/#phase-1-dns-lookup" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Your browser needs to convert the hostname of the website (say blog.cloudflare.com) into an Internet IP address (like 2400:cb00:2048:1::6813:c166 or 104.19.193.102) before it can connect to it. DNS resolvers operated by your ISP usually cache the IP address for popular domains, and latency to your ISP is fairly low, so this step often takes a negligible amount of time.</p>
	<div class="flex anchor relative">
		<h4 id="phase-2-tcp-handshake-1-round-trip">Phase 2: TCP Handshake (1 round trip)</h4>
		<a href="https://blog.cloudflare.com/#phase-2-tcp-handshake-1-round-trip" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>The next step is to establish a TCP connection to the server. This phase consists of the client sending a SYN packet to the server, and the server responding with an ACK pack. The details don’t matter as much as the fact that this requires data to be sent from client to server and back. This takes one round trip.</p>
	<div class="flex anchor relative">
		<h4 id="phase-3-tls-handshake-2-round-trips">Phase 3: TLS Handshake (2 round trips)</h4>
		<a href="https://blog.cloudflare.com/#phase-3-tls-handshake-2-round-trips" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>In this phase, the client and server exchange cryptographic key material and set up an encrypted connection. For TLS 1.2 and earlier, this takes <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details">two round trips</a>.</p>
	<div class="flex anchor relative">
		<h4 id="phase-4-http-1-round-trip">Phase 4: HTTP (1 round trip)</h4>
		<a href="https://blog.cloudflare.com/#phase-4-http-1-round-trip" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Once the TLS connection has been established, your browser can send an encrypted HTTP request using it. This can be a GET request for a specific URL such as /, for example. The server will respond with an HTTP response containing the webpage’s HTML and the browser will start displaying the page.</p>
	<p>Assuming DNS is instantaneous, this leaves 4 round trips before the browser can start showing the page. If you’re visiting a site you’ve recently connected to, the TLS handshake phase can be shortened from two round trips to one with <a href="https://blog.cloudflare.com/tls-session-resumption-full-speed-and-secure">TLS session resumption</a>.</p>
	<p>This leaves the following minimum wait times:</p>
	<ul>
		<li>
			<p>New Connection: 4 RTT + DNS</p>
		</li>
		<li>
			<p>Resumed Connection: 3 RTT + DNS</p>
		</li>
	</ul>
	<div class="flex anchor relative">
		<h3 id="how-do-tls-1-3-and-0-rtt-improve-connection-times">How do TLS 1.3 and 0-RTT improve connection times?</h3>
		<a href="https://blog.cloudflare.com/#how-do-tls-1-3-and-0-rtt-improve-connection-times" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>One of the biggest advantages of TLS 1.3 over earlier versions is that it only requires one round trip to set up the connection, resumed or not. This provides a significant speed up for new connections, but none for resumed connections. Our measurements show that around 40% of HTTPS connections are resumptions (either via session IDs or session tickets). With 0-RTT, a round trip can be eliminated for most of that 40%.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/53zGSmQOGgFg0ARVyqQu0B/8f7c5096eb40fe509a5991c29b314a06/image04.jpg" alt="TLS connection reuse by time of day" class="kg-image" width="1999" height="1045" loading="lazy">

	</figure>
	<p>TLS connection reuse by time of day.</p>
	<p>To summarize the performance differences:</p>
	<p><i>TLS 1.2 (and earlier)</i></p>
	<ul>
		<li>
			<p>New Connection: 4 RTT + DNS</p>
		</li>
		<li>
			<p>Resumed Connection: 3 RTT + DNS</p>
		</li>
	</ul>
	<p><i>TLS 1.3</i></p>
	<ul>
		<li>
			<p>New Connection: 3 RTT + DNS</p>
		</li>
		<li>
			<p>Resumed Connection: 3 RTT + DNS</p>
		</li>
	</ul>
	<p><i>TLS 1.3 + 0-RTT</i></p>
	<ul>
		<li>
			<p>New Connection: 3 RTT + DNS</p>
		</li>
		<li>
			<p>Resumed Connection: 2 RTT + DNS</p>
		</li>
	</ul>
	<p>The performance gains are huge.</p>
	<div class="flex anchor relative">
		<h3 id="0-rtt-in-action">0-RTT in action</h3>
		<a href="https://blog.cloudflare.com/#0-rtt-in-action" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Both <a href="https://www.mozilla.org/en-US/firefox/channel/desktop">Firefox Beta</a> and <a href="https://www.google.com/chrome/browser/beta.html">Chrome Beta</a> have TLS 1.3 enabled by default. The stable versions of Chrome and Firefox also ship with TLS 1.3 support, but it has to be enabled manually for now. The only browsers which supports 0-RTT as of March 2017 are Firefox Nightly and Aurora. To enable it, do the following:</p>
	<ul>
		<li>
			<p>Enter <code>about:config</code> in the address bar</p>
		</li>
		<li>
			<p>Ensure <code>security.tls.version.max</code> is 4 (this enables TLS 1.3)</p>
		</li>
		<li>
			<p>Set <code>security.tls.enable_0rtt_data</code> to true</p>
		</li>
	</ul>
	<p>This demo loads an image from a server that runs the Cloudflare TLS 1.3 0-RTT proxy. In order to emphasize the latency differences, we used Cloudflare's new <a href="https://www.cloudflare.com/load-balancing">DNS Load Balancer</a> to direct you to a far away server. If the image is loaded over 0-RTT it will be served orange, otherwise black, based on the <code>CF-0RTT-Unique</code> header.</p>
	<p>The image is loaded twice: with and without a query string. 0-RTT is disabled transparently when a query string is used to prevent replays.</p>
	<p>The connection is pre-warmed, Keep-Alives are off and caching is disabled to simulate the first request of a resumed connection.</p>
	<hr>
	<p>Preparing the live demo to run (requires Javascript)...</p>
	<p>Click here to start the live demo.</p>
	<p>Live demo unavailable: your browser doesn't support TLS 1.3, or the connection failed.</p>
	<p>Live demo unavailable: your browser doesn't support 0-RTT.</p>
	<p>0-RTT took: ...ms</p>
	<p>1-RTT took: ...ms</p>
	<p>.demo { text-align: center; } .demo a { font-weight: bold; text-decoration: none; color: inherit; } .demo p { margin-top: 1.5em; } .images { max-width: 440px; margin: 0 auto; } .images &gt; div { width: 200px; float: left; margin: 0 10px; } .images &gt; div.clear { float: none; clear: both; } .images img { width: 100%; } var currentStatus = "preparing"; function demoStatus(s) { document.querySelector(".demo .message."+currentStatus).style.display = "none"; document.querySelector(".demo .message."+s).style.display = ""; currentStatus = s; } function demoLaunch() { var startTime, startTime0; var img = document.querySelector(".demo .images img.nozrtt"); img.onloadstart = function() { startTime = new Date().getTime(); }; img.onload = function() { var loadtime = new Date().getTime() - startTime; document.querySelector(".demo .images .time.nozrtt").innerText = loadtime; }; var img0 = document.querySelector(".demo .images img.zrtt"); img0.onloadstart = function() { startTime0 = new Date().getTime(); }; img0.onload = function() { var loadtime = new Date().getTime() - startTime0; document.querySelector(".demo .images .time.zrtt").innerText = loadtime; window.setTimeout(function() { img.src = "<a href="https://0rtt.tls13.com/img.png?no0rtt=">https://0rtt.tls13.com/img.png?no0rtt</a>"; }, 2000); }; img0.src = "<a href="https://0rtt.tls13.com/img.png">https://0rtt.tls13.com/img.png</a>"; document.querySelector(".demo .message.ready").style.display = "none"; document.querySelector(".demo .images").style.display = ""; }; document.querySelector(".demo .message.ready a").onclick = function() { // var r = new XMLHttpRequest(); // r.addEventListener("load", demoLaunch); // r.open("GET", "<a href="https://0rtt.tls13.com/img.png?warm=">https://0rtt.tls13.com/img.png?warm</a>"); // r.send(); demoLaunch(); return false; }; var r = new XMLHttpRequest(); r.addEventListener("error", function() { demoStatus("no13"); document.querySelector(".demo .fallback").style.display = ""; }); r.addEventListener("loadend", function() { var r = new XMLHttpRequest(); r.addEventListener("error", function() { demoStatus("no13"); document.querySelector(".demo .fallback").style.display = ""; }); r.addEventListener("load", function() { console.log(this.getResponseHeader("X-0rtt")); if (this.getResponseHeader("X-0rtt") == "1") { demoStatus("ready"); } else { demoStatus("no0rtt"); document.querySelector(".demo .fallback").style.display = ""; } }); window.setTimeout(function() { r.open("GET", "<a href="https://0rtt.tls13.com/img.png">https://0rtt.tls13.com/img.png</a>"); r.send(); }, 10000); }); r.open("GET", "<a href="https://0rtt.tls13.com/img.png">https://0rtt.tls13.com/img.png</a>"); r.send();</p>
	<hr>
	<p>To see what’s going on under the hood, take a look in Firefox’s Developer Tools. We’ve taken a screenshot of a version of this demo as run by a user in San Francisco. In the first screenshot, the image is served with TLS 1.3, in the second with TLS 1.3 and 0-RTT.</p>
	<figure class="kg-card kg-image-card ">
		<a href="http://staging.blog.mrk.cfdata.org/content/images/2017/03/image02.jpg">
			<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4IFlqIKCZ4NeVGJv3uuidK/6b46ab2c2cdc758cf452e0c2b50c8289/image02.jpg" alt="0-RTT" class="kg-image" width="1999" height="266" loading="lazy">
		</a>
	</figure>
	<p>In the top image, you can see that the blue “Waiting” bar is around 250ms shorter than it is for the second image. This 250ms represents the time it took for the extra round trip between the browser and the server. If you’re in San Francisco, 0-RTT enables the image to load 1.5 bolts faster than it would have otherwise.</p>
	<div class="flex anchor relative">
		<h3 id="whats-the-catch">What’s the catch?</h3>
		<a href="https://blog.cloudflare.com/#whats-the-catch" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>0-RTT is cutting edge protocol technology. With it, encrypted HTTPS requests become just as fast as an unencrypted HTTP requests. This sort of breakthrough comes at a cost. This cost is that the security properties that TLS provides to 0-RTT request are slightly weaker than those it provides to regular requests. However, this weakness is manageable, and applications and websites that follow HTTP semantics shouldn’t have anything to worry about. The weakness has to do with replays.</p>
	<p>Unlike any other requests sent over TLS, requests sent as part of 0-RTT resumption are vulnerable to what’s called a replay attack. If an attacker has access to your encrypted connection, they can take a copy of the encrypted 0-RTT data (containing your first request) and send it to the server again pretending to be you. This can result in the server seeing repeated requests from you when you only sent one.</p>
	<p>This doesn’t sound like a big deal until you consider that HTTP requests are used for more than just downloading web pages. For example, HTTP requests can trigger transfers of money. If someone makes a request to their bank to “pay $1000 to Craig” and that request is replayed, it could cause Craig to be paid multiple times. A good deal if you’re Craig.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6npVssOtArI92M8EEGPgvM/05162655ebe86e376b1abd35d934c4ba/image00.jpg" alt="" class="kg-image" width="1604" height="1052" loading="lazy">

	</figure>
	<p>Luckily, the example above is somewhat contrived. Applications need to be replay safe to work with modern browsers, whether they support 0-RTT or not. Browsers replay data all the time due to normal network glitches, and researchers from Google have even shown that attackers can <a href="https://vnhacker.blogspot.com/2015/12/bad-life-advice-never-give-up-replay.html">trick the browser into to replaying requests</a> in almost any circumstance by triggering a particular type of network error. In order to be resilient against this reality, well-designed web applications that handle sensitive requests use application-layer mechanisms to prevent replayed requests from affecting them.</p>
	<p>Although web applications should be replay resilient, that’s not always the reality. To protect these applications from malicious replays, Cloudflare took an extremely conservative approach to choosing which 0-RTT requests would be answered. Specifically, only <b>GET requests with no query parameters</b> are answered over 0-RTT. According to the HTTP specification, GET requests are supposed to be <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">idempotent</a>, meaning that they don’t change the state on the server and shouldn’t be used for things like funds transfer. We also implement a maximum size of 0-RTT requests, and limit how long they can be replayed.</p>
	<p>Furthermore, Cloudflare can uniquely identify connection resumption attempts, so we relay this information to the origin by adding an extra header to 0-RTT requests. This header uniquely identifies the request, so if one gets repeated, the origin will know it's a replay attack.</p>
	<p>Here’s what the header looks like:</p>
	<pre class="language-bash"><code class="language-bash">Cf-0rtt-Unique: 37033bcb6b42d2bcf08af3b8dbae305a</code></pre>
	<p>The hexadecimal value is derived from a piece of data called a <a href="https://tlswg.github.io/tls13-spec/#pre-shared-key-extension">PSK binder</a>, which is unique per 0-RTT request.</p>
	<p>Generally speaking, 0-RTT is safe for most web sites and applications. If your web application does strange things and you’re concerned about its replay safety, consider not using 0-RTT until you can be certain that there are no negative effects.</p>
	<div class="flex anchor relative">
		<h3 id="conclusion">Conclusion</h3>
		<a href="https://blog.cloudflare.com/#conclusion" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>TLS 1.3 is a big step forward for web performance and security. By combining TLS 1.3 with 0-RTT, the performance gains are even more dramatic. Combine this with HTTP/2 and the encrypted web has never been faster, especially on mobile networks. Cloudflare is happy to be the first to introduce this feature on a wide scale.</p>
</div>