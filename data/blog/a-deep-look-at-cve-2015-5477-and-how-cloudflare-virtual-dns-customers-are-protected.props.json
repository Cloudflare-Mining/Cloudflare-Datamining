{
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Filippo Valsorda",
				"slug": "filippo",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/46wTy3eKIkbnXRmuf2gsIt/ef5fc878a27d020b33532be5e44d9e1f/filippo.jpg",
				"location": null,
				"website": null,
				"twitter": "@filosottile",
				"facebook": null
			}
		],
		"excerpt": "Last week ISC published a patch for a critical remotely exploitable vulnerability in the BIND9 DNS server capable of causing a crash with a single packet.\n\n",
		"feature_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/5uxCjXfQ5CRFivESn4bJWb/f023a506e77109c78bc967daa952538c/a-deep-look-at-cve-2015-5477-and-how-cloudflare-virtual-dns-customers-are-protected.jpg",
		"featured": false,
		"html": "<p>Last week ISC <a href=\"https://kb.isc.org/article/AA-01272\">published</a> a patch for a critical remotely exploitable vulnerability in the BIND9 DNS server capable of causing a crash with a single packet.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/6WoX0CyBmbXc0MHG4MIfyZ/e7253e5861f89f02fc97af015d689516/8567150970_df04ccbee3_z.jpg\" alt=\"\" class=\"kg-image\" width=\"640\" height=\"123\" loading=\"lazy\"/>\n            \n            </figure><p><a href=\"https://creativecommons.org/licenses/by/2.0/\">CC BY 2.0</a> <a href=\"https://www.flickr.com/photos/rarvesen/8566054615/in/album-72157633018017313/\">image</a> by <a href=\"https://www.flickr.com/photos/rarvesen/\">Ralph Aversen</a></p><p>The public summary tells us that a mistake in handling of queries for the TKEY type causes an assertion to fail, which in turn crashes the server. Since the assertion happens during the query parsing, there is no way to avoid it: it&#39;s the first thing that happens on receiving a packet, before any decision is made about what to do with it.</p><p><a href=\"https://tools.ietf.org/html/rfc2930\">TKEY queries</a> are used in the context of <a href=\"https://tools.ietf.org/html/rfc2845\">TSIG</a>, a protocol DNS servers can use to authenticate to each other. They are special in that unlike normal DNS queries they include a “meta” record (of type TKEY) in the EXTRA/ADDITIONAL section of the message.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/Wu8uM3jN01IT813j8A6Hz/0040bf88fe8f07a50ac5632bdb2b7f56/8567150708_a63cd2cc2b_z.jpg\" alt=\"\" class=\"kg-image\" width=\"640\" height=\"136\" loading=\"lazy\"/>\n            \n            </figure><p><a href=\"https://creativecommons.org/licenses/by/2.0/\">CC BY 2.0</a> <a href=\"https://www.flickr.com/photos/rarvesen/8566054615/in/album-72157633018017313/\">image</a> by <a href=\"https://www.flickr.com/photos/rarvesen/\">Ralph Aversen</a></p><p>Since the exploit packet is now public, I thought we might take a dive and look at the vulnerable code. Let&#39;s start by taking a look at the output of a crashing instance:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">03-Aug-2015 16:38:55.509 message.c:2352: REQUIRE(*name == ((void*)0)) failed, back trace\n03-Aug-2015 16:38:55.510 #0 0x10001510d in assertion_failed()+0x5d\n03-Aug-2015 16:38:55.510 #1 0x1001ee56a in isc_assertion_failed()+0xa\n03-Aug-2015 16:38:55.510 #2 0x1000bc31d in dns_message_findname()+0x1ad\n03-Aug-2015 16:38:55.510 #3 0x10017279c in dns_tkey_processquery()+0xfc\n03-Aug-2015 16:38:55.510 #4 0x100016945 in ns_query_start()+0x695\n03-Aug-2015 16:38:55.510 #5 0x100008673 in client_request()+0x18d3\n03-Aug-2015 16:38:55.510 #6 0x1002125fe in run()+0x3ce\n03-Aug-2015 16:38:55.510 exiting (due to assertion failure)\n[1]    37363 abort (core dumped)  ./bin/named/named -f -c named.conf</pre></code>\n            <p>This is extremely helpful--after all this is a controlled crash caused by a failed assertion--and tells us what failed and where: <code>message.c:2352</code>. Here&#39;s the excerpt.</p>\n            <pre class=\"language-c\"><code class=\"language-c\">// https://source.isc.org/git/bind9.git -- faa3b61 -- lib/dns/message.c\n\n    isc_result_t\n    dns_message_findname(dns_message_t *msg, dns_section_t section,\n                 dns_name_t *target, dns_rdatatype_t type,\n                 dns_rdatatype_t covers, dns_name_t **name,\n                 dns_rdataset_t **rdataset)\n    {\n        dns_name_t *foundname;\n        isc_result_t result;\n    \n        /*\n         * XXX These requirements are probably too intensive, especially\n         * where things can be NULL, but as they are they ensure that if\n         * something is NON-NULL, indicating that the caller expects it\n         * to be filled in, that we can in fact fill it in.\n         */\n        REQUIRE(msg != NULL);\n        REQUIRE(VALID_SECTION(section));\n        REQUIRE(target != NULL);\n        if (name != NULL)\n==>         REQUIRE(*name == NULL);\n\n    [...]</pre></code>\n            <p>What we have here is a function &quot;<code>dns_message_findname</code>&quot; that searches for an RRset with the given name and type in the given message section. It employs a really common C API: to get the results the caller passes pointers that will be filled in (<code>dns_name_t **name, dns_rdataset_t **rdataset</code>).</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/1vYrM6VfswE12W68qh9f5m/08d746369d2782c6ee7ccca92b2cfb56/8566054615_c1c58976a3_z.jpg\" alt=\"\" class=\"kg-image\" width=\"640\" height=\"138\" loading=\"lazy\"/>\n            \n            </figure><p><a href=\"https://creativecommons.org/licenses/by/2.0/\">CC BY 2.0</a> <a href=\"https://www.flickr.com/photos/rarvesen/8566054615/in/album-72157633018017313/\">image</a> by <a href=\"https://www.flickr.com/photos/rarvesen/\">Ralph Aversen</a></p><p>As the big comment ironically acknowledges, it&#39;s really strict when validating these pointers: if they don&#39;t point to <code>(dns_name_t *)NULL</code> the REQUIRE assertion will fail and the server will crash with no attempt at recovery. Code calling this function must take extra care to pass a pointer to a NULL <code>dns_name_t *</code>, which the function will fill in to return the found name.</p><p>In not-memory safe languages is not uncommon to crash when a programmer assertion is violated, because a program might not be able to cleanup its own memory after something that is not supposed to happen happens.</p><p>So we continue our investigation by climbing up the stack trace to find the illegal call. Next step is <code>dns_tkey_processquery</code>. Here is a simplified excerpt.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">// https://source.isc.org/git/bind9.git -- faa3b61 -- lib/dns/tkey.c\n\nisc_result_t\ndns_tkey_processquery(dns_message_t *msg, dns_tkeyctx_t *tctx,\n              dns_tsig_keyring_t *ring)\n{\n    isc_result_t result = ISC_R_SUCCESS;\n    dns_name_t *qname, *name;\n    dns_rdataset_t *tkeyset;\n\n    /*\n     * Interpret the question section.\n     */\n    result = dns_message_firstname(msg, DNS_SECTION_QUESTION);\n    if (result != ISC_R_SUCCESS)\n        return (DNS_R_FORMERR);\n\n    qname = NULL;\n    dns_message_currentname(msg, DNS_SECTION_QUESTION, &qname);\n\n    /*\n     * Look for a TKEY record that matches the question.\n     */\n    tkeyset = NULL;\n    name = NULL;\n    result = dns_message_findname(msg, DNS_SECTION_ADDITIONAL, qname,\n                      dns_rdatatype_tkey, 0, &name, &tkeyset);\n    if (result != ISC_R_SUCCESS) {\n        /*\n         * Try the answer section, since that's where Win2000\n         * puts it.\n         */\n        if (dns_message_findname(msg, DNS_SECTION_ANSWER, qname,\n                     dns_rdatatype_tkey, 0, &name,\n                     &tkeyset) != ISC_R_SUCCESS) {\n            result = DNS_R_FORMERR;\n            tkey_log(\"dns_tkey_processquery: couldn't find a TKEY \"\n                 \"matching the question\");\n            goto failure;\n        }\n    }\n\n[...]</pre></code>\n            <p>There are two <code>dns_message_findname</code> calls here. Since we are looking for the one that passes a dirty <code>name</code> we can ignore the first one which is preceded by an explicit <code>name = NULL;</code>.</p><p>The second call is more interesting. The same <code>dns_name_t *name</code> is reused without resetting it to NULL after the previous <code>dns_message_findname</code> call. This must be where the bug is.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/56BHTJoLMp0YSCIWfkeVk8/1a0a92db350c33d1b895667bffc42948/8566054163_6f3f9e42da_z.jpg\" alt=\"\" class=\"kg-image\" width=\"640\" height=\"136\" loading=\"lazy\"/>\n            \n            </figure><p><a href=\"https://creativecommons.org/licenses/by/2.0/\">CC BY 2.0</a> <a href=\"https://www.flickr.com/photos/rarvesen/8566054163/in/album-72157633018017313/\">image</a> by <a href=\"https://www.flickr.com/photos/rarvesen/\">Ralph Aversen</a></p><p>Now the question is: when would <code>dns_message_findname</code> set <code>name</code> but not return <code>ISC_R_SUCCESS</code> (so that the <i>if</i> is satisfied)? Let&#39;s have a look at the full function body now.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">// https://source.isc.org/git/bind9.git -- faa3b61 -- lib/dns/message.c\n\nisc_result_t\ndns_message_findname(dns_message_t *msg, dns_section_t section,\n             dns_name_t *target, dns_rdatatype_t type,\n             dns_rdatatype_t covers, dns_name_t **name,\n             dns_rdataset_t **rdataset)\n{\n    dns_name_t *foundname;\n    isc_result_t result;\n\n    /*\n     * XXX These requirements are probably too intensive, especially\n     * where things can be NULL, but as they are they ensure that if\n     * something is NON-NULL, indicating that the caller expects it\n     * to be filled in, that we can in fact fill it in.\n     */\n    REQUIRE(msg != NULL);\n    REQUIRE(VALID_SECTION(section));\n    REQUIRE(target != NULL);\n    if (name != NULL)\n        REQUIRE(*name == NULL);\n    if (type == dns_rdatatype_any) {\n        REQUIRE(rdataset == NULL);\n    } else {\n        if (rdataset != NULL)\n            REQUIRE(*rdataset == NULL);\n    }\n\n    result = findname(&foundname, target,\n              &msg->sections[section]);\n\n    if (result == ISC_R_NOTFOUND)\n        return (DNS_R_NXDOMAIN);\n    else if (result != ISC_R_SUCCESS)\n        return (result);\n\n    if (name != NULL)\n        *name = foundname;\n\n    /*\n     * And now look for the type.\n     */\n    if (type == dns_rdatatype_any)\n        return (ISC_R_SUCCESS);\n\n    result = dns_message_findtype(foundname, type, covers, rdataset);\n    if (result == ISC_R_NOTFOUND)\n        return (DNS_R_NXRRSET);\n\n    return (result);\n}</pre></code>\n            <p>As you can see <code>dns_message_findname</code> uses first <code>findname</code> to match the records with the target name, and then <code>dns_message_findtype</code> to match the target type. In between the two calls... <code>*name = foundname</code>! So if <code>dns_message_findname</code> can find a record with <code>name == qname</code> in <code>DNS_SECTION_ADDITIONAL</code> but then it turns out not to have type <code>dns_rdatatype_tkey</code>, <code>name</code> will be filled in and a failure returned. The second <code>dns_message_findname</code> call will trigger on the dirty <code>name</code> and... boom.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/V4HKcvOVDy2i5aFe2FJAF/e2c68b68040fd22795c82283e8e6a2b2/8566054013_9202ac3209_z.jpg\" alt=\"\" class=\"kg-image\" width=\"640\" height=\"154\" loading=\"lazy\"/>\n            \n            </figure><p><a href=\"https://creativecommons.org/licenses/by/2.0/\">CC BY 2.0</a> <a href=\"https://www.flickr.com/photos/rarvesen/8566054163/in/album-72157633018017313/\">image</a> by <a href=\"https://www.flickr.com/photos/rarvesen/\">Ralph Aversen</a></p><p>Indeed, the patch just adds <code>name = NULL</code> before the second call. (No, we couldn&#39;t have started our investigation from the patch; what&#39;s the fun in that!?)</p>\n            <pre class=\"language-diff\"><code class=\"language-diff\">diff --git a/lib/dns/tkey.c b/lib/dns/tkey.c\nindex 66210d5..34ad90b 100644\n--- a/lib/dns/tkey.c\n+++ b/lib/dns/tkey.c\n@@ -654,6 +654,7 @@ dns_tkey_processquery(dns_message_t *msg, dns_tkeyctx_t *tctx,\n \t\t * Try the answer section, since that's where Win2000\n \t\t * puts it.\n \t\t */\n+\t\tname = NULL;\n \t\tif (dns_message_findname(msg, DNS_SECTION_ANSWER, qname,\n \t\t\t\t\t dns_rdatatype_tkey, 0, &name,\n \t\t\t\t\t &tkeyset) != ISC_R_SUCCESS) {</pre></code>\n            <p>To recap, here is the bug flow:</p><ul><li><p>a <b>query for type TKEY</b> is received, <code>dns_tkey_processquery</code> is called to parse it</p></li><li><p><code>dns_message_findname</code> is called a first time on the EXTRA section</p></li><li><p><b>a record with the same name as the query is found in the EXTRA section</b>, causing <code>name</code> to be filled, <b>but it&#39;s not a TKEY record</b>, causing <code>result != ISC_R_SUCCESS</code></p></li><li><p><code>dns_message_findname</code> is called a second time to look in the ANS section, and it is passed the now dirty <code>name</code> reference</p></li><li><p>the assertion <code>*name != NULL</code> fails, <b>BIND crashes</b></p></li></ul><p>This bug <a href=\"https://twitter.com/ISCdotORG/status/626132833849905152\">was found with</a> the amazing <a href=\"http://lcamtuf.coredump.cx/afl/\"><i>american fuzzy lop</i></a> fuzzer by <a href=\"https://twitter.com/@jfoote_\">@jfoote_</a>. A fuzzer is an automated tool that keeps feeding automatically mutated inputs to a target program until it crashes. You can see how it eventually stumbled upon the TKEY query + non-TKEY EXTRA RR combo and found this bug.</p><h3>Virtual DNS customers have always been protected</h3><p>Good news! <a href=\"https://www.cloudflare.com/virtual-dns\">CloudFlare Virtual DNS</a> customers have always been protected from this attack, even if they run BIND. Our custom Go DNS server, RRDNS, parses and sanitizes all queries before forwarding them to the origin servers if needed.</p><p>Since Virtual DNS does not support TSIG and TKEY (which are meant to authenticate server-to-server traffic, not recursive lookups) it has no reason to relay EXTRA section records in queries, so it doesn&#39;t! That reduces the attack surface and indeed makes it impossible to exploit this vulnerability through Virtual DNS.</p><p>No special rules are in place to protect from this specific vulnerability: RRDNS always validates incoming packets, making sure they look like regular queries, and strips them down to the most simple form possible before relaying them.</p>",
		"id": "60sgN5iyY1xyuGiTzlqnxo",
		"localeList": {
			"name": "A deep look at CVE-2015-5477 and how CloudFlare Virtual DNS customers are protected Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": null,
		"metadata": {
			"imgPreview": ""
		},
		"primary_author": {},
		"published_at": "2015-08-04T11:36:24.000+01:00",
		"reading_time": 5,
		"slug": "a-deep-look-at-cve-2015-5477-and-how-cloudflare-virtual-dns-customers-are-protected",
		"tags": [
			{
				"id": "2pFyOCtANFB5qS6nbtQbVp",
				"name": "Vulnerabilities",
				"slug": "vulnerabilities"
			},
			{
				"id": "5fZHv2k9HnJ7phOPmYexHw",
				"name": "DNS",
				"slug": "dns"
			},
			{
				"id": "6QVJOBzgKXUO9xAPEpqxvK",
				"name": "Reliability",
				"slug": "reliability"
			},
			{
				"id": "6lhzEBz2B56RKa4nUEAGYJ",
				"name": "Programming",
				"slug": "programming"
			}
		],
		"title": "A deep look at CVE-2015-5477 and how CloudFlare Virtual DNS customers are protected",
		"updated_at": "2024-08-27T02:38:28.357Z",
		"url": "https://blog.cloudflare.com/a-deep-look-at-cve-2015-5477-and-how-cloudflare-virtual-dns-customers-are-protected"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.blurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}