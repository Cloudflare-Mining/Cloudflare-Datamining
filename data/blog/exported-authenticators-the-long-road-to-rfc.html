<div class="mb2 gray5">8 min read</div><img class="mr2" src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/0Zs6LqudmjnXUvpvu9vkO/b1040b1454c260209c87f21fe719b3e0/exported-authenticators-the-long-road-to-rfc.png" alt="">
<div class="post-content lh-copy gray1">
	<p></p>
	<p>Our earlier <a href="https://blog.cloudflare.com/cloudflare-and-the-ietf">blog post</a> talked in general terms about how we work with the IETF. In this post we’re going to talk about a particular IETF project we’ve been working on, Exported Authenticators (EAs). Exported Authenticators is a new extension to TLS that we think will prove really exciting. It unlocks all sorts of fancy new authentication possibilities, from TLS connections with multiple certificates attached, to logging in to a website without ever revealing your password.</p>
	<p>Now, you might have thought that given the innumerable hours that went into the design of TLS 1.3 that it couldn’t possibly be improved, but it turns out that there are a number of places where the design falls a little short. TLS allows us to establish a secure connection between a client and a server. The TLS connection presents a certificate to the browser, which proves the server is authorised to use the name written on the certificate, for example <a href="https://blog.cloudflare.com">blog.cloudflare.com</a>. One of the most common things we use that ability for is delivering webpages. In fact, if you’re reading this, your browser has already done this for you. The Cloudflare Blog is delivered over TLS, and by presenting a certificate for <a href="https://blog.cloudflare.com">blog.cloudflare.com</a> the server proves that it’s allowed to deliver Cloudflare’s blog.</p>
	<p>When your browser requests <a href="https://blog.cloudflare.com">blog.cloudflare.com</a> you receive a big blob of HTML that your browser then starts to render. In the dim and distant past, this might have been the end of the story. Your browser would render the HTML, and display it. Nowadays, the web has become more complex, and the HTML your browser receives often tells it to go and load lots of other resources. For example, when I loaded the Cloudflare blog just now, my browser made 73 subrequests.</p>
	<p>As we mentioned in our <a href="https://blog.cloudflare.com/connection-coalescing-experiments">connection coalescing</a> blog post, sometimes those resources are also served by Cloudflare, but on a different domain. In our connection coalescing experiment, we acquired certificates with a special extension, called a Subject Alternative Name (SAN), that tells the browser that the owner of the certificate can act as two different websites. Along with some further shenanigans that you can read about in our <a href="https://blog.cloudflare.com/connection-coalescing-experiments">blog post</a>, this lets us serve the resources for both the domains over a single TLS connection.</p>
	<p>Cloudflare, however, services millions of domains, and we have millions of certificates. It’s possible to generate certificates that cover lots of domains, and in fact this is what Cloudflare used to do. We used to use so-called “<a href="https://dl.acm.org/doi/pdf/10.1145/2976749.2978301">cruise-liner</a>” certificates, with dozens of names on them. But for connection coalescing this quickly becomes impractical, as we would need to know what sub-resources each webpage might request, and acquire certificates to match. We switched away from this model because issues with individual domains could affect other customers.</p>
	<p>What we’d like to be able to do is serve as much content as possible down a single connection. When a user requests a resource from a different domain they need to perform a new TLS handshake, <a href="https://blog.cloudflare.com/how-expensive-is-crypto-anyway">costing valuable time and resources</a>. Our connection coalescing experiment showed the benefits when we know in advance what resources are likely to be requested, but most of the time we don’t know what subresources are going to be requested until the requests actually arrive. What we’d rather do is attach extra identities to a connection after it’s been established, and we know what extra domains the client actually wants. Because the TLS connection is just a transport mechanism and doesn’t understand the information being sent across it, it doesn’t actually know what domains might subsequently be requested. This is only available to higher-layer protocols such as HTTP. However, we don’t want any website to be able to impersonate another, so we still need to have strong authentication.</p>
	<div class="flex anchor relative">
		<h3 id="exported-authenticators">Exported Authenticators</h3>
		<a href="https://blog.cloudflare.com/#exported-authenticators" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Enter Exported Authenticators. They give us even more than we asked for. They allow us to do application layer authentication that’s just as strong as the authentication you get from TLS, and then tie it to the TLS channel. Now that’s a pretty complicated idea, so let’s break it down.</p>
	<p>To understand application layer authentication we first need to explain what the application layer is. The application layer is a reference to the <a href="https://www.cloudflare.com/learning/ddos/glossary/open-systems-interconnection-model-osi">OSI model</a>. The OSI model describes the various layers of abstraction we use, to make things work across the Internet. When you’re developing your latest web application you don’t want to have to worry about how light is flickered down a fibre optic cable, or even how the TLS handshake is encoded (although that’s a fascinating topic in its own right, let’s leave that for another time.)</p>
	<p>All you want to care about is having your content delivered to your end-user, and using TLS gives you a guaranteed in-order, reliable, authenticated channel over which you can communicate. You just shove bits in one end of the pipe, and after lots of blinky lights, fancy routing, maybe a touch of congestion control, and a little decoding, *poof*, your data arrives at the end-user.</p>
	<p>The application layer is the top of the OSI stack, and contains things like HTTP. Because the TLS handshake is lower in the stack, the application is oblivious to this process. So, what Exported Authenticators give us is the ability for the very top of the stack to reliably authenticate their partner.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5gnmKyKSeUeRR2kNpasByF/ce60689aede76d539b46a440ac9c87f8/osi-model-7-layers-1.png" alt="The seven-layered OSI model" class="kg-image" width="766" height="522" loading="lazy">

	</figure>
	<p>The seven-layered OSI model</p>
	<p>Now let’s jump back a bit, and discuss what we mean when we say that EAs give us authentication that’s as strong as TLS authentication. TLS, as we know, is used to create a secure connection between two endpoints, but lots of us are hazy when we try and pin down exactly what we mean by “secure”. The TLS standard makes <a href="https://datatracker.ietf.org/doc/html/rfc8446#appendix-E.1">eight specific promises</a>, but rather than get buried in that particular ocean of weeds, let’s just pick out the one guarantee that we care about most: Peer Authentication.</p>
	<pre class="language-bash"><code class="language-bash">Peer authentication: The client's view of the peer identity should reflect the server's identity. [...]</code></pre>
	<p>In other words, if the client thinks that it’s talking to <code>example.com</code> then it should, in fact, be talking to <code>example.com</code>.</p>
	<p>What we want from EAs is that if I receive an EA then I have cryptographic proof that the person I’m talking to is the person I think I’m talking to. Now at this point you might be wondering what an EA actually looks like, and what it has to do with certificates. Well, an EA is actually a trio of messages, the first of which is a <code>Certificate</code>. The second is a <code>CertificateVerify</code>, a cryptographic proof that the sender knows the private key for the certificate. Finally there is a <code>Finished</code> message, which acts as a MAC, and proves the first two parts of the message haven’t been tampered with. If this structure sounds familiar to you, it’s because it’s the same structure as used by the server in the TLS handshake to prove it is the owner of the certificate.</p>
	<p>The final piece of unpacking we need to do is explaining what we mean by tying the authentication to the TLS channel. Because EAs are an application layer construct they don’t provide any transport mechanism. So, whilst I know that the EA was created by the server I want to talk to, without binding the EA to a TLS connection I can’t be sure that I’m talking <i>directly</i> to the server I want.</p>
	<figure class="kg-card kg-image-card kg-width-wide">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1TE1tNAHGeIgpWWXLSo6d4/73aab69ccbfdcb00ba7819d8936df1d7/image5-16.png" alt="An EA without channel bindings, leading to an attack." class="kg-image" width="1999" height="225" loading="lazy">

	</figure>
	<p>Without protection, a malicious server can move Exported Authenticators from one connection to another.</p>
	<p>For all I know, the TLS server I’m talking to is creating a new TLS connection to the EA Server, and relaying my request, and then returning the response. This would be very bad, because it would allow a malicious server to impersonate any server that supports EAs.</p>
	<figure class="kg-card kg-image-card kg-width-wide">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1zeVsOVQkSEccH77eRqMQb/0868ebd0c27b34da59f32fa0837e3b29/image2-23.png" alt="An EA protected by channel bindings." class="kg-image" width="1999" height="202" loading="lazy">

	</figure>
	<p>Because EAs are bound to a single TLS connection, if a malicious server copies an EA from one connection to another it will fail to verify.</p>
	<p>EAs therefore have an extra security feature. They use the fact that every TLS connection is guaranteed to produce a unique set of keys. EAs take one of these keys and use it to construct the EA. This means that if some malicious third-party copies an EA from one TLS session to another, the recipient wouldn’t be able to validate it. This technique is called <a href="https://datatracker.ietf.org/doc/html/rfc5056">channel binding</a>, and is another fascinating topic, but this post is already getting a bit long, so we’ll have to revisit channel binding in a future blog post.</p>
	<div class="flex anchor relative">
		<h3 id="how-the-sausage-is-made">How the sausage is made</h3>
		<a href="https://blog.cloudflare.com/#how-the-sausage-is-made" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>OK, now we know what EAs do, let’s talk about how they were designed and built. EAs are going through the <a href="https://www.ietf.org/standards/process/informal">IETF standardisation process</a>. Draft standards move through the IETF process starting as Internet Drafts (I-Ds), and ending up as published Requests For Comment (RFCs). RFCs are voluntary standards that underpin much of the global Internet plumbing, and not just for security protocols like TLS. RFCs define DNS, UDP, TCP, and many, many more.</p>
	<p>The first step in producing a new IETF standard is coming up with a proposal. Designing security protocols is a very conservative business, firstly because it’s very easy to introduce really subtle bugs, and secondly, because if you do introduce a security issue, things can go very wrong, very quickly. A flaw in the design of a protocol can be especially problematic as it can be replicated across multiple independent implementations — for example the <a href="https://kryptera.se/Renegotiating%20TLS.pdf">TLS renegotiation vulnerabilities reported in 2009</a> and the <a href="https://dl.acm.org/doi/10.1145/2382196.2382206">custom EC(DH) parameters vulnerability from 2012</a>. To minimise the risks of design issues, EAs hew closely to the design of the TLS 1.3 handshake.</p>
	<div class="flex anchor relative">
		<h3 id="security-and-assurance">Security and Assurance</h3>
		<a href="https://blog.cloudflare.com/#security-and-assurance" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Before making a big change to how authentication works on the Internet, we want as much assurance as possible that we’re not going to break anything. To give us more confidence that EAs are secure, they reuse parts of the design of TLS 1.3. The TLS 1.3 design was carefully examined by dozens of experts, and underwent multiple rounds of formal analysis — more on that in a moment. Using well understood design patterns is a super important part of security protocols. Making something secure is incredibly difficult, because security issues can be introduced in thousands of ways, and an attacker only needs to find one. By starting from a well understood design we can leverage the years of expertise that went into it.</p>
	<p>Another vital step in catching design errors early is baked into the IETF process: achieving rough consensus. Although the ins and outs of the IETF process are worthy of their own blog post, suffice it to say the IETF works to ensure that all technical objections get addressed, and even if they aren’t solved they are given due care and attention. Exported Authenticators were proposed way back in 2016, and after many rounds of comments, feedback, and analysis the TLS Working Group (WG) at the IETF has finally reached consensus on the protocol. All that’s left before the EA I-D becomes an RFC is for a final revision of the text to be submitted and sent to the RFC Editors, leading hopefully to a published standard very soon.</p>
	<p>As we just mentioned, the WG has to come to a consensus on the design of the protocol. One thing that can hold up achieving consensus are worries about security. After the Snowden revelations there was a <a href="https://www.mitls.org/downloads/tlsauth.pdf">barrage</a> <a href="https://heartbleed.com">of</a> <a href="https://www.openssl.org/~bodo/ssl-poodle.pdf">attacks</a> <a href="https://freakattack.com">on</a> <a href="https://www.imperva.com/docs/HII_Attacking_SSL_when_using_RC4.pdf">TLS 1.2</a>, not to mention some even earlier attacks from academia. Changing how trust works on the Internet can be pretty scary, and the TLS WG didn’t want to be caught flat-footed. Luckily this coincided with the maturation of some tools and techniques we can use to get mathematical guarantees that a protocol is secure. This class of techniques is known as <a href="https://en.wikipedia.org/wiki/Formal_methods">formal methods</a>. To help ensure that people are confident in the security of EAs I performed a formal analysis.</p>
	<div class="flex anchor relative">
		<h3 id="formal-analysis">Formal Analysis</h3>
		<a href="https://blog.cloudflare.com/#formal-analysis" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Formal analysis is a special technique that can be used to examine security protocols. It creates a mathematical description of the protocol, the security properties we want it to have, and a model attacker. Then, aided by some sophisticated software, we create a proof that the protocol has the properties we want even in the presence of our model attacker. This approach is able to catch incredibly subtle edge cases, which, if not addressed, could lead to attacks, as has <a href="https://cispa.saarland/group/cremers/downloads/papers/CHSV2016-TLS13.pdf">happened</a> <a href="https://hal.inria.fr/hal-01528752/document">before</a>. Trotting out a formal analysis gives us strong assurances that we haven’t missed any horrible issues. By sticking as closely as possible to the design of TLS 1.3 we were able to repurpose much of the original analysis for EAs, giving us a big leg up in our ability to prove their security. Our EA model is <a href="https://bitbucket.org/jhoyla/tamarin-exported-authenticators/src/master">available in Bitbucket</a>, along with the proofs. You can check it out using <a href="https://tamarin-prover.github.io">Tamarin</a>, a theorem prover for security protocols.</p>
	<p>Formal analysis, and formal methods in general, give very strong guarantees that rule out entire classes of attack. However, they are not a panacea. TLS 1.3 was subject to a number of rounds of formal analysis, and yet <a href="https://eprint.iacr.org/2019/347.pdf">an attack</a> was still found. However, this attack in many ways confirms our faith in formal methods. The attack was found in a blind spot of the proof, showing that attackers have been pushed to the very edges of the protocol. As our formal analyses get more and more rigorous, attackers will have fewer and fewer places to search for attacks. As formal analysis has become more and more practical, more and more groups at the IETF have been asking to see proofs of security before standardising new protocols. This hopefully will mean that future attacks on protocol design will become rarer and rarer.</p>
	<p>Once the EA I-D becomes an RFC, then all sorts of cool stuff gets unlocked — for example <a href="https://datatracker.ietf.org/doc/html/draft-sullivan-tls-opaque-01">OPAQUE-EA</a>s, which will allow us to do password-based login on the web without the server ever seeing the password! Watch this space.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5QK1yWnP1qWPVURzf9ZlIk/63325574b90a74a60ed147994cc197fc/image4-22.png" alt="" class="kg-image" width="1446" height="749" loading="lazy">

	</figure>
</div>