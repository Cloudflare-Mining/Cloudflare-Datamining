{
	"locale": "en-us",
	"post": {
		"access": true,
		"authors": [
			{
				"id": "5d1644b141acde0011a95022",
				"name": "Ashcon Partovi",
				"slug": "ashcon",
				"profile_image": "http://blog.cloudflare.com/content/images/2021/04/117158947_4858836477475662_2532132460047140852_o.jpeg",
				"cover_image": "http://blog.cloudflare.com/content/images/2019/05/general@2x-23.png",
				"bio": null,
				"website": null,
				"location": null,
				"facebook": null,
				"twitter": "@ashconpartovi",
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/ashcon/"
			}
		],
		"canonical_url": null,
		"codeinjection_foot": null,
		"codeinjection_head": null,
		"comment_id": "5b5f597788337a00bf812568",
		"comments": false,
		"created_at": "2018-07-30T19:31:19.000+01:00",
		"custom_excerpt": "If you've ever played a video game in the past couple of years, chances are you know about Minecraft. You might be familiar with the game or even planted a tree or two, but what you might not know about is the vast number of Minecraft online communities. ",
		"custom_template": null,
		"email_subject": null,
		"excerpt": "If you've ever played a video game in the past couple of years, chances are you know about Minecraft. You might be familiar with the game or even planted a tree or two, but what you might not know about is the vast number of Minecraft online communities. ",
		"feature_image": "http://blog.cloudflare.com/content/images/2018/07/profile2.png",
		"feature_image_alt": null,
		"feature_image_caption": null,
		"featured": false,
		"frontmatter": null,
		"html": "<!--kg-card-begin: markdown--><p><em>The following was originally written as a guest post by <a href=\"https://ashcon.app\">Ashcon Partovi</a>, while a computer science and business undergraduate at the University of British Columbia in Vancouver, Canada. He's the founder of a popular Minecraft multiplayer server, <a href=\"https://stratus.network/forums\">stratus.network</a>, that provides competitive, team-based gameplay to thousands of players every week. He also now works at Cloudflare.</em></p>\n<p>If you've ever played a video game in the past couple of years, chances are you know about <a href=\"https://en.wikipedia.org/wiki/Minecraft\"><em>Minecraft</em>.</a> You might be familiar with the game or even planted a tree or two, but what you might not know about is the vast number of <em>Minecraft</em> online communities. In this post, I'm going to describe how I used Cloudflare Workers to deploy and scale a production-grade API that solves a big problem for these <em>Minecraft</em> websites.</p>\n<h3 id=\"introducingtheproblem\">Introducing the Problem</h3>\n<p>Here is an example of my <em>Minecraft</em> <a href=\"https://stratus.network/ElectroidFilms\">player profile</a> from one of the many multiplayer websites. It shows some identity information such as my username, a bitmap of my avatar, and a preview of my friends. Although rendering this page with 49 bitmap avatars may seem like an easy task, it's far from trivial. In fact, it's unnecessarily complicated.</p>\n<p>Here is the current workflow to render a player profile on a website given their username:</p>\n<ol>\n<li>Find the UUID from the player's username.</li>\n</ol>\n<pre><code>curl api.mojang.com/users/profiles/minecraft/ElectroidFilms\n{\n    &quot;id&quot;: &quot;dad8b95ccf6a44df982e8c8dd70201e0&quot;,\n    &quot;name&quot;: &quot;ElectroidFilms&quot;\n}\n</code></pre>\n<ol start=\"2\">\n<li>Use that UUID to fetch the latest player information from the session server.</li>\n</ol>\n<pre><code>curl sessionserver.mojang.com/session/minecraft/profile/dad8b95cc...\n{\n    &quot;id&quot;: &quot;dad8b95ccf6a44df982e8c8dd70201e0&quot;,\n    &quot;name&quot;: &quot;ElectroidFilms&quot;,\n    &quot;properties&quot;: [{\n      &quot;name&quot;: &quot;textures&quot;,\n      &quot;value&quot;: &quot;eyJ0aW1lc3RhbXAiOjE1MzI1MDI...&quot; // &lt;base64&gt;\n    }]\n}\n</code></pre>\n<ol start=\"3\">\n<li>Decode the textures string which is encoded as base64.</li>\n</ol>\n<pre><code>echo &quot;eyJ0aW1lc3RhbXAiOjE1MzI1MDIwNDY5NjIsIn...&quot; | base64 --decode\n{\n    &quot;timestamp&quot;: 1532502046962,\n    &quot;profileId&quot;: &quot;dad8b95ccf6a44df982e8c8dd70201e0&quot;,\n    &quot;profileName&quot;: &quot;ElectroidFilms&quot;,\n    &quot;textures&quot;: {\n      &quot;SKIN&quot;: {&quot;url&quot;: &quot;textures.minecraft.net/texture/741df6aa0...&quot;},\n      &quot;CAPE&quot;: {&quot;url&quot;: &quot;textures.minecraft.net/texture/e7dfea16d...&quot;}\n    }\n}\n</code></pre>\n<ol start=\"4\">\n<li>Fetch the texture from the URL in the decoded JSON payload.</li>\n</ol>\n<pre><code>curl textures.minecraft.net/texture/741df6aa027... &gt; skin.png\n</code></pre>\n<ol start=\"5\">\n<li>Cache the texture in a database to avoid the 60-second rate limit.</li>\n</ol>\n<pre><code>mongo\n&gt; db.users.findOneAndUpdate(\n      { _id: &quot;dad8b95ccf6a44df982e8c8dd70201e0&quot; },\n      { skin_png: new BinData(0, &quot;GWA3u4F42GIH318sAlN2wfDAWTQ...&quot;) })\n</code></pre>\n<p>Yikes, that's 5 complex operations required to render a single avatar! But that's not all, in my example profile, there are 49 avatars, which would require a total of <code>5 * 49 = 245</code> operations.</p>\n<p>And that's just <em>fetching</em> the data, we haven't even started to serve it to players! Then you have to setup a host to serve the web traffic, ensure that the service scales with demand, handle cache expiration of assets, and deploy across multiple regions. Then you have to deploy There has to be a better way!</p>\n<h3 id=\"prototypingwithworkers\">Prototyping with Workers</h3>\n<p>I'm a strong believer in the future of serverless computing. So naturally, when I learned how <a href=\"https://developers.cloudflare.com/workers/about/\">Cloudflare Workers</a> allow you to run JavaScript code in 150+ points of presence, I started to tinker with the possibilities of solving this problem. After looking at the documentation and using the <a href=\"https://cloudflareworkers.com\">Workers playground</a>, I quickly put together some JavaScript code that aggregated all that profile complexity into a single request.</p>\n<pre><code class=\"language-javascript\">addEventListener('fetch', event =&gt; {\n  event.respondWith(renderPlayerBitmap(event.request))\n})\n\nasync function renderPlayerBitmap(request) {\n  var username = request.url.split(&quot;/&quot;).pop()\n  console.log(&quot;Starting request for... &quot; + username)\n\n  // Step 1: Username -&gt; UUID\n  var uuid = await fetch(&quot;https://api.mojang.com/users/profiles/minecraft/&quot; + username)\n  if(uuid.ok) {\n    uuid = (await uuid.json()).id\n    console.log(&quot;Found uuid... &quot; + uuid)\n\n    // Step 2: UUID -&gt; Profile\n    var session = await fetch(&quot;https://sessionserver.mojang.com/session/minecraft/profile/&quot; + uuid)\n    if(session.ok) {\n      session = await session.json()\n      console.log(&quot;Found session... &quot; + JSON.stringify(session))\n\n      // Step 3: Profile -&gt; Texture URL\n      var texture = atob(session.properties[0].value)\n      console.log(&quot;Found texture... &quot; + texture)\n\n      // Step 4 + 5: Texture URL -&gt; Texture PNG + Caching\n      texture = JSON.parse(texture)\n      return fetch(texture.textures.SKIN.url, cf: {cacheTtl: 60})\n    }\n  }\n\n  return new Response(undefined, {status: 500})\n}\n\n</code></pre>\n<p>Within a couple minutes I had my first Workers implementation! I gave it my username and it was able to make all the necessary sub-requests to return my player's bitmap texture.</p>\n<p><img src=\"https://ashcon.nyc3.digitaloceanspaces.com/blog/worker_playground.png\" alt=\"worker_playground\" loading=\"lazy\"></p>\n<p>After realizing the potential of Workers, I started to wonder if I could use it for more than just a single script. What if I could design and deploy a production-ready API for <em>Minecraft</em> that runs exclusively on Workers?</p>\n<h3 id=\"designinganapi\">Designing an API</h3>\n<p>I wanted to address an essential problem for <em>Minecraft</em> developers: too many APIs with too many restrictions. The hassle of parsing multiple requests and handling errors prevents developers from focusing on creating great experiences for players. There needs to be a solution that requires only <strong>1 HTTP request with no rate limiting and no client-side caching.</strong> After looking at the various use-cases for the existing APIs, I created a JSON schema that encompassed all the essential data into a single response:</p>\n<pre><code>GET: api.ashcon.app/mojang/v1/user/&lt;username|uuid&gt;\n</code></pre>\n<pre><code class=\"language-json\">{\n  &quot;uuid&quot;: &quot;&lt;uuid&gt;&quot;,\n  &quot;username&quot;: &quot;&lt;username&gt;&quot;,\n  &quot;username_history&quot;: [\n    {\n      &quot;username&quot;: &quot;&lt;username&gt;&quot;,\n      &quot;changed_at&quot;: &quot;&lt;date|null&gt;&quot;\n    }\n  ],\n  &quot;textures&quot;: {\n    &quot;slim&quot;: &quot;&lt;boolean&gt;&quot;,\n    &quot;custom&quot;: &quot;&lt;boolean&gt;&quot;,\n    &quot;skin&quot;: {\n      &quot;url&quot;: &quot;&lt;url&gt;&quot;,\n      &quot;data&quot;: &quot;&lt;base64&gt;&quot;\n    },\n    &quot;cape&quot;: {\n      &quot;url&quot;: &quot;&lt;url|null&gt;&quot;,\n      &quot;data&quot;: &quot;&lt;base64|null&gt;&quot;\n    }\n  },\n  &quot;cached_at&quot;: &quot;&lt;date&gt;&quot;\n}\n</code></pre>\n<p>One of the primary goals I had in mind was to minimize sub-requests by clients. For example, instead of giving developers a URL to a <code>image/png</code> static asset, why not fetch it for them and embed it as a base64 string? Now that's simplicity!</p>\n<h3 id=\"gettingstarted\">Getting Started</h3>\n<p>For this project, I decided to use <a href=\"https://coffeescript.org\">CoffeeScript</a>, which transcompiles to JavaScript and has a simple syntax. We'll also need to use <a href=\"https://webpack.js.org\">Webpack</a> to bundle all of our code into a single JavaScript file to upload to Cloudflare.</p>\n<pre><code class=\"language-coffeescript\"># Welcome to CoffeeScript!\n\nstr = &quot;heyo! #{40+2}&quot;    # 'heyo! 42'\nnum = 12 if str?         # 12\narr = [1, null, &quot;apple&quot;] # [1, null, 'apple']\nval = arr[1]?.length()   # null\nhash =                   # {key: 'value'}\n  key: &quot;value&quot;\n\nadd = (a, b, {c, d} = {}) -&gt;\n  c ?= 3\n  d ?= 4\n  a + b + c + d\n\nadd(1, 2, d: 5) # 1 + 2 + 3 + 5 = 11\n</code></pre>\n<p>First, let's make sure we have the proper dependencies installed for the project! These commands will create a <code>package.json</code> file and a <code>node_modules/</code> folder in our workspace.</p>\n<pre><code>mkdir -p workspace/src\ncd workspace\nnpm init --yes\nnpm install --save-dev webpack webpack-cli coffeescript coffee-loader workers-preview\n</code></pre>\n<p>Now, we're going to edit our <code>package.json</code> to add two helper scripts for later. You can delete the default <code>&quot;test&quot;</code> script as well.</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;: {\n  &quot;build&quot;: &quot;webpack&quot;,\n  &quot;build:watch&quot;: &quot;webpack --watch&quot;,\n  &quot;preview&quot;: &quot;workers-preview &lt; dist/bundle.js&quot;\n}\n</code></pre>\n<p>We also need to initialize a <code>webpack.config.js</code> file with a CoffeeScript compiler.</p>\n<pre><code class=\"language-javascript\">const path = require('path')\n\nmodule.exports = {\n  entry: {\n    bundle: path.join(__dirname, './src/index.coffee'),\n  },\n  output: {\n    filename: 'bundle.js',\n    path: path.join(__dirname, 'dist'),\n  },\n  mode: 'production',\n  watchOptions: {\n    ignored: /node_modules|dist|\\.js/g,\n  },\n  resolve: {\n    extensions: ['.coffee', '.js', '.json'],\n    plugins: [],\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.coffee?$/,\n        loader: 'coffee-loader',\n      }\n    ]\n  }\n}\n</code></pre>\n<p>Before we start coding, we'll create a <code>src/index.coffee</code> file and make sure everything is working so far.</p>\n<pre><code class=\"language-coffeescript\">addEventListener('fetch', (event) -&gt;\n  event.respondWith(route(event.request)))\n\n# We will populate this with our own logic after we test it!\nroute = (request) -&gt;\n  fetch('https://api.ashcon.app/mojang/v1/user/ElectroidFilms')\n</code></pre>\n<p>Open your terminal in the <code>workspace/</code> directory and run the following commands:</p>\n<pre><code>npm run build\nnpm run preview\n</code></pre>\n<p>Your computer's default internet browser will open up a new window and preview the result of our Worker. If you see a JSON response, then everything is working properly and we're ready to go!</p>\n<p><img src=\"https://ashcon.nyc3.digitaloceanspaces.com/blog/worker_example.png\" alt=\"worker_example\" loading=\"lazy\"></p>\n<h3 id=\"writingproductioncodeforworkers\">Writing Production Code for Workers</h3>\n<p>Now that we're setup with a working example, we can design our source code file structure. It's important that we break up our code into easily testable chunks, so I've gone ahead and outlined the approach that I took with this project:</p>\n<pre><code>src/\n  index.coffee  # routing and serving requests\n  api.coffee    # logic layer to mutate and package requests\n  mojang.coffee # non-logic layer to send upstream requests\n  http.coffee   # HTTP requesting, parsing, and responding\n  util.coffee   # util methods and extensions\n</code></pre>\n<p>If you've feeling adventurous, I've included a simplified version of my API code that you can browse through below. If you look at each file, you'll have a fully working implementation by the end! Otherwise, you can continue reading to learn about my deployment and analysis of the APIs impact.</p>\n<h4 id=\"httpcoffee\"><code>http.coffee</code></h4>\n<p>Since our API will be making several HTTP requests, it's a good idea to code some common <code>request</code> and <code>respond</code> methods that can be reused among multiple requests. At the very least, we need to support parsing JSON or base64 responses and sending JSON or string data back to the client.</p>\n<pre><code class=\"language-coffeescript\"># Send a Http request and get a response.\n#\n# @param {string} url - Url to send the request.\n# @param {string} method - Http method (get, post, etc).\n# @param {integer} ttl - Time in seconds for Cloudflare to cache the request.\n# @param {boolean} json - Whether to parse the response as json.\n# @param {boolean} base64 - Whether to parse the response as a base64 string.\n# @returns {promise&lt;\n#   json -&gt; [err, json]\n#   base64 -&gt; string|null\n#   else -&gt; response\n# &gt;} - A different response based on the method parameters above.\nexport request = (url, {method, ttl, json, base64} = {}) -&gt;\n  method ?= &quot;GET&quot;\n  response = await fetch(url, method: method, cf: {cacheTtl: ttl} if ttl)\n  if json # Return a tuple of [err, json].\n    if err = coerce(response.status)\n      [err, null]\n    else\n      [null, await response.json()]\n  else if base64 # Return base64 string or null.\n    if response.ok\n      Buffer.from(await response.arrayBuffer(), &quot;binary&quot;).toString(&quot;base64&quot;)\n  else # If no parser is specified, just return the raw response.\n    response\n\nexport get = (url, options = {}) -&gt;\n  request(url, Object.assign(options, {method: &quot;GET&quot;}))\n\n# Respond to a client with a http response.\n#\n# @param {object} data - Data to send back in the response.\n# @param {integer} code - Http status code.\n# @param {string} type - Http content type.\n# @param {boolean} json - Whether to respond in json.\n# @param {boolean} text - Whether to respond in plain text.\n# @returns {response} - Raw response object.\nexport respond = (data, {code, type, json, text} = {}) -&gt;\n  code ?= 200\n  if json\n    type = &quot;application/json&quot;\n    # &quot;Pretty-print&quot; our JSON response with 2 spaces.\n    data = JSON.stringify(data, undefined, 2)\n  else if text\n    type = &quot;text/plain&quot;\n    data = String(data)\n  else\n    type ?= &quot;application/octet-stream&quot;\n  new Response(data, {status: code, headers: {&quot;Content-Type&quot;: type}})\n\nexport error = (reason = null, {code, type} = {}) -&gt;\n  code ?= 500\n  type ?= &quot;Internal Error&quot;\n  # An example would be: &quot;Internal Error - 500 (this is the reason)&quot;\n  respond(&quot;#{code} - #{type}&quot; + (if reason then &quot; (#{reason})&quot; else &quot;&quot;), code: code, text: true)\n\nexport badRequest = (reason = null) -&gt;\n  error(reason, code: 400, type: &quot;Bad Request&quot;)\n\nexport notFound = (reason = null) -&gt;\n  error(reason, code: 404, type: &quot;Not Found&quot;)\n\nexport tooManyRequests = (reason = null) -&gt;\n  error(reason, code: 429, type: &quot;Too Many Requests&quot;)\n\n# Convert common http error codes into error responses.\n#\n# @param {integer} code - Http status code.\n# @returns {response|null} - An error response or null if a 200 code.\nexport coerce = (code) -&gt;\n  switch code\n    when 200 then null\n    # Some Minecraft APIs use 204 as a stand-in for a 404.\n    when 204 then notFound()\n    when 400 then invalidRequest()\n    # Theoretically this should never happen, but sometimes does.\n    when 429 then tooManyRequests()\n    else error(&quot;Unknown Response&quot;, code: code)\n</code></pre>\n<p>The <code>cf</code> key can be used to control various Cloudflare features, including how sub-requests are cached. See the <a href=\"https://developers.cloudflare.com/workers/reference/cloudflare-features/\">Workers documentation</a> for a more in-depth explanation.</p>\n<pre><code class=\"language-coffeescript\">cf:\n  cacheTtl: 120 # Cache for 2 mins.\n  # Pro+ only.\n  polish: &quot;lossless&quot; # Compress image data.\n  # Enterprise only.\n  cacheTtlByStatus:\n    &quot;200-299&quot;: 60 # Cache for 60 secs.\n    &quot;300-399&quot;: 0  # Cache but expire instantly.\n    &quot;400-404&quot;: 10 # Cache for 10 secs.\n    &quot;405-599&quot;: -1 # Do not cache at all.\n  cacheKey: url # Cache lookup key, defaults to the request URL.\n</code></pre>\n<h4 id=\"mojangcoffee\"><code>mojang.coffee</code></h4>\n<p>Now that we have code to send and parse requests, we can create an interface to retrieve data from the upstream APIs. It's good to note that there should be no mutation logic in this file, it's purpose is just to get the old APIs, not change them.</p>\n<pre><code class=\"language-coffeescript\">import { get } from &quot;./http&quot;\n\n# Get the UUID of a username at the current time.\n#\n# @param {string} name - Minecraft username.\n# @throws {204} - When no user exists with that name.\n# @returns {[err, json]} - An error or username and UUID response.\nexport usernameToUuid = (name) -&gt;\n  get(&quot;https://api.mojang.com/users/profiles/minecraft/#{name}&quot;, json: true)\n\n# Get the history of usernames for the given UUID.\n#\n# @param {string} id - The UUID to check the username history.\n# @returns {[err, json]} - An error or the username history.\nexport uuidToUsernameHistory = (id) -&gt;\n  get(&quot;https://api.mojang.com/user/profiles/#{id}/names&quot;, json: true)\n\n# Get the session profile of the UUID.\n#\n# @param {string} id - UUID to get the session profile.\n# @returns {[err, json]} - An error or the session profile.\nexport uuidToProfile = (id) -&gt;\n  get(&quot;https://sessionserver.mojang.com/session/minecraft/profile/#{id}&quot;, json: true)\n</code></pre>\n<h4 id=\"apicoffee\"><code>api.coffee</code></h4>\n<p>This is where the bulk of our API logic will reside. I've broken up the process into 3 interdependent tasks that are executed in order:</p>\n<ol>\n<li>Given a username, fetch its UUID.</li>\n<li>Given a UUID, fetch the user's profile.</li>\n<li>Given a user's profile, decode and fetch the textures.</li>\n</ol>\n<pre><code class=\"language-coffeescript\">import { get, respond, error, notFound, badRequest } from &quot;./http&quot;\nimport { usernameToUuid, uuidToProfile, uuidToUsernameHistory } from &quot;./mojang&quot;\n\n# Get the uuid of a user given their username.\n#\n# @param {string} name - Minecraft username, must be alphanumeric 16 characters.\n# @returns {[err, response]} - An error or the dashed uuid of the user.\nexport uuid = (name) -&gt;\n  if name.asUsername() # Fits regex of a Minecraft username.\n    [err, res] = await usernameToUuid(name)\n    if id = res?.id?.asUuid(dashed: true)\n      [null, respond(id, text: true)]\n    else # Response was received, but contains no UUID.\n      [err || notFound(), null]\n  else\n    [badRequest(&quot;malformed username '#{name}'&quot;), null]\n\n# Get the full profile of a user given their uuid or username.\n#\n# @param {string} id - Minecraft username or uuid.\n# @returns {[err, json]} - An error or user profile.\nexport user = (id) -&gt;\n  if id.asUsername()\n    [err, res] = await uuid(id)\n    if err # Could not find a player with that username.\n      [err, null]\n    else # Recurse with the new UUID.\n      await user(id = await res.text())\n  else if id.asUuid()\n    # Fetch the profile and usernames in parallel.\n    [[err0, profile], [err1, history]] = await Promise.all([\n      uuidToProfile(id = id.asUuid())\n      uuidToUsernameHistory(id)])\n    # Extract the textures from the profile.\n    # Since this operation is complex, off-load\n    # the logic into its own method.\n    [err2, texture] = await textures(profile)\n    if err = err0 || err1 || err2\n      [err, null] # One of the last three operations failed.\n    else\n      # Everything is good, now just put the data together.\n      [null, respond(\n        uuid: profile.id.asUuid(dashed: true)\n        username: profile.name\n        username_history: history.map((item) -&gt;\n          username: item.name\n          changed_at: item.changedToAt?.asDate())\n        textures: texture\n        cached_at: new Date(),\n      json: true)]\n  else\n    [badRequest(&quot;malformed uuid '#{id}'&quot;), null]\n\n# Parse and decode base64 textures from the user profile.\n#\n# @param {json} profile - User profile from #uuidToProfile(id).\n# @returns {json} - Enhanced user profile with more convient texture fields.\ntextures = (profile) -&gt;\n  unless profile # Will occur if the profile api failed.\n    return [error(&quot;no user profile found&quot;), null]\n  properties = profile.properties\n  if properties.length == 1\n    texture = properties[0]\n  else\n    texture = properties.filter((pair) -&gt; pair.name == &quot;textures&quot; &amp;&amp; pair.value?)[0]\n  # If a embedded texture does not exist or is empty,\n  # that user does not have a custom skin.\n  if !texture || (texture = JSON.parse(atob(texture.value)).textures).isEmpty()\n    skinUrl = &quot;http://assets.mojang.com/SkinTemplates/steve.png&quot;\n  # Fetch the skin and cape data in parallel, and cache for a day.\n  [skin, cape] = await Promise.all([\n    get(skinUrl ?= texture.SKIN?.url, base64: true, ttl: 86400)\n    get(capeUrl = texture.CAPE?.url, base64: true, ttl: 86400)])\n  unless skin\n    [error(&quot;unable to fetch skin '#{skinUrl}'&quot;), null]\n  else\n    texture =\n      slim: texture.SKIN?.metadata?.model == &quot;slim&quot;\n      skin: {url: skinUrl, data: skin}\n      cape: {url: capeUrl, data: cape} if capeUrl\n    [null, texture]\n</code></pre>\n<h4 id=\"indexcoffee\"><code>index.coffee</code></h4>\n<p>Now, we parse the request's route and respond with the corresponding API.</p>\n<pre><code class=\"language-coffeescript\">import &quot;./util&quot;\nimport { notFound } from &quot;./http&quot;\nimport { uuid, user } from &quot;./api&quot;\n\naddEventListener(&quot;fetch&quot;, (event) -&gt;\n  event.respondWith(route(event.request)))\n\nroute = (request) -&gt;\n  [base, version, method, id] = request.url.split(&quot;/&quot;)[3..6]\n  if base == &quot;mojang&quot; &amp;&amp; id?\n    if version == &quot;v1&quot;\n      v1(method, id)\n    else\n      notFound(&quot;unknown api version '#{version}'&quot;)\n  else\n    notFound(&quot;unknown route&quot;)\n\nv1 = (method, id) -&gt;\n  if method == &quot;uuid&quot;\n    [err, res] = await uuid(id)\n  else if method == &quot;user&quot;\n    [err, res] = await user(id)\n  err || res || notFound(&quot;unknown v1 route '#{method}'&quot;)\n</code></pre>\n<h4 id=\"utilcoffee\"><code>util.coffee</code></h4>\n<p>Finally, we'll add some prototype extensions that we used along the way.</p>\n<pre><code class=\"language-coffeescript\"># Insert a string at a given index.\n#\n# @param {integer} i - Index to insert the string at.\n# @param {string} str - String to insert.\nString::insert = (i, str) -&gt;\n  this.slice(0, i) + str + this.slice(i)\n\n# Ensure that the string is a valid Uuid.\n#\n# If dashed is enabled, it is possible the input\n# string is not the same as the output string.\n#\n# @param {boolean} dashed - Whether to return a dashed uuid.\n# @returns {string|null} - A uuid or null.\nString::asUuid = ({dashed} = {}) -&gt;\n  if match = uuidPattern.exec(this)\n    uuid = match[1..].join(&quot;&quot;)\n    if dashed\n      uuid.insert(8, &quot;-&quot;)\n          .insert(12+1, &quot;-&quot;)\n          .insert(16+2, &quot;-&quot;)\n          .insert(20+3, &quot;-&quot;)\n    else\n      uuid\nuuidPattern = /^([0-9a-f]{8})(?:-|)([0-9a-f]{4})(?:-|)(4[0-9a-f]{3})(?:-|)([0-9a-f]{4})(?:-|)([0-9a-f]{12})$/i\n\n# Ensure that the string is a valid Minecraft username.\n#\n# @returns {string|null} - Minecraft username or null.\nString::asUsername = -&gt;\n  if usernamePattern.test(this) then this else false\nusernamePattern = /^[0-9A-Za-z_]{1,16}$/i\n\n# Ensure that the unix number is a Date.\n#\n# @returns {date} - The number as a floored date.\nNumber::asDate = -&gt;\n  new Date(Math.floor(this))\n\n# Determine if the object is empty.\n#\n# @returns {boolean} - Whether the object is empty.\nObject::isEmpty = -&gt;\n  Object.keys(this).length == 0\n</code></pre>\n<h3 id=\"analyzingaworkersdeployment\">Analyzing a Workers Deployment</h3>\n<p>I've had this code deployed and tested by real <em>Minecraft</em> users for the past few weeks. As a developer that has global web traffic, it's pivotal that players can quickly get access to my services. The essential advantage of Workers is that I don't need to deploy several replicas of my code to different cloud regions, it's everywhere! That means players from any part of the world get the same great web experience with minimal latency.</p>\n<p><img src=\"https://ashcon.nyc3.digitaloceanspaces.com/blog/worker_world_dns.png\" alt=\"worker_world_dns\" loading=\"lazy\"></p>\n<p>As of today, the API is processing over <strong>400k requests per day</strong> from users all over the world! Cloudflare caches responses in the closest point of presence to the client, so I don't need to setup a database and developers don't need to worry about rate-limiting.</p>\n<p><img src=\"https://ashcon.nyc3.digitaloceanspaces.com/blog/worker_success.png\" alt=\"worker_success\" loading=\"lazy\"></p>\n<p>Since each request to the API generates 4 to 5 additional sub-requests, it handles approximately <strong>1.8 million fetches per day</strong> with a 88% cache hit rate.</p>\n<p><img src=\"https://ashcon.nyc3.digitaloceanspaces.com/blog/worker_requests.png\" alt=\"worker_requests\" loading=\"lazy\"></p>\n<h3 id=\"wrappingup\">Wrapping Up</h3>\n<p>Cloudflare Workers have enabled me to solve complex technical problems without worrying about host infrastructure or cloud regions. It's simple, easy to deploy, and works blazing fast all around the world. And for <strong>50 cents for every 1 million requests</strong>, it's incomparable to the other serverless solutions on the market.</p>\n<p>If you're not already convinced to start using Workers, here's the deployment history of my API. I went from <strong>0 to 5 million requests</strong> with no scaling, no resizing, no servers, no clusters, and no containers. Just code.</p>\n<p><img src=\"https://ashcon.nyc3.digitaloceanspaces.com/blog/worker_progress.png\" alt=\"worker_progress\" loading=\"lazy\"></p>\n<p>If you're interested in looking at all of the code used in the post, you can find it here:<br><a href=\"https://github.com/Electroid/mojang-api\">https://github.com/Electroid/mojang-api</a></p>\n<p>And if you're a <em>Minecraft</em> developer, my API is open for you to use for free:</p>\n<pre><code>curl https://api.ashcon.app/mojang/v1/uuid/ElectroidFilms\ncurl https://api.ashcon.app/mojang/v1/user/ElectroidFilms\n</code></pre>\n<p>You can also use this <a href=\"https://github.com/Electroid/mojang-api/tree/master/avatar\">extra goodie</a> that will crop just the face from a player texture:</p>\n<pre><code>curl https://api.ashcon.app/mojang/v1/avatar/ElectroidFilms &gt; avatar.png\nopen avatar.png\n</code></pre>\n<!--kg-card-end: markdown-->",
		"id": "5d16453b41acde0011a9571f",
		"meta_description": null,
		"meta_title": null,
		"og_description": null,
		"og_image": null,
		"og_title": null,
		"primary_author": {
			"id": "5d1644b141acde0011a95022",
			"name": "Ashcon Partovi",
			"slug": "ashcon",
			"profile_image": "http://blog.cloudflare.com/content/images/2021/04/117158947_4858836477475662_2532132460047140852_o.jpeg",
			"cover_image": "http://blog.cloudflare.com/content/images/2019/05/general@2x-23.png",
			"bio": null,
			"website": null,
			"location": null,
			"facebook": null,
			"twitter": "@ashconpartovi",
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/ashcon/"
		},
		"primary_tag": {
			"id": "5d16450341acde0011a95253",
			"name": "Cloudflare Workers",
			"slug": "workers",
			"description": null,
			"feature_image": null,
			"visibility": "public",
			"meta_title": null,
			"meta_description": null,
			"og_image": null,
			"og_title": null,
			"og_description": null,
			"twitter_image": null,
			"twitter_title": null,
			"twitter_description": null,
			"codeinjection_head": null,
			"codeinjection_foot": null,
			"canonical_url": null,
			"accent_color": null,
			"url": "http://blog.cloudflare.com/tag/workers/"
		},
		"published_at": "2018-07-31T09:00:00.000+01:00",
		"reading_time": 14,
		"slug": "minecraft-api-with-workers-coffeescript",
		"tags": [
			{
				"id": "5d16450341acde0011a95253",
				"name": "Cloudflare Workers",
				"slug": "workers",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/workers/"
			},
			{
				"id": "5d16450341acde0011a95252",
				"name": "Serverless",
				"slug": "serverless",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Serverless.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Serverless",
				"meta_description": "Cloudflare blog posts tagged 'serverless'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/serverless/"
			},
			{
				"id": "5d16450341acde0011a95204",
				"name": "Developers",
				"slug": "developers",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Developers-1.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Developers",
				"meta_description": "Collection of Cloudflare blog posts tagged 'Developers'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/developers/"
			},
			{
				"id": "5d16450341acde0011a95214",
				"name": "Programming",
				"slug": "programming",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/programming/"
			},
			{
				"id": "64a3e2b834124c000b00b717",
				"name": "Developer Platform",
				"slug": "developer-platform",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/developer-platform/"
			}
		],
		"title": "Minecraft API with Workers + CoffeeScript",
		"twitter_description": null,
		"twitter_image": null,
		"twitter_title": null,
		"updated_at": "2023-05-22T22:18:18.000+01:00",
		"url": "http://blog.cloudflare.com/minecraft-api-with-workers-coffeescript/",
		"uuid": "4430a268-85a6-4238-bd93-a4592e5044ce",
		"visibility": "public"
	}
}