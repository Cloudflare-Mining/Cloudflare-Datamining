{
	"initialReadingTime": "8",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Jakub Sitnicki",
				"slug": "jakub",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/6RLFhbkBfkn8gecOR2w7wW/2f197d3a7e99f966ac7b627789d4d8a2/jakub.jpg",
				"location": null,
				"website": null,
				"twitter": null,
				"facebook": null
			}
		],
		"excerpt": "We have been dealing with conntrack, the connection tracking layer in the Linux kernel, for years. And yet, despite the collected know-how, questions about its inner workings occasionally come up. When they do, it is hard to resist the temptation to go digging for answers.",
		"feature_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/3OztDB9XCSExjkMFfbL0i4/38c4b838be7f3fa46a7ade4c6b42c274/conntrack-turns-a-blind-eye-to-dropped-syns.jpg",
		"featured": false,
		"html": "\n          <div class=\"flex anchor relative\">\n            <h2 id=\"intro\">Intro</h2>\n            <a href=\"#intro\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>We have been working with conntrack, the connection tracking layer in the Linux kernel, for years. And yet, despite the collected know-how, questions about its inner workings occasionally come up. When they do, it is hard to resist the temptation to go digging for answers.</p><p>One such question popped up while writing <a href=\"/conntrack-tales-one-thousand-and-one-flows/\">the previous blog post on conntrack</a>:</p><blockquote><p>“Why are there no entries in the conntrack table for SYN packets dropped by the firewall?”</p></blockquote><p>Ready for a deep dive into the network stack? Let’s find out.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/2hrMaSaIFXFsXevfMqgsdh/3ada84053fda492f9a5b1e95c0316fad/tqbla_C4bF9esDdiQKx-12wXVI3xKv6IDUklAgB0zu6G4KiC3ziZeCJkSgUWechnpaCnFBL6XY_glt1HNaXDqURrRm6ttta7ciHiG8vidp7x6Th0eQUqXQF4Ure.jpeg\" alt=\"\" class=\"kg-image\" width=\"1280\" height=\"853\" loading=\"lazy\"/>\n            \n            </figure><p><a href=\"https://pixabay.com/photos/female-diver-sea-scuba-diving-4829158/\"><i>Image</i></a> <i>by</i> <a href=\"https://pixabay.com/users/chulmin1700-15022416/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=4829158\"><i>chulmin park</i></a> <i>from</i> <a href=\"https://pixabay.com/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=4829158\"><i>Pixabay</i></a></p><p>We already know from <a href=\"/conntrack-tales-one-thousand-and-one-flows/\">last time</a> that conntrack is in charge of tracking incoming and outgoing network traffic. By running conntrack -L we can inspect existing network flows, or as conntrack calls them, connections.</p><p>So if we spin up a <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2021-03-conntrack-syn-drop/Vagrantfile\">toy VM</a>, <i>connect</i> to it over SSH, and inspect the contents of the conntrack table, we will see…</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">$ vagrant init fedora/33-cloud-base\n$ vagrant up\n…\n$ vagrant ssh\nLast login: Sun Jan 31 15:08:02 2021 from 192.168.122.1\n[vagrant@ct-vm ~]$ sudo conntrack -L\nconntrack v1.4.5 (conntrack-tools): 0 flow entries have been shown.</pre></code>\n            <p>… nothing!</p><p>Even though the conntrack kernel module is loaded:</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">[vagrant@ct-vm ~]$ lsmod | grep &#039;^nf_conntrack\\b&#039;\nnf_conntrack          163840  1 nf_conntrack_netlink</pre></code>\n            <p>Hold on a minute. Why is the SSH connection to the VM not listed in conntrack entries? SSH is working. With each keystroke we are sending packets to the VM. But conntrack doesn’t register it.</p><p>Isn’t conntrack an integral part of the network stack that sees every packet passing through it? ?</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/2NeBs0DqiYv9no3mYlBp7f/985045d51fb126d70023679a083cf99e/image1-5.png\" alt=\"\" class=\"kg-image\" width=\"1246\" height=\"564\" loading=\"lazy\"/>\n            \n            </figure><p>Based on an <a href=\"https://commons.wikimedia.org/wiki/File:Netfilter-packet-flow.svg\"><i>image</i></a> <i>by</i> <a href=\"https://commons.wikimedia.org/wiki/User_talk:Jengelh\"><i>Jan Engelhardt</i></a> <i>CC BY-SA 3.0</i></p><p>Clearly everything we learned about conntrack last time is not the whole story.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"calling-into-conntrack\">Calling into conntrack</h2>\n            <a href=\"#calling-into-conntrack\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Our little experiment with SSH’ing into a VM begs the question — how does conntrack actually get notified about network packets passing through the stack?</p><p>We can walk <a href=\"https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/\">the receive path step by step</a> and we won’t find any direct calls into the conntrack code in either the IPv4 or IPv6 stack. Conntrack does not interface with the network stack directly.</p><p>Instead, it relies on the Netfilter framework, and its set of hooks baked into in the stack:</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">int ip_rcv(struct sk_buff *skb, struct net_device *dev, …)\n{\n    …\n    return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,\n               net, NULL, skb, dev, NULL,\n               ip_rcv_finish);\n}</pre></code>\n            <p>Netfilter users, like conntrack, can register callbacks with it. Netfilter will then run all registered callbacks when its hook processes a network packet.</p><p>For the INET family, that is IPv4 and IPv6, there are five Netfilter hooks  to choose from:</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/3TAI6xvDHx8kWETIdRURIw/a78b6e374033be09c7bf9fd8e6f27eed/image5-1.png\" alt=\"\" class=\"kg-image\" width=\"1424\" height=\"464\" loading=\"lazy\"/>\n            \n            </figure><p>Based on <a href=\"https://thermalcircle.de/doku.php?id=blog:linux:nftables_packet_flow_netfilter_hooks_detail\"><i>Nftables - Packet flow and Netfilter hooks in detail</i></a><i>,</i> <a href=\"https://thermalcircle.de/\"><i>thermalcircle.de</i></a><i>,</i> <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.en\"><i>CC BY-SA 4.0</i></a></p><p>Which ones does conntrack use? We will get to that in a moment.</p><p>First, let’s focus on the trigger. What makes conntrack register its callbacks with Netfilter?</p><p>The SSH connection doesn’t show up in the conntrack table just because the module is loaded. We already saw that. This means that conntrack doesn’t register its callbacks with Netfilter at module load time.</p><p>Or at least, it doesn&#39;t do it by <i>default</i>. Since Linux v5.1 (May 2019) the conntrack module has the <a href=\"https://github.com/torvalds/linux/commit/ba3fbe663635ae7b33a2d972c5d2def036258e42\">enable_hooks parameter</a>, which causes conntrack to register its callbacks on load:</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">[vagrant@ct-vm ~]$ modinfo nf_conntrack\n…\nparm:           enable_hooks:Always enable conntrack hooks (bool)</pre></code>\n            <p>Going back to our toy VM, let’s try to reload the conntrack module with enable_hooks set:</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">[vagrant@ct-vm ~]$ sudo rmmod nf_conntrack_netlink nf_conntrack\n[vagrant@ct-vm ~]$ sudo modprobe nf_conntrack enable_hooks=1\n[vagrant@ct-vm ~]$ sudo conntrack -L\ntcp      6 431999 ESTABLISHED src=192.168.122.204 dst=192.168.122.1 sport=22 dport=34858 src=192.168.122.1 dst=192.168.122.204 sport=34858 dport=22 [ASSURED] mark=0 secctx=system_u:object_r:unlabeled_t:s0 use=1\nconntrack v1.4.5 (conntrack-tools): 1 flow entries have been shown.\n[vagrant@ct-vm ~]$</pre></code>\n            <p>Nice! The conntrack table now contains an entry for our SSH session.</p><p>The Netfilter hook notified conntrack about SSH session packets passing through the stack.</p><p>Now that we know how conntrack gets called, we can go back to our question — can we observe a TCP SYN packet dropped by the firewall with conntrack?</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"listing-netfilter-hooks\">Listing Netfilter hooks</h2>\n            <a href=\"#listing-netfilter-hooks\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>That is easy to check:</p><ol><li><p>Add a rule to drop anything coming to port tcp/2570<sup>2</sup></p></li></ol>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">[vagrant@ct-vm ~]$ sudo iptables -t filter -A INPUT -p tcp --dport 2570 -j DROP</pre></code>\n            <ol><li><p>Connect to the VM on port tcp/2570 from the outside</p></li></ol>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">host $ nc -w 1 -z 192.168.122.204 2570</pre></code>\n            <ol><li><p>List conntrack table entries</p></li></ol>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">[vagrant@ct-vm ~]$ sudo conntrack -L\ntcp      6 431999 ESTABLISHED src=192.168.122.204 dst=192.168.122.1 sport=22 dport=34858 src=192.168.122.1 dst=192.168.122.204 sport=34858 dport=22 [ASSURED] mark=0 secctx=system_u:object_r:unlabeled_t:s0 use=1\nconntrack v1.4.5 (conntrack-tools): 1 flow entries have been shown.</pre></code>\n            <p>No new entries. Conntrack didn’t record a new flow for the dropped SYN.</p><p>But did it process the SYN packet? To answer that we have to find out which callbacks conntrack registered with Netfilter.</p><p>Netfilter keeps track of callbacks registered for each hook in instances of <code>struct nf_hook_entries</code>. We can reach these objects through the Netfilter state (<code>struct netns_nf</code>), which lives inside network namespace (<code>struct net</code>).</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">struct netns_nf {\n    …\n    struct nf_hook_entries __rcu *hooks_ipv4[NF_INET_NUMHOOKS];\n    struct nf_hook_entries __rcu *hooks_ipv6[NF_INET_NUMHOOKS];\n    …\n}</pre></code>\n            <p><code>struct nf_hook_entries</code>, if you look at its <a href=\"https://elixir.bootlin.com/linux/v5.10.14/source/include/linux/netfilter.h#L101\">definition</a>, is a bit of an exotic construct. A glance at how the object size is calculated during its <a href=\"https://elixir.bootlin.com/linux/v5.10.14/source/net/netfilter/core.c#L50\">allocation</a> gives a hint about its memory layout:</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">    struct nf_hook_entries *e;\n    size_t alloc = sizeof(*e) +\n               sizeof(struct nf_hook_entry) * num +\n               sizeof(struct nf_hook_ops *) * num +\n               sizeof(struct nf_hook_entries_rcu_head);</pre></code>\n            <p>It’s an element count, followed by two arrays glued together, and some <a href=\"https://en.wikipedia.org/wiki/Read-copy-update\">RCU</a>-related state which we’re going to ignore. The two arrays have the same size, but hold different kinds of values.</p><p>We can walk the second array, holding pointers to struct nf_hook_ops, to discover the registered callbacks and their priority. Priority determines the invocation order.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/5nKYeHIB6aTRVx36yUT3la/f42aff5de0e02f59116cbd31ff136629/image3-3.png\" alt=\"\" class=\"kg-image\" width=\"1234\" height=\"746\" loading=\"lazy\"/>\n            \n            </figure><p>With <a href=\"https://github.com/osandov/drgn\">drgn</a>, a programmable C debugger tailored for the Linux kernel, we can locate the Netfilter state in kernel memory, and walk its contents relatively easily. Given we know what we are looking for.</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">[vagrant@ct-vm ~]$ sudo drgn\ndrgn 0.0.8 (using Python 3.9.1, without libkdumpfile)\n…\n&gt;&gt;&gt; pre_routing_hook = prog[&#039;init_net&#039;].nf.hooks_ipv4[0]\n&gt;&gt;&gt; for i in range(0, pre_routing_hook.num_hook_entries):\n...     pre_routing_hook.hooks[i].hook\n...\n(nf_hookfn *)ipv4_conntrack_defrag+0x0 = 0xffffffffc092c000\n(nf_hookfn *)ipv4_conntrack_in+0x0 = 0xffffffffc093f290\n&gt;&gt;&gt;</pre></code>\n            <p>Neat! We have a way to access Netfilter state.</p><p>Let’s take it to the next level and list all registered callbacks for each Netfilter hook (using <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2021-03-conntrack-syn-drop/tools/list-nf-hooks\">less than 100 lines of Python</a>):</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">[vagrant@ct-vm ~]$ sudo /vagrant/tools/list-nf-hooks\n? ipv4 PRE_ROUTING\n       -400 → ipv4_conntrack_defrag     ☜ conntrack callback\n       -300 → iptable_raw_hook\n       -200 → ipv4_conntrack_in         ☜ conntrack callback\n       -150 → iptable_mangle_hook\n       -100 → nf_nat_ipv4_in\n\n? ipv4 LOCAL_IN\n       -150 → iptable_mangle_hook\n          0 → iptable_filter_hook\n         50 → iptable_security_hook\n        100 → nf_nat_ipv4_fn\n 2147483647 → ipv4_confirm\n…</pre></code>\n            <p>The output from our script shows that conntrack has two callbacks registered with the <code>PRE_ROUTING</code> hook - <code>ipv4_conntrack_defrag</code> and <code>ipv4_conntrack_in</code>. But are they being called?</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/iBNniB9sIszNQV2u34qd4/1ec473a09cae3fa1211d8b7906672bcc/image4-3.png\" alt=\"\" class=\"kg-image\" width=\"1644\" height=\"224\" loading=\"lazy\"/>\n            \n            </figure><p>Based on <a href=\"https://thermalcircle.de/doku.php?id=blog:linux:nftables_packet_flow_netfilter_hooks_detail\"><i>Netfilter PRE_ROUTING hook</i></a><i>,</i> <a href=\"https://thermalcircle.de/\"><i>thermalcircle.de</i></a><i>,</i> <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.en\"><i>CC BY-SA 4.0</i></a></p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"tracing-conntrack-callbacks\">Tracing conntrack callbacks</h2>\n            <a href=\"#tracing-conntrack-callbacks\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>We expect that when the Netfilter <code>PRE_ROUTING</code> hook processes a TCP SYN packet, it will invoke <code>ipv4_conntrack_defrag</code> and then <code>ipv4_conntrack_in</code> callbacks.</p><p>To confirm it we will put to use the tracing powers of <a href=\"https://ebpf.io/\">BPF ?</a>. BPF programs can run on entry to functions. These kinds of programs are known as BPF kprobes. In our case we will attach BPF kprobes to conntrack callbacks.</p><p>Usually, when working with BPF, we would write the BPF program in C and use <code>clang -target bpf</code> to compile it. However, for tracing it will be much easier to use <a href=\"https://bpftrace.org/\">bpftrace</a>. With bpftrace we can write <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2021-03-conntrack-syn-drop/tools/trace-conntrack-prerouting.bt\">our BPF kprobe program</a> in a <a href=\"https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md\">high-level language</a> inspired by <a href=\"https://en.wikipedia.org/wiki/AWK\">AWK</a>:</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">kprobe:ipv4_conntrack_defrag,\nkprobe:ipv4_conntrack_in\n{\n    $skb = (struct sk_buff *)arg1;\n    $iph = (struct iphdr *)($skb-&gt;head + $skb-&gt;network_header);\n    $th = (struct tcphdr *)($skb-&gt;head + $skb-&gt;transport_header);\n\n    if ($iph-&gt;protocol == 6 /* IPPROTO_TCP */ &amp;&amp;\n        $th-&gt;dest == 2570 /* htons(2570) */ &amp;&amp;\n        $th-&gt;syn == 1) {\n        time(&quot;%H:%M:%S &quot;);\n        printf(&quot;%s:%u &gt; %s:%u tcp syn %s\\n&quot;,\n               ntop($iph-&gt;saddr),\n               (uint16)($th-&gt;source &lt;&lt; 8) | ($th-&gt;source &gt;&gt; 8),\n               ntop($iph-&gt;daddr),\n               (uint16)($th-&gt;dest &lt;&lt; 8) | ($th-&gt;dest &gt;&gt; 8),\n               func);\n    }\n}</pre></code>\n            <p>What does this program do? It is roughly an equivalent of a tcpdump filter:</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">dst port 2570 and tcp[tcpflags] &amp; tcp-syn != 0</pre></code>\n            <p>But only for packets passing through conntrack <code>PRE_ROUTING</code> callbacks.</p><p>(If you haven’t used bpftrace, it comes with an excellent <a href=\"https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md\">reference guide</a> and gives you the ability to explore kernel data types on the fly with <code>bpftrace -lv &#39;struct iphdr&#39;</code>.)</p><p>Let’s run the tracing program while we connect to the VM from the outside (<code>nc -z 192.168.122.204 2570</code>):</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">[vagrant@ct-vm ~]$ sudo bpftrace /vagrant/tools/trace-conntrack-prerouting.bt\nAttaching 3 probes...\nTracing conntrack prerouting callbacks... Hit Ctrl-C to quit\n13:22:56 192.168.122.1:33254 &gt; 192.168.122.204:2570 tcp syn ipv4_conntrack_defrag\n13:22:56 192.168.122.1:33254 &gt; 192.168.122.204:2570 tcp syn ipv4_conntrack_in\n^C\n\n[vagrant@ct-vm ~]$</pre></code>\n            <p>Conntrack callbacks have processed the TCP SYN packet destined to tcp/2570.</p><p>But if conntrack saw the packet, why is there no corresponding flow entry in the conntrack table?</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"going-down-the-rabbit-hole\">Going down the rabbit hole</h2>\n            <a href=\"#going-down-the-rabbit-hole\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>What actually happens inside the conntrack <code>PRE_ROUTING</code> callbacks?</p><p>To find out, we can trace the call chain that starts on entry to the conntrack callback. The <code>function_graph</code> tracer built into the <a href=\"https://lwn.net/Articles/365835/\">Ftrace</a> framework is perfect for this task.</p><p>But because all incoming traffic goes through the <code>PRE_ROUTING</code> hook, including our SSH connection, our trace will be polluted with events from SSH traffic. To avoid that, let’s switch from SSH access to a serial console.</p><p>When using <a href=\"https://github.com/vagrant-libvirt/vagrant-libvirt\">libvirt</a> as the Vagrant provider, you can connect to the serial console with <code>virsh</code>:</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">host $ virsh -c qemu:///session list\n Id   Name                State\n-----------------------------------\n 1    conntrack_default   running\n\nhost $ virsh -c qemu:///session console conntrack_default\nOnce connected to the console and logged into the VM, we can record the call chain using the trace-cmd wrapper for Ftrace:\n[vagrant@ct-vm ~]$ sudo trace-cmd start -p function_graph -g ipv4_conntrack_defrag -g ipv4_conntrack_in\n  plugin &#039;function_graph&#039;\n[vagrant@ct-vm ~]$ # … connect from the host with `nc -z 192.168.122.204 2570` …\n[vagrant@ct-vm ~]$ sudo trace-cmd stop\n[vagrant@ct-vm ~]$ sudo cat /sys/kernel/debug/tracing/trace\n# tracer: function_graph\n#\n# CPU  DURATION                  FUNCTION CALLS\n# |     |   |                     |   |   |   |\n 1)   1.219 us    |  finish_task_switch();\n 1)   3.532 us    |  ipv4_conntrack_defrag [nf_defrag_ipv4]();\n 1)               |  ipv4_conntrack_in [nf_conntrack]() {\n 1)               |    nf_conntrack_in [nf_conntrack]() {\n 1)   0.573 us    |      get_l4proto [nf_conntrack]();\n 1)               |      nf_ct_get_tuple [nf_conntrack]() {\n 1)   0.487 us    |        nf_ct_get_tuple_ports [nf_conntrack]();\n 1)   1.564 us    |      }\n 1)   0.820 us    |      hash_conntrack_raw [nf_conntrack]();\n 1)   1.255 us    |      __nf_conntrack_find_get [nf_conntrack]();\n 1)               |      init_conntrack.constprop.0 [nf_conntrack]() {  ❷\n 1)   0.427 us    |        nf_ct_invert_tuple [nf_conntrack]();\n 1)               |        __nf_conntrack_alloc [nf_conntrack]() {      ❶\n                             … \n 1)   3.680 us    |        }\n                           … \n 1) + 15.847 us   |      }\n                         … \n 1) + 34.595 us   |    }\n 1) + 35.742 us   |  }\n …\n[vagrant@ct-vm ~]$</pre></code>\n            <p>What catches our attention here is the allocation, <a href=\"https://elixir.bootlin.com/linux/v5.10.14/source/net/netfilter/nf_conntrack_core.c#L1471\">__nf_conntrack_alloc()</a> (❶), inside <code>init_conntrack() (❷). __nf_conntrack_alloc()</code> creates a <a href=\"https://elixir.bootlin.com/linux/v5.10.14/source/include/net/netfilter/nf_conntrack.h#L58\">struct nf_conn</a> object which represents a tracked connection.</p><p>This object is not created in vain. <a href=\"https://elixir.bootlin.com/linux/v5.10.14/source/net/netfilter/nf_conntrack_core.c#L1633\">A glance</a> at <code>init_conntrack()</code> <a href=\"https://elixir.bootlin.com/linux/v5.10.14/source/net/netfilter/nf_conntrack_core.c#L1633\">source</a> shows that it is pushed onto a list of unconfirmed connections<sup>3</sup>.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/4NAnZwLE3NnwyYdlSpnPls/86bd9cb30698156370731dae75fcbd92/image6-1.png\" alt=\"\" class=\"kg-image\" width=\"1102\" height=\"494\" loading=\"lazy\"/>\n            \n            </figure><p>What does it mean that a connection is unconfirmed? As <a href=\"https://manpages.debian.org/buster/conntrack/conntrack.8.en.html\">conntrack(8) man page</a> explains:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">unconfirmed:\n       This table shows new entries, that are not yet inserted into the\n       conntrack table. These entries are attached to packets that  are\n       traversing  the  stack, but did not reach the confirmation point\n       at the postrouting hook.</pre></code>\n            <p>Perhaps we have been looking for our flow in the wrong table? Does the unconfirmed table have a record for our dropped TCP SYN?</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"pulling-the-rabbit-out-of-the-hat\">Pulling the rabbit out of the hat</h2>\n            <a href=\"#pulling-the-rabbit-out-of-the-hat\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>I have bad news…</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">[vagrant@ct-vm ~]$ sudo conntrack -L unconfirmed\nconntrack v1.4.5 (conntrack-tools): 0 flow entries have been shown.\n[vagrant@ct-vm ~]$</pre></code>\n            <p>The flow is not present in the unconfirmed table. We have to dig deeper.</p><p>Let’s for a moment assume that a <code>struct nf_conn</code> object was added to the <code>unconfirmed</code> list. If the list is now empty, then the object must have been removed from the list before we inspected its contents.</p><p>Has an entry been removed from the <code>unconfirmed</code> table? What function removes entries from the <code>unconfirmed</code> table?</p><p>It turns out that <code>nf_ct_add_to_unconfirmed_list()</code> which <code>init_conntrack()</code> invokes, has its opposite defined just right beneath it - <code>nf_ct_del_from_dying_or_unconfirmed_list()</code>.</p><p>It is worth a shot to check if this function is being called, and if so, from where. For that we can again use a BPF tracing program, attached to function entry. However, this time our program will record a kernel stack trace:</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">kprobe:nf_ct_del_from_dying_or_unconfirmed_list { @[kstack()] = count(); exit(); }</pre></code>\n            <p>With <code>bpftrace</code> running our one-liner, we connect to the VM from the host with <code>nc</code> as before:</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">[vagrant@ct-vm ~]$ sudo bpftrace -e &#039;kprobe:nf_ct_del_from_dying_or_unconfirmed_list { @[kstack()] = count(); exit(); }&#039;\nAttaching 1 probe...\n\n@[\n    nf_ct_del_from_dying_or_unconfirmed_list+1 ❹\n    destroy_conntrack+78\n    nf_conntrack_destroy+26\n    skb_release_head_state+78\n    kfree_skb+50 ❸\n    nf_hook_slow+143 ❷\n    ip_local_deliver+152 ❶\n    ip_sublist_rcv_finish+87\n    ip_sublist_rcv+387\n    ip_list_rcv+293\n    __netif_receive_skb_list_core+658\n    netif_receive_skb_list_internal+444\n    napi_complete_done+111\n    …\n]: 1\n\n[vagrant@ct-vm ~]$</pre></code>\n            <p>Bingo. The conntrack delete function was called, and the captured stack trace shows that on local delivery path (❶), where <code>LOCAL_IN</code> Netfilter hook runs (❷), the packet is destroyed (❸). Conntrack must be getting called when <a href=\"https://elixir.bootlin.com/linux/v5.10.14/source/include/linux/skbuff.h#L713\">sk_buff</a> (the packet and its metadata) is destroyed. This causes conntrack to remove the unconfirmed flow entry (❹).</p><p>It makes sense. After all we have a <code>DROP</code> rule in the <code>filter/INPUT</code> chain. And that <code>iptables -j DROP</code> rule has a significant side effect. It cleans up an entry in the conntrack <code>unconfirmed</code> table!</p><p>This explains why we can’t observe the flow in the <code>unconfirmed</code> table. It lives for only a very short period of time.</p><p>Not convinced? You don’t have to take my word for it. I will prove it with a dirty trick!</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"making-the-rabbit-disappear-or-actually-appear\">Making the rabbit disappear, or actually appear</h2>\n            <a href=\"#making-the-rabbit-disappear-or-actually-appear\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>If you recall the output from <code>list-nf-hooks</code> that we’ve seen earlier, there is another conntrack callback there - <code>ipv4_confirm</code>, which I have ignored:</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">[vagrant@ct-vm ~]$ sudo /vagrant/tools/list-nf-hooks\n…\n? ipv4 LOCAL_IN\n       -150 → iptable_mangle_hook\n          0 → iptable_filter_hook\n         50 → iptable_security_hook\n        100 → nf_nat_ipv4_fn\n 2147483647 → ipv4_confirm              ☜ another conntrack callback\n… </pre></code>\n            <p><code>ipv4_confirm</code> is “the confirmation point” mentioned in the <a href=\"https://manpages.debian.org/buster/conntrack/conntrack.8.en.html\">conntrack(8) man page</a>. When a flow gets confirmed, it is moved from the <code>unconfirmed</code> table to the main <code>conntrack</code> table.</p><p>The callback is registered with a “weird” priority – 2,147,483,647. It’s the maximum positive value of a 32-bit signed integer can hold, and at the same time, the lowest possible priority a callback can have.</p><p>This ensures that the <code>ipv4_confirm</code> callback runs last. We want the flows to graduate from the <code>unconfirmed</code> table to the main <code>conntrack</code> table only once we know the corresponding packet has made it through the firewall.</p><p>Luckily for us, it is possible to have more than one callback registered with the same priority. In such cases, the order of registration matters. We can put that to use. Just for educational purposes.</p><p>Good old <code>iptables</code> won’t be of much help here. Its Netfilter callbacks have hard-coded priorities which we can’t change. But <code>nftables</code>, the <code>iptables</code> <a href=\"https://developers.redhat.com/blog/2016/10/28/what-comes-after-iptables-its-successor-of-course-nftables/\">successor</a>, is much more flexible in this regard. With <code>nftables</code> we can create a rule chain with arbitrary priority.</p><p>So this time, let’s use nftables to install a filter rule to drop traffic to port tcp/2570. The trick, though, is to register our chain before conntrack registers itself. This way our filter will run <i>last</i>.</p><p>First, delete the tcp/2570 drop rule in iptables and unregister conntrack.</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">vm # iptables -t filter -F\nvm # rmmod nf_conntrack_netlink nf_conntrack</pre></code>\n            <p>Then add tcp/2570 drop rule in <code>nftables</code>, with lowest possible priority.</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">vm # nft add table ip my_table\nvm # nft add chain ip my_table my_input { type filter hook input priority 2147483647 \\; }\nvm # nft add rule ip my_table my_input tcp dport 2570 counter drop\nvm # nft -a list ruleset\ntable ip my_table { # handle 1\n        chain my_input { # handle 1\n                type filter hook input priority 2147483647; policy accept;\n                tcp dport 2570 counter packets 0 bytes 0 drop # handle 4\n        }\n}</pre></code>\n            <p>Finally, re-register conntrack hooks.</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">vm # modprobe nf_conntrack enable_hooks=1</pre></code>\n            <p>The registered callbacks for the <code>LOCAL_IN</code> hook now look like this:</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">vm # /vagrant/tools/list-nf-hooks\n…\n? ipv4 LOCAL_IN\n       -150 → iptable_mangle_hook\n          0 → iptable_filter_hook\n         50 → iptable_security_hook\n        100 → nf_nat_ipv4_fn\n 2147483647 → ipv4_confirm, nft_do_chain_ipv4\n…</pre></code>\n            <p>What happens if we connect to port tcp/2570 now?</p>\n            <pre class=\"language-ssh\"><code class=\"language-ssh\">vm # conntrack -L\ntcp      6 115 SYN_SENT src=192.168.122.1 dst=192.168.122.204 sport=54868 dport=2570 [UNREPLIED] src=192.168.122.204 dst=192.168.122.1 sport=2570 dport=54868 mark=0 secctx=system_u:object_r:unlabeled_t:s0 use=1\nconntrack v1.4.5 (conntrack-tools): 1 flow entries have been shown.</pre></code>\n            <p>We have fooled conntrack ?</p><p>Conntrack promoted the flow from the <code>unconfirmed</code> to the main <code>conntrack</code> table despite the fact that the firewall dropped the packet. We can observe it.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"outro\">Outro</h2>\n            <a href=\"#outro\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>Conntrack processes every received packet<sup>4</sup> and creates a flow for it. A flow entry is always created even if the packet is dropped shortly after. The flow might never be promoted to the main conntrack table and can be short lived.</p><p>However, this blog post is not really about conntrack. Its internals have been covered by <a href=\"https://www.usenix.org/publications/login/june-2006-volume-31-number-3/netfilters-connection-tracking-system\">magazines</a>, <a href=\"https://www.semanticscholar.org/paper/Netfilter-Connection-Tracking-and-NAT-Boye/3f3c09dbc2a13c4840bb4a148753bb528493b607\">papers</a>, <a href=\"https://books.google.pl/books?id=RpsQAwAAQBAJ&lpg=PP1&pg=PA253#v=onepage&q&f=false\">books</a>, and on other blogs long before. We probably could have learned elsewhere all that has been shown here.</p><p>For us, conntrack was really just an excuse to demonstrate various ways to discover the inner workings of the Linux network stack. As good as any other.</p><p>Today we have powerful introspection tools like <a href=\"https://github.com/osandov/drgn\">drgn</a>, <a href=\"https://bpftrace.org/\">bpftrace</a>, or <a href=\"https://lwn.net/Articles/365835/\">Ftrace</a>, and a <a href=\"https://elixir.bootlin.com/\">cross referencer</a> to plow through the source code, at our fingertips. They help us look under the hood of a live operating system and gradually deepen our understanding of its workings.</p><p>I have to warn you, though. Once you start digging into the kernel, it is hard to stop…</p><p>...........</p><p><sup>1</sup>Actually since <a href=\"https://kernelnewbies.org/Linux_5.10#Networking\">Linux v5.10</a> (Dec 2020) there is an additional Netfilter hook for the INET family named <code>NF_INET_INGRESS</code>. The new hook type allows users to attach nftables chains to the Traffic Control ingress hook.</p><p><sup>2</sup>Why did I pick this port number? Because 2570 = 0x0a0a. As we will see later, this saves us the trouble of converting between the network byte order and the host byte order.</p><p><sup>3</sup>To be precise, there are multiple lists of unconfirmed connections. One per each CPU. This is a common pattern in the kernel. Whenever we want to prevent CPUs from contending for access to a shared state, we give each CPU a private instance of the state.</p><p><sup>4</sup>Unless we explicitly exclude it from being tracked with <code>iptables -j NOTRACK</code>.</p>",
		"id": "2F04ZqBN3X4bKtLaLCptMm",
		"localeList": {
			"name": "Conntrack turns a blind eye to dropped SYNs Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "We have been dealing with conntrack, the connection tracking layer in the Linux kernel, for years. And yet, despite the collected know-how, questions about its inner workings occasionally come up. When they do, it is hard to resist the temptation to go digging for answers.",
		"metadata": {
			"title": "Conntrack turns a blind eye to dropped SYNs",
			"description": "We have been dealing with conntrack, the connection tracking layer in the Linux kernel, for years. And yet, despite the collected know-how, questions about its inner workings occasionally come up. When they do, it is hard to resist the temptation to go digging for answers.",
			"imgPreview": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/U6InCiv1XwuwA6rUdO45a/edb02364e53af87c06a075c5c79769aa/conntrack-turns-a-blind-eye-to-dropped-syns-kNVt1J.jpeg"
		},
		"primary_author": {},
		"published_at": "2021-03-04T12:00:00.000+00:00",
		"slug": "conntrack-turns-a-blind-eye-to-dropped-syns",
		"tags": [
			{
				"id": "383iv0UQ6Lp0GZwOAxGq2p",
				"name": "Linux",
				"slug": "linux"
			},
			{
				"id": "1U6ifhBwTuaJ2w4pjNOzNT",
				"name": "Network",
				"slug": "network"
			},
			{
				"id": "73alK6sbtKLS6uB7ZrYrjj",
				"name": "Kernel",
				"slug": "kernel"
			}
		],
		"title": "Conntrack turns a blind eye to dropped SYNs",
		"updated_at": "2024-08-27T01:53:22.526Z",
		"url": "https://blog.cloudflare.com/conntrack-turns-a-blind-eye-to-dropped-syns"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.blurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}