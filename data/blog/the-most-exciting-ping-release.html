<div class="mb2 gray5">12 min read</div>
<div class="post-content lh-copy gray1">
	<!--kg-card-begin: markdown-->
	<p><small>This post is also available in <a href="https://blog.cloudflare.com/zh-cn/the-most-exciting-ping-release-zh-cn">简体中文</a>, <a href="https://blog.cloudflare.com/zh-tw/the-most-exciting-ping-release-zh-tw">繁體中文</a>.</small></p>
	<!--kg-card-end: markdown-->
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2023/01/image1-35.png" class="kg-image" alt="Give us a ping. (Cloudflare) One ping only" loading="lazy"></figure>
	<p>Ping was born in 1983 when the Internet needed a simple, effective way to measure reachability and distance. In short, ping (and subsequent utilities like traceroute and MTR) &nbsp;provides users with a quick way to validate whether one machine can communicate with another. Fast-forward to today and these network utility tools have become ubiquitous. Not only are they now the de facto standard for troubleshooting connectivity and network performance issues, but they also improve our overall quality of life by acting as a common suite of tools almost all Internet users are comfortable employing in their day-to-day roles and responsibilities.</p>
	<p>Making network utility tools work as expected is very important to us, especially now as more and more customers are building their private networks on Cloudflare. Over 10,000 teams now run a private network on Cloudflare. Some of these teams are among the world's largest enterprises, some are small crews, and yet others are hobbyists, but they all want to know - can I reach that?</p>
	<p>That’s why today we’re excited to incorporate support for these utilities into our already expansive troubleshooting toolkit for Cloudflare Zero Trust. To get started, <a href="https://forms.gle/gpfGAJW2jsxykC6y9" target="_blank">sign up</a> to receive beta access and start using the familiar debugging tools that we all know and love like ping, traceroute, and MTR to test connectivity to private network destinations running behind Tunnel.</p>
	<h2 id="cloudflare-zero-trust">Cloudflare Zero Trust</h2>
	<p>With Cloudflare Zero Trust, we’ve made it <a href="https://blog.cloudflare.com/ridiculously-easy-to-use-tunnels">ridiculously easy</a> to build your private network on Cloudflare. In fact, it takes just three steps to get started. First, download Cloudflare’s device client, WARP, to connect your users to Cloudflare. Then, create identity and device aware policies to determine who can reach what within your network. And finally, connect your network to Cloudflare with Tunnel directly from the Zero Trust dashboard.</p>
	<figure class="kg-card kg-image-card kg-width-wide"><img src="https://blog.cloudflare.com/content/images/2023/01/Untitled-1.png" class="kg-image" alt="" loading="lazy"></figure>
	<p>We’ve designed Cloudflare Zero Trust to act as a single pane of glass for your organization. This means that after you’ve deployed <em>any</em> part of our <a href="https://www.cloudflare.com/learning/security/glossary/what-is-zero-trust" target="_blank">Zero Trust</a> solution, whether that be <a href="https://www.cloudflare.com/learning/access-management/what-is-ztna" target="_blank">ZTNA</a> or <a href="https://www.cloudflare.com/learning/access-management/what-is-a-secure-web-gateway" target="_blank">SWG</a>, you are clicks, not months, away from deploying <a href="https://www.cloudflare.com/products/zero-trust/browser-isolation" target="_blank">Browser Isolation</a>, <a href="https://www.cloudflare.com/products/zero-trust/dlp" target="_blank">Data Loss Prevention</a>, <a href="https://www.cloudflare.com/products/zero-trust/casb" target="_blank">Cloud Access Security Broker</a>, and <a href="https://www.cloudflare.com/products/zero-trust/email-security" target="_blank">Email Security</a>. This is a stark contrast from other solutions on the market which may require distinct implementations or have limited interoperability across their portfolio of services.</p>
	<p>It’s that simple, but if you’re looking for more prescriptive guidance watch our <a href="https://www.cloudflare.com/products/zero-trust/interactive-demo" target="_blank">demo</a> below to get started:</p><!--kg-card-begin: html-->
	<div style="position: relative; padding-top: 54.961832061068705%;"><iframe src="https://customer-eq7kiuol0tk9chox.cloudflarestream.com/3a8e2191f0580961e6320c2d24e01294/iframe?preload=true&amp;poster=https%3A%2F%2Fcustomer-eq7kiuol0tk9chox.cloudflarestream.com%2F3a8e2191f0580961e6320c2d24e01294%2Fthumbnails%2Fthumbnail.jpg%3Ftime%3D%26height%3D600" style="border: none; position: absolute; top: 0; left: 0; height: 100%; width: 100%;" allow="accelerometer; gyroscope; autoplay; encrypted-media; picture-in-picture;" allowfullscreen="true"></iframe></div>
	<p></p><!--kg-card-end: html-->
	<p>To get started, sign-up for early access to the closed beta. If you’re interested in learning more about how it works and what else we will be launching in the future, keep scrolling.</p>
	<h2 id="so-how-do-these-network-utilities-actually-work">So, how do these network utilities actually work?</h2>
	<p>Ping, traceroute and MTR are all powered by the same underlying <a href="https://www.cloudflare.com/learning/network-layer/what-is-a-protocol" target="_blank">protocol</a>, ICMP. Every <a href="https://www.cloudflare.com/learning/ddos/glossary/internet-control-message-protocol-icmp" target="_blank">ICMP</a> message has 8-bit type and code fields, which define the purpose and semantics of the message. While ICMP has many types of messages, the network diagnostic tools mentioned above make specific use of the echo request and echo reply message types.</p>
	<p>Every ICMP message has a type, code and checksum. As you may have guessed from the name, an echo reply is generated in response to the receipt of an echo request, and critically, the request and reply have matching identifiers and sequence numbers. Make a mental note of this fact as it will be useful context later in this blog post.</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2023/01/ICMP-header-format.png" class="kg-image" alt="" loading="lazy"></figure>
	<h2 id="a-crash-course-in-ping-traceroute-and-mtr">A crash course in ping, traceroute, and MTR</h2>
	<p>As you may expect, each one of these utilities comes with its own unique nuances, but don’t worry. We’re going to provide a quick refresher on each before getting into the nitty-gritty details.</p>
	<h3 id="ping">Ping</h3>
	<p>Ping works by sending a sequence of echo request packets to the destination. Each router hop between the sender and destination decrements the TTL field of the IP packet containing the ICMP message and forwards the packet to the next hop. If a hop decrements the TTL to 0 before reaching the destination, or doesn’t have a next hop to forward to, it will return an ICMP error message – “TTL exceeded” or “Destination host unreachable” respectively – to the sender. A destination which speaks ICMP will receive these echo request packets and return matching echo replies to the sender. The same process of traversing routers and TTL decrementing takes place on the return trip. On the sender’s machine, ping reports the final TTL of these replies, as well as the roundtrip latency of sending and receiving the ICMP messages to the destination. From this information a user can determine the distance between themselves and the origin server, both in terms of number of network hops and time.</p>
	<h3 id="traceroute-and-mtr">Traceroute and MTR</h3>
	<p>As we’ve just outlined, while helpful, the output provided by ping is relatively simple. It does provide some useful information, but we will generally want to follow up this request with a traceroute to learn more about the specific path to a given destination. Similar to ping, traceroutes start by sending an ICMP echo request. However, it handles TTL a bit differently. You can <a href="https://www.cloudflare.com/learning/network-layer/what-is-mtr" target="_blank">learn more</a> about why that is the case in our <a href="https://www.cloudflare.com/learning" target="_blank">Learning Center</a>, but the important takeaway is that this is how traceroutes are able to map and capture the IP address of each unique hop on the network path. This output makes traceroute an incredibly powerful tool to understanding not only <em>if</em> a machine can connect to another, but also <em>how</em> it will get there! And finally, we’ll cover MTR. We’ve grouped traceroute and MTR together for now as they operate in an extremely similar fashion. In short, the output of an MTR will provide everything traceroute can, but with some additional, aggregate statistics for each unique hop. MTR will also run until explicitly stopped allowing users to receive a statistical average for each hop on the path.</p>
	<h2 id="checking-connectivity-to-the-origin">Checking connectivity to the origin</h2>
	<p>Now that we’ve had a quick refresher, let’s say I cannot connect to my private application server. With ICMP support enabled on my Zero Trust account, I could run a traceroute to see if the server is online.</p>
	<p>Here is simple example from one of our lab environments:</p>
	<figure class="kg-card kg-image-card kg-width-wide"><img src="https://blog.cloudflare.com/content/images/2023/01/ICMP-support-for-Warp-to-Tunnel_d.png" class="kg-image" alt="" loading="lazy"></figure>
	<p>Then, if my server is online, traceroute should output something like the following:</p><!--kg-card-begin: markdown-->
	<pre><code>traceroute -I 172.16.10.120
traceroute to 172.16.10.120 (172.16.10.120), 64 hops max, 72 byte packets
 1  172.68.101.57 (172.68.101.57)  20.782 ms  12.070 ms  15.888 ms
 2  172.16.10.100 (172.16.10.100)  31.508 ms  30.657 ms  29.478 ms
 3  172.16.10.120 (172.16.10.120)  40.158 ms  55.719 ms  27.603 ms
</code></pre>
	<!--kg-card-end: markdown-->
	<p>Let’s examine this a bit deeper. Here, the first hop is the Cloudflare data center where my Cloudflare WARP device is connected via our <a href="https://www.cloudflare.com/learning/cdn/glossary/anycast-network" target="_blank">Anycast</a> network. Keep in mind this IP may look different depending on your location. The second hop will be the server running cloudflared. And finally, the last hop is my application server.</p>
	<p>Conversely, if I could not connect to my app server I would expect traceroute to output the following:</p><!--kg-card-begin: markdown-->
	<pre><code>traceroute -I 172.16.10.120
traceroute to 172.16.10.120 (172.16.10.120), 64 hops max, 72 byte packets
 1  172.68.101.57 (172.68.101.57)  20.782 ms  12.070 ms  15.888 ms
 2  * * *
 3  * * *
</code></pre>
	<!--kg-card-end: markdown-->
	<p>In the example above, this means the ICMP echo requests are not reaching cloudflared. To troubleshoot, first I will make sure cloudflared is running by checking the status of the Tunnel in the <a href="https://dash.teams.cloudflare.com" target="_blank">ZeroTrust dashboard</a>. Then I will check if the Tunnel has a route to the destination IP. This can be found in the Routes column of the Tunnels table in the dashboard. If it does not, I will add a route to my Tunnel to see if this changes the output of my traceroute.</p>
	<p>Once I have confirmed that cloudflared is running and the Tunnel has a route to my app server, traceroute will show the following:</p><!--kg-card-begin: markdown-->
	<pre><code>raceroute -I 172.16.10.120
traceroute to 172.16.10.120 (172.16.10.120), 64 hops max, 72 byte packets
 1  172.68.101.57 (172.68.101.57)  20.782 ms  12.070 ms  15.888 ms
 2  172.16.10.100 (172.16.10.100)  31.508 ms  30.657 ms  29.478 ms
 3  * * *
</code></pre>
	<!--kg-card-end: markdown-->
	<p>However, it looks like we still can’t quite reach the application server. This means the ICMP echo requests reached cloudflared, but my application server isn’t returning echo replies. Now, I can narrow down the problem to my application server, or communication between cloudflared and the app server. Perhaps the machine needs to be rebooted or there is a firewall rule in place, but either way we have what we need to start troubleshooting the last hop. With ICMP support, we now have many network tools at our disposal to troubleshoot connectivity end-to-end.</p>
	<p>Note that the route cloudflared to origin is always shown as a single hop, even if there are one or more routers between the two. This is because cloudflared creates its own echo request to the origin, instead of forwarding the original packets. In the next section we will explain the technical reason behind it.</p>
	<h2 id="what-makes-icmp-traffic-unique">What makes ICMP traffic unique?</h2>
	<p>A few quarters ago, Cloudflare Zero Trust <a href="https://blog.cloudflare.com/extending-cloudflares-zero-trust-platform-to-support-udp-and-internal-dns">extended support for UDP</a> end-to-end as well. Since UDP and ICMP are both datagram-based protocols, within the Cloudflare network we can reuse the same infrastructure to proxy both UDP and ICMP traffic. To do this, we send the individual datagrams for either protocol over a QUIC connection using <a href="https://datatracker.ietf.org/doc/html/rfc9221" target="_blank">QUIC datagrams</a> between Cloudflare and the cloudflared instances within your network.</p>
	<p>With UDP, we establish and maintain a <em>session</em> per client/destination pair, such that we are able to send <strong>only</strong> the UDP payload and a session identifier in datagrams. In this way, we don’t need to send the IP and port to which the UDP payload should be forwarded with every single packet.</p>
	<p>However, with ICMP we decided that establishing a session like this is far too much overhead, given that typically only a handful of ICMP packets are exchanged between endpoints. Instead, we send the entire IP packet (with the ICMP payload inside) as a single datagram.</p>
	<p>What this means is that cloudflared can read the destination of the ICMP packet from the IP header it receives. While this conveys the eventual destination of the packet to cloudflared, there is still work to be done to actually send the packet. Cloudflared cannot simply send out the IP packet it receives without modification, because the source IP in the packet is still the <em>original</em> client IP, and not a source that is routable to the cloudflared instance itself.</p>
	<p>To receive ICMP echo replies in response to the ICMP packets it forwards, cloudflared must apply a source NAT to the packet. This means that when cloudflared receives an IP packet, it must complete the following:</p>
	<ul>
		<li>Read the destination IP address of the packet</li>
		<li>Strip off the IP header to get the ICMP payload</li>
		<li>Send the ICMP payload to the destination, meaning the source address of the ICMP packet will be the IP of a network interface to which cloudflared can bind</li>
		<li>When cloudflared receives replies on this address, it must rewrite the destination address of the received packet (destination because the direction of the packet is reversed) to the original client source address</li>
	</ul>
	<p>Network Address Translation like this is done all the time for <a href="https://www.cloudflare.com/learning/ddos/glossary/tcp-ip" target="_blank">TCP</a> and UDP, but is much easier in those cases because ports can be used to disambiguate cases where the source and destination IPs are the same. Since ICMP packets do not have ports associated with them, we needed to find a way to map packets received from the upstream back to the original source which sent cloudflared those packets.</p>
	<p>For example, imagine that two clients 192.0.2.1 and 192.0.2.2 both send an ICMP echo request to a destination 10.0.0.8. As we previously outlined, cloudflared must rewrite the source IPs of these packets to a source address to which it can bind. In this scenario, when the echo replies come back, the IP headers will be identical: source=10.0.0.8 destination=&lt;cloudflared’s IP&gt;. So, how can cloudflared determine which packet needs to have its destination rewritten to 192.0.2.1 and which to 192.0.2.2?</p>
	<p>To solve this problem, we use fields of the ICMP packet to track packet flows, in the same way that ports are used in TCP/UDP NAT. The field we’ll use for this purpose is the Echo ID. When an echo request is received, conformant ICMP endpoints will return an echo reply with the same identifier as was received in the request. This means we can send the packet from 192.0.2.1 with ID 23 and the one from 192.0.2.2 with ID 45, and when we receive replies with IDs 23 and 45, we know which one corresponds to each original source.</p>
	<p>Of course this strategy only works for ICMP echo requests, which make up a relatively small percentage of the available ICMP message types. For security reasons, however, and owing to the fact that these message types are sufficient to implement the ubiquitous ping and traceroute functionality that we’re after, these are the only message types we currently support. We’ll talk through the security reasons for this choice in the next section.</p>
	<h2 id="how-to-proxy-icmp-without-elevated-permissions">How to proxy ICMP without elevated permissions</h2>
	<p>Generally, applications need to send ICMP packets through raw sockets. Applications have control of the IP header using this socket, so it requires elevated privileges to open. Whereas the IP header for TCP and UDP packets are added on send and removed on receive by the operating system. To adhere to security best-practices, we don’t really want to run cloudflared with additional privileges. We needed a better solution. To solve this, we found inspiration in the ping utility, which you’ll note can be run by <em>any</em> user, <em>without</em> elevated permissions. So then, how does ping send ICMP echo requests and listen for echo replies as a normal user program? Well, the answer is less satisfying: it depends (on the platform). And as cloudflared supports all the following platforms, we needed to answer this question for each.</p>
	<h3 id="linux">Linux</h3>
	<p>On linux, ping opens a datagram socket for the ICMP protocol with the syscall <em><strong>socket(PF_INET, SOCK_DGRAM, PROT_ICMP).</strong></em> This type of socket can only be opened if the group ID of the user running the program is in <em><strong>/proc/sys/net/ipv4/ping_group_range</strong></em>, but critically, the user does not need to be root. This socket is “special” in that it can only send ICMP echo requests and receive echo replies. Great! It also has a conceptual “port” associated with it, despite the fact that ICMP does not use ports. In this case, the identifier field of echo requests sent through this socket are rewritten to the “port” assigned to the socket. Reciprocally, echo replies received by the kernel which have the same identifier are sent to the socket which sent the request.</p>
	<p>Therefore, on linux cloudflared is able to perform source NAT for ICMP packets simply by opening a unique socket per source IP address. This rewrites the identifier field and source address of the request. Replies are delivered to this same socket meaning that cloudflared can easily rewrite the destination IP address (destination because the packets are flowing <em>to </em>the client) and echo identifier back to the original values received from the client.</p>
	<h3 id="darwin">Darwin</h3>
	<p>On Darwin (the UNIX-based core set of components which make up macOS), things are similar, in that we can open an unprivileged ICMP socket with the same syscall <strong><em>socket(PF_INET, SOCK_DGRAM, PROT_ICMP)</em></strong>. However, there is an important difference. With Darwin the kernel does not allocate a conceptual “port” for this socket, and thus, when sending ICMP echo requests the kernel does not rewrite the echo ID as it does on linux. Further, and more importantly for our purposes, the kernel does not demultiplex ICMP echo replies to the socket which sent the corresponding request using the echo identifier. This means that on macOS, we effectively need to perform the echo ID rewriting manually. In practice, this means that when cloudflared receives an echo request on macOS, it must choose an echo ID which is unique for the destination. Cloudflared then adds a key of (chosen echo ID, destination IP) to a mapping it then maintains, with a value of (original echo ID, original source IP). Cloudflared rewrites the echo ID in the echo request packet to the one it chose and forwards it to the destination. When it receives a reply, it is able to use the source IP address and echo ID to look up the client address and original echo ID and rewrite the echo ID and destination address in the reply packet before forwarding it back to the client.</p>
	<h3 id="windows">Windows</h3>
	<p>Finally, we arrived at Windows which conveniently provides a Win32 API IcmpSendEcho that sends echo requests and returns echo reply, timeout or error. For ICMPv6 we just had to use Icmp6SendEcho. The APIs are in C, but cloudflared can call them through CGO without a problem. If you also need to call these APIs in a Go program, <a href="https://github.com/cloudflare/cloudflared/blob/master/ingress/icmp_windows.go" target="_blank">checkout our wrapper</a> for inspiration.</p>
	<p>And there you have it! That’s how we built the most exciting ping release since 1983. Overall, we’re thrilled to announce this new feature and can’t wait to get your feedback on ways we can continue improving our implementation moving forward.</p>
	<h2 id="what-s-next">What’s next</h2>
	<p>Support for these ICMP-based utilities is just the beginning of how we’re thinking about improving our Zero Trust administrator experience. Our goal is to continue providing tools which make it easy to identify issues within the network that impact connectivity and performance.</p>
	<p>Looking forward, we plan to add more dials and knobs for observability with announcements like <a href="https://blog.cloudflare.com/introducing-digital-experience-monitoring">Digital Experience Monitoring</a> across our Zero Trust platform to help users proactively monitor and stay alert to changing network conditions. In the meantime, try applying Zero Trust controls to your private network for free by <a href="https://dash.cloudflare.com/sign-up" target="_blank">signing up</a> today. </p>
</div>