{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "2",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Steven Pack",
				"slug": "stevenpack",
				"bio": "Partner Engineering Director",
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5KBJRA6GGkWLzkmUgwTrMs/82479e6c25be69362e444cdcad205625/stevenpack.png",
				"location": "San Francisco Bay Area, California",
				"website": null,
				"twitter": "@steven_pack",
				"facebook": null,
				"publiclyIndex": true
			}
		],
		"excerpt": "If you followed part one, I’ve set up an environment to write TypeScript with tests and deploy to the Cloudflare Edge using npm run upload. In this post, I’ll expand on one Worker Recipe even further.",
		"feature_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4RdnhNAtJacuWQ4LBWWeQX/6b8095dcf9cbce198c29ef6018cefd90/image3-36.png",
		"featured": false,
		"html": "<p>If you followed <a href=\"/p/607ad519-5652-4688-9fff-33fbb1fc9d3f/\">part one</a>, I have an environment setup where I can write Typescript with tests and deploy to the Cloudflare Edge with <code>npm run upload</code>. For this post, I want to take one of the <a href=\"https://developers.cloudflare.com/workers/recipes/aggregating-multiple-requests/\">Worker Recipes</a> further.</p><p>I&#39;m going to build a mini HTTP request routing and handling framework, then use it to build a <a href=\"https://www.cloudflare.com/learning/security/api/what-is-an-api-gateway/\">gateway</a> to multiple cryptocurrency API providers. My point here is that in a single file, with no dependencies, you can quickly build pretty sophisticated logic and deploy fast and easily to the Edge. Furthermore, using modern Typescript with async/await and the rich type structure, you also write clean, async code.</p><p>OK, here we go...</p><p>My API will look like this:</p><table><tr><td><p>Verb</p></td><td><p>Path</p></td><td><p>Description</p></td></tr><tr><td><p>GET</p></td><td><p><code>/api/ping</code></p></td><td><p>Check the Worker is up</p></td></tr><tr><td><p>GET</p></td><td><p><code>/api/all/spot/:symbol</code></p></td><td><p>Aggregate the responses from all our configured gateways</p></td></tr><tr><td><p>GET</p></td><td><p><code>/api/race/spot/:symbol</code></p></td><td><p>Return the response of the provider who responds fastest</p></td></tr><tr><td><p>GET</p></td><td><p><code>/api/direct/:exchange/spot/:symbol</code></p></td><td><p>Pass through the request to the gateway. E.g. gdax or bitfinex</p></td></tr></table>\n    <div class=\"flex anchor relative\">\n      <h3 id=\"the-framework\">The Framework</h3>\n      <a href=\"#the-framework\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>OK, this is Typescript, I get interfaces and I&#39;m going to use them. Here&#39;s my ultra-mini-http-routing framework definition:</p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">export interface IRouter {\n  route(req: RequestContextBase): IRouteHandler;\n}\n\n/**\n * A route\n */\nexport interface IRoute {\n  match(req: RequestContextBase): IRouteHandler | null;\n}\n\n/**\n * Handles a request.\n */\nexport interface IRouteHandler {\n  handle(req: RequestContextBase): Promise&lt;Response&gt;;\n}\n\n/**\n * Request with additional convenience properties\n */\nexport class RequestContextBase {\n  public static fromString(str: string) {\n    return new RequestContextBase(new Request(str));\n  }\n\n  public url: URL;\n  constructor(public request: Request) {\n    this.url = new URL(request.url);\n  }\n}</pre></code>\n            <p>So basically all requests will go to <code>IRouter</code>. If it finds an <code>IRoute</code> that returns an <code>IRouterHandler</code>, then it will call that and pass in <code>RequestContextBase</code>, which is just the request with a parsed URL for convenience.</p><p>I stopped short of dependency injection, so here&#39;s the router implementation with 4 routes we&#39;ve implemented (Ping, Race, All and Direct). Each route corresponds to one of the four operations I defined in the API above and returns the corresponding <code>IRouteHandler</code>.</p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">export class Router implements IRouter {\n  public routes: IRoute[];\n\n  constructor() {\n    this.routes = [\n      new PingRoute(),\n      new RaceRoute(),\n      new AllRoute(),\n      new DirectRoute(),\n    ];\n  }\n\n  public async handle(request: Request): Promise&lt;Response&gt; {\n    try {\n      const req = new RequestContextBase(request);\n      const handler = this.route(req);\n      return handler.handle(req);\n    } catch (e) {\n      return new Response(undefined, {\n        status: 500,\n        statusText: `Error. ${e.message}`,\n      });\n    }\n  }\n\n  public route(req: RequestContextBase): IRouteHandler {\n    const handler: IRouteHandler | null = this.match(req);\n    if (handler) {\n      logger.debug(`Found handler for ${req.url.pathname}`);\n      return handler;\n    }\n    return new NotFoundHandler();\n  }\n\n  public match(req: RequestContextBase): IRouteHandler | null {\n    for (const route of this.routes) {\n      const handler = route.match(req);\n      if (handler != null) {\n        return handler;\n      }\n    }\n    return null;\n  }\n}</pre></code>\n            <p>You can see above I return a NotFoundHandler if we can&#39;t find a matching route. Its implementation is below. It&#39;s easy to see how 401, 405, 500 and all the common handlers could be implemented.</p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">/**\n * 404 Not Found\n */\nexport class NotFoundHandler implements IRouteHandler {\n  public async handle(req: RequestContextBase): Promise&lt;Response&gt; {\n    return new Response(undefined, {\n      status: 404,\n      statusText: &#039;Unknown route&#039;,\n    });\n  }\n}</pre></code>\n            <p>Now let&#39;s start with Ping. The framework separates matching a route and handling the request. Firstly the route:</p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">export class PingRoute implements IRoute {\n  public match(req: RequestContextBase): IRouteHandler | null {\n    if (req.request.method !== &#039;GET&#039;) {\n      return new MethodNotAllowedHandler();\n    }\n    if (req.url.pathname.startsWith(&#039;/api/ping&#039;)) {\n      return new PingRouteHandler();\n    }\n    return null;\n  }\n}</pre></code>\n            <p>Simple enough, if the URL starts with <code>/api/ping</code>, handle the request with a <code>PingRouteHandler</code></p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">export class PingRouteHandler implements IRouteHandler {\n  public async handle(req: RequestContextBase): Promise&lt;Response&gt; {\n    const pong = &#039;pong;&#039;;\n    const res = new Response(pong);\n    logger.info(`Responding with ${pong} and ${res.status}`);\n    return new Response(pong);\n  }\n}</pre></code>\n            <p>So at this point, if you followed along with Part 1, you can do:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ npm run upload\n$ curl https://cryptoserviceworker.com/api/ping\npong</pre></code>\n            <p>OK, next the <code>AllHandler</code>, this aggregates the responses. Firstly the route matcher:</p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">export class AllRoute implements IRoute {\n  public match(req: RequestContextBase): IRouteHandler | null {\n    if (req.url.pathname.startsWith(&#039;/api/all/&#039;)) {\n      return new AllHandler();\n    }\n    return null;\n  }\n}</pre></code>\n            <p>And if the route matches, we&#39;ll handle it by farming off the requests to our downstream handlers:</p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">export class AllHandler implements IRouteHandler {\n  constructor(private readonly handlers: IRouteHandler[] = []) {\n    if (handlers.length === 0) {\n      const factory = new HandlerFactory();\n      logger.debug(&#039;No handlers, getting from factory&#039;);\n      this.handlers = factory.getProviderHandlers();\n    }\n  }\n\n  public async handle(req: RequestContextBase): Promise&lt;Response&gt; {\n    const responses = await Promise.all(\n      this.handlers.map(async h =&gt; h.handle(req))\n    );\n    const jsonArr = await Promise.all(responses.map(async r =&gt; r.json()));\n    return new Response(JSON.stringify(jsonArr));\n  }\n}</pre></code>\n            <p>I&#39;m cheating a bit here because I haven&#39;t shown you the code for <code>HandlerFactory</code> or the implementation of <code>handle</code> for each one. You can look up the full source <a href=\"https://github.com/stevenpack/cryptoserviceworker/blob/master/src/service-worker.ts\">here</a>.</p><p>Take a moment here to appreciate just what&#39;s happening. You&#39;re writing very expressive async code that in a few lines, is able to multiplex a request to multiple endpoints and aggregate the results. Furthermore, it&#39;s running in a sandboxed environment in a data center very close to your end user. <b>Edge-side code is a game changer.</b></p><p>Let&#39;s see it in action.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ curl https://cryptoserviceworker.com/api/all/spot/btc-usd\n[  \n   {  \n      &quot;symbol&quot;:&quot;btc-usd&quot;,\n      &quot;price&quot;:&quot;6609.06000000&quot;,\n      &quot;utcTime&quot;:&quot;2018-06-20T05:26:19.512000Z&quot;,\n      &quot;provider&quot;:&quot;gdax&quot;\n   },\n   {  \n      &quot;symbol&quot;:&quot;btc-usd&quot;,\n      &quot;price&quot;:&quot;6600.7&quot;,\n      &quot;utcTime&quot;:&quot;2018-06-20T05:26:22.284Z&quot;,\n      &quot;provider&quot;:&quot;bitfinex&quot;\n   }\n]</pre></code>\n            <p>Cool, OK, who&#39;s fastest? First, the route handler:</p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">export class RaceRoute implements IRoute {\n  public match(req: RequestContextBase): IRouteHandler | null {\n    if (req.url.pathname.startsWith(&#039;/api/race/&#039;)) {\n      return new RaceHandler();\n    }\n    return null;\n  }\n}</pre></code>\n            <p>And the handler. Basically just using <code>Promise.race</code> to pick the winner</p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">export class RaceHandler implements IRouteHandler {\n  constructor(private readonly handlers: IRouteHandler[] = []) {\n    const factory = new HandlerFactory();\n    this.handlers = factory.getProviderHandlers();\n  }\n\n  public handle(req: RequestContextBase): Promise&lt;Response&gt; {\n    return this.race(req, this.handlers);\n  }\n\n  public async race(\n    req: RequestContextBase,\n    responders: IRouteHandler[]\n  ): Promise&lt;Response&gt; {\n    const arr = responders.map(r =&gt; r.handle(req));\n    return Promise.race(arr);\n  }\n}</pre></code>\n            <p>So who&#39;s fastest? Tonight it&#39;s gdax.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">curl https://cryptoserviceworker.com/api/race/spot/btc-usd\n{  \n   &quot;symbol&quot;:&quot;btc-usd&quot;,\n   &quot;price&quot;:&quot;6607.15000000&quot;,\n   &quot;utcTime&quot;:&quot;2018-06-20T05:33:16.074000Z&quot;,\n   &quot;provider&quot;:&quot;gdax&quot;\n}</pre></code>\n            \n    <div class=\"flex anchor relative\">\n      <h3 id=\"summary\">Summary</h3>\n      <a href=\"#summary\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>Using Typescript+Workers, in &lt; 500 lines of code, we were able to</p><ul><li><p>Define an interface for a mini HTTP routing and handling framework</p></li><li><p>Implement a basic implementation of that framework</p></li><li><p>Build Routes and Handlers to provide Ping, All, Race and Direct handlers</p></li><li><p>Deploy it to 160+ data centers with <code>npm run upload</code></p></li></ul><p>Stay tuned for more, and PRs welcome, particularly for more providers.</p><p><i>If you have a worker you&#39;d like to share, or want to check out workers from other Cloudflare users, visit the </i><a href=\"https://community.cloudflare.com/tags/recipe-exchange\"><i>“Recipe Exchange”</i></a><i> in the Workers section of the </i><a href=\"https://community.cloudflare.com/c/developers/workers\"><i>Cloudflare Community Forum</i></a><i>.</i></p>",
		"id": "6vJMJrpNtXwRzr8sYBkXpj",
		"localeList": {
			"name": "Cryptocurrency API Gateway using Typescript+Workers Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "If you followed part one, I’ve set up an environment to write TypeScript with tests and deploy to the Cloudflare Edge using npm run upload. In this post, I’ll expand on one Worker Recipe even further.",
		"metadata": {
			"imgPreview": ""
		},
		"primary_author": {},
		"publicly_index": true,
		"published_at": "2018-06-29T14:00:00.000+01:00",
		"slug": "cryptocurrency-api-gateway-typescript-workers",
		"tags": [
			{
				"id": "78aSAeMjGNmCuetQ7B4OgU",
				"name": "JavaScript",
				"slug": "javascript"
			},
			{
				"id": "5cye1Bh5KxFh3pKSnX8Dsy",
				"name": "Serverless",
				"slug": "serverless"
			},
			{
				"id": "6hbkItfupogJP3aRDAq6v8",
				"name": "Cloudflare Workers",
				"slug": "workers"
			},
			{
				"id": "6lhzEBz2B56RKa4nUEAGYJ",
				"name": "Programming",
				"slug": "programming"
			},
			{
				"id": "1QsJUMpv0QBSLiVZLLQJ3V",
				"name": "Cryptography",
				"slug": "cryptography"
			},
			{
				"id": "7aSCe0ZArYqX0ThFK2gRm0",
				"name": "API Gateway",
				"slug": "api-gateway"
			},
			{
				"id": "4HIPcb68qM0e26fIxyfzwQ",
				"name": "Developers",
				"slug": "developers"
			},
			{
				"id": "3JAY3z7p7An94s6ScuSQPf",
				"name": "Developer Platform",
				"slug": "developer-platform"
			}
		],
		"title": "Cryptocurrency API Gateway using Typescript+Workers",
		"updated_at": "2025-03-10T04:17:01.267Z",
		"url": "https://blog.cloudflare.com/cryptocurrency-api-gateway-typescript-workers"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.icon_aria_label": "Search",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"search.result_stat_empty": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong>",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"search.autocomplete_title": "Insert a query. Press enter to send",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}