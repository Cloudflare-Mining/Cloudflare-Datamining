{
	"locale": "en-us",
	"post": {
		"access": true,
		"authors": [
			{
				"id": "5d1644b141acde0011a94fc5",
				"name": "Steven Pack",
				"slug": "stevenpack",
				"profile_image": "http://blog.cloudflare.com/content/images/2022/08/steven-pack.png",
				"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-123.png",
				"bio": "Partner Engineering Director",
				"website": null,
				"location": "San Francisco Bay Area, California",
				"facebook": null,
				"twitter": "@steven_pack",
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/stevenpack/"
			}
		],
		"canonical_url": null,
		"codeinjection_foot": null,
		"codeinjection_head": null,
		"comment_id": "5b2b2caa7cbc6900bf7f4344",
		"comments": false,
		"created_at": "2018-06-21T05:42:18.000+01:00",
		"custom_excerpt": "If you followed part one, I have an environment setup where I can write Typescript with tests and deploy to the Cloudflare Edge with npm run upload. For this post, I want to take one of the Worker Recipes further.",
		"custom_template": null,
		"email_subject": null,
		"excerpt": "If you followed part one, I have an environment setup where I can write Typescript with tests and deploy to the Cloudflare Edge with npm run upload. For this post, I want to take one of the Worker Recipes further.",
		"feature_image": null,
		"feature_image_alt": null,
		"feature_image_caption": null,
		"featured": false,
		"frontmatter": null,
		"html": "<!--kg-card-begin: markdown--><p>If you followed <a href=\"http://blog.cloudflare.com/p/607ad519-5652-4688-9fff-33fbb1fc9d3f/\">part one</a>, I have an environment setup where I can write Typescript with tests and deploy to the Cloudflare Edge with <code>npm run upload</code>. For this post, I want to take one of the <a href=\"https://developers.cloudflare.com/workers/recipes/aggregating-multiple-requests/\">Worker Recipes</a> further.</p>\n<p>I'm going to build a mini HTTP request routing and handling framework, then use it to build a <a href=\"https://www.cloudflare.com/learning/security/api/what-is-an-api-gateway/\">gateway</a> to multiple cryptocurrency API providers. My point here is that in a single file, with no dependencies, you can quickly build pretty sophisticated logic and deploy fast and easily to the Edge. Furthermore, using modern Typescript with async/await and the rich type structure, you also write clean, async code.</p>\n<p>OK, here we go...</p>\n<p>My API will look like this:</p>\n<table>\n<thead>\n<tr>\n<th>Verb</th>\n<th>Path</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td><code>/api/ping</code></td>\n<td>Check the Worker is up</td>\n</tr>\n<tr>\n<td>GET</td>\n<td><code>/api/all/spot/:symbol</code></td>\n<td>Aggregate the responses from all our configured gateways</td>\n</tr>\n<tr>\n<td>GET</td>\n<td><code>/api/race/spot/:symbol</code></td>\n<td>Return the response of the provider who responds fastest</td>\n</tr>\n<tr>\n<td>GET</td>\n<td><code>/api/direct/:exchange/spot/:symbol</code></td>\n<td>Pass through the request to the gateway. E.g. gdax or bitfinex</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"theframework\">The Framework</h3>\n<p>OK, this is Typescript, I get interfaces and I'm going to use them. Here's my ultra-mini-http-routing framework definition:</p>\n<pre><code class=\"language-Typescript\">export interface IRouter {\n  route(req: RequestContextBase): IRouteHandler;\n}\n\n/**\n * A route\n */\nexport interface IRoute {\n  match(req: RequestContextBase): IRouteHandler | null;\n}\n\n/**\n * Handles a request.\n */\nexport interface IRouteHandler {\n  handle(req: RequestContextBase): Promise&lt;Response&gt;;\n}\n\n/**\n * Request with additional convenience properties\n */\nexport class RequestContextBase {\n  public static fromString(str: string) {\n    return new RequestContextBase(new Request(str));\n  }\n\n  public url: URL;\n  constructor(public request: Request) {\n    this.url = new URL(request.url);\n  }\n}\n</code></pre>\n<p>So basically all requests will go to <code>IRouter</code>. If it finds an <code>IRoute</code> that returns an <code>IRouterHandler</code>, then it will call that and pass in <code>RequestContextBase</code>, which is just the request with a parsed URL for convenience.</p>\n<p>I stopped short of dependency injection, so here's the router implementation with 4 routes we've implemented (Ping, Race, All and Direct). Each route corresponds to one of the four operations I defined in the API above and returns the corresponding <code>IRouteHandler</code>.</p>\n<pre><code class=\"language-Typescript\">export class Router implements IRouter {\n  public routes: IRoute[];\n\n  constructor() {\n    this.routes = [\n      new PingRoute(),\n      new RaceRoute(),\n      new AllRoute(),\n      new DirectRoute(),\n    ];\n  }\n\n  public async handle(request: Request): Promise&lt;Response&gt; {\n    try {\n      const req = new RequestContextBase(request);\n      const handler = this.route(req);\n      return handler.handle(req);\n    } catch (e) {\n      return new Response(undefined, {\n        status: 500,\n        statusText: `Error. ${e.message}`,\n      });\n    }\n  }\n\n  public route(req: RequestContextBase): IRouteHandler {\n    const handler: IRouteHandler | null = this.match(req);\n    if (handler) {\n      logger.debug(`Found handler for ${req.url.pathname}`);\n      return handler;\n    }\n    return new NotFoundHandler();\n  }\n\n  public match(req: RequestContextBase): IRouteHandler | null {\n    for (const route of this.routes) {\n      const handler = route.match(req);\n      if (handler != null) {\n        return handler;\n      }\n    }\n    return null;\n  }\n}\n</code></pre>\n<p>You can see above I return a NotFoundHandler if we can't find a matching route. Its implementation is below. It's easy to see how 401, 405, 500 and all the common handlers could be implemented.</p>\n<pre><code class=\"language-Typescript\">/**\n * 404 Not Found\n */\nexport class NotFoundHandler implements IRouteHandler {\n  public async handle(req: RequestContextBase): Promise&lt;Response&gt; {\n    return new Response(undefined, {\n      status: 404,\n      statusText: 'Unknown route',\n    });\n  }\n}\n</code></pre>\n<p>Now let's start with Ping. The framework separates matching a route and handling the request. Firstly the route:</p>\n<pre><code class=\"language-Typescript\">export class PingRoute implements IRoute {\n  public match(req: RequestContextBase): IRouteHandler | null {\n    if (req.request.method !== 'GET') {\n      return new MethodNotAllowedHandler();\n    }\n    if (req.url.pathname.startsWith('/api/ping')) {\n      return new PingRouteHandler();\n    }\n    return null;\n  }\n}\n</code></pre>\n<p>Simple enough, if the URL starts with <code>/api/ping</code>, handle the request with a <code>PingRouteHandler</code></p>\n<pre><code class=\"language-Typescript\">export class PingRouteHandler implements IRouteHandler {\n  public async handle(req: RequestContextBase): Promise&lt;Response&gt; {\n    const pong = 'pong;';\n    const res = new Response(pong);\n    logger.info(`Responding with ${pong} and ${res.status}`);\n    return new Response(pong);\n  }\n}\n</code></pre>\n<p>So at this point, if you followed along with <a href=\"\">Part 1</a>, you can do:</p>\n<pre><code class=\"language-bash\">$ npm run upload\n$ curl https://cryptoserviceworker.com/api/ping\npong\n</code></pre>\n<p>OK, next the <code>AllHandler</code>, this aggregates the responses. Firstly the route matcher:</p>\n<pre><code class=\"language-Typescript\">export class AllRoute implements IRoute {\n  public match(req: RequestContextBase): IRouteHandler | null {\n    if (req.url.pathname.startsWith('/api/all/')) {\n      return new AllHandler();\n    }\n    return null;\n  }\n}\n</code></pre>\n<p>And if the route matches, we'll handle it by farming off the requests to our downstream handlers:</p>\n<pre><code class=\"language-Typescript\">export class AllHandler implements IRouteHandler {\n  constructor(private readonly handlers: IRouteHandler[] = []) {\n    if (handlers.length === 0) {\n      const factory = new HandlerFactory();\n      logger.debug('No handlers, getting from factory');\n      this.handlers = factory.getProviderHandlers();\n    }\n  }\n\n  public async handle(req: RequestContextBase): Promise&lt;Response&gt; {\n    const responses = await Promise.all(\n      this.handlers.map(async h =&gt; h.handle(req))\n    );\n    const jsonArr = await Promise.all(responses.map(async r =&gt; r.json()));\n    return new Response(JSON.stringify(jsonArr));\n  }\n}\n</code></pre>\n<p>I'm cheating a bit here because I haven't shown you the code for <code>HandlerFactory</code> or the implementation of <code>handle</code> for each one. You can look up the full source <a href=\"https://github.com/stevenpack/cryptoserviceworker/blob/master/src/service-worker.ts\">here</a>.</p>\n<p>Take a moment here to appreciate just what's happening. You're writing very expressive async code that in a few lines, is able to multiplex a request to multiple endpoints and aggregate the results. Furthermore, it's running in a sandboxed environment in a data center very close to your end user. <strong>Edge-side code is a game changer.</strong></p>\n<p>Let's see it in action.</p>\n<pre><code>$ curl https://cryptoserviceworker.com/api/all/spot/btc-usd\n[  \n   {  \n      &quot;symbol&quot;:&quot;btc-usd&quot;,\n      &quot;price&quot;:&quot;6609.06000000&quot;,\n      &quot;utcTime&quot;:&quot;2018-06-20T05:26:19.512000Z&quot;,\n      &quot;provider&quot;:&quot;gdax&quot;\n   },\n   {  \n      &quot;symbol&quot;:&quot;btc-usd&quot;,\n      &quot;price&quot;:&quot;6600.7&quot;,\n      &quot;utcTime&quot;:&quot;2018-06-20T05:26:22.284Z&quot;,\n      &quot;provider&quot;:&quot;bitfinex&quot;\n   }\n]\n</code></pre>\n<p>Cool, OK, who's fastest? First, the route handler:</p>\n<pre><code class=\"language-Typescript\">export class RaceRoute implements IRoute {\n  public match(req: RequestContextBase): IRouteHandler | null {\n    if (req.url.pathname.startsWith('/api/race/')) {\n      return new RaceHandler();\n    }\n    return null;\n  }\n}\n</code></pre>\n<p>And the handler. Basically just using <code>Promise.race</code> to pick the winner</p>\n<pre><code class=\"language-Typescript\">export class RaceHandler implements IRouteHandler {\n  constructor(private readonly handlers: IRouteHandler[] = []) {\n    const factory = new HandlerFactory();\n    this.handlers = factory.getProviderHandlers();\n  }\n\n  public handle(req: RequestContextBase): Promise&lt;Response&gt; {\n    return this.race(req, this.handlers);\n  }\n\n  public async race(\n    req: RequestContextBase,\n    responders: IRouteHandler[]\n  ): Promise&lt;Response&gt; {\n    const arr = responders.map(r =&gt; r.handle(req));\n    return Promise.race(arr);\n  }\n}\n</code></pre>\n<p>So who's fastest? Tonight it's gdax.</p>\n<pre><code class=\"language-bash\">curl https://cryptoserviceworker.com/api/race/spot/btc-usd\n{  \n   &quot;symbol&quot;:&quot;btc-usd&quot;,\n   &quot;price&quot;:&quot;6607.15000000&quot;,\n   &quot;utcTime&quot;:&quot;2018-06-20T05:33:16.074000Z&quot;,\n   &quot;provider&quot;:&quot;gdax&quot;\n}\n</code></pre>\n<h3 id=\"summary\">Summary</h3>\n<p>Using Typescript+Workers, in &lt; 500 lines of code, we were able to</p>\n<ul>\n<li>Define an interface for a mini HTTP routing and handling framework</li>\n<li>Implement a basic implementation of that framework</li>\n<li>Build Routes and Handlers to provide Ping, All, Race and Direct handlers</li>\n<li>Deploy it to 160+ data centers with <code>npm run upload</code></li>\n</ul>\n<p>Stay tuned for more, and PRs welcome, particularly for more providers.</p>\n<hr>\n<p><em><small>If you have a worker you'd like to share, or want to check out workers from other Cloudflare users, visit the <a href=\"https://community.cloudflare.com/tags/recipe-exchange\">“Recipe Exchange”</a> in the Workers section of the <a href=\"https://community.cloudflare.com/c/developers/workers\">Cloudflare Community Forum</a>. </small></em></p>\n<!--kg-card-end: markdown-->",
		"id": "5d16453b41acde0011a95706",
		"meta_description": null,
		"meta_title": null,
		"og_description": null,
		"og_image": null,
		"og_title": null,
		"primary_author": {
			"id": "5d1644b141acde0011a94fc5",
			"name": "Steven Pack",
			"slug": "stevenpack",
			"profile_image": "http://blog.cloudflare.com/content/images/2022/08/steven-pack.png",
			"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-123.png",
			"bio": "Partner Engineering Director",
			"website": null,
			"location": "San Francisco Bay Area, California",
			"facebook": null,
			"twitter": "@steven_pack",
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/stevenpack/"
		},
		"primary_tag": {
			"id": "5d16450341acde0011a95165",
			"name": "JavaScript",
			"slug": "javascript",
			"description": null,
			"feature_image": null,
			"visibility": "public",
			"meta_title": null,
			"meta_description": null,
			"og_image": null,
			"og_title": null,
			"og_description": null,
			"twitter_image": null,
			"twitter_title": null,
			"twitter_description": null,
			"codeinjection_head": null,
			"codeinjection_foot": null,
			"canonical_url": null,
			"accent_color": null,
			"url": "http://blog.cloudflare.com/tag/javascript/"
		},
		"published_at": "2018-06-29T14:00:00.000+01:00",
		"reading_time": 4,
		"slug": "cryptocurrency-api-gateway-typescript-workers",
		"tags": [
			{
				"id": "5d16450341acde0011a95165",
				"name": "JavaScript",
				"slug": "javascript",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/javascript/"
			},
			{
				"id": "5d16450341acde0011a95252",
				"name": "Serverless",
				"slug": "serverless",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Serverless.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Serverless",
				"meta_description": "Cloudflare blog posts tagged 'serverless'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/serverless/"
			},
			{
				"id": "5d16450341acde0011a95253",
				"name": "Cloudflare Workers",
				"slug": "workers",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/workers/"
			},
			{
				"id": "5d16450341acde0011a95214",
				"name": "Programming",
				"slug": "programming",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/programming/"
			},
			{
				"id": "5d16450341acde0011a95277",
				"name": "Cryptography",
				"slug": "cryptography",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/cryptography/"
			},
			{
				"id": "6231b1426e52fb000b52ecdf",
				"name": "API Gateway",
				"slug": "api-gateway",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/api-gateway/"
			},
			{
				"id": "5d16450341acde0011a95204",
				"name": "Developers",
				"slug": "developers",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Developers-1.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Developers",
				"meta_description": "Collection of Cloudflare blog posts tagged 'Developers'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/developers/"
			},
			{
				"id": "64a3e2b834124c000b00b717",
				"name": "Developer Platform",
				"slug": "developer-platform",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/developer-platform/"
			}
		],
		"title": "Cryptocurrency API Gateway using Typescript+Workers",
		"twitter_description": null,
		"twitter_image": null,
		"twitter_title": null,
		"updated_at": "2023-04-05T22:23:53.000+01:00",
		"url": "http://blog.cloudflare.com/cryptocurrency-api-gateway-typescript-workers/",
		"uuid": "5cd5d990-7b88-4e62-9615-9c51d33daae8",
		"visibility": "public"
	}
}