{
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Steven Pack",
				"slug": "stevenpack",
				"bio": "Partner Engineering Director",
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/5KBJRA6GGkWLzkmUgwTrMs/d8f2a46776c74dd2a77603f2742afc18/stevenpack.png",
				"location": "San Francisco Bay Area, California",
				"website": null,
				"twitter": "@steven_pack",
				"facebook": null
			}
		],
		"excerpt": "If you followed part one, I have an environment setup where I can write Typescript with tests and deploy to the Cloudflare Edge with npm run upload. For this post, I want to take one of the Worker Recipes further.",
		"feature_image": "https:undefined",
		"featured": false,
		"html": "<p>If you followed <a href=\"/p/607ad519-5652-4688-9fff-33fbb1fc9d3f/\">part one</a>, I have an environment setup where I can write Typescript with tests and deploy to the Cloudflare Edge with <code>npm run upload</code>. For this post, I want to take one of the <a href=\"https://developers.cloudflare.com/workers/recipes/aggregating-multiple-requests/\">Worker Recipes</a> further.</p><p>I&#39;m going to build a mini HTTP request routing and handling framework, then use it to build a <a href=\"https://www.cloudflare.com/learning/security/api/what-is-an-api-gateway/\">gateway</a> to multiple cryptocurrency API providers. My point here is that in a single file, with no dependencies, you can quickly build pretty sophisticated logic and deploy fast and easily to the Edge. Furthermore, using modern Typescript with async/await and the rich type structure, you also write clean, async code.</p><p>OK, here we go...</p><p>My API will look like this:</p><p>Verb</p><p>Path</p><p>Description</p><p>GET</p><p><code>/api/ping</code></p><p>Check the Worker is up</p><p>GET</p><p><code>/api/all/spot/:symbol</code></p><p>Aggregate the responses from all our configured gateways</p><p>GET</p><p><code>/api/race/spot/:symbol</code></p><p>Return the response of the provider who responds fastest</p><p>GET</p><p><code>/api/direct/:exchange/spot/:symbol</code></p><p>Pass through the request to the gateway. E.g. gdax or bitfinex</p><h3>The Framework</h3><p>OK, this is Typescript, I get interfaces and I&#39;m going to use them. Here&#39;s my ultra-mini-http-routing framework definition:</p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">export interface IRouter {\n  route(req: RequestContextBase): IRouteHandler;\n}\n\n/**\n * A route\n */\nexport interface IRoute {\n  match(req: RequestContextBase): IRouteHandler | null;\n}\n\n/**\n * Handles a request.\n */\nexport interface IRouteHandler {\n  handle(req: RequestContextBase): Promise<Response>;\n}\n\n/**\n * Request with additional convenience properties\n */\nexport class RequestContextBase {\n  public static fromString(str: string) {\n    return new RequestContextBase(new Request(str));\n  }\n\n  public url: URL;\n  constructor(public request: Request) {\n    this.url = new URL(request.url);\n  }\n}</pre></code>\n            <p>So basically all requests will go to <code>IRouter</code>. If it finds an <code>IRoute</code> that returns an <code>IRouterHandler</code>, then it will call that and pass in <code>RequestContextBase</code>, which is just the request with a parsed URL for convenience.</p><p>I stopped short of dependency injection, so here&#39;s the router implementation with 4 routes we&#39;ve implemented (Ping, Race, All and Direct). Each route corresponds to one of the four operations I defined in the API above and returns the corresponding <code>IRouteHandler</code>.</p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">export class Router implements IRouter {\n  public routes: IRoute[];\n\n  constructor() {\n    this.routes = [\n      new PingRoute(),\n      new RaceRoute(),\n      new AllRoute(),\n      new DirectRoute(),\n    ];\n  }\n\n  public async handle(request: Request): Promise<Response> {\n    try {\n      const req = new RequestContextBase(request);\n      const handler = this.route(req);\n      return handler.handle(req);\n    } catch (e) {\n      return new Response(undefined, {\n        status: 500,\n        statusText: `Error. ${e.message}`,\n      });\n    }\n  }\n\n  public route(req: RequestContextBase): IRouteHandler {\n    const handler: IRouteHandler | null = this.match(req);\n    if (handler) {\n      logger.debug(`Found handler for ${req.url.pathname}`);\n      return handler;\n    }\n    return new NotFoundHandler();\n  }\n\n  public match(req: RequestContextBase): IRouteHandler | null {\n    for (const route of this.routes) {\n      const handler = route.match(req);\n      if (handler != null) {\n        return handler;\n      }\n    }\n    return null;\n  }\n}</pre></code>\n            <p>You can see above I return a NotFoundHandler if we can&#39;t find a matching route. Its implementation is below. It&#39;s easy to see how 401, 405, 500 and all the common handlers could be implemented.</p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">/**\n * 404 Not Found\n */\nexport class NotFoundHandler implements IRouteHandler {\n  public async handle(req: RequestContextBase): Promise<Response> {\n    return new Response(undefined, {\n      status: 404,\n      statusText: 'Unknown route',\n    });\n  }\n}</pre></code>\n            <p>Now let&#39;s start with Ping. The framework separates matching a route and handling the request. Firstly the route:</p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">export class PingRoute implements IRoute {\n  public match(req: RequestContextBase): IRouteHandler | null {\n    if (req.request.method !== 'GET') {\n      return new MethodNotAllowedHandler();\n    }\n    if (req.url.pathname.startsWith('/api/ping')) {\n      return new PingRouteHandler();\n    }\n    return null;\n  }\n}</pre></code>\n            <p>Simple enough, if the URL starts with <code>/api/ping</code>, handle the request with a <code>PingRouteHandler</code></p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">export class PingRouteHandler implements IRouteHandler {\n  public async handle(req: RequestContextBase): Promise<Response> {\n    const pong = 'pong;';\n    const res = new Response(pong);\n    logger.info(`Responding with ${pong} and ${res.status}`);\n    return new Response(pong);\n  }\n}</pre></code>\n            <p>So at this point, if you followed along with Part 1, you can do:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ npm run upload\n$ curl https://cryptoserviceworker.com/api/ping\npong</pre></code>\n            <p>OK, next the <code>AllHandler</code>, this aggregates the responses. Firstly the route matcher:</p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">export class AllRoute implements IRoute {\n  public match(req: RequestContextBase): IRouteHandler | null {\n    if (req.url.pathname.startsWith('/api/all/')) {\n      return new AllHandler();\n    }\n    return null;\n  }\n}</pre></code>\n            <p>And if the route matches, we&#39;ll handle it by farming off the requests to our downstream handlers:</p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">export class AllHandler implements IRouteHandler {\n  constructor(private readonly handlers: IRouteHandler[] = []) {\n    if (handlers.length === 0) {\n      const factory = new HandlerFactory();\n      logger.debug('No handlers, getting from factory');\n      this.handlers = factory.getProviderHandlers();\n    }\n  }\n\n  public async handle(req: RequestContextBase): Promise<Response> {\n    const responses = await Promise.all(\n      this.handlers.map(async h => h.handle(req))\n    );\n    const jsonArr = await Promise.all(responses.map(async r => r.json()));\n    return new Response(JSON.stringify(jsonArr));\n  }\n}</pre></code>\n            <p>I&#39;m cheating a bit here because I haven&#39;t shown you the code for <code>HandlerFactory</code> or the implementation of <code>handle</code> for each one. You can look up the full source <a href=\"https://github.com/stevenpack/cryptoserviceworker/blob/master/src/service-worker.ts\">here</a>.</p><p>Take a moment here to appreciate just what&#39;s happening. You&#39;re writing very expressive async code that in a few lines, is able to multiplex a request to multiple endpoints and aggregate the results. Furthermore, it&#39;s running in a sandboxed environment in a data center very close to your end user. <b>Edge-side code is a game changer.</b></p><p>Let&#39;s see it in action.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">$ curl https://cryptoserviceworker.com/api/all/spot/btc-usd\n[  \n   {  \n      \"symbol\":\"btc-usd\",\n      \"price\":\"6609.06000000\",\n      \"utcTime\":\"2018-06-20T05:26:19.512000Z\",\n      \"provider\":\"gdax\"\n   },\n   {  \n      \"symbol\":\"btc-usd\",\n      \"price\":\"6600.7\",\n      \"utcTime\":\"2018-06-20T05:26:22.284Z\",\n      \"provider\":\"bitfinex\"\n   }\n]</pre></code>\n            <p>Cool, OK, who&#39;s fastest? First, the route handler:</p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">export class RaceRoute implements IRoute {\n  public match(req: RequestContextBase): IRouteHandler | null {\n    if (req.url.pathname.startsWith('/api/race/')) {\n      return new RaceHandler();\n    }\n    return null;\n  }\n}</pre></code>\n            <p>And the handler. Basically just using <code>Promise.race</code> to pick the winner</p>\n            <pre class=\"language-typescript\"><code class=\"language-typescript\">export class RaceHandler implements IRouteHandler {\n  constructor(private readonly handlers: IRouteHandler[] = []) {\n    const factory = new HandlerFactory();\n    this.handlers = factory.getProviderHandlers();\n  }\n\n  public handle(req: RequestContextBase): Promise<Response> {\n    return this.race(req, this.handlers);\n  }\n\n  public async race(\n    req: RequestContextBase,\n    responders: IRouteHandler[]\n  ): Promise<Response> {\n    const arr = responders.map(r => r.handle(req));\n    return Promise.race(arr);\n  }\n}</pre></code>\n            <p>So who&#39;s fastest? Tonight it&#39;s gdax.</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">curl https://cryptoserviceworker.com/api/race/spot/btc-usd\n{  \n   \"symbol\":\"btc-usd\",\n   \"price\":\"6607.15000000\",\n   \"utcTime\":\"2018-06-20T05:33:16.074000Z\",\n   \"provider\":\"gdax\"\n}</pre></code>\n            <h3>Summary</h3><p>Using Typescript+Workers, in &lt; 500 lines of code, we were able to</p><ul><li><p>Define an interface for a mini HTTP routing and handling framework</p></li><li><p>Implement a basic implementation of that framework</p></li><li><p>Build Routes and Handlers to provide Ping, All, Race and Direct handlers</p></li><li><p>Deploy it to 160+ data centers with <code>npm run upload</code></p></li></ul><p>Stay tuned for more, and PRs welcome, particularly for more providers.</p><hr/><p><i>If you have a worker you&#39;d like to share, or want to check out workers from other Cloudflare users, visit the </i><a href=\"https://community.cloudflare.com/tags/recipe-exchange\"><i>“Recipe Exchange”</i></a><i> in the Workers section of the </i><a href=\"https://community.cloudflare.com/c/developers/workers\"><i>Cloudflare Community Forum</i></a><i>.</i></p>",
		"id": "6vJMJrpNtXwRzr8sYBkXpj",
		"localeList": {
			"name": "Cryptocurrency API Gateway using Typescript+Workers Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": null,
		"metadata": {
			"imgPreview": ""
		},
		"primary_author": {},
		"published_at": "2018-06-29T14:00:00.000+01:00",
		"reading_time": 3,
		"slug": "cryptocurrency-api-gateway-typescript-workers",
		"tags": [
			{
				"id": "78aSAeMjGNmCuetQ7B4OgU",
				"name": "JavaScript",
				"slug": "javascript"
			},
			{
				"id": "5cye1Bh5KxFh3pKSnX8Dsy",
				"name": "Serverless",
				"slug": "serverless"
			},
			{
				"id": "6hbkItfupogJP3aRDAq6v8",
				"name": "Cloudflare Workers",
				"slug": "workers"
			},
			{
				"id": "6lhzEBz2B56RKa4nUEAGYJ",
				"name": "Programming",
				"slug": "programming"
			},
			{
				"id": "1QsJUMpv0QBSLiVZLLQJ3V",
				"name": "Cryptography",
				"slug": "cryptography"
			},
			{
				"id": "7aSCe0ZArYqX0ThFK2gRm0",
				"name": "API Gateway",
				"slug": "api-gateway"
			},
			{
				"id": "4HIPcb68qM0e26fIxyfzwQ",
				"name": "Developers",
				"slug": "developers"
			},
			{
				"id": "3JAY3z7p7An94s6ScuSQPf",
				"name": "Developer Platform",
				"slug": "developer-platform"
			}
		],
		"title": "Cryptocurrency API Gateway using Typescript+Workers",
		"updated_at": "2024-08-27T02:21:14.254Z",
		"url": "https://blog.cloudflare.com/cryptocurrency-api-gateway-typescript-workers"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.blurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}