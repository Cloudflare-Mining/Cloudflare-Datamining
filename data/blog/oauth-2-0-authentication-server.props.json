{
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Victoria Bernard",
				"slug": "victoria",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/3ZkxhWDKU0Figr2UZd6SqN/12a204e9e4a767ecb6bf13d7e23d68e0/victoria.jpg",
				"location": null,
				"website": null,
				"twitter": null,
				"facebook": null
			}
		],
		"excerpt": "Services need to talk to each other safely without inconveniencing users. Let’s pretend I own a service with users and I want to grant other services access to my service on behalf of my users. ",
		"feature_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/2Y2cbwlsOkF1fkvNHmspE/b004f98d1549b580b3a2008c38812549/oauth-2-0-authentication-server.png",
		"featured": false,
		"html": "<p>Let’s pretend I own a service and I want to grant other services access to my service on behalf of my users. The familiar OAuth 2.0 is the industry standard used by the likes of <a href=\"https://developers.google.com/identity/protocols/OAuth2\">Google sign in</a>, Facebook, etc. to communicate safely without inconveniencing users.</p><p>Implementing an OAuth Authentication server is conceptually simple but a pain in practice. We can leverage the power of <a href=\"https://cloudflareworkers.com\">Cloudflare Workers</a> to simplify the implementation, reduce latency, and segregate our service logic from the authentication layer.</p><p>For those unfamiliar with OAuth, I highly recommend reading a more in depth <a href=\"https://aaronparecki.com/oauth-2-simplified/\">article</a>.</p><p>The steps of the OAuth 2.0 workflow are as follows:</p><ol><li><p>The consumer service redirects the user to a callback URL that was setup by the auth server. At this callback URL, the auth server asks the user to sign in and accept the consumer permissions requests.</p></li><li><p>The auth server redirects the user to the consumer service with a code.</p></li><li><p>The consumer service asks to exchange this code for an access token. The consumer service validates their identity by including their client secret in the callback URL.</p></li><li><p>The auth server gives the consumer the access token.</p></li><li><p>The consumer service can now use the access token to get resources on behalf of the user.</p></li></ol><p>In the rest of this post, I will be walking through my implementation of an OAuth Authentication server using a Worker. For simplicity, I will make the assumption the user has already logged in and obtained a session token in the form of a JWT that I will refer to as “token” herein. My <a href=\"https://github.com/victoriabernard92/OAuth-Server\">full implementation</a> has a more thorough flow that includes initial user login and registration.</p><h3>Setup</h3><p>We must be able to reference valid user sessions, codes and login information. Because Workers do not maintain state between executions, we will store this information using <a href=\"https://developers.cloudflare.com/workers/writing-workers/storing-data/\">Cloudflare Storage</a>. We setup up three namespaces called: USERS, CODES, and TOKENS .</p><p>On your OAuth server domain, create two empty worker scripts called auth and token. Bind the three namespaces to the two workers scripts. Then configure the namespaces to the scripts so that your resources end up looking like:</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/1VFGcOfkTKZXNuEHBDlReT/5206887028df2278ee441724b5ba9972/Screen-Shot-2018-12-11-at-3.46.15-PM.png\" alt=\"Screen-Shot-2018-12-11-at-3.46.15-PM\" class=\"kg-image\" width=\"510\" height=\"518\" loading=\"lazy\"/>\n            \n            </figure><p>To put and get items from storage using KV Storage syntax:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">// @ts-ignore \nCODES.get(“user@ex.com”) </pre></code>\n            <p>We include <code>// @ts-ignore</code> preceding all KV storage commands. We do not have type definitions for these variables locally, so Typescript would throw an error at compile time otherwise.</p><p>To set up a project using Typescript and the Cloudflare Previewer, follow this <a href=\"/using-webpack-to-bundle-workers/\">blog post</a>. Webpack will allow us to <code>import</code> which we will need to use the JWT library <code>jsonwebtoken</code>.</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">import * as jwt from &quot;jsonwebtoken&quot;;</pre></code>\n            <p>Remember to run:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">npm install jsonwebtoken &amp;&amp; npm install @types/jsonwebtoken</pre></code>\n            <p>Optionally, we can set up a file to specify endpoints and credentials.</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">import { hosts } from &quot;./private&quot;;\n\nexport const credentials = {/* for demo purposes, ideally use KV to store secrets */\n  clients: [{\n    id: &quot;victoriasclient&quot;,\n    secret: &quot;victoriassecret&quot;\n  }],\n  storage: {\n    secret: &quot;somesecrettodecryptfromtheKV&quot;\n  }\n\n};\n\nexport const paths = {\n  auth: {\n    authorize: hosts.auth + &quot;/authorize&quot;,\n    login: hosts.auth + &quot;/login&quot;,\n    code: hosts.auth + &quot;/code&quot;,\n  },\n  token: {\n    resource: hosts.token + &quot;/resource&quot;,\n    token: hosts.token + &quot;/authorize&quot;,\n  }\n}</pre></code>\n            <h4>1. Accept page after callback</h4><p>The consumer service generates some callback URL that redirects the user to our authentication server. The authentication server then presents the user with a login or accept page to generate a code. The authentication server thus must listen on the <code>authorize</code> url endpoint and return <code>giveLoginPageResponse</code>.</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">addEventListener(&quot;fetch&quot;, (event: FetchEvent) =&gt; {\n const url = new URL(event.request.url);\n if (url.pathname.includes(&quot;/authorize&quot;))\n  return event.respondWith(giveLoginPageResponse(event.request));\n}\n\nexport async function giveLoginPageResponse(request: Request) {\n ...checks for cases where I am not necessarily logged in... \n let token = getTokenFromRequest(request)\n if (token) { //user already signed in\n  return new Response(giveAcceptPage(request)\n }</pre></code>\n            <p>Since the user already has a stored session, we can use a method <code>giveAcceptPage</code>. To display the accept page and return a redirect to generate the code.</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">export function giveAcceptPage(request: Request) {\n  let req_url = new URL(request.url);\n  let params = req_url.search\n  let fetchCodeURL = paths.auth.code + params\n  return `&lt;!DOCTYPE html&gt;\n  &lt;html&gt;\n    &lt;body&gt;\n      &lt;a href=&quot;${fetchCodeURL}&quot;&gt; Accept&lt;/button&gt;\n    &lt;/body&gt;\n  &lt;/html&gt;\n    `;\n}</pre></code>\n            <h4>2. Redirect back to consumer</h4><p>At the endpoint for <code>fetchCodeURL</code>, the authentication server will redirect the user’s browser to the consumer’s page as specified by <code>redirect_uri</code> in the original URL params of the callback with the code.</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">addEventListener(&quot;fetch&quot;, (event: FetchEvent) =&gt; {\n ...\n if (url.pathname.includes(&quot;/code&quot;))\n  return event.respondWith(redirectCodeToConsumer(event.request));\n}\nexport async function redirectCodeToConsumer(request: Request) {\n let session = await verifyUser(request)\n\n if (session.msg == &quot;403&quot;) return new Response(give403Page(), { status: 403 })\n if (session.msg == &quot;dne&quot;) return registerNewUser(session.email, session.pwd)\n let code = Math.random().toString(36).substring(2, 12)\n try {\n  let req_url = new URL(request.url)\n  let redirect_uri = new URL(encodeURI(req_url.searchParams.get(&quot;redirect_uri&quot;)))\n  let client_id = new URL(encodeURI(req_url.searchParams.get(&quot;client_id&quot;)))\n  // @ts-ignore\n  await CODES.put(client_id + email, code)\n  redirect_uri.searchParams.set(&quot;code&quot;, code);\n  redirect_uri.searchParams.set(&quot;response_type&quot;, &quot;code&quot;);\n  return Response.redirect(redirect_uri.href, 302);\n } catch (e) {\n  // @ts-ignore\n  await CODES.delete(email, code)\n  return new Response(\n   JSON.stringify(factoryIError({ message: &quot;error with the URL passed in&quot; + e})),\n  { status: 500 });\n }\n}</pre></code>\n            <h4>3. Code to Token Exchange</h4><p>Now the consumer has the code. They can use this code to request a token. On our token worker, configure the endpoint to exchange the code for the consumer service to grant a token.</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">addEventListener(&quot;fetch&quot;, (event: FetchEvent) =&gt; {\n...\n if (url.pathname.includes(&quot;/token&quot;))\n  return event.respondWith(giveToken(event.request));</pre></code>\n            <p>Grab the code from the request and validate this code matches the code that is stored for this client. Once the code is verified, deliver the token by grabbing the existing token from the KV storage or by signing the user information to generate a new token.</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">export async function giveToken(request: Request) {\n let req_url = new URL(request.url);\n let code = req_url.searchParams.get(&quot;code&quot;);\n let email = req_url.searchParams.get(&quot;email&quot;);\n if (code){\n   if(!validClientSecret(request) return errorResponse()\n  // @ts-ignore\n  let storedCode = await CODES.get(email)\n  if(code != storedCode) return new Response(give403Page(), { status:403})\n\n  let tokenJWT = jwt.sign(email, credentials.client.secret);\n  ... return token</pre></code>\n            <h4>4. Give the token to the consumer</h4><p>Continuing where step 3 left off from the <code>giveToken</code> method, respond to the consumer with this valid token.</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">  ...\n  headers.append(&quot;set-cookie&quot;, &quot;token=Bearer &quot; + tokenJWT);\n  // @ts-ignore\n  await TOKENS.put(email, tokenJWT)\n  var respBody = factoryTokenResponse({\n   &quot;access_token&quot;: tokenJWT,\n   &quot;token_type&quot;: &quot;bearer&quot;,\n   &quot;expires_in&quot;: 2592000,\n   &quot;refresh_token&quot;: token,\n   &quot;token&quot;: token\n  })\n } else {\n  respBody.errors.push(factoryIError({ message: &quot;there was no code sent to the authorize token url&quot; }))\n }\n return new Response(JSON.stringify(respBody), { headers });\n}</pre></code>\n            <h4>5. Accepting the token</h4><p>At this point voila, your duty as an OAuth 2.0 Authentication server is complete! The consumer service that wishes to use your service has the token that you have not so magically generated.</p><p>The consumer server would send a request including the token:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">GET /resource/some-goods\nAuthorization: Bearer eyJhbGci..bGAqA</pre></code>\n            <p>Authentication server would validate the token and give the goods:</p>\n            <pre class=\"language-javascript\"><code class=\"language-javascript\">export async function giveResource(request: Request) {\n var respBody: HookResponse = factoryHookResponse({})\n let token = &quot;&quot;\n let decodedJWT = factoryJWTPayload()\n try { //validate request is who they claim\n  token = getCookie(request.headers.get(&quot;cookie&quot;), &quot;token&quot;)\n  if (!token) token = request.headers.get(&quot;Authorization&quot;).substring(7)\n  decodedJWT = jwt.verify(token, credentials.storage.secret)\n  // @ts-ignore\n  let storedToken = await TOKENS.get(decodedJWT.sub)\n  if (isExpired(storedToken)) throw new Error(&quot;token is expired&quot;) /* TODO instead of throwing error send to refresh */\n  if (storedToken != token) throw new Error(&quot;token does not match what is stored&quot;)\n }\n catch (e) {\n  respBody.errors.push(factoryIError({ message: e.message, type: &quot;oauth&quot; }))\n  return new Response(JSON.stringify(respBody), init)\n }\n respBody.body = getUsersPersonalBody(decodedJWT.sub)\n return new Response(JSON.stringify(respBody), init)\n}</pre></code>\n            <p>The boundaries of serverless are pushed everyday, though if your app just needs to authorize users, you may be better off using <a href=\"https://www.cloudflare.com/products/cloudflare-access/\">Cloudflare Access</a>. We&#39;ve demonstrated that a full blown OAuth 2.0 authentication server implementation can be achieved with Cloudflare Workers and Storage.</p><p>Stay tuned for a follow-up blog post on an OAuth consumer implementation.</p>",
		"id": "3DMym5hzg83QDRvOxJCSTo",
		"localeList": {
			"name": "OAuth Auth Server through Workers Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": null,
		"metadata": {
			"imgPreview": ""
		},
		"primary_author": {},
		"published_at": "2018-12-11T23:48:12.000+00:00",
		"reading_time": 4,
		"slug": "oauth-2-0-authentication-server",
		"tags": [
			{
				"id": "2iLPezAh3dM2OI570IiXAc",
				"name": "Cloudflare Apps",
				"slug": "cloudflare-apps"
			},
			{
				"id": "4HIPcb68qM0e26fIxyfzwQ",
				"name": "Developers",
				"slug": "developers"
			},
			{
				"id": "6hbkItfupogJP3aRDAq6v8",
				"name": "Cloudflare Workers",
				"slug": "workers"
			},
			{
				"id": "5cye1Bh5KxFh3pKSnX8Dsy",
				"name": "Serverless",
				"slug": "serverless"
			},
			{
				"id": "3JAY3z7p7An94s6ScuSQPf",
				"name": "Developer Platform",
				"slug": "developer-platform"
			}
		],
		"title": "OAuth Auth Server through Workers",
		"updated_at": "2024-08-27T02:16:29.713Z",
		"url": "https://blog.cloudflare.com/oauth-2-0-authentication-server"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.blurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}