{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "9",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Alex Fattouche",
				"slug": "alex-fattouche",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/6yn7x5vl3Mx87V0s83LuNG/5182b3647a30ee4fc326a877997ad3d1/alex-fattouche.png",
				"location": null,
				"website": null,
				"twitter": null,
				"facebook": null,
				"publiclyIndex": true
			}
		],
		"excerpt": "In response to customer demand, we now support the ability to DELETE, PATCH, PUT and POST multiple DNS records in a single API call, enabling more efficient and reliable zone management.\n",
		"feature_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/7N1J9zFI9ab89A5h1Ea3iG/4fd1422795d2a75986d81e65f5e96d43/BLOG-2495_1.png",
		"featured": false,
		"html": "<p>Customers that use Cloudflare to manage their DNS often need to create a whole batch of records, enable <a href=\"https://developers.cloudflare.com/dns/manage-dns-records/reference/proxied-dns-records/\"><u>proxying</u></a> on many records, update many records to point to a new target at the same time, or even delete all of their records. Historically, customers had to resort to bespoke scripts to make these changes, which came with their own set of issues. In response to customer demand, we are excited to announce support for batched API calls to the <a href=\"https://developers.cloudflare.com/dns/manage-dns-records/how-to/create-dns-records/\"><u>DNS records API</u></a> starting today. This lets customers make large changes to their zones much more efficiently than before. Whether sending a POST, PUT, PATCH or DELETE, users can now execute these four different <a href=\"https://en.wikipedia.org/wiki/HTTP#Request_methods\"><u>HTTP methods</u></a>, and multiple HTTP requests all at the same time.</p>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"efficient-zone-management-matters\">Efficient zone management matters</h2>\n      <a href=\"#efficient-zone-management-matters\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p><a href=\"https://www.cloudflare.com/en-gb/learning/dns/dns-records/\"><u>DNS records</u></a> are an essential part of most web applications and websites, and they serve many different purposes. The most common use case for a DNS record is to have a hostname point to an <a href=\"https://en.wikipedia.org/wiki/IPv4\"><u>IPv4</u></a> address, this is called an <a href=\"https://www.cloudflare.com/en-gb/learning/dns/dns-records/dns-a-record/\"><u>A record</u></a>:</p><p><b>example.com</b> 59 IN A <b>198.51.100.0</b></p><p><b>blog.example.com</b> 59 IN A <b>198.51.100.1</b></p><p><b>ask.example.com</b> 59 IN A <b>198.51.100.2</b></p><p>In its most simple form, this enables Internet users to connect to websites without needing to memorize their IP address. </p><p>Often, our customers need to be able to do things like create a whole batch of records, or enable <a href=\"https://developers.cloudflare.com/dns/manage-dns-records/reference/proxied-dns-records/\"><u>proxying</u></a> on many records, or update many records to point to a new target at the same time, or even delete all of their records. Unfortunately, for most of these cases, we were asking customers to write their own custom scripts or programs to do these tasks for them, a number of which are open sourced and whose content has not been checked by us. These scripts are often used to avoid needing to repeatedly make the same API calls manually. This takes time, not only for the development of the scripts, but also to simply execute all the API calls, not to mention it can leave the zone in a bad state if some changes fail while others succeed.</p>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"introducing-batch\">Introducing /batch</h2>\n      <a href=\"#introducing-batch\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>Starting today, everyone with a <a href=\"https://developers.cloudflare.com/dns/zone-setups/\"><u>Cloudflare zone</u></a> will have access to this endpoint, with free tier customers getting access to 200 changes in one batch, and paid plans getting access to 3,500 changes in one batch. We have successfully tested up to 100,000 changes in one call. The API is simple, expecting a POST request to be made to the <a href=\"https://developers.cloudflare.com/api/operations/dns-records-for-a-zone-batch-dns-records\"><u>new API endpoint</u></a> /dns_records/batch, which passes in a JSON object in the body in the format:</p>\n            <pre class=\"language-JavaScript\"><code class=\"language-JavaScript\">{\n    deletes:[]Record\n    patches:[]Record\n    puts:[]Record\n    posts:[]Record\n}\n</pre></code>\n            <p>Each list of records []Record will follow the same requirements as the regular API, except that the record ID on deletes, patches, and puts will be required within the Record object itself. Here is a simple example:</p>\n            <pre class=\"language-JavaScript\"><code class=\"language-JavaScript\">{\n    &quot;deletes&quot;: [\n        {\n            &quot;id&quot;: &quot;143004ef463b464a504bde5a5be9f94a&quot;\n        },\n        {\n            &quot;id&quot;: &quot;165e9ef6f325460c9ca0eca6170a7a23&quot;\n        }\n    ],\n    &quot;patches&quot;: [\n        {\n            &quot;id&quot;: &quot;16ac0161141a4e62a79c50e0341de5c6&quot;,\n            &quot;content&quot;: &quot;192.0.2.45&quot;\n        },\n        {\n            &quot;id&quot;: &quot;6c929ea329514731bcd8384dd05e3a55&quot;,\n            &quot;name&quot;: &quot;update.example.com&quot;,\n            &quot;proxied&quot;: true\n        }\n    ],\n    &quot;puts&quot;: [\n        {\n            &quot;id&quot;: &quot;ee93eec55e9e45f4ae3cb6941ffd6064&quot;,\n            &quot;content&quot;: &quot;192.0.2.50&quot;,\n            &quot;name&quot;: &quot;no-change.example.com&quot;,\n            &quot;proxied&quot;: false,\n            &quot;ttl:&quot;: 1\n        },\n        {\n            &quot;id&quot;: &quot;eab237b5a67e41319159660bc6cfd80b&quot;,\n            &quot;content&quot;: &quot;192.0.2.45&quot;,\n            &quot;name&quot;: &quot;no-change.example.com&quot;,\n            &quot;proxied&quot;: false,\n            &quot;ttl:&quot;: 3000\n        }\n    ],\n    &quot;posts&quot;: [\n        {\n            &quot;name&quot;: &quot;@&quot;,\n            &quot;type&quot;: &quot;A&quot;,\n            &quot;content&quot;: &quot;192.0.2.45&quot;,\n            &quot;proxied&quot;: false,\n            &quot;ttl&quot;: 3000\n        },\n        {\n            &quot;name&quot;: &quot;a.example.com&quot;,\n            &quot;type&quot;: &quot;A&quot;,\n            &quot;content&quot;: &quot;192.0.2.45&quot;,\n            &quot;proxied&quot;: true\n        }\n    ]\n}</pre></code>\n            <p>Our API will then parse this and execute these calls in the following order: </p><ol><li><p>deletes</p></li><li><p>patches</p></li><li><p>puts</p></li><li><p>posts</p></li></ol><p>Each of these respective lists will be executed in the order given. This ordering system is important because it removes the need for our clients to worry about conflicts, such as if they need to create a CNAME on the same hostname as a to-be-deleted A record, which is not allowed in <a href=\"https://datatracker.ietf.org/doc/html/rfc1912#section-2.4\"><u>RFC 1912</u></a>. In the event that any of these individual actions fail, the entire API call will fail and return the first error it sees. The batch request will also be executed inside a single database <a href=\"https://en.wikipedia.org/wiki/Database_transaction\"><u>transaction</u></a>, which will roll back in the event of failure.</p><p>After the batch request has been successfully executed in our database, we then propagate the changes to our edge via <a href=\"https://blog.cloudflare.com/introducing-quicksilver-configuration-distribution-at-internet-scale\"><u>Quicksilver</u></a>, our distributed KV store. Each of the individual record changes inside the batch request is treated as a single key-value pair, and database transactions are not supported. As such, <b>we cannot guarantee that the propagation to our edge servers will be atomic</b>. For example, if replacing a <a href=\"https://developers.cloudflare.com/dns/manage-dns-records/how-to/subdomains-outside-cloudflare/\"><u>delegation</u></a> with an A record, some resolvers may see the <a href=\"https://www.cloudflare.com/en-gb/learning/dns/dns-records/dns-ns-record/\"><u>NS</u></a> record removed before the A record is added. </p><p>The response will follow the same format as the request. Patches and puts that result in no changes will be placed at the end of their respective lists.</p><p>We are also introducing some new changes to the Cloudflare dashboard, allowing users to select multiple records and subsequently:</p><ol><li><p>Delete all selected records</p></li><li><p>Change the proxy status of all selected records</p></li></ol>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1ZU7nvMlcH2L51IqJrS1zC/db7ac600e503a72bb0c25679d63394e7/BLOG-2495_2.png\" alt=\"BLOG-2495 2\" class=\"kg-image\" width=\"1999\" height=\"1241\" loading=\"lazy\"/>\n          </figure><p>We plan to continue improving the dashboard to support more batch actions based on your feedback.</p>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"the-journey\">The journey</h2>\n      <a href=\"#the-journey\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>Although at the surface, this batch endpoint may seem like a fairly simple change, behind the scenes it is the culmination of a multi-year, multi-team effort. Over the past several years, we have been working hard to improve the DNS pipeline that takes our customers&#39; records and pushes them to <a href=\"https://blog.cloudflare.com/introducing-quicksilver-configuration-distribution-at-internet-scale\"><u>Quicksilver</u></a>, our distributed database. As part of this effort, we have been improving our <a href=\"https://developers.cloudflare.com/api/operations/dns-records-for-a-zone-list-dns-records\"><u>DNS Records API</u></a> to reduce the overall latency. The DNS Records API is Cloudflare&#39;s most used API externally, serving twice as many requests as any other API at peak. In addition, the DNS Records API supports over 20 internal services, many of which touch very important areas such as DNSSEC, TLS, Email, Tunnels, Workers, Spectrum, and R2 storage. Therefore, it was important to build something that scales. </p><p>To improve API performance, we first needed to understand the complexities of the entire stack. At Cloudflare, we use <a href=\"https://www.jaegertracing.io/\"><u>Jaeger tracing</u></a> to debug our systems. It gives us granular insights into a sample of requests that are coming into our APIs. When looking at API request latency, the <a href=\"https://www.jaegertracing.io/docs/1.23/architecture/#span\"><u>span</u></a> that stood out was the time spent on each individual database lookup. The latency here can vary anywhere from ~1ms to ~5ms. </p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/61f3sKGUs9oWMPT9P4au6R/a91d8291b626f4bab3ac1c69adf62a5d/BLOG-2495_3.png\" alt=\"BLOG-2495 3\" class=\"kg-image\" width=\"1074\" height=\"104\" loading=\"lazy\"/>\n          </figure>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3L3OaTb9cTKKKcIjCm1RLq/86ffd63116988025fd52105e316c5b5a/BLOG-2495_4.png\" alt=\"BLOG-2495 4\" class=\"kg-image\" width=\"1090\" height=\"108\" loading=\"lazy\"/>\n          </figure><p><sub><i>Jaeger trace showing variable database latency</i></sub></p><p>Given this variability in database query latency, we wanted to understand exactly what was going on within each DNS Records API request. When we first started on this journey, the breakdown of database lookups for each action was as follows:</p><table><tr><th><p><b>Action</b></p></th><th><p><b>Database Queries</b></p></th><th><p><b>Reason</b></p></th></tr><tr><td><p>POST</p></td><td><p>2 </p></td><td><p>One to write and one to read the new record.</p></td></tr><tr><td><p>PUT</p></td><td><p>3</p></td><td><p>One to collect, one to write, and one to read back the new record.</p></td></tr><tr><td><p>PATCH</p></td><td><p>3</p></td><td><p>One to collect, one to write, and one to read back the new record.</p></td></tr><tr><td><p>DELETE</p></td><td><p>2</p></td><td><p>One to read and one to delete.</p></td></tr></table><p>The reason we needed to read the newly created records on POST, PUT, and PATCH was because the record contains information filled in by the database which we cannot infer in the API. </p><p>Let’s imagine that a customer needed to edit 1,000 records. If each database lookup took 3ms to complete, that was 3ms * 3 lookups * 1,000 records = 9 seconds spent on database queries alone, not taking into account the round trip time to and from our API or any other processing latency. It’s clear that we needed to reduce the number of overall queries and ideally minimize per query latency variation. Let’s tackle the variation in latency first.</p><p>Each of these calls is not a simple INSERT, UPDATE, or DELETE, because we have functions wrapping these database calls for sanitization purposes. In order to understand the variable latency, we enlisted the help of <a href=\"https://www.postgresql.org/docs/current/auto-explain.html\"><u>PostgreSQL’s “auto_explain”</u></a>. This module gives a breakdown of execution times for each statement without needing to EXPLAIN each one by hand. We used the following settings:</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2myvmIREh2Q9yl30HbRus/29f085d40ba7dde34e9a46c27e3c6ba2/BLOG-2495_5.png\" alt=\"BLOG-2495 5\" class=\"kg-image\" width=\"660\" height=\"412\" loading=\"lazy\"/>\n          </figure><p>A handful of queries showed durations like the one below, which took an order of magnitude longer than other queries.</p>\n          <figure class=\"kg-card kg-image-card\">\n          <Image src=\"https://cf-assets.www.cloudflare.com/zkvhlag99gkb/557xg66x8OiHM6pcAG4svk/56157cd0e5b6d7fd47f0152798598729/BLOG-2495_6.png\" alt=\"BLOG-2495 6\" class=\"kg-image\" width=\"1908\" height=\"104\" loading=\"lazy\"/>\n          </figure><p>We noticed that in several locations we were doing queries like:</p><p><code>IF (EXISTS (SELECT id FROM table WHERE row_hash = __new_row_hash))</code></p><p>If you are trying to insert into very large zones, such queries could mean even longer database query times, potentially explaining the discrepancy between 1ms and 5ms in our tracing images above. Upon further investigation, we already had a unique index on that exact hash. <a href=\"https://www.postgresql.org/docs/current/indexes-unique.html\"><u>Unique indexes</u></a> in PostgreSQL enforce the uniqueness of one or more column values, which means we can safely remove those existence checks without risk of inserting duplicate rows.</p><p>The next task was to introduce database batching into our DNS Records API. In any API, external calls such as SQL queries are going to add substantial latency to the request. Database batching allows the DNS Records API to execute multiple SQL queries within one single network call, subsequently lowering the number of database round trips our system needs to make. </p><p>According to the table above, each database write also corresponded to a read after it had completed the query. This was needed to collect information like creation/modification timestamps and new IDs. To improve this, we tweaked our database functions to now return the newly created DNS record itself, removing a full round trip to the database. Here is the updated table:</p><table><tr><th><p><b>Action</b></p></th><th><p><b>Database Queries</b></p></th><th><p><b>Reason</b></p></th></tr><tr><td><p>POST</p></td><td><p>1 </p></td><td><p>One to write</p></td></tr><tr><td><p>PUT</p></td><td><p>2</p></td><td><p>One to read, one to write.</p></td></tr><tr><td><p>PATCH</p></td><td><p>2</p></td><td><p>One to read, one to write.</p></td></tr><tr><td><p>DELETE</p></td><td><p>2</p></td><td><p>One to read, one to delete.</p></td></tr></table><p>We have room for improvement here, however we cannot easily reduce this further due to some restrictions around auditing and other sanitization logic.</p><p><b>Results:</b></p><table><tr><th><p><b>Action</b></p></th><th><p><b>Average database time before</b></p></th><th><p><b>Average database time after</b></p></th><th><p><b>Percentage Decrease</b></p></th></tr><tr><td><p>POST</p></td><td><p>3.38ms</p></td><td><p>0.967ms</p></td><td><p>71.4%</p></td></tr><tr><td><p>PUT</p></td><td><p>4.47ms</p></td><td><p>2.31ms</p></td><td><p>48.4%</p></td></tr><tr><td><p>PATCH</p></td><td><p>4.41ms</p></td><td><p>2.24ms</p></td><td><p>49.3%</p></td></tr><tr><td><p>DELETE</p></td><td><p>1.21ms</p></td><td><p>1.21ms</p></td><td><p>0%</p></td></tr></table><p>These are some pretty good improvements! Not only did we reduce the API latency, we also reduced the database query load, benefiting other systems as well.</p>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"werent-we-talking-about-batching\">Weren’t we talking about batching?</h2>\n      <a href=\"#werent-we-talking-about-batching\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>I previously mentioned that the /batch endpoint is fully atomic, making use of a single database transaction. However, a single transaction may still require multiple database network calls, and from the table above, that can add up to a significant amount of time when dealing with large batches. To optimize this, we are making use of <a href=\"https://pkg.go.dev/github.com/jackc/pgx/v4#Batch\"><u>pgx/batch</u></a>, a Golang object that allows us to write and subsequently read multiple queries in a single network call. Here is a high level of how the batch endpoint works:</p><ol><li><p>Collect all the records for the PUTs, PATCHes and DELETEs.</p></li><li><p>Apply any per record differences as requested by the PATCHes and PUTs.</p></li><li><p>Format the batch SQL query to include each of the actions.</p></li><li><p>Execute the batch SQL query in the database.</p></li><li><p>Parse each database response and return any errors if needed.</p></li><li><p>Audit each change.</p></li></ol><p>This takes at most only two database calls per batch. One to fetch, and one to write/delete. If the batch contains only POSTs, this will be further reduced to a single database call. Given all of this, we should expect to see a significant improvement in latency when making multiple changes, which we do when observing how these various endpoints perform: </p><p><i>Note: Each of these queries was run from multiple locations around the world and the median of the response times are shown here. The server responding to queries is located in Portland, Oregon, United States. Latencies are subject to change depending on geographical location.</i></p><p><b>Create only:</b></p><table><tr><th><p>\n</p></th><th><p><b>10 Records</b></p></th><th><p><b>100 Records</b></p></th><th><p><b>1,000 Records</b></p></th><th><p><b>10,000 Records</b></p></th></tr><tr><td><p><b>Regular API</b></p></td><td><p>7.55s</p></td><td><p>74.23s</p></td><td><p>757.32s</p></td><td><p>7,877.14s</p></td></tr><tr><td><p><b>Batch API - Without database batching</b></p></td><td><p>0.85s</p></td><td><p>1.47s</p></td><td><p>4.32s</p></td><td><p>16.58s</p></td></tr><tr><td><p><b>Batch API - with database batching</b></p></td><td><p>0.67s</p></td><td><p>1.21s</p></td><td><p>3.09s</p></td><td><p>10.33s</p></td></tr></table><p><b>Delete only:</b></p><table><tr><th><p>\n</p></th><th><p><b>10 Records</b></p></th><th><p><b>100 Records</b></p></th><th><p><b>1,000 Records</b></p></th><th><p><b>10,000 Records</b></p></th></tr><tr><td><p><b>Regular API</b></p></td><td><p>7.28s</p></td><td><p>67.35s</p></td><td><p>658.11s</p></td><td><p>7,471.30s</p></td></tr><tr><td><p><b>Batch API - without database batching</b></p></td><td><p>0.79s</p></td><td><p>1.32s</p></td><td><p>3.18s</p></td><td><p>17.49s</p></td></tr><tr><td><p><b>Batch API - with database batching</b></p></td><td><p>0.66s</p></td><td><p>0.78s</p></td><td><p>1.68s</p></td><td><p>7.73s</p></td></tr></table><p><b>Create/Update/Delete:</b></p><table><tr><th><p>\n</p></th><th><p><b>10 Records</b></p></th><th><p><b>100 Records</b></p></th><th><p><b>1,000 Records</b></p></th><th><p><b>10,000 Records</b></p></th></tr><tr><td><p><b>Regular API</b></p></td><td><p>7.11s</p></td><td><p>72.41s</p></td><td><p>715.36s</p></td><td><p>7,298.17s</p></td></tr><tr><td><p><b>Batch API - without database batching</b></p></td><td><p>0.79s</p></td><td><p>1.36s</p></td><td><p>3.05s</p></td><td><p>18.27s</p></td></tr><tr><td><p><b>Batch API - with database batching</b></p></td><td><p>0.74s</p></td><td><p>1.06s</p></td><td><p>2.17s</p></td><td><p>8.48s</p></td></tr></table><p><b>Overall Average:</b></p><table><tr><th><p>\n</p></th><th><p><b>10 Records</b></p></th><th><p><b>100 Records</b></p></th><th><p><b>1,000 Records</b></p></th><th><p><b>10,000 Records</b></p></th></tr><tr><td><p><b>Regular API</b></p></td><td><p>7.31s</p></td><td><p>71.33s</p></td><td><p>710.26s</p></td><td><p>7,548.87s</p></td></tr><tr><td><p><b>Batch API - without database batching</b></p></td><td><p>0.81s</p></td><td><p>1.38s</p></td><td><p>3.51s</p></td><td><p>17.44s</p></td></tr><tr><td><p><b>Batch API - with database batching</b></p></td><td><p>0.69s</p></td><td><p>1.02s</p></td><td><p>2.31s</p></td><td><p>8.85s</p></td></tr></table><p>We can see that on average, the new batching API is significantly faster than the regular API trying to do the same actions, and it’s also nearly twice as fast as the batching API without batched database calls. We can see that at 10,000 records, the batching API is a staggering 850x faster than the regular API. As mentioned above, these numbers are likely to change for a number of different reasons, but it’s clear that making several round trips to and from the API adds substantial latency, regardless of the region.</p>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"batch-overload\">Batch overload</h2>\n      <a href=\"#batch-overload\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>Making our API faster is awesome, but we don’t operate in an isolated environment. Each of these records needs to be processed and pushed to <a href=\"https://blog.cloudflare.com/introducing-quicksilver-configuration-distribution-at-internet-scale\"><u>Quicksilver</u></a>, our distributed database. If we have customers creating tens of thousands of records every 10 seconds, we need to be able to handle this downstream so that we don’t overwhelm our system. In a May 2022 blog post titled <a href=\"https://blog.cloudflare.com/dns-build-improvement\"><i><u>How we improved DNS record build speed by more than 4,000x</u></i></a>, I noted<i> </i>that:</p><blockquote><p><i>We plan to introduce a batching system that will collect record changes into groups to minimize the number of queries we make to our database and Quicksilver.</i></p></blockquote><p>This task has since been completed, and our propagation pipeline is now able to batch thousands of record changes into a single database query which can then be published to Quicksilver in order to be propagated to our global network. </p>\n    <div class=\"flex anchor relative\">\n      <h2 id=\"next-steps\">Next steps</h2>\n      <a href=\"#next-steps\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n        <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n      </a>\n    </div>\n    <p>We have a couple more improvements we may want to bring into the API. We also intend to improve the UI to bring more usability improvements to the dashboard to more easily manage zones. <a href=\"https://research.rallyuxr.com/cloudflare/lp/cm0zu2ma7017j1al98l1m8a7n?channel=share&studyId=cm0zu2ma4017h1al9byak79iw\"><u>We would love to hear your feedback</u></a>, so please let us know what you think and if you have any suggestions for improvements.</p><p>For more details on how to use the new /batch API endpoint, head over to our <a href=\"https://developers.cloudflare.com/dns/manage-dns-records/how-to/batch-record-changes/\"><u>developer documentation</u></a> and <a href=\"https://developers.cloudflare.com/api/operations/dns-records-for-a-zone-batch-dns-records\"><u>API reference</u></a>.</p>",
		"id": "op0CI3wllMcGjptdRb2Ce",
		"localeList": {
			"name": "blog-english-only",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "In response to customer demand, we now support the ability to DELETE, PATCH, PUT and POST multiple DNS records in a single API call, enabling more efficient and reliable zone management.\n",
		"metadata": {
			"imgPreview": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/7GOZD8wICrGFK9sussU95/8703f78d5c183f747158eaef1b6a4531/BLOG-2495_OG.png"
		},
		"primary_author": {},
		"publicly_index": true,
		"published_at": "2024-09-23T14:00+01:00",
		"slug": "batched-dns-changes",
		"tags": [
			{
				"id": "1Cv5JjXzKWKEA10JdYbXu1",
				"name": "Birthday Week",
				"slug": "birthday-week"
			},
			{
				"id": "5fZHv2k9HnJ7phOPmYexHw",
				"name": "DNS",
				"slug": "dns"
			},
			{
				"id": "5x72ei67SoD11VQ0uqFtpF",
				"name": "API",
				"slug": "api"
			},
			{
				"id": "4WdWDf1411wmpAnMnDwVDY",
				"name": "Kafka",
				"slug": "kafka"
			},
			{
				"id": "6txTUIMHOhipqANVWJGAmG",
				"name": "Database",
				"slug": "database"
			}
		],
		"title": "Making zone management more efficient with batch DNS record updates",
		"updated_at": "2025-10-24T09:42:45.798Z",
		"url": "https://blog.cloudflare.com/batched-dns-changes"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.icon_aria_label": "Search",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"search.result_stat_empty": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong>",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"search.autocomplete_title": "Insert a query. Press enter to send",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}