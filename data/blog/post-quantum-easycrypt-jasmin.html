<div class="mb2 gray5">13 min read</div>
<div class="post-content lh-copy gray1">
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/1BwLb4xQVWZDUhb4XgFL82/45aa8ee20d4ebae9970d32d0104c14a9/image13-2.png" alt="Blog post about how to use EasyCrypt and Jasmin." class="kg-image" width="1800" height="1013" loading="lazy">

	</figure>
	<p>Cryptographic code is everywhere: it gets run when we connect to the bank, when we send messages to our friends, or when we <a href="https://www.sciencedirect.com/science/article/abs/pii/S0747563215004343">watch cat videos</a>. But, it is not at all easy to take a cryptographic specification written in a natural language and produce running code from it, and it is even harder to validate both the theoretical assumptions and the correctness of the implementation itself. Mathematical <a href="https://en.wikipedia.org/wiki/Mathematical_proof">proofs</a>, as we talked about in <a href="https://blog.cloudflare.com/post-quantum-formal-analysis">our previous blog post</a>, and <a href="https://en.wikipedia.org/wiki/Code_review">code inspection</a> are simply not enough. <a href="https://en.wikipedia.org/wiki/Software_testing">Testing</a> and <a href="https://blog.cloudflare.com/a-gentle-introduction-to-linux-kernel-fuzzing">fuzzing</a> can catch common or well-known bugs or mistakes, but might miss rare ones that can, nevertheless, be triggered by an attacker. <a href="https://en.wikipedia.org/wiki/Static_program_analysis">Static analysis</a> can detect mistakes in the code, but cannot check whether the code behaves as described by the specification in natural-language (for functional correctness). This gap between implementation and validation can have <a href="https://www.mitls.org/pages/attacks">grave consequences</a> in terms of security in the real world, and we need to bridge this chasm.</p>
	<p>In this blog post, we will be talking about ways to make this gap smaller by making the code we deploy better through analyzing its security properties and its implementation. This blog post continues our work on high assurance cryptography, for example, on using Tamarin to <a href="https://blog.cloudflare.com/post-quantum-formal-analysis">analyze entire protocol specifications</a>. In this one, we want to look more on the side of verifying implementations. Our desire for high assurance cryptography isn’t specific to post-quantum cryptography, but because quantum-safe algorithms and protocols are so new, we want extra reassurance that we’re doing the best we can. The post-quantum era also gives us a great opportunity to try and apply all the lessons we’ve learned while deploying classical cryptography, which will hopefully prevent us from making the same mistakes all over again.</p>
	<p>This blog post will discuss <a href="https://eprint.iacr.org/2019/1393.pdf">formal verification</a>. Formal verification is a technique we can use to prove that a piece of code correctly implements a specification. Formal verification, and <a href="https://en.wikipedia.org/wiki/Formal_methods">formal methods</a> in general, have been around for a long time, appearing as early as the 1950s. Today, they are being applied in a variety of ways: from <a href="https://csrc.nist.gov/CSRC/media/Events/third-pqc-standardization-conference/documents/accepted-papers/meijers-formal-verification-pqc2021.pdf">automating the checking of security proofs</a> to automating checks for functional correctness and the absence of side-channels attacks. Code verified using such formal verification has been deployed in popular products like <a href="https://blog.mozilla.org/security/2020/07/06/performance-improvements-via-formally-verified-cryptography-in-firefox">Mozilla Firefox</a> and <a href="https://boringssl.googlesource.com/boringssl/+/refs/heads/master/third_party/fiat">Google Chrome</a>.</p>
	<p><i>Formal verification</i>, as opposed to <i>formal analysis</i>, the topic of <a href="https://blog.cloudflare.com/post-quantum-formal-analysis">other blog posts</a>, deals with verifying code and checking that it correctly implements a specification. <i>Formal analysis</i>, on the other hand, deals with establishing that a specification has the desired properties, for example, having a specific security guarantee.</p>
	<p>Let’s explore what it means for an algorithm to have a proof that it achieves a certain security goal and what it means to have an implementation we can prove correctly implements that algorithm.</p>
	<h3>Goals of a formal analysis and verification process</h3>
	<p>Our goal, given a description of an algorithm in a natural language, is to produce two proofs: first, one that shows that the algorithm has the security properties we want and, second, that we have a correct implementation of it. We can go about this in four steps:</p>
	<ol>
		<li>
			<p>Turn the algorithm and its security goals into a formal specification. This is us defining the problem.</p>
		</li>
		<li>
			<p>Use formal analysis to prove, in our case using a computer-aided proof tooling, that the algorithm attains the specified properties.</p>
		</li>
		<li>
			<p>Use formal verification to prove that the implementation correctly implements the algorithm.</p>
		</li>
		<li>
			<p>Use formal verification to prove that our implementation has additional properties, like memory safety, running in constant time, efficiency, etc.</p>
		</li>
	</ol>
	<p>Interestingly we can do step 2 in parallel with steps 3 and 4, because the two proofs are actually independent. As long as they are both building from the same specification established in step 1, the properties we establish in the formal analysis should flow down to the implementation.</p>
	<p>Suppose, more concretely, we’re looking at an implementation and specification of a Key Encapsulation Mechanism (a KEM, such as <a href="https://frodokem.org/files/FrodoKEM-specification-20210604.pdf"><i>FrodoKEM</i></a>). FrodoKEM is designed to achieve <a href="https://en.wikipedia.org/wiki/Ciphertext_indistinguishability">IND-CCA security</a>, so we want to prove that it does, and that we have an efficient, side-channel resistant and correct implementation of it.</p>
	<p>As you might imagine, achieving even one of these goals is no small feat. Achieving all, especially given the way they conflict (efficiency clashes with side-channel resistance, for example), is a Herculean task. <a href="https://eprint.iacr.org/2019/1393.pdf">Decades of research have gone into this space</a>, and it is huge; so let’s carve out and examine a small subsection to look at: we’ll look at two tools, <a href="https://github.com/EasyCrypt/easycrypt">EasyCrypt</a> and <a href="https://acmccs.github.io/papers/p1807-almeidaA.pdf">Jasmin</a>.</p>
	<p>Before we jump into the tools, let’s take a brief aside to discuss why we’re not using Tamarin, which we’ve talked about in our <a href="https://blog.cloudflare.com/post-quantum-formal-analysis">other blog posts</a>. Like EasyCrypt, <a href="https://tamarin-prover.github.io">Tamarin</a> is also a tool used for formal analysis, but beyond that, the two tools are quite different. Formal analysis broadly splits into two camps, symbolic analysis and computational analysis. Tamarin, as <a href="https://blog.cloudflare.com/post-quantum-formal-analysis">we saw</a>, uses symbolic analysis, which treats all functions effectively as black boxes, whereas EasyCrypt uses computational analysis. Computational analysis is much closer to how we program, and functions are given specific implementations. This gives computational analysis a much higher “resolution”: we can study properties in much greater detail and, perhaps, with greater ease. This detail, of course, comes at a cost. As functions grow into full protocols, with multiple modes, branching paths, and in the case of the Transport Layer Security (TLS), sometimes even resumption, computational models become unwieldy and difficult to work with, even with computer-assisted tooling. We therefore have to pick the correct tool for the job. When we need maximum assurance, sometimes both computational and symbolic proofs are constructed, with each playing to its strengths and compensating for the other’s drawbacks.</p>
	<h3>EasyCrypt</h3>
	<p>EasyCrypt is a <i>proof assistant</i> for cryptographic algorithms and <a href="https://en.wikipedia.org/wiki/Imperative_programming">imperative programs</a>. A proof is basically a formal demonstration that some statement is true. EasyCrypt is called a proof assistant because it “assists” you with creating a proof; it does not create a proof for you, but rather, helps you come to it and gives you the power to have a machine check that each step logically follows from the last. It provides a language to write definitions, programs, and theorems along with an environment to develop machine-checked proofs.</p>
	<p>A proof starts from a set of assumptions, and by taking a series of logical steps demonstrates that some statement is true. Let’s imagine for a moment that we are <a href="https://en.wikipedia.org/wiki/Perseus">the hero Perseus</a> on a quest to kill a mythological being, the terrifying <a href="https://en.wikipedia.org/wiki/Medusa">Medusa</a>. How can we prove to everyone that we’ve succeeded? No one is going to want to enter Medusa's cave to check that she is dead because they’ll be turned to stone. And we cannot just state, “I killed the Medusa.” Who will believe us without proof? After all, is this not a <a href="https://en.wikipedia.org/wiki/Leap_of_faith">leap of faith</a>?</p>
	<p>What we can do is bring the head of the Medusa as proof. Providing the head as a demonstration is our proof because no mortal <a href="https://en.wikipedia.org/wiki/Gorgon">Gorgon</a> can live without a head. Legend has it that Perseus completed the proof by demonstrating that the head was indeed that of the Medusa: Perseus used the head’s powers to turn <a href="https://en.wikipedia.org/wiki/Polydectes">Polydectes</a> to stone (the latter was about to force Perseus’ mother to marry him, so let’s just say it wasn’t totally unprovoked). One can say that this proof was done “by hand” in that it was done without any mechanical help. For computer security proofs, sometimes the statements we want to prove are so cumberstone to prove and are so big that having a machine to help us is needed.</p>
	<p>How does EasyCrypt achieve this? How does it help you? As we are dealing with cryptography here, first, let’s start by defining how one can reason about cryptography, the security it provides, and the proofs one uses to corroborate them.</p>
	<p>When we encrypt something, we do this to hide whatever we want to send. In a perfect world, it would be <i>indistinguishable</i> from noise. Unfortunately, only the <a href="https://en.wikipedia.org/wiki/One-time_pad">one-time-pad</a> truly offers this property, so most of the time we make do with “close enough”: it should be infeasible to differentiate a true encrypted value from a random one.</p>
	<p>When we want to show that a certain cryptographic protocol or algorithm has this property, we write it down as an “indistinguishability game.” The idea of the game is as follows:</p>
	<blockquote>
		<p>Imagine a gnome is sitting in a box. The gnome takes a message as input to the box and produces a ciphertext. The gnome records each message and the ciphertext they see generated. A troll outside the box chooses two messages (m1 and m2) of the same length and sends them to the box. The gnome records the box operations and flips a coin. If the coin lands on its face, then the gnome sends the ciphertext (c1) corresponding to m1. Otherwise, they send c2 corresponding to m2. In order to win, the troll, knowing the messages and the ciphertext, has to guess which message was encrypted.</p>
	</blockquote>
	<p>In this example, we can see two things: first, choices are random as the ciphertext sent is chosen by flipping a coin; second, the goal of the adversary is to win a game.</p>
	<p>EasyCrypt takes this approach. Security goals are modeled as probabilistic programs (basically, as games) played by an adversary. Tools from program verification and programming language theory are used to justify the cryptographic reasoning. EasyCrypt relies on a “<a href="https://arxiv.org/abs/cs/0603118">goal directed proof” approach</a>, in which two important mechanisms occur: lemmas and tactics. Let’s see how this approach works (following this <a href="https://arxiv.org/abs/cs/0603118">amazing paper</a>):</p>
	<ol>
		<li>
			<p>The prover (in this case, you) enters a small <i>statement</i> to prove. For this, one uses the command <i>lemma</i> (meaning this is a <a href="https://en.wikipedia.org/wiki/Lemma_(mathematics)">minor statement</a> needed to be proven)<i>.</i></p>
		</li>
		<li>
			<p>EasyCrypt will display the formula as a statement to be proved (i.e <i>the goal</i>) and will also display all the known hypotheses (unproven lemmas) at any given point.</p>
		</li>
		<li>
			<p>The prover enters a command (a <i>tactic</i>) to either decompose the statement into simpler ones, apply a hypothesis, or make progress in the proof in some other way.</p>
		</li>
		<li>
			<p>EasyCrypt displays a new set of hypotheses and the parts that still need to be proved.</p>
		</li>
		<li>
			<p>Back to step 3.</p>
		</li>
	</ol>
	<p>Let’s say you want to prove something small, like the statement “if <i>p</i> <i>in conjunction</i> with <i>q</i>, then <i>q</i> <i>in conjunction with p.</i>” In <a href="https://www.site.uottawa.ca/~lucia/courses/2101-10/lecturenotes/03PredicateLogic.pdf">predicate logic terms</a>, this will be written as <code><i>(p ∧ q) → (q ∧ p)</i></code>. If we translate this into English statements, as Alice will say in <a href="https://en.wikipedia.org/wiki/Alice%27s_Adventures_in_Wonderland">Alice in Wonderland</a>, it could be:</p>
	<p> <i>p</i>: I have a world of my own. <i>q:</i> Everything is nonsense. <i>p∧q:</i> I have a world of my own and everything is nonsense. <i>(p ∧ q) → (q ∧ p):</i> If I have a world of my own and everything is nonsense, then, everything is nonsense, and I have a world of my own.</p>
	<p>We will walk through such a <a href="https://github.com/alleystoughton/EasyTeach/blob/master/SimpLogic.ec">statement and its proof</a> in EasyCrypt. For more of these examples, see these <a href="https://github.com/alleystoughton/EasyTeach">given by</a> the marvelous Alley Stoughton.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/4WeNK8JivTymXgaqSVJwf2/eb04ac349a0881bea2f2ec614bd31a04/image9-2.png" alt="Screenshot of the code implementing our lemma and proof in EasyCrypt." class="kg-image" width="652" height="220" loading="lazy">

	</figure>
	<p>Our lemma and proof in EasyCrypt.</p>
	<pre class="language-bash"><code class="language-bash">lemma implies_and () :

This line introduces the stated lemma and creatively calls it “implies_and”. It takes no parameters.

(forall (P, Q: bool) =&gt; P /\ Q =&gt; Q /\ P.

This is the statement we want to prove. We use the variables P and Q of type bool (booleans), and we state that if P and Q, then Q and P.</code></pre>
	<p>Up until now we have just declared our statement to prove to EasyCrypt. Let’s see how we write the proof:</p>
	<pre class="language-bash"><code class="language-bash">proof.
This line demarcates the start of the proof for EasyCrypt.


move =&gt; p q H.
We introduce the hypothesis we want to prove (we move them to the “context”). We state that P and Q are both booleans, and that H is the hypothesis P /\ Q.


elim H.

We eliminate H (the conjunctive hypothesis) and we get the components: “p =&gt; q =&gt; q /\ p”.

trivial.

The proof is now trivial.

qed.</code></pre>
	<p><i>Quod erat demonstrandum</i> (QED) denotes the end of the proof (if both are true, then the conjunction holds). Whew! For such a simple statement, this took quite a bit of work, because EasyCrypt leaves no stone unturned. If you get to this point, you can be sure your proof is absolutely correct, unless there is a bug in EasyCrypt itself (or unless we are proving something that we weren't supposed to).</p>
	<p>As you see, EasyCrypt helped us by guiding us in decomposing the statement into simpler terms, and stating what still needed to be proven. And by strictly following logical principles, we managed to realize a proof. If we are doing something wrong, and our proof is incorrect, EasyCrypt will let us know, saying something like:</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/1kHg8ZYbefNDYuO5ys4IeA/754c034b843aab0abf4045120582f75a/image2-23.png" alt="Screenshot of EasyCrypt showing us that we did something wrong." class="kg-image" width="1344" height="258" loading="lazy">

	</figure>
	<p>Screenshot of EasyCrypt showing us that we did something wrong.</p>
	<p>What we have achieved is a computer-checked proof of the statement, giving us far greater confidence in the proof than if we had to scan over one written with pen and paper. But what makes EasyCrypt particularly attractive in addition to this is its tight integration with the <a href="https://github.com/jasmin-lang">Jasmin programming language</a> as we will see later.</p>
	<p>EasyCrypt will also interactively guide us to the proof, as it easily works with <a href="https://proofgeneral.github.io">ProofGeneral</a> in Emacs. In the image below we see, for example, that EasyCrypt is guiding us by showing the variables we have declared (p, q, and H) and what is missing to be proven (after the dashed line).</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/3ZxKXX1WhxdT4ooPSWct8b/7486f1d7e122e6137211c094b1edbb35/image8-2.png" alt="EasyCrypt interactively showing us at which point of the proof we are at." class="kg-image" width="1440" height="582" loading="lazy">

	</figure>
	<p>EasyCrypt interactively showing us at which point of the proof we are at: the cyan section shows us up until which point we have arrived.</p>
	<p>If one is more comfortable with <a href="https://cs-people.bu.edu/gaboardi/teaching/S21-CS591/labs/week3/hoare.pdf">Coq</a> proof assistant (you can find <a href="https://www.youtube.com/watch?v=z861PoZPGqk&amp;list=PLDD40A96C2ED54E99&amp;index=5&amp;ab_channel=AndrejBauer">very good tutorials</a> of it), a similar proof can be given:</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/4UKDlNoMQOtzkKB9qTxF3W/4ec463068042d22abcaa01ee9b609191/image3-25.png" alt="Screenshot of the code implementing our lemma and proof in Coq." class="kg-image" width="586" height="266" loading="lazy">

	</figure>
	<p>Our lemma and proof in Coq.</p>
	<p>EasyCrypt allows us to prove statements in a faster and more assured manner than if we do proofs by hand. Proving the truthness of the statement we just showed would be easy with the usage of truth tables, for example. But, it is only easy to find these truth tables or proofs when the statement is small. If one is given a complex cryptography algorithm or protocol, the situation is much harder.</p>
	<h3>Jasmin</h3>
	<p><a href="https://acmccs.github.io/papers/p1807-almeidaA.pdf">Jasmin</a> is an assembly-like programming language with some high-level syntactic conveniences such as loops and procedure calls while using assembly-level instructions. It does support function calls and functional arrays, as well. The Jasmin compiler predictably transforms source code into assembly code for a chosen platform (currently only <a href="https://www.intel.com/content/dam/develop/external/us/en/documents/introduction-to-x64-assembly-181178.pdf">x64</a> is supported). This transformation is verified: the correctness of some compiler passes (like function inlining or loop unrolling) are proven and verified in the Coq proof assistant. Other passes are programmed in a conventional programming language and the results are validated in Coq. The compiler also comes with a built-in checker for memory safety and constant-time safety.</p>
	<p>This assembly-like syntax, combined with the stated assurances of the compiler, means that we have deep control over the output, and we can optimize it however we like without compromising safety. Because low-level cryptographic code tends to be concise and non-branching, Jasmin doesn’t need full support for general purpose language features or to provide lots of libraries. It only needs to support a set of basic features to give us everything we need.</p>
	<p>One reason Jasmin is so powerful is that it provides a way to formally verify low-level code. The other reason is that Jasmin code can be automatically converted by the compiler into equivalent EasyCrypt code, which lets us reason about its security. In general terms, whatever guarantees apply to the EasyCrypt code also flow into the Jasmin code, and subsequently into the assembly code.</p>
	<p>Let’s use the example of a very simple Jasmin function that performs multiplication to see Jasmin in action:</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/6qKbsZ1rUwceP0AXOM23ms/e969e8e406eba6ef9af56a5432348048/image1-23.png" alt="Code showing a multiplication function written in Jasmin." class="kg-image" width="790" height="416" loading="lazy">

	</figure>
	<p>A multiplication function written in Jasmin.</p>
	<p>What the function (“fn”) “mul” does, in this case, is to multiply by whatever number is provided as an argument to the function (the variable <code><i>a</i></code>). The syntax of this small function should feel very familiar to anyone that has worked with the <a href="https://en.wikipedia.org/wiki/List_of_C-family_programming_languages">C family of programming languages</a>. The only big difference is the use of the words <code><i>reg</i></code> and <code><i>u64</i></code>. What they state is that the variable <code><i>a</i></code>, for example, is <a href="https://en.wikipedia.org/wiki/Register_allocation">allocated in registers</a> (hence, the use of <i>reg</i>: this defines the storage of the variable) and that it is <a href="https://en.wikipedia.org/wiki/Word_(computer_architecture)">64-bit machine-word</a> (hence, the use of <i>u64</i>). We can convert now this to “pure” x64 assembly:</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/2TFayfomwD2qaL1cR1Dx3b/4747da665605989ead148d3d3f45c320/image7-4.png" alt="Code showing a multiplication function written in Jasmin and transformed to Assembly." class="kg-image" width="570" height="274" loading="lazy">

	</figure>
	<p>A multiplication function written in Jasmin and transformed to Assembly.</p>
	<p>The first lines of the assembly code are just “setting all up”. They are then followed by the <a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf">“imulq” instruction</a>, which just multiplies the variable by the constant (which in this case is labeled as “param”). While this small function might not show the full power of having the ability of safely translating to assembly, it can be seen when more complex functions are created. Functions that use while loops, arrays, calls to other functions are accepted by Jasmin and will be safely translated to assembly.</p>
	<p>Assembly language has a <a href="http://flint.cs.yale.edu/cs421/papers/art-of-asm/pdf/FORWARD.PDF">little bit of a bad reputation</a> because it is thought to be hard to learn, hard to read, and hard to maintain. Having a tool that helps you with translation is very useful to a programmer, and it is also useful as you can manually or automatically check what the assembly code looks like.</p>
	<p>We can further check the code for its safety:</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/70mzl8XIVNieFBNw1FShm7/ba48a8f1414e373a066483d1cab180d3/image6-9.png" alt="Code showing a multiplication function written and checked in Jasmin." class="kg-image" width="1170" height="490" loading="lazy">

	</figure>
	<p>A multiplication function written and checked in Jasmin.</p>
	<p>In this check, there are many things to understand. First, it checks that the inputs are allocated in a memory region of at least 0 bytes. Second, the “Rel” entry checks the allocated memory region safety pre-condition: for example, <i>n</i> must point to an allocated memory region of sufficient length.</p>
	<p>You can then <a href="https://github.com/jasmin-lang/jasmin/wiki/Extraction-to-EasyCrypt">extract this functionality to EasyCrypt</a> (and even configure EasyCrypt to verify Jasmin programs). Here is the corresponding EasyCrypt code, automatically produced by the Jasmin compiler:</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/3wYndYnFsKrBcIPhDIDizI/e418e5f5cbae157a8dc0a5332cdb4a39/image4-15.png" alt="Code showing a multiplication function written in Jasmin and extracted to EasyCrypt." class="kg-image" width="726" height="486" loading="lazy">

	</figure>
	<p>A multiplication function written in Jasmin and extracted to EasyCrypt.</p>
	<p>Here’s a slightly more involved example, that of a FrodoKEM utility function written in Jasmin.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/2kXt7r2F4RguoMalUYiUWl/8bf2d64b1c4d7de552515d341919b053/image5-9.png" alt="Code showing a utility function for addition for FrodoKEM." class="kg-image" width="1590" height="546" loading="lazy">

	</figure>
	<p>A utility function for addition for FrodoKEM.</p>
	<p>With a C-like syntax, &nbsp;this function adds two arrays (<code><i>a</i></code> and <code><i>b</i></code>), and returns the result (in <i>out</i>). The value <i>NBAR</i> is just a parameter you can specify in a C-like manner. You can then take this function and <a href="https://github.com/jasmin-lang/jasmin/wiki/Compilation-to-assembly">compile it to assembly</a>. You can also use the Jasmin compiler to analyze <a href="https://github.com/jasmin-lang/jasmin/wiki/Safety-checker">the safety of the code</a> (for example, that array accesses are in bounds, that memory accesses are valid, that arithmetic operations are applied to valid arguments) and <a href="https://github.com/jasmin-lang/jasmin/wiki/Constant-time-verification">verify the code runs in constant-time</a>.</p>
	<p>The addition function as used by FrodoKEM can also be extracted to EasyCrypt:</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/9IZw1XeDt61yAapX1P1za/429cb4262a74ab58f6fead3f3fa62619/image10-2.png" alt="Code showing the addition function as extracted to EasyCrypt." class="kg-image" width="1716" height="928" loading="lazy">

	</figure>
	<p>The addition function as extracted to EasyCrypt.</p>
	<p>A theorem expressing the correctness (meaning that addition is correct) is expressed in EasyCrypt as so:</p>
	<figure class="kg-card kg-image-card kg-width-wide">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/5SDmCcTq5mHAJV73C8dzdd/123ccae82dde11bfc08989c348868f6c/image12-2.png" alt="Code showing the theorem addition function as extracted to EasyCrypt." class="kg-image" width="1808" height="208" loading="lazy">

	</figure>
	<p>The theorem of addition function as extracted to EasyCrypt.</p>
	<p>Note that EasyCrypt uses <a href="https://cs-people.bu.edu/gaboardi/teaching/S21-CS591/labs/week3/hoare.pdf">While Language and Hoare Logic</a>. The corresponding proof that states that addition is correct:</p>
	<figure class="kg-card kg-image-card kg-width-wide">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/3JiYmQNHCVA7MHZv4xOPB4/87916d5494db19bb9a9800b0a743c457/image11-2.png" alt="Code showing the proof of the addition function as extracted to EasyCrypt." class="kg-image" width="1999" height="245" loading="lazy">

	</figure>
	<p>The proof of the addition function as extracted to EasyCrypt.</p>
	<h3>Why formal verification for post-quantum cryptography?</h3>
	<p>As we have previously stated, cryptographic implementations are very hard to get right, and even if they are right, the security properties they claim to provide are sometimes wrong for their intended application. The reason why this matters so much is that post-quantum cryptography is the cryptography we will be using in the future due to the arrival of quantum computers. Deploying post-quantum cryptographic algorithms with bugs or flaws in their security properties would be a disaster because connections and data that travels through it can be decrypted or attacked. We are trying to prevent that.</p>
	<p>Cryptography is difficult to get right, and it is not only difficult to get right by people new to it, but it is also difficult for anyone, even for the experts. The designs and code we write are error-prone as we all are, as humans, prone to errors. Some examples of when some designs got it wrong are as follows (luckily, these example &nbsp;were not deployed, and they did not have the usual disastrous consequences):</p>
	<ul>
		<li>
			<p><a href="https://falcon-sign.info">Falcon</a> (a post-quantum algorithm currently part of the <a href="https://csrc.nist.gov/projects/post-quantum-cryptography">NIST procedure</a>), produced valid signatures “but leaked information on the private key,” according to an <a href="https://csrc.nist.gov/CSRC/media/Projects/post-quantum-cryptography/documents/round-2/official-comments/FALCON-round2-official-comment.pdf">official comment</a> posted to the NIST post-quantum process on the algorithm. The comment also noted that “the fact that these bugs existed in the first place shows that the traditional development methodology (i.e. “being super careful”) has failed.“</p>
		</li>
		<li>
			<p>“The De Feo–Jao–Plût identification scheme (the basis for <a href="https://en.wikipedia.org/wiki/Supersingular_isogeny_key_exchange">SIDH signatures</a>) contains an invalid assumption and provide[s] a counterexample for this assumption: thus showing the proof of soundness is invalid,” according to a <a href="https://eprint.iacr.org/2021/1023.pdf">finding</a> that one proof of a post-quantum algorithm was not valid. This is an example of an incorrect proof, whose flaws were discovered and eliminated prior to any deployment.</p>
		</li>
	</ul>
	<p>Perhaps these two examples might convince the reader that formal analysis and formal verification of implementations are needed. While they help us avoid some human errors, they are not perfect. As for us, we are convinced of these methods. We are working towards a <a href="https://github.com/xvzcf/VeriFrodo">formally verified implementation of FrodoKEM</a> (we have a first implementation of it in our <a href="https://github.com/cloudflare/circl/pull/311">cryptographic library, CIRCL</a>), and we are collaborating to create a <a href="https://github.com/jasmin-lang/cryptolib">formally verified and implemented library</a> we can run in real-world connections. If you are interested in learning more about EasyCrypt and Jasmin, visit the <a href="https://github.com/claucece/formal-tutorials">resources we have put together</a>, try to <a href="https://github.com/xvzcf/VeriFrodo/blob/main/install.md">install it following our guidelines</a>, or follow <a href="https://cryptojedi.org/programming/jasmin.shtml">some tutorials</a>.</p>
	<p>See you on other adventures in post-quantum (and some <a href="https://www.youtube.com/c/utahactor">cat videos for you</a>)!</p>
	<h3>References:</h3>
	<ul>
		<li>
			<p>“SoK: Computer-Aided Cryptography” by Manuel Barbosa, Gilles Barthe, Karthik Bhargavan, Bruno Blanchet, Cas Cremers, Kevin Liao and Bryan Parno: <a href="https://eprint.iacr.org/2019/1393.pdf">https://eprint.iacr.org/2019/1393.pdf</a></p>
		</li>
		<li>
			<p>“EasyPQC: Verifying Post-Quantum Cryptography” by Manuel Barbosa, Gilles Barthe, Xiong Fan, Benjamin Grégoire, Shih-Han Hung, Jonathan Katz, Pierre-Yves Strub, Xiaodi Wu and Li Zhou: <a href="https://eprint.iacr.org/2021/1253">https://eprint.iacr.org/2021/1253</a></p>
		</li>
		<li>
			<p>“Jasmin: High-Assurance and High-Speed Cryptography” by José Bacelar Almeida, Manuel Barbosa, Gilles Barthe, Arthur Blot, Benjamin Grégoire, Vincent Laporte, Tiago Oliveira, Hugo Pacheco, Benedikt Schmidt and Pierre-Yves Strub: <a href="https://dl.acm.org/doi/pdf/10.1145/3133956.3134078">https://dl.acm.org/doi/pdf/10.1145/3133956.3134078</a></p>
		</li>
		<li>
			<p>“The Last Mile: High-Assurance and High-Speed Cryptographic Implementations” by José Bacelar Almeida, Manuel Barbosa, Gilles Barthe, Benjamin Grégoire, Adrien Koutsos, Vincent Laporte,Tiago Oliveira and Pierre-Yves Strub: <a href="https://arxiv.org/pdf/1904.04606.pdf">https://arxiv.org/pdf/1904.04606.pdf</a></p>
		</li>
	</ul>
</div>