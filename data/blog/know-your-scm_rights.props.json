{
	"footerBlurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
	"initialReadingTime": "3",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Vlad Krasnov",
				"slug": "vlad-krasnov",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4aDp3XtkBoeuPj5b9e5oRE/084f9a39036700298e0a62b5e8c2aa3c/vlad-krasnov.jpg",
				"location": null,
				"website": null,
				"twitter": null,
				"facebook": null
			}
		],
		"excerpt": "As TLS 1.3 was ratified earlier this year, I was recollecting how we got started with it here at Cloudflare. We made the decision to be early adopters of TLS 1.3 a little over two years ago. It was a very important decision, and we took it very seriously.",
		"feature_image": "https:undefined",
		"featured": false,
		"html": "<p>As TLS 1.3 was ratified earlier <a href=\"/rfc-8446-aka-tls-1-3/\">this year</a>, I was recollecting how we got started with it here at Cloudflare. We made the decision to be early adopters of <a href=\"/introducing-tls-1-3/\">TLS 1.3</a> a little over two years ago. It was a very important decision, and we took it very seriously.</p><p>It is no secret that Cloudflare uses <a href=\"/end-of-the-road-for-cloudflare-nginx/\">nginx</a> to handle user traffic. A little less known fact, is that we have several instances of nginx running. I won’t go into detail, but there is one instance whose job is to accept connections on port 443, and proxy them to another instance of nginx that actually handles the requests. It has pretty limited functionality otherwise. We fondly call it nginx-ssl.</p><p>Back then we were using OpenSSL for TLS and Crypto in nginx, but OpenSSL (and BoringSSL) had yet to announce a timeline for TLS 1.3 support, therefore we had to implement our own TLS 1.3 stack. Obviously we wanted an implementation that would not affect any customer or client that would not enable TLS 1.3. We also needed something that we could iterate on quickly, because the spec was very fluid back then, and also something that we can release frequently without worrying about the rest of the Cloudflare stack.</p><p>The obvious solution was to implement it on top of OpenSSL. The OpenSSL version we were using was 1.0.2, but not only were we looking ahead to replace it with version 1.1.0 or with <a href=\"/make-ssl-boring-again/\">BoringSSL</a> (which we eventually did), it was so ingrained in our stack and so fragile that we wouldn’t be able to achieve our stated goals, without risking serious bugs.</p><p>Instead, Filippo Valsorda and Brendan McMillion suggested that the easier path would be to implement TLS 1.3 on top of the Go TLS library and make a Go replica of nginx-ssl (go-ssl). Go is very easy to iterate and prototype, with a powerful standard library, and we had a great pool of Go talent to use, so it made a lot of sense. Thus <a href=\"https://github.com/cloudflare/tls-tris\">tls-tris</a> was born.</p><p>The question remained how would we have Go handle only TLS 1.3 while letting nginx handling all prior versions of TLS?</p><p>And herein lies the problem. Both TLS 1.3 and older versions of TLS communicate on port 443, and it is common knowledge that only one application can listen on a given TCP port, and that application is nginx, that would still handle the bulk of the TLS traffic. We could pipe all the TCP data into another connection in Go, effectively creating an additional proxy layer, but where is the fun in that? Also it seemed a little inefficient.</p>\n          <div class=\"flex anchor relative\">\n            <h2 id=\"meet-scm_rights\">Meet SCM_RIGHTS</h2>\n            <a href=\"#meet-scm_rights\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>So how do you make two different processes, written in two different programming languages, share the same TCP socket?</p><p>Fortunately, Linux (or rather UNIX) provides us with just the tool that we need. You can use UNIX-domain sockets to pass file descriptors between applications, and like everything else in UNIX connections are files.Looking at <code>man 7 unix</code> we see the following:</p>\n            <pre class=\"language-bash\"><code class=\"language-bash\">   Ancillary messages\n       Ancillary  data  is  sent and received using sendmsg(2) and recvmsg(2).\n       For historical reasons the ancillary message  types  listed  below  are\n       specified with a SOL_SOCKET type even though they are AF_UNIX specific.\n       To send them  set  the  cmsg_level  field  of  the  struct  cmsghdr  to\n       SOL_SOCKET  and  the cmsg_type field to the type.  For more information\n       see cmsg(3).\n\n       SCM_RIGHTS\n              Send or receive a set of  open  file  descriptors  from  another\n              process.  The data portion contains an integer array of the file\n              descriptors.  The passed file descriptors behave as though  they\n              have been created with dup(2).</pre></code>\n            <blockquote><p>Technically you do not send “file descriptors”. The “file descriptors” you handle in the code are simply indices into the processes&#39; local file descriptor table, which in turn points into the OS&#39; open file table, that finally points to the vnode representing the file. Thus the “file descriptor” observed by the other process will most likely have a different numeric value, despite pointing to the same file.</p></blockquote><p>We can also check <code>man 3 cmsg</code> as suggested, to find a handy example on how to use SCM_RIGHTS:</p>\n            <pre class=\"language-c\"><code class=\"language-c\">   struct msghdr msg = { 0 };\n   struct cmsghdr *cmsg;\n   int myfds[NUM_FD];  /* Contains the file descriptors to pass */\n   int *fdptr;\n   union {         /* Ancillary data buffer, wrapped in a union\n                      in order to ensure it is suitably aligned */\n       char buf[CMSG_SPACE(sizeof(myfds))];\n       struct cmsghdr align;\n   } u;\n\n   msg.msg_control = u.buf;\n   msg.msg_controllen = sizeof(u.buf);\n   cmsg = CMSG_FIRSTHDR(&amp;msg);\n   cmsg-&gt;cmsg_level = SOL_SOCKET;\n   cmsg-&gt;cmsg_type = SCM_RIGHTS;\n   cmsg-&gt;cmsg_len = CMSG_LEN(sizeof(int) * NUM_FD);\n   fdptr = (int *) CMSG_DATA(cmsg);    /* Initialize the payload */\n   memcpy(fdptr, myfds, NUM_FD * sizeof(int));</pre></code>\n            <p>And that is what we decided to use. We let OpenSSL read the “Client Hello” message from an established TCP connection. If the “Client Hello” indicated TLS version 1.3, we would use SCM_RIGHTS to send it to the Go process. The Go process would in turn try to parse the rest of the “Client Hello”, if it were successful it would proceed with TLS 1.3 connection, and upon failure it would give the file descriptor back to OpenSSL, to handle regularly.</p><p>So how exactly do you implement something like that?</p><p>Since in our case we established that the C process will listen for TCP connections, our other process will have to listen on a UNIX socket, for connections C will want to forward.</p><p>For example in Go:</p>\n            <pre class=\"language-go\"><code class=\"language-go\">type scmListener struct {\n\t*net.UnixListener\n}\n\ntype scmConn struct {\n\t*net.UnixConn\n}\n\nvar path = &quot;/tmp/scm_example.sock&quot;\n\nfunc listenSCM() (*scmListener, error) {\n\tsyscall.Unlink(path)\n\n\taddr, err := net.ResolveUnixAddr(&quot;unix&quot;, path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tul, err := net.ListenUnix(&quot;unix&quot;, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = os.Chmod(path, 0777)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &amp;scmListener{ul}, nil\n}\n\nfunc (l *scmListener) Accept() (*scmConn, error) {\n\tuc, err := l.AcceptUnix()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &amp;scmConn{uc}, nil\n}</pre></code>\n            <p>Then in the C process, for each connection we want to pass, we will connect to that socket first:</p>\n            <pre class=\"language-c\"><code class=\"language-c\">int connect_unix()\n{\n    struct sockaddr_un addr = {.sun_family = AF_UNIX,\n                               .sun_path = &quot;/tmp/scm_example.sock&quot;};\n\n    int unix_sock = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (unix_sock == -1)\n        return -1;\n\n    if (connect(unix_sock, (struct sockaddr *)&amp;addr, sizeof(addr)) == -1)\n    {\n        close(unix_sock);\n        return -1;\n    }\n\n    return unix_sock;\n}</pre></code>\n            <p>To actually pass a file descriptor we utilize the example from <code>man 3 cmsg</code>:</p>\n            <pre class=\"language-c\"><code class=\"language-c\">int send_fd(int unix_sock, int fd)\n{\n    struct iovec iov = {.iov_base = &quot;:)&quot;, // Must send at least one byte\n                        .iov_len = 2};\n\n    union {\n        char buf[CMSG_SPACE(sizeof(fd))];\n        struct cmsghdr align;\n    } u;\n\n    struct msghdr msg = {.msg_iov = &amp;iov,\n                         .msg_iovlen = 1,\n                         .msg_control = u.buf,\n                         .msg_controllen = sizeof(u.buf)};\n\n    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&amp;msg);\n    *cmsg = (struct cmsghdr){.cmsg_level = SOL_SOCKET,\n                             .cmsg_type = SCM_RIGHTS,\n                             .cmsg_len = CMSG_LEN(sizeof(fd))};\n\n    memcpy(CMSG_DATA(cmsg), &amp;fd, sizeof(fd));\n\n    return sendmsg(unix_sock, &amp;msg, 0);\n}</pre></code>\n            <p>Then to receive the file descriptor in Go:</p>\n            <pre class=\"language-go\"><code class=\"language-go\">func (c *scmConn) ReadFD() (*os.File, error) {\n\tmsg, oob := make([]byte, 2), make([]byte, 128)\n\n\t_, oobn, _, _, err := c.ReadMsgUnix(msg, oob)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcmsgs, err := syscall.ParseSocketControlMessage(oob[0:oobn])\n\tif err != nil {\n\t\treturn nil, err\n\t} else if len(cmsgs) != 1 {\n\t\treturn nil, errors.New(&quot;invalid number of cmsgs received&quot;)\n\t}\n\n\tfds, err := syscall.ParseUnixRights(&amp;cmsgs[0])\n\tif err != nil {\n\t\treturn nil, err\n\t} else if len(fds) != 1 {\n\t\treturn nil, errors.New(&quot;invalid number of fds received&quot;)\n\t}\n\n\tfd := os.NewFile(uintptr(fds[0]), &quot;&quot;)\n\tif fd == nil {\n\t\treturn nil, errors.New(&quot;could not open fd&quot;)\n\t}\n\n\treturn fd, nil\n}</pre></code>\n            \n          <div class=\"flex anchor relative\">\n            <h2 id=\"rust\">Rust</h2>\n            <a href=\"#rust\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>We can also do this in Rust, although the standard library in Rust does not yet support UNIX sockets, but it does let you address the C library via the <a href=\"https://rust-lang.github.io/libc/x86_64-unknown-linux-gnu/libc/\">libc</a> crate. Warning, unsafe code ahead!</p><p>First we want to implement some UNIX socket functionality in Rust:</p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">use libc::*;\nuse std::io::prelude::*;\nuse std::net::TcpStream;\nuse std::os::unix::io::FromRawFd;\nuse std::os::unix::io::RawFd;\n\nfn errno_str() -&gt; String {\n    let strerr = unsafe { strerror(*__error()) };\n    let c_str = unsafe { std::ffi::CStr::from_ptr(strerr) };\n    c_str.to_string_lossy().into_owned()\n}\n\npub struct UNIXSocket {\n    fd: RawFd,\n}\n\npub struct UNIXConn {\n    fd: RawFd,\n}\n\nimpl Drop for UNIXSocket {\n    fn drop(&amp;mut self) {\n        unsafe { close(self.fd) };\n    }\n}\n\nimpl Drop for UNIXConn {\n    fn drop(&amp;mut self) {\n        unsafe { close(self.fd) };\n    }\n}\n\nimpl UNIXSocket {\n    pub fn new() -&gt; Result&lt;UNIXSocket, String&gt; {\n        match unsafe { socket(AF_UNIX, SOCK_STREAM, 0) } {\n            -1 =&gt; Err(errno_str()),\n            fd @ _ =&gt; Ok(UNIXSocket { fd }),\n        }\n    }\n\n    pub fn bind(self, address: &amp;str) -&gt; Result&lt;UNIXSocket, String&gt; {\n        assert!(address.len() &lt; 104);\n\n        let mut addr = sockaddr_un {\n            sun_len: std::mem::size_of::&lt;sockaddr_un&gt;() as u8,\n            sun_family: AF_UNIX as u8,\n            sun_path: [0; 104],\n        };\n\n        for (i, c) in address.chars().enumerate() {\n            addr.sun_path[i] = c as i8;\n        }\n\n        match unsafe {\n            unlink(&amp;addr.sun_path as *const i8);\n            bind(\n                self.fd,\n                &amp;addr as *const sockaddr_un as *const sockaddr,\n                std::mem::size_of::&lt;sockaddr_un&gt;() as u32,\n            )\n        } {\n            -1 =&gt; Err(errno_str()),\n            _ =&gt; Ok(self),\n        }\n    }\n\n    pub fn listen(self) -&gt; Result&lt;UNIXSocket, String&gt; {\n        match unsafe { listen(self.fd, 50) } {\n            -1 =&gt; Err(errno_str()),\n            _ =&gt; Ok(self),\n        }\n    }\n\n    pub fn accept(&amp;self) -&gt; Result&lt;UNIXConn, String&gt; {\n        match unsafe { accept(self.fd, std::ptr::null_mut(), std::ptr::null_mut()) } {\n            -1 =&gt; Err(errno_str()),\n            fd @ _ =&gt; Ok(UNIXConn { fd }),\n        }\n    }\n}</pre></code>\n            <p>And the code to extract the file desciptor:</p>\n            <pre class=\"language-rust\"><code class=\"language-rust\">#[repr(C)]\npub struct ScmCmsgHeader {\n    cmsg_len: c_uint,\n    cmsg_level: c_int,\n    cmsg_type: c_int,\n    fd: c_int,\n}\n\nimpl UNIXConn {\n    pub fn recv_fd(&amp;self) -&gt; Result&lt;RawFd, String&gt; {\n        let mut iov = iovec {\n            iov_base: std::ptr::null_mut(),\n            iov_len: 0,\n        };\n\n        let mut scm = ScmCmsgHeader {\n            cmsg_len: 0,\n            cmsg_level: 0,\n            cmsg_type: 0,\n            fd: 0,\n        };\n\n        let mut mhdr = msghdr {\n            msg_name: std::ptr::null_mut(),\n            msg_namelen: 0,\n            msg_iov: &amp;mut iov as *mut iovec,\n            msg_iovlen: 1,\n            msg_control: &amp;mut scm as *mut ScmCmsgHeader as *mut c_void,\n            msg_controllen: std::mem::size_of::&lt;ScmCmsgHeader&gt;() as u32,\n            msg_flags: 0,\n        };\n\n        let n = unsafe { recvmsg(self.fd, &amp;mut mhdr, 0) };\n\n        if n == -1\n            || scm.cmsg_len as usize != std::mem::size_of::&lt;ScmCmsgHeader&gt;()\n            || scm.cmsg_level != SOL_SOCKET\n            || scm.cmsg_type != SCM_RIGHTS\n        {\n            Err(&quot;Invalid SCM message&quot;.to_string())\n        } else {\n            Ok(scm.fd)\n        }\n    }\n}</pre></code>\n            \n          <div class=\"flex anchor relative\">\n            <h2 id=\"conclusion\">Conclusion</h2>\n            <a href=\"#conclusion\" aria-hidden=\"true\" class=\"relative sm:absolute sm:-left-5\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\"></path></svg>\n            </a>\n          </div>\n          <p>SCM_RIGHTS is a very powerful tool that can be used for many purposes. In our case we used to to introduce a new service in a non-obtrusive fashion. Other uses may be:</p><ul><li><p>A/B testing</p></li><li><p>Phasing out of an old C based service in favor of new Go or Rust one</p></li><li><p>Passing connections from a privileged process to an unprivileged one</p></li></ul><p>And more</p><p>You can find the full example <a href=\"https://github.com/vkrasnov/scm_sample\">here</a>.</p>",
		"id": "6FPYG7UeMVoKyzz6mA3tpB",
		"localeList": {
			"name": "Know your SCM_RIGHTS Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": null,
		"metadata": {
			"imgPreview": ""
		},
		"primary_author": {},
		"published_at": "2018-11-29T09:54:22.000+00:00",
		"slug": "know-your-scm_rights",
		"tags": [
			{
				"id": "14zCAfc7F9ROKtNbSxs2Pe",
				"name": "TLS 1.3",
				"slug": "tls-1-3"
			},
			{
				"id": "56vA0Z6hqev6QaJBQmO2J8",
				"name": "TLS",
				"slug": "tls"
			},
			{
				"id": "6Mp7ouACN2rT3YjL1xaXJx",
				"name": "Security",
				"slug": "security"
			},
			{
				"id": "383iv0UQ6Lp0GZwOAxGq2p",
				"name": "Linux",
				"slug": "linux"
			},
			{
				"id": "5NpgoTJYJjhgjSLaY7Gt3p",
				"name": "TCP",
				"slug": "tcp"
			},
			{
				"id": "2fnCQE8RAlAe4IVUpITe58",
				"name": "OpenSSL",
				"slug": "openssl"
			},
			{
				"id": "KDI5hQcs301H8vxpGKXO0",
				"name": "Go",
				"slug": "go"
			},
			{
				"id": "3FBpuRfF7HUFga2Z5jgAFf",
				"name": "NGINX",
				"slug": "nginx"
			}
		],
		"title": "Know your SCM_RIGHTS",
		"updated_at": "2024-10-10T00:32:37.491Z",
		"url": "https://blog.cloudflare.com/know-your-scm_rights"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"search.clear": "Clear",
		"search.filter": "Filter",
		"search.source": "Source",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"search.filters": "Filters",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"search.language": "Language",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"search.result_stat": "Results <strong>{search_range}</strong> of <strong>{search_total}</strong> for <strong>{search_keyword}</strong>",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"search.source_location": "Source/Location",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}