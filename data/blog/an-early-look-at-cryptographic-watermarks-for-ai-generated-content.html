<div class="mb2 gray5">17 min read</div><img class="mr2" src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3qaJH3smwhOnOoWKFqpgXb/719d23b2ecf3dad33a6138c6a867efef/Feature_Image.png" alt="">
<div class="post-content lh-copy gray1">
	<p><a href="https://www.cloudflare.com/learning/ai/what-is-generative-ai">Generative AI</a> is reshaping many aspects of our lives, from how we work and learn, to how we play and interact. Given that it's Security Week, it's a good time to think about some of the unintended consequences of this information revolution and the role that we play in bringing them about.</p>
	<p>Today's web is full of AI-generated content: text, code, <a href="https://www.cloudflare.com/learning/ai/ai-image-generation">images</a>, audio, and video can all be generated by machines, normally based on a prompt from a human. Some models have become so sophisticated that distinguishing their artifacts — that is, the text, audio, and video they generate — from everything else can be quite difficult, <a href="https://originality.ai/blog/openai-text-classifier-review"><u>even for machines themselves</u></a>. This difficulty creates a number of challenges. On the one hand, those who train and deploy generative AI need to be able to identify AI-created artifacts they scrape from websites in order <a href="https://www.nature.com/articles/s41586-024-07566-y"><u>to avoid polluting their training data</u></a>. On the other hand, the origin of these artifacts may be intentionally misrepresented, creating <a href="https://www.gov.ca.gov/2024/09/19/governor-newsom-signs-bills-to-crack-down-on-sexually-explicit-deepfakes-require-ai-watermarking"><u>myriad problems</u></a> for society writ large.</p>
	<p>Part of the solution to this problem might be <b>watermarking</b>. The basic idea of watermarking is to modify the training process, the inference process, or both so that an artifact of the model embeds some identifying information of the model from which it originates. This way a model operator, or potentially the consumer of the content themselves, can determine whether some artifact came from the model by checking for the presence of the watermark.</p>
	<p>Watermarking shares many of the same goals as the <a href="https://c2pa.org"><u>C2PA initiative</u></a>. C2PA seeks to add provenance of media from a variety of sources, not just AI. Think of it as a chain of digital signatures, where each link in the chain corresponds to some modification of the artifact. For example, if you're a Cloudflare customer using <a href="https://www.cloudflare.com/developer-platform/products/cloudflare-images"><u>Images</u></a> to serve C2PA-tagged content, <a href="https://blog.cloudflare.com/preserve-content-credentials-with-cloudflare-images"><u>you can opt in to preserve the provenance</u></a> by extending this signature chain, even after the image is compressed on our network.</p>
	<p>The challenge of this approach is that it requires participation by each entity in the chain of custody of the artifact. Watermarking has the potential to make C2PA more robust by preserving the origin of the artifact even after unattributed modification. Whereas the C2PA signature is encoded in an image’s metadata, a watermark is embedded in the pixels of the image itself.</p>
	<p>In this post, we're going to take a look at an emerging paradigm for AI watermarking. Based on cryptography, these new watermarks aim to provide rigorous, mathematical guarantees of quality preservation and robustness to modification of the content. This field is, as of 2025, only a couple of years old, and we don't yet know if it will yield schemes that are practical to deploy. Nevertheless, we believe this is a promising area of research, and we hope this post inspires someone to come up with the next big idea.</p>
	<div class="flex anchor relative">
		<h3 id="the-case-for-cryptography">The case for cryptography</h3>
		<a href="https://blog.cloudflare.com/#the-case-for-cryptography" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>It's often said that cryptography is necessary but not sufficient for security. In other words, cryptographers make certain assumptions about the state of the system, like that a key is kept secret from the attacker, or that some computational puzzle is hard to solve. When these assumptions hold, a good cryptosystem provides a mathematical proof of security against the class of attacks it is designed to prevent.</p>
	<p>Artifact watermarking usually has three security goals:</p>
	<ol>
		<li>
			<p>Robustness: Users of the model should not be able to easily misrepresent the origin of its artifacts. The watermark should be verifiable even after the artifact is modified to some extent.</p>
		</li>
		<li>
			<p>Undetectability: Watermarking should have negligible impact on the quality of the model output. In particular, watermarked artifacts should be indistinguishable from non-watermarked artifacts of the same model.</p>
		</li>
		<li>
			<p>Unforgeability: It should be impossible for anyone but the model operator to produce watermarked artifacts. No one should be able to convince the model operator that an artifact was generated by the model when it wasn't.</p>
		</li>
	</ol>
	<p>Today's state-of-the-art watermarks, including Google's <a href="https://deepmind.google/technologies/synthid"><u>SynthID</u></a> and Meta's <a href="https://aidemos.meta.com/videoseal"><u>Video Seal</u></a>, are often based on <a href="https://www.cloudflare.com/learning/ai/what-is-deep-learning"><u>deep learning</u></a>. These schemes involve training a <a href="https://www.cloudflare.com/learning/ai/what-is-machine-learning">machine learning model</a>, typically one with an encoder–decoder architecture where the encoder encodes a signature into an artifact and the decoder decodes the signature:</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/wk6vE9ArPOK7EXP2otytf/f847db73272c932ba546d8a6b3176480/1.png" alt="" class="kg-image" width="1608" height="1032" loading="lazy">
	</figure>
	<p><sup><i>Figure 1: Illustration of the process of training an encoder-decoder watermarking model.</i></sup></p>
	<p>The training process involves subjecting the watermarked artifact to a series of known attacks. The more attacks the model thwarts, the higher the model quality. For example, the trainer would alter the artifact in various ways and run the decoder on the outputs: the model scores high if the decoder manages to correctly output the signature most of the time.</p>
	<p>This idea is quite beautiful. It's like a scaled up version of <a href="https://www.cloudflare.com/learning/security/glossary/what-is-penetration-testing">penetration testing</a>, an essential practice of security engineering whereby the system is subjected to a suite of known attacks until all known vulnerabilities are patched. Of course, there will always be new attack variants or new attack strategies that the model was not trained on and that may evade the model.</p>
	<p>And so ensues the proverbial game of cat-and-mouse that consumes so much time in security engineering. Coping with new attacks on robustness, undetectability, or unforgeability of deep-learning based watermarks requires continual intelligence gathering and re-training of deployed models to keep up with attackers.</p>
	<p>The promise of cryptography is that it helps us break out of these kinds of cat-and-mouse games. Cryptography reduces the attack surface by focusing the attacker's attention on breaking some narrow aspect of the system that is easier to reason about. This might be gaining access to some secret key, or solving some (seemingly unrelated) computational puzzle that is believed to be impossible to solve.</p>
	<div class="flex anchor relative">
		<h3 id="pseudorandom-codes">Pseudorandom codes</h3>
		<a href="https://blog.cloudflare.com/#pseudorandom-codes" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>To the best of our knowledge, the first cryptographic AI watermark was proposed by Scott Aaronson <a href="https://scottaaronson.blog/?p=6823"><u>in the summer of 2022 while he was working at OpenAI</u></a>. Tailored specifically for chatbots, Aaronson's simple scheme was both undetectable and unforgeable. However, it was susceptible to some simple attacks on robustness.</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4XcSE2infymYTGywob2XlS/b79819f48b58c26a7c1713a89879d412/2.png" alt="" class="kg-image" width="778" height="282" loading="lazy">
	</figure>
	<p><sup><i>Figure 2: The "emoji attack": Ask the chatbot to embed a simple pattern in its response, then remove the pattern manually. This is sufficient to remove some cryptographic watermarks from the model output.</i></sup></p>
	<p>In the year or so that followed, other cryptographic watermarks were proposed, all making different trade-offs between detectability and robustness. Two years later, in a paper that appeared at <a href="https://eprint.iacr.org/2024/235"><u>CRYPTO 2024</u></a>, Miranda Christ and Sam Gunn articulated a new framework for watermarks that, if properly instantiated, would provide all three properties simultaneously.</p>
	<p>Along with the prompt provided by the user, generative AI models typically take as input some randomness generated by the model operator. For many such models, it is often possible to run the model "in reverse" such that, given an artifact of the model, one can recover <b>an approximation of</b> the initial randomness used to generate it. We'll see why this is important in a moment.</p>
	<p>The starting point for Christ-Gunn-2024 is a mathematical tool called an <a href="https://en.wikipedia.org/wiki/Error_correction_code"><u>error correcting code</u></a>. These codes are normally used to transmit messages over noisy channels and are found in just about every system we rely on, including fiber optics, satellites, the data bus on your motherboard, and even quantum computers.</p>
	<p>To transmit a message <code>m</code>, one first encodes it into a <b>codeword</b> <code>c=encode(m)</code>. Then the receiver attempts to decode the codeword as <code>decode(c)</code>. Error correcting codes are designed to tolerate some fraction of the codeword bits being flipped: if too many bits are flipped, then decoding will fail.</p>
	<p>Now, ignoring undetectability and unforgeability for a moment, we can use an error correcting code to make a robust watermark as follows:</p>
	<ol>
		<li>
			<p>Generate the initial randomness.</p>
		</li>
		<li>
			<p>Embed a codeword <code>c=encode(m)</code> into the randomness in some manner, by overwriting bits of randomness with bits of <code>c</code>. The message <code>m</code> can be whatever we want, for example a short string identifying the version of our model.</p>
		</li>
		<li>
			<p>Run the model with the modified randomness.</p>
		</li>
	</ol>
	<p>To verify the watermark, we:</p>
	<ol>
		<li>
			<p>Run the model "in reverse" on the artifact, obtaining an approximation of the initial randomness.</p>
		</li>
		<li>
			<p>Extract the codeword <code>c</code><code><sup>*</sup></code> from the randomness.</p>
		</li>
		<li>
			<p>If <code>decode(c</code><code><sup>*</sup></code><code>) </code>succeeds, then the watermark is present.</p>
		</li>
	</ol>
	<p>Why does this work? Since c is a codeword, we can verify the watermark even if our approximation of the initial randomness isn't perfect. Some of the bits will be flipped, but the error correcting property of the code allows us to compensate for this. In fact, this is also what makes the watermark robust, since we can also tolerate bit flips caused by an attacker munging the artifact. Of course, the better our approximation of the initial randomness, the more robust our watermark will be, since we'll be able to correct for more bit flips.</p>
	<p>To see why this watermark is detectable, notice that overwriting bits of the randomness with a fixed codeword (<code>c=encode(m)</code>) biases the randomness and thereby the output of the model. Thus, the distribution of watermarked artifacts will be slightly different from unwatermarked artifacts, perhaps even noticeably so. This watermark is also forgeable, since the encoding algorithm is public and can be run by anyone.</p>
	<p>The challenge then is to design error-correcting codes for which codewords look random, and generating codewords requires knowledge of a secret key held by the model operator. Christ-Gunn-2024 names these <b>pseudorandom error-correcting codes</b>, or simply <b>pseudorandom codes</b>.</p>
	<p>A pseudorandom code consists of three algorithms:</p>
	<ul>
		<li>
			<p><code>k = key_gen()</code>: the key generation algorithm. Let's call <code>k</code> the <b>watermarking key</b>.</p>
		</li>
		<li>
			<p><code>c = encode(k,m)</code>: the encoding algorithm takes in a message <code>m</code> and outputs a codeword <code>c</code>.</p>
		</li>
		<li>
			<p><code>m = decode(k,c)</code>: the decoding algorithm takes in a codeword <code>c</code> and outputs the underlying message <code>m</code>, or an indication that decoding failed.</p>
		</li>
	</ul>
	<p>The term "pseudorandom" refers to the fact that codewords aren't technically random bit strings. Intuitively, an attacker can distinguish a codeword from a random string if it manages to guess the watermarking key. Thus, our goal is to choose parameters for the code such that distinguishing codewords from random — for example, by guessing the watermarking key — is hard for any computationally bounded attacker.</p>
	<p>To use a pseudorandom code for watermarking, the operator first generates a watermarking key <code>k</code>. Then each time it gets a prompt from a user, it generates the initial randomness, embeds <code>c=encode(k,m)</code> into the initial randomness, and runs the model. To verify the watermark, the operator runs the model in reverse to get the inverted randomness, extracts the inverted codeword, <code>c</code><code><sup>*</sup></code>, and computes <code>decode(k,c</code><code><sup>*</sup></code><code>)</code>: if decoding succeeds, then the watermark is present.</p>
	<p>In order for this watermark to be undetectable, we need to pick an embedding of the codeword that doesn't change the distribution of the initial randomness. The details of this embedding depend on the model. Let's take a look at <a href="https://en.wikipedia.org/wiki/Stable_Diffusion"><u>Stable Diffusion</u></a> as an example.</p>
	<div class="flex anchor relative">
		<h3 id="a-watermark-for-stable-diffusion">A watermark for Stable Diffusion</h3>
		<a href="https://blog.cloudflare.com/#a-watermark-for-stable-diffusion" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p><a href="https://en.wikipedia.org/wiki/Stable_Diffusion"><u>Stable Diffusion</u></a> is a model used for image generation that takes as input a tensor of normally distributed floating point numbers called a <b>latent</b>. The model uses the user's prompt to "denoise" the latent tensor over a number of iterations, then converts the final version of the latent to an image.</p>
	<h4>Approximating the initial latent</h4>
	<p>Diffusion inversion is an iterative process that returns an exact or approximate initial latent by reversing the sampling process that generated an image. Inversion for text to image diffusion models is a relatively new area of research. A common application of diffusion inversion is <a href="https://arxiv.org/abs/2211.09794"><u>editing images by text prompts</u></a>.</p>
	<p><a href="https://arxiv.org/abs/2010.02502"><u>Denoising Diffusion Implicit Models (DDIMs)</u></a> are iterative, implicit probabilistic models that can generate high quality images using a faster sampling process than other approaches, as it only requires a relatively small number of timesteps to generate a sample. This makes <a href="https://arxiv.org/abs/2211.09794"><u>DDIM Inversion</u></a> a popular inversion technique because it is computationally fast, as it requires only a few timesteps to return an approximate initial latent of a generated image. Despite its popularity, it has some known limitations and can be <a href="https://arxiv.org/abs/2312.12540v5"><u>problematic to use for tasks where exact image reproduction is required</u></a>. These limitations have led researchers to explore techniques that produce <a href="https://arxiv.org/abs/2311.18387"><u>exact initial latents</u></a>. However, since watermarks based on pseudorandom codes can tolerate errors, it's worth investigating whether DDIM Inversion suffices for our purposes.</p>
	<p>Before we can generate an approximate initial latent, we need a generated image. To do this we use a pretrained Stable Diffusion model that uses a DDIM scheduler. The scheduler performs the “denoising” process that generates an image from a random noise seed (initial latent). By default, the pipeline computes random latents; when embedding a watermark we will generate this latent ourselves as described in the next section. The Stable Diffusion pipelines in the code snippets below sets the number of inference steps to 50. This parameter controls the number of steps the denoising process takes. 50 steps provides a nice balance between speed and image quality.</p>
	<pre class="language-Python"><code class="language-Python">from stable_diffusion.utils import build_stable_diffusion_pipeline
from stable_diffusion.schedulers import ddim_scheduler

# Instantiate Stable Diffusion pipeline
model_cache_path = './model_cache'
model = 'stabilityai/stable-diffusion-2-1-base'
scheduler, _ = ddim_scheduler()
pipe, device = build_stable_diffusion_pipeline(model, model_cache_path, scheduler)

# Generate image
prompt = 'grainy photo of a UFO at night'
image, _ = pipe(prompt, num_inference_steps=50, return_dict=False)</code></pre>
	<p>To compute the approximate initial latent for the image we generated, we run the sampling process backwards. We could include the prompt, but in the case of verifying a watermark, we will usually not know the initial prompt, so we instead just set it to the empty string:</p>
	<pre class="language-Python"><code class="language-Python">from PIL import Image
from stable_diffusion.utils import build_stable_diffusion_pipeline,   
                                   convert_pil_to_latents
from stable_diffusion.schedulers import ddim_inverse_scheduler

# Load image
img = Image.open(image_path)

# Instantiate Stable Diffusion pipeline with DDIM Inverse scheduler
model_cache_path = './model_cache'
model = 'stabilityai/stable-diffusion-2-1-base'
scheduler, _= ddim_inverse_scheduler()
pipe, _ = build_stable_diffusion_pipeline(model, model_cache_path, scheduler)

# Convert the input image to latent space
image_latent = convert_pil_to_latents(pipe, img)

# Invert the sampling process that generated the image with an empty prompt
inverted_latent, _ = pipe('', output_type='latent', latents=image_latent,  
                          num_inference_steps=50, return_dict=False)</code></pre>
	<h4>Embedding the code</h4>
	<p>The initial latent used for stable diffusion consists of a bunch of floating point numbers, each independently and <a href="https://en.wikipedia.org/wiki/Normal_distribution"><u>normally</u></a> distributed with a mean of zero.</p>
	<p>The following observation is from a <a href="https://arxiv.org/pdf/2410.07369"><u>recent evaluation</u></a> of the watermark of Christ and Gunn for stable diffusion. (There they used a more sophisticated but expensive inversion method than DDIM.) Observe that the probability that each number is negative is equal to the probability that the number is positive. Likewise, if the code is indeed pseudorandom, then each bit of the codeword is computationally indistinguishable from a bit that is one with probability ½ and zero with probability ½.</p>
	<p>To embed the codeword in the latent, we just set the sign of each number according to the corresponding bit of the codeword:</p>
	<pre class="language-Python"><code class="language-Python">from stable_diffusion.utils import build_stable_diffusion_pipeline
from stable_diffusion.schedulers import ddim_scheduler
import numpy as np
import torch

# Generate a normally distributed latent. For the default image
# size of 512x512 pixels, the latent shape is `[1, 4, 64, 64]`.
initial_latent = np.abs(np.random.randn(*LATENTS_SHAPE))

with np.nditer(initial_latent, op_flags=['readwrite']) as it:
    	codeword = encode(k, m)
    	for (i, x) in enumerate(it):
             # `codeword[i]` is a `bool` representing the `i`-th bit of
             # the codeword.
             x *= 1 if codeword[i] else -1

watermarked_latent = torch.from_numpy(initial_latent).to(dtype=torch.float32)

# Instantiate Stable Diffusion pipeline
model_cache_path = './model_cache'
model = 'stabilityai/stable-diffusion-2-1-base'
scheduler, _ = ddim_scheduler()
pipe, _ = build_stable_diffusion_pipeline(model, model_cache_path, scheduler)

# Generate watermarked image
prompt = 'grainy photo of a UFO at night'
watermarked_image, _ = pipe(prompt, num_inference_steps=50,
                                              latents=watermarked_latent, 
                                              return_dict=False)</code></pre>
	<p>To verify this watermark, we compute the inverted latent, extract the codeword, and attempt to decode:</p>
	<pre class="language-Python"><code class="language-Python">from PIL import Image
from stable_diffusion.utils import build_stable_diffusion_pipeline,   
                                   convert_pil_to_latents
from stable_diffusion.schedulers import ddim_inverse_scheduler
import numpy as np

# Load image
img = Image.open(image_path)

# Instantiate Stable Diffusion pipeline with DDIM Inverse scheduler
model_cache_path = './model_cache'
model = 'stabilityai/stable-diffusion-2-1-base'
scheduler, _ = ddim_inverse_scheduler()
pipe, _ = build_stable_diffusion_pipeline(model, model_cache_path, scheduler)

# Convert the input image to latent space
image_latent = convert_pil_to_latents(pipe, img)

# Invert the sampling process that generated the image
inverted_latent, _ = pipe('', output_type='latent', latents=image_latent,     
                         num_inference_steps=50, return_dict=False)

watermark_verified = False
with np.nditer(inverted_latent.cpu().numpy()) as it:
    inverted_codeword = []
    for x in it:
         inverted_codeword.append(x &gt; 0)

    if decode(k, inverted_codeword) == m:
         watermark_verified = True</code></pre>
	<p>This should work in theory given the error-correcting properties of the code. But does it work in practice?</p>
	<h4>Evaluation</h4>
	<p>A good approximate initial latent is one that is very similar to the original latent that generated an image.&nbsp; Given our embedding of a codeword into the latent, we define similarity as latents that have a high percentage of overlapping or matching signs.</p>
	<p>To get a feel for this difference, we can visualize it by comparing a generated image to the same image, but with the inverted latent (these images are unwatermarked):</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/ZFAAipEvnp6u79lcQrk5t/0d06e07468c05d707289a322937e9253/1.png" alt="" class="kg-image" width="540" height="540" loading="lazy">
	</figure>
	<p><sup><i>Figure 3: Image generated with prompt 'grainy photo of a UFO at night' (left) and the same image generated using the inverted latent (right).</i></sup></p>
	<p>To evaluate how good the approximate latents are for preserving the robustness of watermarks, we randomly sampled 1,000 prompts from the <a href="https://github.com/google-research/parti?tab=readme-ov-file#partiprompts-benchmark"><u>PartiPrompts benchmark dataset</u></a>. For each of these prompts we generated initial latent and inverted latent pairs. We then computed our similarity metric for each pair. We found that on average, 82% of the signs matched for all initial latent and inverted latent pairs, and at least 75% of signs matched for 90% of the pairs.</p>
	<p>We were pleasantly surprised with how accurate the approximation was on average. If 75% of the signs are preserved, then this gives us a decent margin for correcting for errors introduced by an attacker attempting to remove the watermark. Of course a better approximation would give us a better robustness margin. More study is required to fully understand the strengths and limitations of using DDIM Inversion for watermark decoding.</p>
	<div class="flex anchor relative">
		<h3 id="candidate-pseudorandom-codes">Candidate pseudorandom codes</h3>
		<a href="https://blog.cloudflare.com/#candidate-pseudorandom-codes" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Now that we have a feel for how to apply pseudorandom codes, let's take a look at how we actually build them. Although the field is barely a year old, we already have a handful of candidates.</p>
	<p>One obvious idea to try is to compose a plain error-correcting code with some cryptographic primitive to make the code pseudorandom. For instance, we might use some standard authenticated encryption scheme, like <a href="https://datatracker.ietf.org/doc/html/rfc8452"><u>AES-GCM-SIV</u></a>, to encrypt <code>m</code>, then apply an error correcting code to the ciphertext. (The watermarking key would be the encryption key.) This "encrypt-then-encode" composition seems natural because encryption schemes are already designed so that their ciphertexts are pseudorandom. Unfortunately, error correcting codes are generally highly structured, and this structure would be betrayed by the codeword, even when applied to a (pseudo)random input.</p>
	<p>The dual composition, "encode-then-encrypt", also doesn't work. If the ciphertext is non-malleable, as in AES-GCM-SIV, then we wouldn't be able to tolerate any number of bit flips. On the other hand, if the ciphertext were malleable, as in <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_(CTR)"><u>AES-CTR</u></a>, then the attacker would be able to forge codewords by manipulating a known codeword in a targeted manner.</p>
	<p>The strategy of Christ-Gunn-2024 is to modify an existing error-correcting code to make it pseudorandom.</p>
	<h4>Pseudorandom LDPC codes</h4>
	<p>Their starting point is the widely used <a href="https://en.wikipedia.org/wiki/Low-density_parity-check_code"><u>Low-Density Parity-Check (LDPC) code</u></a>. This code is defined by a <b>parity check</b> matrix <code>P</code> with and a corresponding <b>generator</b> matrix <code>G</code>. The parity check matrix has bit entries and might look something like this:</p>
	<pre class="language-Python"><code class="language-Python">import numpy as np
P = np.matrix([[1, 0, 1],
               [0, 0, 1],
               [0, 1, 1],
               [1, 1, 1],
               [1, 0, 0],
               [0, 1, 0]])</code></pre>
	<p>This matrix is used to check if a given bit string is a codeword. By definition, a codeword is any bit string c for which the weight of <code>P*c</code> (the number ones in the output of <code>P*c</code>) is small. (Note that arithmetic is modulo <code>2</code> here.) The generator matrix <code>G</code> is constructed from <code>P </code>so that it can be used as the encoder. In particular, for any bit string <code>m</code>, <code>c=G*m </code>is a codeword. The performance of this code depends in large part on the sparsity of the parity check matrix: roughly speaking, the more zero entries the matrix has, the more the bit flips the code can tolerate.</p>
	<p>The main idea of Christ-Gunn-2024 is to tune the parameters of the LDPC code (the dimensions of the parity check matrix and its density) so that when the parity-check matrix <code>P</code> is chosen at random, the generator matrix <code>G</code> is pseudorandom. This means that, intuitively, when we encode a random input <code>m</code> as <code>c=G*m</code>, the codeword <code>c</code> is also pseudorandom. (There is a bit more that goes into constructing the input <code>m</code>, but this is roughly the idea.)</p>
	<p>It's easy to see that a watermark based on this construction is robust, as it follows immediately from the capacity of LDPC to tolerate bit flips. Ensuring the watermark remains undetectable is more delicate, as it relies on relatively strong and understudied computational assumptions. As a result, it's not clear today for what parameter ranges this scheme is concretely secure. (There has been some progress here: <a href="https://eprint.iacr.org/2024/1425"><u>a recent preprint</u></a> by Surendra Ghentiyala and Venkatesan Guruswami showed that the pseudorandomness of Christ-Gunn-2024 can be proved with slightly weaker assumptions.)</p>
	<p>To get a feel for how things might go wrong, consider what happens if the attacker manages to guess one of the rows of the parity check matrix<code> P</code>. When we take the dot product of this row with a codeword, then the output will be 0 with high probability. (By definition, <code>c</code> is a codeword if the sum of the dot products of <code>c </code>with each row of <code>P</code> is small.) But if we take the dot product of this row with a random bit string, then we should expect to see 0 with probability roughly ½. This gives us a way of distinguishing codewords from random bit strings.</p>
	<p>Guessing a row of <code>P</code> is easy if the matrix is too sparse. In the extreme case, if each row has only one bit set, then there are only <code>n</code> possible values for that row, where <code>n</code> is the number of columns of <code>P</code>. On the other hand, making <code>P</code> too dense will degrade the code's ability to detect bit flips.</p>
	<p>Similarly, it may be easy to guess a row of <code>P</code> if the length of the codeword itself (<code>n</code>) is too small. Thus, in order for this code to be pseudorandom, it is necessary (but not sufficient) for the number of possible parity check matrices to be so large that exhaustively searching for <code>P</code> is not feasible. This can be done by increasing the size of the codeword or tolerating fewer bit flips.</p>
	<h4>Pseudorandom codes from PRFs</h4>
	<p>Another approach to constructing pseudorandom codes comes from <a href="https://eprint.iacr.org/2024/898"><u>a 2024 preprint</u></a> from Noah Golowich and Ankur Moitra. Their starting point is a common cryptographic primitive called a pseudorandom function (PRF). They require a PRF that takes as input a key <code>k</code>, a bit string <code>x</code> of length <code>m</code> and outputs a bit, denoted <code>F(k,m)</code>.</p>
	<p>Suppose our codewords are <code>x</code><code><sub>1</sub></code>, ⁣<code>w</code><code><sub>1</sub></code><code>=F(k,x</code><code><sub>1</sub></code><code>)</code>, …,<code> x</code><code><sub>n</sub></code>,<code> w</code><code><sub>n</sub></code><code>=F(k,x</code><code><sub>n</sub></code><code>) </code>where <code>x</code><code><sub>1</sub></code>, …, <code>x</code><code><sub>n</sub></code> are random <code>m</code>-bit strings. (Notice that the codeword length is <code>(m+1)*n</code>.) To verify if a string is a codeword, we parse the codeword into <code>x</code><code><sub>1</sub></code>, <code>w</code><code><sub>1</sub></code>, …, <code>x</code><code><sub>n</sub></code>, <code>w</code><code><sub>n</sub></code><code> </code>and check if <code>w</code><code><sub>i</sub></code><code> = F(k,x</code><code><sub>i</sub></code><code>)</code> for all <code>i</code>. If the number of checks that pass is sufficiently high, then the string is likely a codeword.</p>
	<p>It's easy to see that this code is pseudorandom if the output of <code>F</code> is pseudorandom. However, it's not very robust: to make the <code>i</code>-th check fail, we just need to flip a single bit, <code>w</code><code><sub>i</sub></code>. The attacker just needs to flip a sufficient number of these bits to cause verification to fail. To defeat this attack, the encoder permutes the bits of the codeword with a secret, random permutation. That way the attacker has to guess the position of a sufficient number of <code>w</code><code><sub>i</sub></code>s in the permuted bit string. (A bit more is required to make this scheme provably robust, but this is the idea.)</p>
	<p>Note that the number of bit flips we can tolerate with this scheme depends significantly on the number of PRF checks. This in turn determines the length of the codeword, so we may only get a reasonable degree of robustness for longer codewords. Note that we can increase the number of PRF checks by decreasing the length <code>m</code> of the <code>x</code><code><sub>i</sub></code>s, but making these strings too short is detrimental for pseudorandomness. (What happens if we happen to randomly pick <code>x</code><code><sub>i</sub></code><code>==x</code><code><sub>j</sub></code><code> </code>for <code>i!=j</code>?)</p>
	<h4>Are these schemes practical?</h4>
	<p>In our own experiments with Stable Diffusion, we were able to tune the LDPC code to tolerate up to 33% of the codeword bits being mangled, which is likely more than sufficient for robustness in practice. However, achieving this required making the parity check matrix so sparse that the code is not strongly pseudorandom. Thus, the resulting watermark cannot be considered cryptographically undetectable. Among the parameter sets for which the code is plausibly pseudorandom, we didn't find any for which the code tolerates more than 5% bit flips.</p>
	<p>Our findings were similar for the PRF-based code: with plausibly pseudorandom parameters, we couldn't tune the code to tolerate more than 1% bit flips. Like the LDPC code, we can crank this higher by sacrificing pseudorandomness, but we weren't able to crack 5% with any parameters we tried.</p>
	<p>There are a few ways to think about this.</p>
	<p>First, for both codes, robustness improves as the codeword gets larger. In particular, if the latent space for Stable Diffusion were larger, then we'd expect to be able to tolerate more bit flips. In general, cryptographic watermarks of all kinds perform better when there is more randomness to work with. For example, short responses produced by chatbots are especially hard for any watermarking strategy, including pseudorandom codes.</p>
	<p>Another takeaway is that we need a better approximation of the initial latent than provided by DDIM. Indeed, <a href="https://arxiv.org/abs/2410.07369"><u>in their own evaluation</u></a> of the LDPC-based code, Sam Gunn, Xuandong Zhao, and Dawn Song chose a much more sophisticated inversion method, which exhibited better results, albeit at a higher computational cost.</p>
	<p>A third view is that, as a practical matter, cryptographic undetectability might not be all that important for some applications. For instance, we might decide the watermark is good enough on the basis of statistical tests to check for biases within, or correlations across, codewords. Of course, such tests can't rule out the possibility of perceptible differences between watermarked and unwatermarked artifacts.</p>
	<figure class="kg-card kg-image-card">
		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/7BVEy8oI4HZUU6u7zUgW9G/20c48669c252dfe99a689dd0860a54a7/2.png" alt="" class="kg-image" width="540" height="540" loading="lazy">
	</figure>
	<p><sup><i>Figure 4: Images with verified LDPC watermarks generated with prompt 'grainy photo of a UFO at night'.</i></sup></p>
	<div class="flex anchor relative">
		<h3 id="conclusion">Conclusion</h3>
		<a href="https://blog.cloudflare.com/#conclusion" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>The sign of a good abstraction boundary is that it allows folks to collaborate across disciplines. With pseudorandom codes, it seems like we've landed on the right abstraction for AI watermarking: it's up to cryptography experts to figure out how to instantiate them; and it's up to AI/ML experts to figure out how to embed them in their applications. We believe this separation of concerns has the potential to make watermarking easier to deploy, especially for operators like Cloudflare's <a href="https://www.cloudflare.com/developer-platform/products/workers-ai"><u>Workers AI</u></a>, who don't train and maintain the models themselves.</p>
	<p>After spending a few weeks playing around with this stuff, we're excited by the potential of pseudorandom codes to make strong watermarks for generative AI. However, we feel it will take some time for this field to yield practical schemes.</p>
	<p>Existing candidates will require further study to determine the parameter ranges for which they provide good security. It is also worthwhile to investigate new approaches to building pseudorandom codes, perhaps starting with some other error correcting code besides LDPC. We should also examine what is even theoretically possible in this space: perhaps there is a fundamental tension between detectability and robustness that can't be resolved for some parameter regimes.</p>
	<p>It's also going to be important for watermarks based on pseudorandom codes to be publicly verifiable, as some other cryptographic watermarks are. Concretely, the LDPC code is sort of analogous to public key encryption, where the ciphertext corresponds to a codeword. It might be possible to flip this paradigm around and make a digital signature where the signature is a codeword. Of course, this only works when the weights of the model are also publicly available.</p>
	<p>On the AI/ML side, we need to look closer at methods of approximating the initial randomness for different types of models. This blog looked at what is perhaps the simplest possible method for Stable Diffusion, and while this seems to work pretty well, it's obvious that we can do a lot better. It's just a matter of keeping costs low. A good rule of thumb might be that verifying the watermark should not be more expensive than watermarked inference.</p>
	<p>Pseudorandom codes may also have applications beyond watermarking. When we circulated this blog post internally, an idea that came up a lot was to somehow apply this technology to non-AI content, to embed in the content its provenance. Indeed, this is the idea behind the <a href="https://blog.cloudflare.com/preserve-content-credentials-with-cloudflare-images"><u>C2PA integration</u></a>. Pseudorandom codes aren't immediately applicable, but may be in the future. Wherever you have a source of randomness in the process of generating some artifact, like digital photography, you can embed in that randomness a codeword.</p>
	<p>Thanks for reading! We hope we've managed to pique your interest in this field. We certainly will be following along. If you'd like to play with the code we used to produce the numbers in this blog, or just make some cool watermarked AI content, you can find our demo on <a href="https://github.com/cloudflareresearch/poc-watermark"><u>GitHub</u></a>.</p>
</div>