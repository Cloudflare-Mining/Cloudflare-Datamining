<div class="mb2 gray5">12 min read</div>
<div class="mt4">This post is also available in <a href="https://blog.cloudflare.com/zh-cn/post-quantum-for-all">简体中文</a>, <a href="https://blog.cloudflare.com/de-de/post-quantum-for-all">Deutsch</a>, <a href="https://blog.cloudflare.com/ja-jp/post-quantum-for-all">日本語</a>, <a href="https://blog.cloudflare.com/es-es/post-quantum-for-all">Español</a> and <a href="https://blog.cloudflare.com/fr-fr/post-quantum-for-all">Français</a>.</div><img class="mr2" src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2HYXT7ECRWOzaVKhvCOzFF/902093abfde98cec64d87a5848ad7639/post-quantum-for-all.png" alt="">
<div class="post-content lh-copy gray1">
	<p>There is an expiration date on the cryptography we use every day. It’s not easy to read, but somewhere <a href="https://globalriskinstitute.org/download/quantum-threat-timeline-report-2021-full-report">between 15 or 40 years</a>, a sufficiently powerful quantum computer is expected to be built that will be <a href="https://en.wikipedia.org/wiki/Shor%27s_algorithm">able to decrypt</a> essentially any encrypted data on the Internet today.</p>
	<p>Luckily, there is a solution: <a href="https://www.cloudflare.com/learning/ssl/quantum/what-is-post-quantum-cryptography">post-quantum (PQ) cryptography</a> has been designed to be secure against the threat of quantum computers. Just three months ago, in July 2022, after a six-year worldwide competition, the US National Institute of Standards and Technology (NIST), known for AES and SHA2, <a href="https://blog.cloudflare.com/nist-post-quantum-surprise">announced</a> which post-quantum cryptography they will standardize. NIST plans to publish the final standards in 2024, but we want to help drive early adoption of post-quantum cryptography.</p>
	<p>Starting today, as a beta service, <b>all</b> websites and APIs served through Cloudflare support post-quantum hybrid key agreement. This is on by default<sup>1</sup>; no need for an opt-in. This means that if your browser/app supports it, the connection to our network is also secure against any future quantum computer.</p>
	<p>We offer this post-quantum cryptography free of charge: we believe that post-quantum security should be the new baseline for the Internet.</p>
	<p>Deploying post-quantum cryptography seems like a no-brainer with quantum computers on the horizon, but it’s not without risks. To start, this is new cryptography: even with years of scrutiny, it is not inconceivable that a catastrophic attack might still be discovered. That is why we are deploying <i>hybrids</i>: a combination of a tried and tested key agreement together with a new one that adds post-quantum security.</p>
	<p>We are primarily worried about what might seem mere practicalities. Even though the protocols used to secure the Internet are designed to allow smooth transitions like this, in reality there is a lot of buggy code out there: trying to create a post-quantum secure connection might fail for many reasons — for example a middlebox being confused about the larger post-quantum keys and other reasons we have yet to observe because these post-quantum key agreements are brand new. It’s because of these issues that we feel it is important to deploy post-quantum cryptography early, so that together with browsers and other clients we can find and work around these issues.</p>
	<p>In this blog post we will explain how TLS, the protocol used to secure the Internet, is designed to allow a smooth and secure migration of the cryptography it uses. Then we will discuss the technical details of the post-quantum cryptography we have deployed, and how, in practice, this migration might not be that smooth at all. We finish this blog post by explaining how you can build a better, post-quantum secure, Internet by helping us test this new generation of cryptography.</p>
	<div class="flex anchor relative">
		<h2 id="tls-transport-layer-security">TLS: Transport Layer Security</h2>
		<a href="https://blog.cloudflare.com/#tls-transport-layer-security" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>When you’re browsing a website using a <i>secure connection</i>, whether that’s using HTTP/1.1 or <a href="https://blog.cloudflare.com/quic-version-1-is-live-on-cloudflare">QUIC</a>, you are using the Transport Layer Security (<b>TLS</b>) protocol under the hood. There are two major versions of TLS <a href="https://radar.cloudflare.com/adoption-and-usage">in common use today</a>: the new <a href="https://blog.cloudflare.com/rfc-8446-aka-tls-1-3">TLS 1.3</a> (~90%) and the older TLS 1.2 (~10%), which is on the decline.</p>
	<p>TLS 1.3 is a <a href="https://blog.cloudflare.com/rfc-8446-aka-tls-1-3">huge improvement</a> over TLS 1.2: it’s faster, more secure, simpler and more flexible in just the right places. This makes it easier to add post-quantum security to TLS 1.3 compared to 1.2. For the moment, we will leave it at that: we’ve only added post-quantum support to TLS 1.3.</p>
	<p>So, what is TLS all about? The goal is to set up a connection between a browser and website such that</p>
	<ul>
		<li>
			<p><b>Confidentiality and integrity</b>, no one can read along or tamper with the data undetected.</p>
		</li>
		<li>
			<p><b>Authenticity</b> you know you’re connected to the right website; not an imposter.</p>
		</li>
	</ul>
	<div class="flex anchor relative">
		<h3 id="building-blocks-aead-key-agreement-and-signatures">Building blocks: AEAD, key agreement and signatures</h3>
		<a href="https://blog.cloudflare.com/#building-blocks-aead-key-agreement-and-signatures" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Three different types of cryptography are used in TLS to reach this goal.</p>
	<ul>
		<li>
			<p><b>Symmetric encryption</b>, or more precisely <i>Authenticated Encryption With Associated Data</i> (AEAD), is the workhorse of cryptography: it’s used to ensure confidentiality and integrity. This is a straight-forward kind of encryption: there is a <i>single key</i> that is used to encrypt and decrypt the data. Without the right key you cannot decrypt the data and any tampering with the encrypted data results in an error while decrypting.</p>
		</li>
	</ul>
	<p>In TLS 1.3, <a href="https://blog.cloudflare.com/do-the-chacha-better-mobile-performance-with-cryptography">ChaCha20-Poly1305</a> and AES128-GCM are in common use today. What about quantum attacks? At first glance, it looks like we need to switch to 256-bit symmetric keys to defend against <a href="https://en.wikipedia.org/wiki/Grover%27s_algorithm">Grover’s algorithm</a>. In practice, however, Grover’s algorithm <a href="https://blog.cloudflare.com/nist-post-quantum-surprise/#post-quantum-security-levels">doesn’t parallelize well</a>, so the currently deployed AEADs will serve just fine.</p>
	<p>So if we can agree on a shared key to use with symmetric encryption, we’re golden. But how to get to a shared key? You can’t just pick a key and send it to the server: anyone listening in would know the key as well. One might think it’s an impossible task, but this is where the magic of asymmetric cryptography helps out:</p>
	<ul>
		<li>
			<p>A <b>key agreement</b>, also called <i>key exchange</i> or <i>key distribution</i>, is a cryptographic protocol with which two parties can agree on a shared key without an eavesdropper being able to learn anything. Today the <a href="https://cr.yp.to/ecdh.html">X25519</a> Elliptic Curve <a href="https://developers.cloudflare.com/internet/protocols/tls#ephemeral-diffie-hellman-handshake">Diffie–Hellman</a> protocol (ECDH) is the de facto standard key agreement used in TLS 1.3. The security of X25519 is based on the <a href="https://en.wikipedia.org/wiki/Discrete_logarithm">discrete logarithm problem</a> for elliptic curves, which is vulnerable to quantum attacks, as it is easily solved by a cryptographically relevant quantum computer using <a href="https://en.wikipedia.org/wiki/Shor%27s_algorithm">Shor’s algorithm</a>. The solution is to use a post-quantum key agreement, such as <a href="https://pq-crystals.org/kyber/index.shtml">Kyber</a>.</p>
		</li>
	</ul>
	<p>A key agreement only protects against a passive attacker. An active attacker, that can intercept and modify messages (<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">MitM</a>), can establish separate shared keys with both the server and the browser, re-encrypting all data passing through. To solve this problem, we need the final piece of cryptography.</p>
	<ul>
		<li>
			<p>With a <b>digital</b> <b>signature</b> algorithm, such as <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> or <a href="https://www.cloudflare.com/learning/dns/dnssec/ecdsa-and-dnssec">ECDSA</a>, there are two keys: a <i>public</i> and a <i>private key</i>. Only with the private key, one can create a <i>signature</i> for a message. Anyone with the corresponding public key can check whether a signature is indeed valid for a given message. These digital signatures are at the heart of <a href="https://www.cloudflare.com/learning/ssl/what-is-an-ssl-certificate"><i>TLS certificates</i></a> that are used to authenticate websites. Both RSA and ECDSA are vulnerable to quantum attacks. We haven’t replaced those with post-quantum signatures, yet. The reason is that authentication is less urgent: we only need to have them replaced by the time a sufficiently large quantum computer is built, whereas any data secured by a vulnerable key agreement today can be stored and decrypted in the future. Even though we have more time, deploying post-quantum authentication will be <a href="https://blog.cloudflare.com/sizing-up-post-quantum-signatures">quite challenging</a>.</p>
		</li>
	</ul>
	<p>So, how do these building blocks come together to create TLS?</p><!--kg-card-begin: html-->
	<h2 id="tls-anchor">High-level overview of TLS 1.3</h2><!--kg-card-end: html-->
	<p>A TLS connection starts with a <b>handshake</b> which is used to authenticate the server and derive a shared key. The browser (client) starts by sending a <i>ClientHello</i> message that contains a list of the AEADs, signature algorithms, and key agreement methods it supports. To remove a roundtrip, the client is allowed to make a guess of what the server supports and start the key agreement by sending one or more <i>client keyshares</i>. That guess might be correct (on the left in the diagram below) or the client has to retry (on the right).</p>
	<figure class="kg-card kg-image-card kg-width-wide">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/4jeNtG1jP4LRmICiNeBUIG/87c30c89aeef2ce319bb25c0c5cddc2d/image4.png" alt="Protocol flow for server-authenticated TLS 1.3 with a supported client keyshare on the left and a HelloRetryRequest on the right." class="kg-image" width="1726" height="1346" loading="lazy">

	</figure>
	<p>Protocol flow for server-authenticated TLS 1.3 with a supported client keyshare on the left and a HelloRetryRequest on the right.</p>
	<h4><b>Key agreement</b></h4>
	<p>Before we explain the rest of this interaction, let’s dig into the key agreement: what is a keyshare? The way the key agreement for Kyber and X25519 work <a href="https://blog.cloudflare.com/nist-post-quantum-surprise/#kem-versus-diffie-hellman">is different</a>: the first is a Key Encapsulation Mechanism (KEM), while the latter is a Diffie–Hellman (DH) style agreement. The latter is more flexible, but for TLS it doesn’t make a difference.</p>
	<figure class="kg-card kg-image-card kg-width-wide">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/25zN3n7EymPx0ZLTOKBEO6/71928fb621191c1de4883f77b1e9cae5/image3.png" alt="The shape of a KEM and Diffie–Hellman key agreement in TLS-compatible handshake is the same." class="kg-image" width="1779" height="1028" loading="lazy">

	</figure>
	<p>The shape of a KEM and Diffie–Hellman key agreement in TLS-compatible handshake is the same.</p>
	<p>In both cases the client sends a <i>client keyshare</i> to the server. From this <i>client keyshare</i> the server generates the <i>shared key</i>. The server then returns a <i>server keyshare</i> with which the client can also compute the shared key.</p>
	<p>Going back to the TLS 1.3 flow: when the server receives the <i>ClientHello</i> message it picks an AEAD (cipher), signature algorithm and client keyshare that it supports. It replies with a <i>ServerHello</i> message that contains the chosen AEAD and the <i>server keyshare</i> for the selected key agreement. With the AEAD and shared key locked in, the server starts encrypting data (shown with blue boxes).</p>
	<h4><b>Authentication</b></h4>
	<p>Together with the AEAD and server keyshare, the server sends a signature, the <i>handshake signature</i>, on the transcript of the communication so far together with a <a href="https://www.cloudflare.com/learning/ssl/what-is-an-ssl-certificate"><i>certificate</i></a><i> (chain)</i> for the public key that it used to create the signature. This allows the client to authenticate the server: it checks whether it trusts the <i>certificate authority</i> (e.g. <a href="https://letsencrypt.org">Let’s Encrypt</a>) that certified the public key and whether the signature verifies for the messages it sent and received so far. This not only authenticates the server, but it also protects against downgrade attacks.</p>
	<h4><b>Downgrade protection</b></h4>
	<p>We cannot upgrade all clients and servers to post-quantum cryptography at once. Instead, there will be a transition period where only some clients and some servers support post-quantum cryptography. The key agreement negotiation in TLS 1.3 allows this: during the transition servers and clients will still support non post-quantum key agreements, and can fall back to it if necessary.</p>
	<p>This flexibility is great, but also scary: if both client and server support post-quantum key agreement, we want to be sure that they also negotiate the post-quantum key agreement. This is the case in TLS 1.3, but it is not obvious: the keyshares, the chosen keyshare and the list of supported key agreements are all sent in plain text. Isn’t it possible for an attacker in the middle to remove the post-quantum key agreements? This is called a <i>downgrade attack</i>.</p>
	<p>This is where the transcript comes in: the handshake signature is taken over all messages received and sent by the server so far. This includes the supported key agreements and the key agreement that was picked. If an attacker changes the list of supported key agreements that the client sends, then the server will not notice. However, the client checks the server’s handshake signature against the list of supported key agreements it has actually sent and thus will detect the mischief.</p>
	<p>The downgrade attack problems are <a href="https://eprint.iacr.org/2018/298">much</a> <a href="https://eprint.iacr.org/2016/072.pdf">more</a> <a href="https://www.rfc-editor.org/rfc/rfc7627">complicated</a> for TLS 1.2, which is one of the reasons we’re hesitant to retrofit post-quantum security in TLS 1.2.</p>
	<h4><b>Wrapping up the handshake</b></h4>
	<p>The last part of the server’s response is <i>“server finished”,</i> a <i>message authentication code</i> (MAC) on the whole transcript so far. Most of the work has been done by the handshake signature, but in other operating modes of TLS without handshake signature, such as session resumption, it’s important.</p>
	<p>With the chosen AEAD and server keyshare, the client can compute the shared key and decrypt and verify the certificate chain, handshake signature and handshake MAC. We did not mention it before, but the shared key is not used directly for encryption. Instead, for good measure, <a href="https://www.rfc-editor.org/rfc/rfc8446.html#page-93">it’s mixed together</a> with communication transcripts, to derive several specific keys for use during the handshake and the main connection afterwards.</p>
	<p>To wrap up the handshake, the client sends its own handshake MAC, and can then proceed to send application-specific data encrypted with the keys derived during the handshake.</p>
	<h4><b>Hello! Retry Request?</b></h4>
	<p>What we just sketched is the desirable flow where the client sends a keyshare that is supported by the server. That might not be the case. If the server doesn’t accept any key agreements advertised by the client, then it will tell the client and abort the connection.</p><!--kg-card-begin: html-->If there is a key agreement that both support, but for which the client did not send a keyshare, then the server will respond with a HelloRetryRequest (HRR) message requesting a keyshare of a specific key agreement that the client supports as shown <a href="https://blog.cloudflare.com/#tls-anchor">on the diagram on the right</a>. In turn, the client responds with a new ClientHello with the selected keyshare.
	<p></p><!--kg-card-end: html-->
	<p>This is not the whole story: a server is also allowed to send a <i>HelloRetryRequest</i> to request a different key agreement that it prefers over those for which the client sent shares. For instance, a server can send a <i>HelloRetryRequest</i> to a post-quantum key agreement if the client supports it, but didn’t send a keyshare for it.</p>
	<p>_HelloRetryRequest_s are rare today. Almost every server supports the X25519 key-agreement and almost every client (98% today) sends a X25519 keyshare. Earlier P-256 was the de facto standard and for a long time many browsers would send both a P-256 and X25519 keyshare to prevent a HelloRetryRequest. As we will discuss later, we might not have the luxury to send two post-quantum keyshares.</p>
	<h4><b>That’s the theory</b></h4>
	<p>TLS 1.3 is designed to be flexible in the cryptography it uses without sacrificing security or performance, which is convenient for our migration to post-quantum cryptography. That is the theory, but there are some serious issues in practice — we’ll go into detail later on. But first, let’s check out the post-quantum key agreements we’ve deployed.</p>
	<div class="flex anchor relative">
		<h3 id="what-we-deployed">What we deployed</h3>
		<a href="https://blog.cloudflare.com/#what-we-deployed" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Today we have enabled support for the <b>X25519Kyber512Draft00</b> and <b>X25519Kyber768Draft00</b> key agreements using TLS identifiers 0xfe30 and 0xfe31 respectively. These are exactly the same key agreements <a href="https://blog.cloudflare.com/experiment-with-pq">we enabled</a> on a limited number of zones this July.</p>
	<p>These two key agreements are a combination, a <a href="https://datatracker.ietf.org/doc/draft-stebila-tls-hybrid-design"><b>hybrid</b></a>, of the classical <a href="https://www.rfc-editor.org/rfc/rfc8410">X25519</a> and the new post-quantum Kyber512 and Kyber768 respectively and in that order. That means that even if Kyber turns out to be insecure, the connection remains as secure as X25519.</p>
	<p><a href="https://pq-crystals.org/kyber/index.shtml">Kyber</a>, for now, is the only key agreement that NIST <a href="https://blog.cloudflare.com/nist-post-quantum-surprise">has selected</a> for standardization. Kyber is very light on the CPU: it is faster than X25519 which is already known for its speed. On the other hand, its keyshares are much bigger:</p><!--kg-card-begin: html-->
	<style type="text/css">
		.tg {
			border-collapse: collapse;
			border-color: #ccc;
			border-spacing: 0;
		}

		.tg td {
			background-color: #fff;
			border-color: #ccc;
			border-style: solid;
			border-width: 1px;
			color: #333;
			font-family: Arial, sans-serif;
			font-size: 14px;
			overflow: hidden;
			padding: 10px 5px;
			word-break: normal;
		}

		.tg th {
			background-color: #f0f0f0;
			border-color: #ccc;
			border-style: solid;
			border-width: 1px;
			color: #333;
			font-family: Arial, sans-serif;
			font-size: 14px;
			font-weight: normal;
			overflow: hidden;
			padding: 10px 5px;
			word-break: normal;
		}

		.tg .tg-c6q4 {
			font-family: inherit;
			text-align: left;
			vertical-align: top
		}

		.tg .tg-1jcf {
			font-family: inherit;
			font-weight: bold;
			text-align: center;
			vertical-align: top
		}

		.tg .tg-u5z2 {
			font-family: inherit;
			text-align: center;
			vertical-align: top
		}

		.tg .tg-3xvn {
			font-family: inherit;
			font-weight: bold;
			text-align: left;
			vertical-align: top
		}

		.tg .tg-mpw7 {
			font-family: inherit;
			text-align: right;
			vertical-align: top
		}
	</style>
	<table class="tg" width="100%">
		<thead>
			<tr>
				<th class="tg-c6q4" colspan="2"></th>
				<th class="tg-u5z2" colspan="2"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Size keyshares(in bytes)</span></th>
				<th class="tg-u5z2" colspan="2"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Ops/sec (higher is better)</span></th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td class="tg-c6q4"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Algorithm</span></td>
				<td class="tg-u5z2"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">PQ</span></td>
				<td class="tg-1jcf"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Client</span></td>
				<td class="tg-1jcf"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Server</span></td>
				<td class="tg-1jcf"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Client</span></td>
				<td class="tg-1jcf"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Server</span></td>
			</tr>
			<tr>
				<td class="tg-3xvn"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Kyber512</span></td>
				<td class="tg-u5z2"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">✅</span></td>
				<td class="tg-mpw7"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">800</span></td>
				<td class="tg-mpw7"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">768</span></td>
				<td class="tg-mpw7"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">50,000</span></td>
				<td class="tg-mpw7"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">100,000</span></td>
			</tr>
			<tr>
				<td class="tg-3xvn"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">Kyber768</span></td>
				<td class="tg-u5z2"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">✅</span></td>
				<td class="tg-mpw7"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">1,184</span></td>
				<td class="tg-mpw7"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">1,088</span></td>
				<td class="tg-mpw7"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">31,000</span></td>
				<td class="tg-mpw7"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">70,000</span></td>
			</tr>
			<tr>
				<td class="tg-3xvn"><span style="font-weight:700;font-style:normal;text-decoration:none;color:#000;background-color:transparent">X25519</span></td>
				<td class="tg-u5z2"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">❌</span></td>
				<td class="tg-mpw7"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">32</span></td>
				<td class="tg-mpw7"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">32</span></td>
				<td class="tg-mpw7"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">17,000</span></td>
				<td class="tg-mpw7"><span style="font-weight:400;font-style:normal;text-decoration:none;color:#000;background-color:transparent">17,000</span></td>
			</tr>
		</tbody>
	</table><!--kg-card-end: html-->
	<p><i>Size and CPU performance compared between X25519 and Kyber. Performance varies considerably by hardware platform and implementation constraints and should be taken as a rough indication only.</i></p>
	<p>Kyber is expected to change in minor, but backwards incompatible ways, before final standardization by NIST in 2024. Also, the integration with TLS, including the choice and details of the hybrid key agreement, are not yet finalized by the TLS working group. Once they are, we will adopt them promptly.</p>
	<p>Because of this, we will not support the preliminary key agreements announced today for the long term; they’re provided as a beta service. We will post updates on our deployment on <a href="http://pq.cloudflareresearch.com">pq.cloudflareresearch.com</a> and announce it on the <a href="https://www.ietf.org/mailman/listinfo/Pqc">IETF PQC mailing list</a>.</p>
	<p>Now that we know how TLS negotiation works in theory, and which key agreements we’re adding, how could it fail?</p>
	<div class="flex anchor relative">
		<h2 id="where-things-might-break-in-practice">Where things might break in practice</h2>
		<a href="https://blog.cloudflare.com/#where-things-might-break-in-practice" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>

	<div class="flex anchor relative">
		<h3 id="protocol-ossification">Protocol ossification</h3>
		<a href="https://blog.cloudflare.com/#protocol-ossification" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Protocols are often designed with flexibility in mind, but if that flexibility is not exercised in practice, it’s often lost. This is called <i>protocol ossification</i>. The roll-out of TLS 1.3 <a href="https://blog.cloudflare.com/why-tls-1-3-isnt-in-browsers-yet">was difficult</a> because of several instances of ossification. One poignant example is TLS’ version negotiation: there is a version field in the ClientHello message that indicates the latest version supported by the client. A new version was assigned to TLS 1.3, but in testing it turned out that many servers would not fallback properly to TLS 1.2, but crash the connection instead. How do we deal with ossification?</p>
	<h4><b>Workaround</b></h4>
	<p>Today, TLS 1.3 masquerades itself as TLS 1.2 down to including many legacy fields in the <i>ClientHello</i>. The actual version negotiation is moved into a new <i>extension</i> to the message. A TLS 1.2 server will ignore the new extension and ignorantly continue with TLS 1.2, while a TLS 1.3 server picks up on the extension and continues with TLS 1.3 proper.</p>
	<h4><b>Protocol grease</b></h4>
	<p>How do we prevent ossification? Having learnt from this experience, browsers will regularly advertise dummy versions in this new version field, so that misbehaving servers are caught early on. This is not only done for the new version field, but in many other places in the TLS handshake, and presciently also for the key agreement identifiers. Today, 40% of browsers send two client keyshares: one X25519 and another a bogus 1-byte keyshare to keep key agreement flexibility.</p>
	<p>This behavior is standardized in <a href="https://datatracker.ietf.org/doc/html/rfc8701">RFC 8701</a>: <i>Generate Random Extensions And Sustain Extensibility</i> (GREASE) and we call it protocol <i>greasing</i>, as in “greasing the joints” from Adam Langley’s metaphor of <a href="https://www.imperialviolet.org/2016/05/16/agility.html">protocols having rusty joints</a> in need of oil.</p>
	<p>This keyshare grease helps, but it is not perfect, because it is the size of the keyshare that in this case causes the most concern.</p>
	<div class="flex anchor relative">
		<h3 id="fragmented-clienthello">Fragmented ClientHello</h3>
		<a href="https://blog.cloudflare.com/#fragmented-clienthello" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Post-quantum keyshares are big. The two Kyber hybrids are 832 and 1,216 bytes. Compared to that, X25519 is tiny with only 32 bytes. It is not unlikely that some implementations will fail when seeing such large keyshares.</p>
	<p>Our biggest concern is with the larger Kyber768 based keyshare. A ClientHello with the smaller 832 byte Kyber512-based keyshare will just barely fit in a typical network packet. On the other hand, the larger 1,216 byte Kyber768-keyshare will typically fragment the ClientHello into two packets.</p>
	<p>Assembling packets together isn’t free: it requires you to keep track of the partial messages around. Usually this is done transparently by the operating system’s TCP stack, but optimized middleboxes and load balancers that look at each packet separately, have to (and might not) keep track of the connections themselves.</p>
	<div class="flex anchor relative">
		<h3 id="quic">QUIC</h3>
		<a href="https://blog.cloudflare.com/#quic" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>The situation for <a href="https://www.cloudflare.com/learning/performance/what-is-http3">HTTP/3</a>, which is built on <a href="https://blog.cloudflare.com/quic-version-1-is-live-on-cloudflare">QUIC</a>, is particularly interesting. Instead of a simple port number chosen by the client (as in TCP), a QUIC packet from the client contains a <i>connection ID</i> that is chosen by the server. Think of it as “your reference” and “our reference” in snailmail. This allows a QUIC load-balancer to encode the particular machine handling the connection into the connection ID.</p>
	<p>When opening a connection, the QUIC client doesn’t know which connection ID the server would like and sends a random one instead. If the client needs multiple initial packets, such as with a big ClientHello, then the client will use the same random connection ID. Even though multiple initial packets are allowed by the QUIC standard, a QUIC load balancer might not expect this, and won’t be able to refer to an underlying TCP connection.</p>
	<div class="flex anchor relative">
		<h3 id="performance">Performance</h3>
		<a href="https://blog.cloudflare.com/#performance" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>Aside from these hard failures, <i>soft</i> failures, such as performance degradation are also of concern: if it’s too slow to load, a website might as well have been broken to begin with.</p>
	<p>Back in 2019 in a joint experiment with Google, we deployed two post-quantum key agreements: CECPQ2, based on NTRU-HRSS, and CECPQ2b, based on SIKE. NTRU-HRSS is very similar to Kyber: it’s a bit larger and slower. <a href="https://blog.cloudflare.com/the-tls-post-quantum-experiment">Results from 2019</a> are very promising: X25519+NTRU-HRSS (orange line) is hard to distinguish from X25519 on its own (blue line).</p>
	<figure class="kg-card kg-image-card kg-width-wide">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/3aqgMsHQUv4sMeIF3eHDOK/ac2d93d5156efd813d007997eb712c5f/image2-2.png" alt="Diagrams of performance of CECPQ2 based on NTRU-HRSS and CECPQ2b based on SIKE compared to X25519." class="kg-image" width="2000" height="1063" loading="lazy">

	</figure>
	<p>We will continue to keep a close eye on performance, especially on the tail performance: we want a smooth transition for everyone, from the fastest to the slowest clients on the Internet.</p>
	<div class="flex anchor relative">
		<h2 id="how-to-help-out">How to help out</h2>
		<a href="https://blog.cloudflare.com/#how-to-help-out" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>The Internet is a very heterogeneous system. To find all issues, we need sufficient numbers of diverse testers. We are working with browsers to add support for these key agreements, but there may not be one of these browsers in every network.</p>
	<p>So, to help the Internet out, try and switch a small part of your traffic to Cloudflare domains to use these new key agreement methods. We have open-sourced forks for <a href="https://github.com/cloudflare/boringssl-pq">BoringSSL</a>, <a href="https://github.com/cloudflare/go">Go</a> and <a href="https://github.com/cloudflare/qtls-pq">quic-go</a>. For BoringSSL and Go, check out <a href="https://blog.cloudflare.com/experiment-with-pq/#boringssl">the sample code here</a>. If you have any issues, please let us know at <a href="mailto:ask-research@cloudflare.com">ask-research@cloudflare.com</a>. We will be discussing any issues and workarounds at the IETF <a href="https://datatracker.ietf.org/group/tls/about">TLS working group</a>.</p>
	<div class="flex anchor relative">
		<h2 id="outlook">Outlook</h2>
		<a href="https://blog.cloudflare.com/#outlook" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>The transition to a post-quantum secure Internet is urgent, but not without challenges. Today we have deployed a preliminary post-quantum key agreement on all our servers — a sizable portion of the Internet — so that we can all start testing the big migration today. We hope that come 2024, when NIST puts a bow on Kyber, we will all have laid the groundwork for a smooth transition to a Post-Quantum Internet.</p>
	<p>.....</p>
	<p><sup>1</sup>We only support these post-quantum key agreements in protocols based on TLS 1.3 including HTTP/3. There is one exception: for the moment we disable these hybrid key exchanges for websites in FIPS-mode.</p>
</div>