{
	"initialReadingTime": "17",
	"locale": "en-us",
	"localesAvailable": [],
	"post": {
		"authors": [
			{
				"name": "Armando Faz-Hernández",
				"slug": "armfazh",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/1KZECWa5TCEPjjcRmbx9iT/078177db91eaccf0591ead7e387df80a/armfazh.png",
				"location": null,
				"website": "https://research.cloudflare.com/people/armando-faz/",
				"twitter": "@armfazh",
				"facebook": null
			},
			{
				"name": "Watson Ladd",
				"slug": "watson",
				"bio": null,
				"profile_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/35pgZVxqmPknW7wAv93BIs/f79b9bec0bdc5469e29cf5d01403840c/watson.jpg",
				"location": null,
				"website": "http://kc2kdm.com",
				"twitter": "@WatsonLadd",
				"facebook": null
			}
		],
		"excerpt": "Our Go cryptographic library CIRCL announces support for pairing-based cryptography.",
		"feature_image": "https://cf-assets.www.cloudflare.com/slt3lc6tev37/5Vj6dZxs0Zz0df6E3phZkN/8024abcdbde1b3c6c0b71427e22ca106/circl-pairings-update.png",
		"featured": false,
		"html": "\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/6LK9kez9THVLuJRXJ6R1EE/91170c506ae1067ec941e972cb1ffdb6/image4-15.png\" alt=\"CIRCL logo\" class=\"kg-image\" width=\"1999\" height=\"1125\" loading=\"lazy\"/>\n            \n            </figure><p>In 2019, we announced the release of <a href=\"https://github.com/cloudflare/circl/\">CIRCL</a>, an open-source cryptographic library written in Go that provides optimized implementations of several primitives for key exchange and digital signatures. We are pleased to announce a major update of our library: we have included more packages for elliptic curve-based cryptography (ECC), pairing-based cryptography, and quantum-resistant algorithms.</p><p>All of these packages are the foundation of work we’re doing on bringing the benefits of cutting edge research to Cloudflare. In the past we’ve <a href=\"/the-tls-post-quantum-experiment/\">experimented with post-quantum algorithms</a>, used pairings to keep <a href=\"/geo-key-manager-how-it-works/\">keys safe around the world</a>, and implemented <a href=\"/introducing-circl/\">advanced elliptic curves</a>. Now we’re continuing that work, and sharing the foundation with everyone.</p><p>In this blog post we’re going to focus on pairing-based cryptography and give you a brief overview of some properties that make this topic so pleasant. If you are not so familiar with elliptic curves, we recommend this <a href=\"/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/\">primer on ECC</a>.</p><p>Otherwise, let’s get ready, pairings have arrived!</p><p>What are pairings?</p><hr/><p>Elliptic curve cryptography enables an efficient instantiation of several cryptographic applications: public-key encryption, signatures, zero-knowledge proofs, and many other more exotic applications like <a href=\"https://en.wikipedia.org/wiki/Oblivious_transfer\">oblivious transfer</a> and <a href=\"https://datatracker.ietf.org/doc/draft-irtf-cfrg-voprf/\">OPRF</a>s. With all of those applications you might wonder what is the additional value that pairings offer? To see that, we need first to understand the basic properties of an elliptic curve system, and from that we can highlight the big gap that pairings have.</p><p>Conventional elliptic curve systems work with a single group \\( \\mathbb{G} \\): the points of an elliptic curve \\(E\\). In this group, usually denoted additively, we can add the points \\(P\\) and \\(Q\\) and get another point on the curve \\(R=P+Q\\); also, we can multiply a point \\(P\\) by an integer scalar \\(k\\) and by repeatedly doing$$ kP = \\underbrace{P+P+\\dots+P}_{k \\text{ terms}} $$This operation is known as scalar multiplication, which resembles exponentiation, and there are efficient algorithms for this operation. But given the point \\(Q=kP\\), and \\(P\\), it is very hard for an adversary that doesn’t know \\(k\\) to find it. This is the Elliptic Curve Discrete Logarithm problem (ECDLP).</p><p>Now we show a property of scalar multiplication that can help us to understand the properties of pairings.</p><p><b><i>Scalar Multiplication is a Linear Map</i></b></p><p>Note the following equivalences:</p><p>\\( (a+b)P = aP + bP \\)</p><p>\\( b (aP) = a (bP) \\).</p><p>These are very useful properties for many protocols: for example, the last identity allows Alice and Bob to arrive at the same value when following the Diffie-Hellman key-agreement protocol.</p><p>But while point addition and scalar multiplication are nice, it’s also useful to be able to multiply points: if we had a point \\(P\\) and \\(aP\\) and \\(bP\\), getting \\(abP\\) out would be very cool and let us do all sorts of things. Unfortunately Diffie-Hellman would immediately be insecure, so we can’t get what we want.</p><p>Guess what? Pairings provide an efficient, useful <i>sort of intermediary</i> point multiplication.</p><p>It’s intermediate multiplication because although the operation takes two points as operands, the result of a pairing is not a point, but an element of a different group; thus, in a pairing there are more groups involved and all of them must contain the same number of elements.</p><p>Pairing is defined as  $$ e \\colon\\; \\mathbb{G}_1 \\times \\mathbb{G}_2 \\rightarrow \\mathbb{G}_T $$Groups \\(\\mathbb{G}_1\\) and \\(\\mathbb{G}_2\\) contain points of an elliptic curve \\(E\\). More specifically, they are the \\(r\\)-torsion points, for a fixed prime \\(r\\). Some pairing instances fix \\(\\mathbb{G}_1=\\mathbb{G}_2\\), but it is common to use disjoint sets for efficiency reasons. The third group \\(\\mathbb{G}_T\\) has notable differences. First, it is written multiplicatively, unlike the other two groups. \\(\\mathbb{G}_T\\) is not the set of points on an elliptic curve. It’s instead a subgroup of the multiplicative group over some larger finite field. It contains the elements that satisfy \\(x^r=1\\), better known as the \\(r\\)-roots of unity.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/nmjAHa9jrnE1lnmilM8rR/92bd7ff7f34a0dc0191ee875f24b9015/2ai5WUAviNg3iAxw9x-IMAv3mVWnrMrDOgvJEIHsKqqNNn3OzQdeDJd6kMo578rqUTqoCPdQcFz6rcrTiXlyfdxL_iDLQ9v6zvswJiz5ini3lLgSMfHbFIpIEwS7.png\" alt=\"Image of a pairing acting on points.\" class=\"kg-image\" width=\"909\" height=\"378\" loading=\"lazy\"/>\n            \n            </figure><p>Source: “<i>Pairings are not dead, just resting</i>” by Diego Aranha <a href=\"https://ecc2017.cs.ru.nl/slides/ecc2017-aranha.pdf\">ECC-2017</a> (inspired by Avanzi’s talk at <a href=\"https://www.hyperelliptic.org/SPEED/slides09/avanzi.pdf\">SPEED-2009</a>).</p><p>While every elliptic curve has a pairing, very few have ones that are efficiently computable. Those that do, we call them <i>pairing-friendly curves</i>.</p><p><b>The Pairing Operation is a Bilinear Map</b></p><p>What makes pairings special is that \\(e\\) is a <i>bilinear map</i>. Yes, the linear property of the scalar multiplication is present twice, one per group. Let’s see the first linear map.</p><p>For points \\(P, Q, R\\) and scalars \\(a\\) and \\(b\\) we have:</p><p>\\( e(P+Q, R) = e(P, R) * e(Q, R) \\)</p><p>\\( e(aP, Q) = e(P, Q)^a \\).</p><p>So, a scalar \\(a\\) acting in the first operand as \\(aP\\), finds its way out and escapes from the input of the pairing and appears in the output of the pairing as an exponent in \\(\\mathbb{G}_T\\). The same linear map is observed for the second group:</p><p>\\( e(P, Q+R) = e(P, Q) * e(P, R) \\)</p><p>\\( e(P, bQ) = e(P, Q)^b \\).</p><p>Hence, the pairing is bilinear. We will see below how this property becomes useful.</p><p><b>Can bilinear pairings help solving ECDLP?</b></p><p>The <a href=\"https://www.dima.unige.it/~morafe/MaterialeCTC/p80-menezes.pdf\">MOV</a> (by Menezes, Okamoto, and Vanstone) attack reduces the discrete logarithm problem on elliptic curves to finite fields. An attacker with knowledge of \\(kP\\) and public points \\(P\\) and \\(Q\\) can recover \\(k\\) by computing:</p><p>\\( g = e(P, Q) \\),</p><p>\\( g_k = e(kP, Q) = e(P, Q)^k \\),</p><p>\\( k = \\log_g(g_k) = \\log_g(g^k) \\).</p><p>Note that the discrete logarithm to be solved was moved from \\(\\mathbb{G}_1\\) to \\(\\mathbb{G}_T\\). So an attacker must ensure that the discrete logarithm is easier to solve in \\(\\mathbb{G}_T\\), and surprisingly, for some curves this is the case.</p><p>Fortunately, pairings do not present a threat for standard curves (such as the NIST curves or Curve25519) because these curves are constructed in such a way that \\(\\mathbb{G}_T\\) gets very large, which makes the pairing operation not efficient anymore.</p><p>This attacking strategy was one of the first applications of pairings in cryptanalysis as a tool to solve the discrete logarithm. Later, more people noticed that the properties of pairings are so useful, and can be used constructively to do cryptography. One of the fascinating truisms of cryptography is that one person&#39;s sledgehammer is another person&#39;s brick: while pairings yield a generic attack strategy for the ECDLP problem, it can also be used as a building block in a ton of useful applications.</p><h3>Applications of Pairings</h3><p>In the 2000s decade, a large wave of research works were developed aimed at applying pairings to many practical problems. An iconic pairing-based system was created by Antoine Joux, who constructed a <a href=\"https://link.springer.com/chapter/10.1007/10722028_23\">one-round Diffie-Hellman</a> key exchange for three parties.</p><p>Let’s see first how a three-party Diffie-Hellman is done without pairings. Alice, Bob and Charlie want to agree on a shared key, so they compute, respectively, \\(aP\\), \\(bP\\) and \\(cP\\) for a public point P. Then, they send to each other the points they computed. So Alice receives \\(cP\\) from Charlie and sends \\(aP\\) to Bob, who can then send \\(baP\\) to Charlie and get \\(acP\\) from Alice and so on. After all this is done, they can all compute \\(k=abcP\\). Can this be performed in a single round trip?</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/1pGrpJQPbIktFdaxQz81fd/07f597903d2faf67bcb9c9a1b3c5444b/vnfAPEoM5vefRaP6wysBktjTyxvh4sxXzYY3HUz3ErengPo01exd3LDLZ38SQi_lYTKoJZQEPuvGYaLBE7Kg7ExNErj8Yu5k06klm8cQoXdwgtOZkDR3umqZWa6o.png\" alt=\"Two round Diffie-Hellman without pairings.\" class=\"kg-image\" width=\"538\" height=\"621\" loading=\"lazy\"/>\n            \n            </figure><p>Two round Diffie-Hellman without pairings.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/hIYImdhvrm8dbikA9HnOv/b4cb559cde4ea95bb86a8ec7c13a6dac/n8lyvbn43kHVis2z6mlUO5Msq5jVy2OixIA1xoZ9H3S0XZIczsdmnipD71gvvRDF6hZG10EWY0V803za-sihFWFMf32EF_0rRAlaA_zVXivOv0zYH1KOeMW4qZun.png\" alt=\"One round Diffie-Hellman with pairings.\" class=\"kg-image\" width=\"562\" height=\"550\" loading=\"lazy\"/>\n            \n            </figure><p>One round Diffie-Hellman with pairings.</p><p>The 3-party Diffie-Hellman protocol needs two communication rounds (on the top), but with the use of pairings a one-round trip protocol is possible.</p><p>Affirmative! Antoine Joux <a href=\"https://doi.org/10.1007/s00145-004-0312-y\">showed how</a> to agree on a shared secret in a single round of communication. Alice announces \\(aP\\), gets \\(bP\\) and \\(cP\\) from Bob and Charlie respectively, and then computes \\(k= (bP, cP)^a\\). Likewise Bob computes \\(e(aP,cP)^b\\) and Charlie does \\(e(aP,bP)^c\\). It’s not difficult to convince yourself that all these values are equivalent, just by looking at the bilinear property.</p><p>\\( e(bP,cP)^a  = e(aP,cP)^b  = e(aP,bP)^c = e(P,P)^{abc}\\)</p><p>With pairings we’ve done in one round what would otherwise take two.</p><p>Another application in cryptography addresses a problem posed by Shamir in 1984: does there exist an encryption scheme in which the public key is an arbitrary string? Imagine if your public key was your email address. It would be easy to remember and certificate authorities and certificate management would be unnecessary.</p><p>A solution to this problem came some years later, in 2001, and is the Identity-based Encryption (IBE) scheme proposed by <a href=\"https://crypto.stanford.edu/~dabo/papers/bfibe.pdf\">Boneh and Franklin</a>, which uses bilinear pairings as the main tool.</p><p>Nowadays, pairings are used for the <a href=\"https://eprint.iacr.org/2012/215\">zk-SNARKS</a> that make Zcash an anonymous currency, and are also used in <a href=\"https://developers.cloudflare.com/randomness-beacon/about\">drand</a> to generate public-verifiable randomness. Pairings and the compact, aggregatable BLS signatures are used in Ethereum. We have used pairings to build Geo Key Manager: pairings let us implement a compact broadcast and negative broadcast scheme that together make <a href=\"/geo-key-manager-how-it-works/\">Geo Key Manager</a> work.</p><p>In order to make these schemes, we have to implement pairings, and to do that we need to understand the mathematics behind them.</p><h3>Where do pairings come from?</h3><p>In order to deeply understand pairings we must understand the interplay of geometry and arithmetic, and the origins of the group’s law. The starting point is the concept of a <i>divisor</i>, a formal combination of points on the curve.</p><p>\\( D = \\sum n_i P_i \\)</p><p>The sum of all the coefficients \\(n_i\\) is the degree of the divisor. If we have a function on the curve that has poles and zeros, we can count them with multiplicity to get a <i>principal divisor</i>. Poles are counted as negative, while zeros as positive. For example if we take the projective line, the function \\(x\\) has the divisor \\((0)-(\\infty)\\).</p><p>The degree of a divisor is the sum of its coefficients. All principal divisors have degree equal to \\(0\\).  The group of degree zero divisors modulo the principal divisors is the Jacobian. This means that we take all the degree zero divisors, and freely add or subtract principle divisors, constructing an abelian variety called the Jacobian.</p><p>Until now our constructions have worked for any curve.  Elliptic curves have a special property: since a line intersects the curve in three points, it’s always possible to turn an element of the Jacobian into one of the form \\((P)-(O)\\) for a point \\(P\\). This is where the addition law of elliptic curves comes from.</p>\n            <figure class=\"kg-card kg-image-card \">\n            \n            <Image src=\"https://cf-assets.www.cloudflare.com/slt3lc6tev37/4eisQYqRXhDNLTdMbiFZRO/5632042cccb6348e1859b36d1c42e369/DZUPeC6dl9fx4W7ggusFvWzN6-zjcQAroZZAcu2BsDWuhOd1j9_YjfjyCpCI2jOwLi9IoCDgKSNEyb4Zc3q7cp5wVM6_gyNMBDHfttqQ_cTxedlMzBLS8EOb2miG.png\" alt=\"Intersection of an elliptic curve and a line.\" class=\"kg-image\" width=\"1360\" height=\"412\" loading=\"lazy\"/>\n            \n            </figure><p>The relation between addition on an elliptic curve and the geometry of the curve. Source file <a href=\"https://commons.wikimedia.org/wiki/File:ECClines.svg\">ECClines.svg</a></p><p>Given a function \\(f\\) we can evaluate it on a divisor \\(D=\\sum n_i P_i\\) by taking the product \\(\\prod f(P_i)^{n_i}\\). And if two functions \\(f\\) and \\(g\\) have disjoint divisors, we have the <i>Weil duality</i>:</p><p>\\( f(\\text{div}(g)) = g(\\text{div}(f)) \\),</p><p>The existence of Weil duality is what gives us the bilinear map we seek. Given an \\(r\\)-torsion point \\(T\\) we have a function \\(f\\) whose divisor is \\(r(T)-r(O)\\). We can write down an auxiliary function \\(g\\) such that \\(f(rP)=g^r(P)\\) for any \\(P\\). We then get a pairing by taking:</p><p>\\(e_r(S,T)=\\frac{g(X+S)}{g(X)}\\).</p><p>The auxiliary point \\(X\\) is any point that makes the numerator and denominator defined.</p><p>In practice, the pairing we have defined above, the Weil pairing, is little used. It was historically the first pairing and is extremely important in the mathematics of elliptic curves, but faster alternatives based on more complicated underlying mathematics are used today. These faster pairings have different \\(\\mathbb{G}_1\\) and \\(\\mathbb{G}_2\\), while the Weil pairing made them the same.</p><h3>Shift in parameters</h3><p>As we saw earlier, the discrete logarithm problem can be attacked either on the group of elliptic curve points or on the third group (an extension of a prime field) whichever is weaker. This is why the parameters that define a pairing must balance the security of the three groups.</p><p>Before 2015 a good balance between the extension degree, the size of the prime field, and the security of the scheme was achieved by the family of <a href=\"https://eprint.iacr.org/2005/133.pdf\">Barreto-Naehrig</a> (BN) curves. For 128 bits of security, BN curves use an extension of degree 12, and have a prime of size 256 bits; as a result they are an efficient choice for implementation.</p><p>A breakthrough for pairings occurred in 2015 when Kim and Barbescu <a href=\"https://ia.cr/2015/1027\">published a result</a> that accelerated the attacks in finite fields. This resulted in increasing the size of fields to comply with standard security levels. Just as short hashes like MD5 got depreciated as they became insecure and \\(2^{64}\\) was no longer enough, and RSA-1024 was replaced with RSA-2048, we regularly change parameters to deal with improved attacks.</p><p>For pairings this implied the use of larger primes for all the groups. Roughly speaking, the previous 192-bit security level becomes the new 128-bit level after this attack. Also, this shift in parameters brings the family of <a href=\"https://eprint.iacr.org/2002/088.pdf\">Barreto-Lynn-Scott</a> (BLS) curves to the stage because pairings on BLS curves are faster than BN in this new setting. Hence, currently BLS curves using an extension of degree 12, and primes of around 384 bits provide the equivalent to 128 bit security.</p><p>The IETF draft (currently in preparation) <a href=\"https://datatracker.ietf.org/doc/draft-irtf-cfrg-pairing-friendly-curves/\">draft-irtf-cfrg-pairing-friendly-curves</a> specifies secure pairing-friendly elliptic curves. It includes parameters for BN and BLS families of curves. It also targets different security levels to provide crypto agility for some applications relying on pairing-based cryptography.</p><h2>Implementing Pairings in Go</h2><p>Historically, notable examples of software libraries implementing pairings include <a href=\"https://crypto.stanford.edu/pbc/\">PBC</a> by Ben Lynn, <a href=\"https://github.com/miracl/core\">Miracl</a> by Michael Scott, and <a href=\"https://github.com/relic-toolkit/relic\">Relic</a> by Diego Aranha. All of them are written in C/C++ and some ports and wrappers to other languages exist.</p><p>In the Go standard library we can find the <a href=\"https://pkg.go.dev/golang.org/x/crypto/bn256\">golang.org/x/crypto/bn256</a> package by Adam Langley, an implementation of a pairing using a BN curve with 256-bit prime. Our colleague Brendan McMillion built <a href=\"https://github.com/cloudflare/bn256\">github.com/cloudflare/bn256</a> that dramatically improves the speed of pairing operations for that curve. See the <a href=\"https://youtu.be/eHqIq1kFJJo?t=791\">RWC-2018</a> talk to see our use case of pairing-based cryptography. This time we want to go one step further, and we started looking for alternative pairing implementations.</p><p>Although one can find many libraries that implement pairings, our goal is to rely on one that is efficient, includes protection against side channels, and exposes a flexible API oriented towards applications that permit generality, while avoiding common security pitfalls. This motivated us to include pairings in <a href=\"https://github.com/cloudflare/circl/tree/master/ecc/bls12381\">CIRCL</a>. We followed best practices on secure code development and we want to share with you some details about the implementation.</p><p>We started by choosing a pairing-friendly curve. Due to the attack previously mentioned, the BN256 curve does not meet the 128-bit security level. Thus there is a need for using stronger curves. Such a stronger curve is the <a href=\"https://electriccoin.co/blog/new-snark-curve/\">BLS12-381</a> curve that is widely used in the zk-SNARK protocols and short signature schemes. Using this curve allows us to make our Go pairing implementation interoperable with other implementations available in other programming languages, so other projects can benefit from using CIRCL too.</p><p>This code snippet tests the linearity property of pairings and shows how easy it is to use our library.</p><!--kg-card-begin: html--><!-- HTML generated using hilite.me --><div style=\"background: #f8f8f8; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;\"><pre style=\"margin: 0; line-height: 125%\"><span style=\"color: #008000; font-weight: bold\">import</span> (\n    <span style=\"color: #BA2121\">&quot;crypto/rand&quot;</span>\n    <span style=\"color: #BA2121\">&quot;fmt&quot;</span>\n    e <span style=\"color: #BA2121\">&quot;github.com/cloudflare/circl/ecc/bls12381&quot;</span>\n)\n\n<span style=\"color: #008000; font-weight: bold\">func</span> ExamplePairing() {\n    P,  Q <span style=\"color: #666666\">:=</span> e.G1Generator(), e.G2Generator()\n    a,  b <span style=\"color: #666666\">:=</span> <span style=\"color: #008000\">new</span>(e.Scalar), <span style=\"color: #008000\">new</span>(e.Scalar)\n    aP, bQ <span style=\"color: #666666\">:=</span> <span style=\"color: #008000\">new</span>(e.G1), <span style=\"color: #008000\">new</span>(e.G2)\n    ea, eb <span style=\"color: #666666\">:=</span> <span style=\"color: #008000\">new</span>(e.Gt), <span style=\"color: #008000\">new</span>(e.Gt)\n\n    a.Random(rand.Reader)\n    b.Random(rand.Reader)\n\n    aP.ScalarMult(a, P)\n    bQ.ScalarMult(b, Q)\n\n    g  <span style=\"color: #666666\">:=</span> e.Pair( P, Q)\n    ga <span style=\"color: #666666\">:=</span> e.Pair(aP, Q)\n    gb <span style=\"color: #666666\">:=</span> e.Pair( P,bQ)\n\n    ea.Exp(g, a)\n    eb.Exp(g, b)\n    linearLeft <span style=\"color: #666666\">:=</span> ea.IsEqual(ga) <span style=\"color: #408080; font-style: italic\">// e(P,Q)^a == e(aP,Q)</span>\n    linearRight<span style=\"color: #666666\">:=</span> eb.IsEqual(gb) <span style=\"color: #408080; font-style: italic\">// e(P,Q)^b == e(P,bQ)</span>\n\n    fmt.Print(linearLeft <span style=\"color: #666666\">&amp;&amp;</span> linearRight)\n    <span style=\"color: #408080; font-style: italic\">// Output: true</span>\n}\n</pre></div>\n<!--kg-card-end: html--><p>We applied several optimizations that allowed us to improve on performance and security of the implementation. In fact, as the parameters of the curve are fixed, some other optimizations become easier to apply; for example, the code for prime field arithmetic and the towering construction for extension fields as we detail next.</p><h3>Formally-verified arithmetic using fiat-crypto</h3><p>One of the more difficult parts of a cryptography library to implement correctly is the prime field arithmetic. Typically people specialize it for speed, but there are many tedious constraints on what the inputs to operations can be to ensure correctness. Vulnerabilities have happened when people get it wrong, across many libraries. However, this code is perfect for machines to write and check. One such tool is <a href=\"https://github.com/mit-plv/fiat-crypto\">fiat-crypto</a>.</p><p>Using fiat-crypto to generate the prime field arithmetic means that we have a formal verification that the code does what we need. The fiat-crypto tool is <a href=\"https://github.com/cloudflare/circl/blob/5115a7384c00c16f684872cd8019e82a7b385f30/ecc/bls12381/ff/gen.go\">invoked in this script</a>, and produces Go code for addition, subtraction, multiplication, and squaring over the 381-bit prime field used in the BLS12-381 curve. Other operations are not covered, but those are much easier to check and analyze by hand.</p><p>Another advantage is that it avoids relying on the generic <a href=\"https://golang.org/pkg/math/big/#Int\">big.Int</a> package, which is slow, frequently spills variables to the heap causing dynamic memory allocations, and most importantly, does not run in constant-time. Instead, the code produced is straight-line code, no branches at all, and relies on the <a href=\"https://golang.org/pkg/math/bits\">math/bits</a> package for accessing machine-level instructions. Automated code generation also means that it’s easier to apply new techniques to all primitives.</p><h3>Tower Field Arithmetic</h3><p>In addition to prime field arithmetic, say integers modulo a prime number p, a pairing also requires high-level arithmetic operations over extension fields.</p><p>To better understand what an extension field is, think of the analogous case of going from the reals to the complex numbers: the operations are referred as usual, there exist addition, multiplication and division \\((+, -, \\times, /)\\), however they are computed quite differently.</p><p>The complex numbers are a quadratic extension over the reals, so imagine a two-level house. The first floor is where the real numbers live, however, they cannot access the second floor by themselves. On the other hand, the complex numbers can access the entire house through the use of a staircase. The equation \\(f(x)=x^2+1\\) was not solvable over the reals, but is solvable over the complex numbers, since they have the number \\(i^2=1\\). And because they have the number \\(i\\), they also have to have numbers like \\(3i\\) and \\(5+i\\) that solve other equations that weren’t solvable over the reals either. This second story has given the roots of the polynomials a place to live.</p><p>Algebraically we can view the complex numbers as \\(\\mathbb{R}[x]/(x^2+1)\\), the space of polynomials where we consider \\(x^2=-1\\). Given a polynomial like \\(x^3+5x+1\\), we can turn it into \\(4x+1\\), which is another way of writing \\(1+4i\\). In this new field \\(x^2+1=0\\) holds automatically, and we have added both \\(x\\) as a root of the polynomial we picked. This process of writing down a field extension by adding a root of a polynomial works over any field, including finite fields.</p><p>Following this analogy, one can construct not a house but a tower, say a \\(k=12\\) floor building where the ground floor is the prime field \\(\\mathbb{F}_p\\). The reason to build such a large tower is because we want to host VIP guests: namely a group called \\(\\mu_r\\), <i>the</i> \\(r\\)<i>-roots of unity</i>. There are exactly \\(r\\) members and they behave as an (algebraic) group, i.e. for all \\(x,y \\in \\mu_r\\), it follows \\(x*y \\in \\mu_r\\) and \\(x^r = 1\\).</p><p>One particularity is that making operations on the top-floor can be costly. Assume that whenever an operation is needed in the top-floor, members who live on the main floor are required to provide their assistance. Hence an operation on the top-floor needs to go all the way down to the ground floor. For this reason, our tower needs more than a staircase, it needs an efficient way to move between the levels, something even better than an elevator.</p><p>What if we use portals? Imagine anyone on the twelfth floor using a portal to go down immediately to the sixth floor, and then use another one connecting the sixth to the second floor, and finally another portal connecting to the ground floor. Thus, one can get faster to the first floor rather than descending through a long staircase.</p><p>The building analogy can be used to understand and construct a tower of finite fields. We use only some extensions to build a twelfth extension from the (ground) prime field \\(\\mathbb{F}_p\\).</p><p>\\(\\mathbb{F}_{p}\\) ⇒  \\(\\mathbb{F}_{p^2}\\) ⇒  \\(\\mathbb{F}_{p^6}\\) ⇒  \\(\\mathbb{F}_{p^{12}}\\)</p><p>In fact, the extension of finite fields is as follows:</p><ul><li><p>\\(\\mathbb{F}_{p^2}\\) is built as polynomials in \\(\\mathbb{F}_p[u]\\) reduced modulo \\(u^2+1=0\\).</p></li><li><p>\\(\\mathbb{F}_{p^6}\\) is built as polynomials in \\(\\mathbb{F}_{p^2}[v]\\) reduced modulo \\(v^3+u+1=0\\).</p></li><li><p>\\(\\mathbb{F}_{p^{12}}\\) is built as polynomials in \\(\\mathbb{F}_{p^6}[w]\\) reduced modulo \\(w^2+v=0\\), or as polynomials in \\(\\mathbb{F}_{p^4}[w]\\) reduced modulo \\(w^3+v=0\\).</p></li></ul><p>The portals here are the polynomials used as modulus, as they allow us to move from one extension to the other.</p><p>Different constructions for higher extensions have an impact on the number of operations performed. Thus, we implemented the latter tower field for \\(\\mathbb{F}_{p^{12}}\\) as it results in a lower number of operations. The arithmetic operations are quite easy to implement and manually verify, so at this level formal verification is not as effective as in the case of prime field arithmetic. However, having an automated tool that generates code for this arithmetic would be useful for developers not familiar with the internals of field towering. The fiat-crypto tool keeps track of this idea [<a href=\"https://github.com/mit-plv/fiat-crypto/issues/904\">Issue 904</a>, <a href=\"https://github.com/mit-plv/fiat-crypto/issues/851\">Issue 851</a>].</p><p>Now, we describe more details about the main core operations of a bilinear pairing.</p><h3>The Miller loop and the final exponentiation</h3><p>The pairing function we implemented is the <a href=\"https://eprint.iacr.org/2008/096\">optimal r-ate</a> pairing, which is defined as:</p><p>\\( e(P,Q) = f_Q(P)^{\\text{exp}} \\)</p><p>That is the construction of a function \\(f\\) based on \\(Q\\), then evaluated on a point \\(P\\), and the result of that is raised to a specific power. The efficient function evaluation is performed using “the Miller loop”, which is an algorithm devised by <a href=\"https://crypto.stanford.edu/miller/miller.pdf\">Victor Miller</a> and has a similar structure to a double-and-add algorithm for scalar multiplication.</p><p>After having computed \\(f_Q(P)\\) this value is an element of \\(\\mathbb{F}_{p^{12}}\\), however it is not yet an \\(r\\)-root of unity; in order to do so, the final exponentiation accomplishes this task. Since the exponent is constant for each curve, special algorithms can be tuned for it.</p><p>One interesting acceleration opportunity presents itself: in the Miller loop the elements of \\(\\mathbb{F}_{p^{12}}\\) that we have to multiply by are special — as polynomials, they have no linear term and their constant term lives in \\(\\mathbb{F}_{p^{2}}\\). We created a specialized multiplication that avoids multiplications where the input has to be zero. This specialization accelerated the pairing computation by 12%.</p><p>So far, we have described how the internal operations of a pairing are performed. There are still some other functions floating around regarding the use of pairings in cryptographic protocols. It is also important to optimize these functions and now we will discuss some of them.</p><h3>Product of Pairings</h3><p>Often protocols will want to evaluate a product of pairings, rather than a single pairing. This is the case if we’re evaluating multiple signatures, or if the protocol uses cancellation between different equations to ensure security, as in the <i>dual system encoding</i> approach to designing protocols. If each pairing was evaluated individually, this would require multiple evaluations of the final exponentiation. However, we can evaluate the product first, and then evaluate the final exponentiation once. This requires a different interface that can take vectors of points.</p><p>Occasionally, there is a sign or an exponent in the factors of the product. It’s very easy to deal with a sign explicitly by negating one of the input points, almost for free. General exponents are more complicated, especially when considering the need for side channel protection. But since we expose the interface, later work on the library will accelerate it without changing applications.</p><p>Regarding API exposure, one of the trickiest and most error prone aspects of software engineering is input validation. So we must check that raw binary inputs decode correctly as the points used for a pairing. Part of this verification includes subgroup membership testing which is the topic we discuss next.</p><h3>Subgroup Membership Testing</h3><p>Checking that a point is on the curve is easy, but checking that it has the right order is not: the classical way to do this is an entire expensive scalar multiplication. But implementing pairings involves the use of many clever tricks that help to make things run faster.</p><p>One example is <i>twisting</i>: the \\(\\mathbb{G}_2\\) group are points with coordinates in \\(\\mathbb{F}_{p^{12}}\\), however, one can use a smaller field to reduce the number of operations. The trick here is using an associated curve \\(E’\\), which is a twist of the original curve \\(E\\). This allows us to work on the subfield \\(\\mathbb{F}_{p^{2}}\\) that has cheaper operations.</p><p>Additionally, twisting the curve over \\(\\mathbb{G}_2\\) carries some efficiently computable endomorphisms coming from the field structure. For the cost of two field multiplications, we can compute an additional endomorphism, dramatically decreasing the cost of scalar multiplication.</p><p>By searching for the smallest combination of scalars that could zero out the \\(r\\)-torsion points, <a href=\"https://eprint.iacr.org/2019/814\">Sean Bowe</a> came up with a much more efficient way to do subgroup checks. We implement his trick, with a big reduction in the complexity of some applications.</p><p>As can be seen, implementing a pairing is full of subtleties. We just saw that point validation in the pairing setting is a bit more challenging than in the conventional case of elliptic curve cryptography. This kind of reformulation also applies to other operations that require special care on their implementation. One another example is how to encode binary strings as elements of the group \\(\\mathbb{G}_1\\) (or \\(\\mathbb{G}_2\\)). Although this operation might sound simple, implementing it securely needs to take into consideration several aspects; thus we expand more on this topic.</p><h3>Hash to Curve</h3><p>An important piece on the <a href=\"https://crypto.stanford.edu/~dabo/papers/bfibe.pdf\">Boneh-Franklin</a> Identity-based Encryption scheme is a special hash function that maps an arbitrary string — the identity, e.g., an email address — to a point on an elliptic curve, and that still behaves as a conventional cryptographic hash function (such as SHA-256) that is hard to invert and collision-resistant. This operation is commonly known as <i>hashing to curve</i>.</p><p>Boneh and Franklin found a particular way to perform hashing to curve: apply a conventional hash function to the input bitstring, and interpret the result as the \\(y\\)-coordinate of a point, then from the curve equation \\(y^2=x^3+b\\), find the \\(x\\)-coordinate as \\(x=\\sqrt[3]{y^2-b}\\). The cubic root always exists on fields of characteristic \\(p\\equiv 2 \\bmod{3}\\). But this algorithm does not apply to other fields in general restricting the parameters to be used.</p><p>Another popular algorithm, but since now we need to remark it is an insecure way for performing hash to curve is the following. Let the hash of the input be the \\(x\\)-coordinate, and from it find the \\(y\\)-coordinate by computing a square root \\(y= \\sqrt{x^3+b}\\). Note that not all \\(x\\)-coordinates lead that the square root exists, which means the algorithm may fail; thus, it’s a probabilistic algorithm. To make sure it works always, a counter can be added to \\(x\\) and increased each time the square root is not found. Although this algorithm always finds a point on the curve, this also makes the algorithm run in variable time i.e., it&#39;s a non-constant time algorithm. The lack of this property on implementations of cryptographic algorithms makes them susceptible to timing attacks. The <a href=\"https://wpa3.mathyvanhoef.com/\">DragonBlood</a> attack is an example of how a non-constant time hashing algorithm resulted in a full key recovery of WPA3 Wi-Fi passwords.</p><p>Secure hash to curve algorithms must guarantee several properties. It must be ensured that any input passed to the hash produces a point on the targeted group. That is no special inputs must trigger exceptional cases, and the output point must belong to the <i>correct</i> group. We make emphasis on the correct group since in certain applications the target group is the entire set of points of an elliptic curve, but in other cases, such as in the pairing setting, the target group is a subgroup of the entire curve, recall that \\(\\mathbb{G}_1\\) and \\(\\mathbb{G}_2\\) are \\(r\\)-torsion points. Finally, some cryptographic protocols are proven secure provided that the hash to curve function behaves as a random oracle of points. This requirement adds another level of complexity to the hash to curve function.</p><p>Fortunately, several researchers have addressed most of these problems and some other researchers have been involved in efforts to define a concrete specification for secure algorithms for hashing to curves, by extending the sort of geometric trick that worked for the Boneh-Franklin curve. We have participated in the Crypto Forum Research Group (CFRG) at IETF on the work-in-progress Internet <a href=\"https://datatracker.ietf.org/doc/draft-irtf-cfrg-hash-to-curve/\">draft-irtf-cfrg-hash-to-curve</a>. This document specifies secure algorithms for hashing targeting several elliptic curves including the BLS12-381 curve. At Cloudflare, we are actively collaborating in several working groups of IETF, see Jonathan Hoyland’s <a href=\"/cloudflare-and-the-ietf\">post</a> to know more about it.</p><p>Our implementation complies with the recommendations given in the hash to curve draft and also includes many implementation techniques and tricks derived from a vast number of academic research articles in pairing-based cryptography. A good compilation of most of these tricks is delightfully explained by <a href=\"https://www.craigcostello.com.au/s/PairingsForBeginners.pdf\">Craig Costello</a>.</p><p>We hope this post helps you to shed some light and guidance on the development of pairing-based cryptography, as it has become much more relevant these days. We will share with you soon an interesting use case in which the application of pairing-based cryptography helps us to harden the security of our infrastructure.</p><h2>What’s next?</h2><p>We invite you to use our <a href=\"https://github.com/cloudflare/circl/\">CIRCL</a> library, now equipped with bilinear pairings. But there is more: look at other primitives already available such as <a href=\"https://github.com/cloudflare/circl/tree/master/hpke\">HPKE</a>, <a href=\"https://github.com/cloudflare/circl/tree/master/oprf\">VOPRF</a>, and <a href=\"https://github.com/cloudflare/circl/tree/master/kem\">Post-Quantum</a> algorithms. On our side, we will continue improving the performance and security of our library, and let us know if any of your projects uses CIRCL, we would like to know your use case. Reach us at <a href=\"https://research.cloudflare.com\">research.cloudflare.com</a>.</p><p>You’ll soon hear more about how we’re using CIRCL across Cloudflare.</p>",
		"id": "78HsUIApwC8CnQLeWxAi07",
		"localeList": {
			"name": "Pairings in CIRCL Config",
			"enUS": "English for Locale",
			"zhCN": "No Page for Locale",
			"zhHansCN": "No Page for Locale",
			"zhTW": "No Page for Locale",
			"frFR": "No Page for Locale",
			"deDE": "No Page for Locale",
			"itIT": "No Page for Locale",
			"jaJP": "No Page for Locale",
			"koKR": "No Page for Locale",
			"ptBR": "No Page for Locale",
			"esLA": "No Page for Locale",
			"esES": "No Page for Locale",
			"enAU": "No Page for Locale",
			"enCA": "No Page for Locale",
			"enIN": "No Page for Locale",
			"enGB": "No Page for Locale",
			"idID": "No Page for Locale",
			"ruRU": "No Page for Locale",
			"svSE": "No Page for Locale",
			"viVN": "No Page for Locale",
			"plPL": "No Page for Locale",
			"arAR": "No Page for Locale",
			"nlNL": "No Page for Locale",
			"thTH": "No Page for Locale",
			"trTR": "No Page for Locale",
			"heIL": "No Page for Locale",
			"lvLV": "No Page for Locale",
			"etEE": "No Page for Locale",
			"ltLT": "No Page for Locale"
		},
		"meta_description": "Our Go cryptographic library CIRCL announces support for pairing-based cryptography.",
		"metadata": {
			"imgPreview": ""
		},
		"primary_author": {},
		"published_at": "2021-10-13T13:59:30.000+01:00",
		"slug": "circl-pairings-update",
		"tags": [
			{
				"id": "1x7tpPmKIUCt19EDgM1Tsl",
				"name": "Research",
				"slug": "research"
			},
			{
				"id": "1QsJUMpv0QBSLiVZLLQJ3V",
				"name": "Cryptography",
				"slug": "cryptography"
			},
			{
				"id": "KDI5hQcs301H8vxpGKXO0",
				"name": "Go",
				"slug": "go"
			}
		],
		"title": "Pairings in CIRCL",
		"updated_at": "2024-08-27T01:43:04.725Z",
		"url": "https://blog.cloudflare.com/circl-pairings-update"
	},
	"translations": {
		"posts.by": "By",
		"footer.gdpr": "GDPR",
		"lang_blurb1": "This post is also available in {lang1}.",
		"lang_blurb2": "This post is also available in {lang1} and {lang2}.",
		"lang_blurb3": "This post is also available in {lang1}, {lang2} and {lang3}.",
		"footer.blurb": "Cloudflare's connectivity cloud protects <a target='_blank' href='https://www.cloudflare.com/network-services/' rel='noreferrer'>entire corporate networks</a>, helps customers build <a target='_blank' href='https://workers.cloudflare.com/' rel='noreferrer'>Internet-scale applications efficiently</a>, accelerates any <a target='_blank' href='https://www.cloudflare.com/performance/accelerate-internet-applications/' rel='noreferrer'>website or Internet application</a>, <a target='_blank' href='https://www.cloudflare.com/ddos/' rel='noreferrer'>wards off DDoS attacks</a>, keeps <a target='_blank' href='https://www.cloudflare.com/application-security/' rel='noreferrer'>hackers at bay</a>, and can help you on <a target='_blank' href='https://www.cloudflare.com/products/zero-trust/' rel='noreferrer'>your journey to Zero Trust</a>.<br/><br/>Visit <a target='_blank' href='https://one.one.one.one/' rel='noreferrer'>1.1.1.1</a> from any device to get started with our free app that makes your Internet faster and safer.<br/><br/>To learn more about our mission to help build a better Internet, <a target='_blank' href='https://www.cloudflare.com/learning/what-is-cloudflare/' rel='noreferrer'>start here</a>. If you&apos;re looking for a new career direction, check out <a target='_blank' href='http://www.cloudflare.com/careers' rel='noreferrer'>our open positions</a>.",
		"footer.press": "Press",
		"header.title": "The Cloudflare Blog",
		"footer.careers": "Careers",
		"footer.company": "Company",
		"footer.support": "Support",
		"footer.the_net": "theNet",
		"footer.our_team": "Our team",
		"footer.webinars": "Webinars",
		"page.more_posts": "More posts",
		"posts.time_read": "{time} min read",
		"footer.community": "Community",
		"footer.resources": "Resources",
		"footer.solutions": "Solutions",
		"footer.trademark": "Trademark",
		"header.subscribe": "Subscribe",
		"footer.compliance": "Compliance",
		"footer.free_plans": "Free plans",
		"footer.impact_ESG": "Impact/ESG",
		"posts.follow_on_X": "Follow on X",
		"footer.help_center": "Help center",
		"footer.network_map": "Network Map",
		"header.please_wait": "Please Wait",
		"page.related_posts": "Related posts",
		"footer.case_studies": "Case Studies",
		"footer.connect_2024": "Connect 2024",
		"footer.terms_of_use": "Terms of Use",
		"footer.white_papers": "White Papers",
		"footer.cloudflare_tv": "Cloudflare TV",
		"footer.community_hub": "Community Hub",
		"footer.compare_plans": "Compare plans",
		"footer.contact_sales": "Contact Sales",
		"header.contact_sales": "Contact Sales",
		"header.email_address": "Email Address",
		"page.error.not_found": "Page not found",
		"footer.developer_docs": "Developer docs",
		"footer.privacy_policy": "Privacy Policy",
		"footer.request_a_demo": "Request a demo",
		"page.continue_reading": "Continue reading",
		"footer.analysts_report": "Analyst reports",
		"footer.for_enterprises": "For enterprises",
		"footer.getting_started": "Getting Started",
		"footer.learning_center": "Learning Center",
		"footer.project_galileo": "Project Galileo",
		"pagination.newer_posts": "Newer Posts",
		"pagination.older_posts": "Older Posts",
		"posts.social_buttons.x": "Discuss on X",
		"footer.about_cloudflare": "About Cloudflare",
		"footer.athenian_project": "Athenian Project",
		"footer.become_a_partner": "Become a partner",
		"footer.cloudflare_radar": "Cloudflare Radar",
		"footer.network_services": "Network services",
		"footer.trust_and_safety": "Trust & Safety",
		"header.get_started_free": "Get Started Free",
		"page.search.placeholder": "Search Cloudflare",
		"footer.cloudflare_status": "Cloudflare Status",
		"footer.cookie_preference": "Cookie Preferences",
		"header.valid_email_error": "Must be valid email.",
		"footer.connectivity_cloud": "Connectivity cloud",
		"footer.developer_services": "Developer services",
		"footer.investor_relations": "Investor relations",
		"page.not_found.error_code": "Error Code: 404",
		"footer.logos_and_press_kit": "Logos & press kit",
		"footer.application_services": "Application services",
		"footer.get_a_recommendation": "Get a recommendation",
		"posts.social_buttons.reddit": "Discuss on Reddit",
		"footer.sse_and_sase_services": "SSE and SASE services",
		"page.not_found.outdated_link": "You may have used an outdated link, or you may have typed the address incorrectly.",
		"footer.report_security_issues": "Report Security Issues",
		"page.error.error_message_page": "Sorry, we can't find the page you are looking for.",
		"header.subscribe_notifications": "Subscribe to receive notifications of new posts:",
		"footer.cloudflare_for_campaigns": "Cloudflare for Campaigns",
		"header.subscription_confimation": "Subscription confirmed. Thank you for subscribing!",
		"posts.social_buttons.hackernews": "Discuss on Hacker News",
		"footer.diversity_equity_inclusion": "Diversity, equity & inclusion",
		"footer.critical_infrastructure_defense_project": "Critical Infrastructure Defense Project"
	}
}