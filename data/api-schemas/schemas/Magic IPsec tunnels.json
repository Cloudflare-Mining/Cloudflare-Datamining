{
	"DELETE /accounts/{account_id}/magic/ipsec_tunnels/{ipsec_tunnel_id}": {
		"description": "Disables and removes a specific static IPsec Tunnel associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.",
		"operationId": "magic-ipsec-tunnels-delete-ipsec-tunnel",
		"parameters": [
			{
				"in": "path",
				"name": "ipsec_tunnel_id",
				"required": true,
				"schema": {
					"description": "Identifier",
					"example": "023e105f4ecef8ad9ca31a8372d0c353",
					"maxLength": 32,
					"readOnly": true,
					"type": "string"
				}
			},
			{
				"in": "path",
				"name": "account_id",
				"required": true,
				"schema": {
					"description": "Identifier",
					"example": "023e105f4ecef8ad9ca31a8372d0c353",
					"maxLength": 32,
					"readOnly": true,
					"type": "string"
				}
			},
			{
				"description": "If true, the health check target in the response body will be presented using the new object format. Defaults to false.",
				"in": "header",
				"name": "x-magic-new-hc-target",
				"schema": {
					"type": "boolean"
				}
			}
		],
		"requestBody": {
			"content": {
				"application/json": {}
			},
			"required": true
		},
		"responses": {
			"200": {
				"content": {
					"application/json": {
						"schema": {
							"allOf": [
								{
									"allOf": [
										{
											"properties": {
												"errors": {
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												},
												"messages": {
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												},
												"result": {
													"anyOf": [
														{
															"type": "object"
														},
														{
															"items": {},
															"type": "array"
														},
														{
															"type": "string"
														}
													]
												},
												"success": {
													"description": "Whether the API call was successful",
													"enum": [
														true
													],
													"example": true,
													"type": "boolean"
												}
											},
											"required": [
												"success",
												"errors",
												"messages",
												"result"
											],
											"type": "object"
										},
										{
											"properties": {
												"result": {
													"anyOf": [
														{
															"nullable": true,
															"type": "object"
														},
														{
															"nullable": true,
															"type": "string"
														}
													]
												}
											}
										}
									],
									"type": "object"
								},
								{
									"properties": {
										"result": {
											"properties": {
												"deleted": {
													"example": true,
													"type": "boolean"
												},
												"deleted_ipsec_tunnel": {
													"properties": {
														"allow_null_cipher": {
															"description": "When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).",
															"example": true,
															"type": "boolean"
														},
														"automatic_return_routing": {
															"default": false,
															"description": "True if automatic stateful return routing should be enabled for a tunnel, false otherwise.",
															"example": true,
															"type": "boolean",
															"x-auditable": true
														},
														"bgp": {
															"properties": {
																"customer_asn": {
																	"description": "ASN used on the customer end of the BGP session",
																	"format": "int32",
																	"minimum": 0,
																	"type": "integer"
																},
																"extra_prefixes": {
																	"description": "Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.",
																	"items": {
																		"format": "cidr",
																		"type": "string"
																	},
																	"type": "array"
																},
																"md5_key": {
																	"description": "MD5 key to use for session authentication.\n\nNote that *this is not a security measure*. MD5 is not a valid security mechanism, and the\nkey is not treated as a secret value. This is *only* supported for preventing\nmisconfiguration, not for defending against malicious attacks.\n\nThe MD5 key, if set, must be of non-zero length and consist only of the following types of\ncharacter:\n\n* ASCII alphanumerics: `[a-zA-Z0-9]`\n* Special characters in the set `'!@#$%^&*()+[]{}<>/.,;:_-~`= \\|`\n\nIn other words, MD5 keys may contain any printable ASCII character aside from newline (0x0A),\nquotation mark (`\"`), vertical tab (0x0B), carriage return (0x0D), tab (0x09), form feed\n(0x0C), and the question mark (`?`). Requests specifying an MD5 key with one or more of\nthese disallowed characters will be rejected.",
																	"type": "string"
																}
															},
															"required": [
																"customer_asn"
															],
															"type": "object"
														},
														"bgp_status": {
															"properties": {
																"bgp_state": {
																	"type": "string"
																},
																"cf_speaker_ip": {
																	"format": "ipv4",
																	"type": "string"
																},
																"cf_speaker_port": {
																	"maximum": 65535,
																	"minimum": 1,
																	"type": "integer"
																},
																"customer_speaker_ip": {
																	"format": "ipv4",
																	"type": "string"
																},
																"customer_speaker_port": {
																	"maximum": 65535,
																	"minimum": 1,
																	"type": "integer"
																},
																"state": {
																	"enum": [
																		"BGP_DOWN",
																		"BGP_UP",
																		"BGP_ESTABLISHING"
																	],
																	"type": "string"
																},
																"tcp_established": {
																	"type": "boolean"
																},
																"updated_at": {
																	"format": "date-time",
																	"type": "string"
																}
															},
															"required": [
																"state",
																"tcp_established",
																"updated_at"
															],
															"type": "object"
														},
														"cloudflare_endpoint": {
															"description": "The IP address assigned to the Cloudflare side of the IPsec tunnel.",
															"example": "203.0.113.1",
															"type": "string"
														},
														"created_on": {
															"description": "The date and time the tunnel was created.",
															"example": "2017-06-14T00:00:00Z",
															"format": "date-time",
															"readOnly": true,
															"type": "string",
															"x-auditable": true
														},
														"custom_remote_identities": {
															"properties": {
																"fqdn_id": {
																	"description": "A custom IKE ID of type FQDN that may be used to identity the IPsec tunnel. The\ngenerated IKE IDs can still be used even if this custom value is specified.\n\nMust be of the form `<custom label>.<account ID>.custom.ipsec.cloudflare.com`.\n\nThis custom ID does not need to be unique. Two IPsec tunnels may have the same custom \nfqdn_id. However, if another IPsec tunnel has the same value then the two tunnels \ncannot have the same cloudflare_endpoint.",
																	"type": "string"
																}
															},
															"type": "object"
														},
														"customer_endpoint": {
															"description": "The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.",
															"example": "203.0.113.1",
															"type": "string"
														},
														"description": {
															"description": "An optional description forthe IPsec tunnel.",
															"example": "Tunnel for ISP X",
															"type": "string"
														},
														"health_check": {
															"allOf": [
																{
																	"properties": {
																		"enabled": {
																			"default": true,
																			"description": "Determines whether to run healthchecks for a tunnel.",
																			"example": true,
																			"type": "boolean",
																			"x-auditable": true
																		},
																		"rate": {
																			"default": "mid",
																			"description": "How frequent the health check is run. The default value is `mid`.",
																			"enum": [
																				"low",
																				"mid",
																				"high"
																			],
																			"example": "low",
																			"type": "string",
																			"x-auditable": true
																		},
																		"target": {
																			"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.",
																			"oneOf": [
																				{
																					"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target.",
																					"properties": {
																						"effective": {
																							"description": "The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.",
																							"example": "203.0.113.1",
																							"readOnly": true,
																							"type": "string",
																							"x-auditable": true
																						},
																						"saved": {
																							"description": "The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.",
																							"example": "203.0.113.1",
																							"type": "string",
																							"x-auditable": true
																						}
																					},
																					"type": "object"
																				},
																				{
																					"type": "string"
																				}
																			]
																		},
																		"type": {
																			"default": "reply",
																			"description": "The type of healthcheck to run, reply or request. The default value is `reply`.",
																			"enum": [
																				"reply",
																				"request"
																			],
																			"example": "request",
																			"type": "string",
																			"x-auditable": true
																		}
																	},
																	"type": "object"
																},
																{
																	"properties": {
																		"direction": {
																			"default": "unidirectional",
																			"description": "The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.",
																			"enum": [
																				"unidirectional",
																				"bidirectional"
																			],
																			"example": "bidirectional",
																			"type": "string"
																		}
																	}
																}
															]
														},
														"id": {
															"description": "Identifier",
															"example": "c4a7362d577a6c3019a474fd6f485821",
															"maxLength": 32,
															"readOnly": true,
															"type": "string",
															"x-auditable": true
														},
														"interface_address": {
															"description": "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.",
															"example": "192.0.2.0/31",
															"type": "string",
															"x-auditable": true
														},
														"interface_address6": {
															"description": "A 127 bit IPV6 prefix from within the virtual_subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual_subnet6. Eg if virtual_subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface_address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127",
															"example": "2606:54c1:7:0:a9fe:12d2:1:200/127",
															"type": "string",
															"x-auditable": true
														},
														"modified_on": {
															"description": "The date and time the tunnel was last modified.",
															"example": "2017-06-14T05:20:00Z",
															"format": "date-time",
															"readOnly": true,
															"type": "string",
															"x-auditable": true
														},
														"name": {
															"description": "The name of the IPsec tunnel. The name cannot share a name with other tunnels.",
															"example": "IPsec_1",
															"type": "string"
														},
														"psk_metadata": {
															"description": "The PSK metadata that includes when the PSK was generated.",
															"properties": {
																"last_generated_on": {
																	"description": "The date and time the tunnel was last modified.",
																	"example": "2017-06-14T05:20:00Z",
																	"format": "date-time",
																	"readOnly": true,
																	"type": "string",
																	"x-auditable": true
																}
															},
															"type": "object"
														},
														"replay_protection": {
															"default": false,
															"description": "If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.",
															"example": false,
															"type": "boolean"
														}
													},
													"required": [
														"id",
														"name",
														"cloudflare_endpoint",
														"interface_address"
													],
													"type": "object"
												}
											},
											"type": "object"
										}
									}
								}
							]
						}
					}
				},
				"description": "Delete IPsec Tunnel response"
			},
			"4XX": {
				"content": {
					"application/json": {
						"schema": {
							"allOf": [
								{
									"allOf": [
										{
											"allOf": [
												{
													"properties": {
														"errors": {
															"example": [],
															"items": {
																"properties": {
																	"code": {
																		"minimum": 1000,
																		"type": "integer"
																	},
																	"message": {
																		"type": "string"
																	}
																},
																"required": [
																	"code",
																	"message"
																],
																"type": "object",
																"uniqueItems": true
															},
															"type": "array"
														},
														"messages": {
															"example": [],
															"items": {
																"properties": {
																	"code": {
																		"minimum": 1000,
																		"type": "integer"
																	},
																	"message": {
																		"type": "string"
																	}
																},
																"required": [
																	"code",
																	"message"
																],
																"type": "object",
																"uniqueItems": true
															},
															"type": "array"
														},
														"result": {
															"anyOf": [
																{
																	"type": "object"
																},
																{
																	"items": {},
																	"type": "array"
																},
																{
																	"type": "string"
																}
															]
														},
														"success": {
															"description": "Whether the API call was successful",
															"enum": [
																true
															],
															"example": true,
															"type": "boolean"
														}
													},
													"required": [
														"success",
														"errors",
														"messages",
														"result"
													],
													"type": "object"
												},
												{
													"properties": {
														"result": {
															"anyOf": [
																{
																	"nullable": true,
																	"type": "object"
																},
																{
																	"nullable": true,
																	"type": "string"
																}
															]
														}
													}
												}
											],
											"type": "object"
										},
										{
											"properties": {
												"result": {
													"properties": {
														"deleted": {
															"example": true,
															"type": "boolean"
														},
														"deleted_ipsec_tunnel": {
															"properties": {
																"allow_null_cipher": {
																	"description": "When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).",
																	"example": true,
																	"type": "boolean"
																},
																"automatic_return_routing": {
																	"default": false,
																	"description": "True if automatic stateful return routing should be enabled for a tunnel, false otherwise.",
																	"example": true,
																	"type": "boolean",
																	"x-auditable": true
																},
																"bgp": {
																	"properties": {
																		"customer_asn": {
																			"description": "ASN used on the customer end of the BGP session",
																			"format": "int32",
																			"minimum": 0,
																			"type": "integer"
																		},
																		"extra_prefixes": {
																			"description": "Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.",
																			"items": {
																				"format": "cidr",
																				"type": "string"
																			},
																			"type": "array"
																		},
																		"md5_key": {
																			"description": "MD5 key to use for session authentication.\n\nNote that *this is not a security measure*. MD5 is not a valid security mechanism, and the\nkey is not treated as a secret value. This is *only* supported for preventing\nmisconfiguration, not for defending against malicious attacks.\n\nThe MD5 key, if set, must be of non-zero length and consist only of the following types of\ncharacter:\n\n* ASCII alphanumerics: `[a-zA-Z0-9]`\n* Special characters in the set `'!@#$%^&*()+[]{}<>/.,;:_-~`= \\|`\n\nIn other words, MD5 keys may contain any printable ASCII character aside from newline (0x0A),\nquotation mark (`\"`), vertical tab (0x0B), carriage return (0x0D), tab (0x09), form feed\n(0x0C), and the question mark (`?`). Requests specifying an MD5 key with one or more of\nthese disallowed characters will be rejected.",
																			"type": "string"
																		}
																	},
																	"required": [
																		"customer_asn"
																	],
																	"type": "object"
																},
																"bgp_status": {
																	"properties": {
																		"bgp_state": {
																			"type": "string"
																		},
																		"cf_speaker_ip": {
																			"format": "ipv4",
																			"type": "string"
																		},
																		"cf_speaker_port": {
																			"maximum": 65535,
																			"minimum": 1,
																			"type": "integer"
																		},
																		"customer_speaker_ip": {
																			"format": "ipv4",
																			"type": "string"
																		},
																		"customer_speaker_port": {
																			"maximum": 65535,
																			"minimum": 1,
																			"type": "integer"
																		},
																		"state": {
																			"enum": [
																				"BGP_DOWN",
																				"BGP_UP",
																				"BGP_ESTABLISHING"
																			],
																			"type": "string"
																		},
																		"tcp_established": {
																			"type": "boolean"
																		},
																		"updated_at": {
																			"format": "date-time",
																			"type": "string"
																		}
																	},
																	"required": [
																		"state",
																		"tcp_established",
																		"updated_at"
																	],
																	"type": "object"
																},
																"cloudflare_endpoint": {
																	"description": "The IP address assigned to the Cloudflare side of the IPsec tunnel.",
																	"example": "203.0.113.1",
																	"type": "string"
																},
																"created_on": {
																	"description": "The date and time the tunnel was created.",
																	"example": "2017-06-14T00:00:00Z",
																	"format": "date-time",
																	"readOnly": true,
																	"type": "string",
																	"x-auditable": true
																},
																"custom_remote_identities": {
																	"properties": {
																		"fqdn_id": {
																			"description": "A custom IKE ID of type FQDN that may be used to identity the IPsec tunnel. The\ngenerated IKE IDs can still be used even if this custom value is specified.\n\nMust be of the form `<custom label>.<account ID>.custom.ipsec.cloudflare.com`.\n\nThis custom ID does not need to be unique. Two IPsec tunnels may have the same custom \nfqdn_id. However, if another IPsec tunnel has the same value then the two tunnels \ncannot have the same cloudflare_endpoint.",
																			"type": "string"
																		}
																	},
																	"type": "object"
																},
																"customer_endpoint": {
																	"description": "The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.",
																	"example": "203.0.113.1",
																	"type": "string"
																},
																"description": {
																	"description": "An optional description forthe IPsec tunnel.",
																	"example": "Tunnel for ISP X",
																	"type": "string"
																},
																"health_check": {
																	"allOf": [
																		{
																			"properties": {
																				"enabled": {
																					"default": true,
																					"description": "Determines whether to run healthchecks for a tunnel.",
																					"example": true,
																					"type": "boolean",
																					"x-auditable": true
																				},
																				"rate": {
																					"default": "mid",
																					"description": "How frequent the health check is run. The default value is `mid`.",
																					"enum": [
																						"low",
																						"mid",
																						"high"
																					],
																					"example": "low",
																					"type": "string",
																					"x-auditable": true
																				},
																				"target": {
																					"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.",
																					"oneOf": [
																						{
																							"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target.",
																							"properties": {
																								"effective": {
																									"description": "The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.",
																									"example": "203.0.113.1",
																									"readOnly": true,
																									"type": "string",
																									"x-auditable": true
																								},
																								"saved": {
																									"description": "The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.",
																									"example": "203.0.113.1",
																									"type": "string",
																									"x-auditable": true
																								}
																							},
																							"type": "object"
																						},
																						{
																							"type": "string"
																						}
																					]
																				},
																				"type": {
																					"default": "reply",
																					"description": "The type of healthcheck to run, reply or request. The default value is `reply`.",
																					"enum": [
																						"reply",
																						"request"
																					],
																					"example": "request",
																					"type": "string",
																					"x-auditable": true
																				}
																			},
																			"type": "object"
																		},
																		{
																			"properties": {
																				"direction": {
																					"default": "unidirectional",
																					"description": "The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.",
																					"enum": [
																						"unidirectional",
																						"bidirectional"
																					],
																					"example": "bidirectional",
																					"type": "string"
																				}
																			}
																		}
																	]
																},
																"id": {
																	"description": "Identifier",
																	"example": "c4a7362d577a6c3019a474fd6f485821",
																	"maxLength": 32,
																	"readOnly": true,
																	"type": "string",
																	"x-auditable": true
																},
																"interface_address": {
																	"description": "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.",
																	"example": "192.0.2.0/31",
																	"type": "string",
																	"x-auditable": true
																},
																"interface_address6": {
																	"description": "A 127 bit IPV6 prefix from within the virtual_subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual_subnet6. Eg if virtual_subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface_address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127",
																	"example": "2606:54c1:7:0:a9fe:12d2:1:200/127",
																	"type": "string",
																	"x-auditable": true
																},
																"modified_on": {
																	"description": "The date and time the tunnel was last modified.",
																	"example": "2017-06-14T05:20:00Z",
																	"format": "date-time",
																	"readOnly": true,
																	"type": "string",
																	"x-auditable": true
																},
																"name": {
																	"description": "The name of the IPsec tunnel. The name cannot share a name with other tunnels.",
																	"example": "IPsec_1",
																	"type": "string"
																},
																"psk_metadata": {
																	"description": "The PSK metadata that includes when the PSK was generated.",
																	"properties": {
																		"last_generated_on": {
																			"description": "The date and time the tunnel was last modified.",
																			"example": "2017-06-14T05:20:00Z",
																			"format": "date-time",
																			"readOnly": true,
																			"type": "string",
																			"x-auditable": true
																		}
																	},
																	"type": "object"
																},
																"replay_protection": {
																	"default": false,
																	"description": "If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.",
																	"example": false,
																	"type": "boolean"
																}
															},
															"required": [
																"id",
																"name",
																"cloudflare_endpoint",
																"interface_address"
															],
															"type": "object"
														}
													},
													"type": "object"
												}
											}
										}
									]
								},
								{
									"properties": {
										"errors": {
											"allOf": [
												{
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												}
											],
											"example": [
												{
													"code": 7003,
													"message": "No route for the URI"
												}
											],
											"minLength": 1
										},
										"messages": {
											"allOf": [
												{
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												}
											],
											"example": []
										},
										"result": {
											"enum": [
												null
											],
											"nullable": true,
											"type": "object"
										},
										"success": {
											"description": "Whether the API call was successful",
											"enum": [
												false
											],
											"example": false,
											"type": "boolean"
										}
									},
									"required": [
										"success",
										"errors",
										"messages",
										"result"
									],
									"type": "object"
								}
							]
						}
					}
				},
				"description": "Delete IPsec Tunnel response failure"
			}
		},
		"security": [
			{
				"api_email": [],
				"api_key": [],
				"api_token": []
			}
		],
		"summary": "Delete IPsec Tunnel",
		"tags": [
			"Magic IPsec tunnels"
		],
		"x-api-token-group": [
			"Magic WAN Write",
			"Magic Transit Write"
		],
		"x-cfPlanAvailability": {
			"business": false,
			"enterprise": true,
			"free": false,
			"pro": false
		}
	},
	"GET /accounts/{account_id}/magic/ipsec_tunnels": {
		"description": "Lists IPsec tunnels associated with an account.",
		"operationId": "magic-ipsec-tunnels-list-ipsec-tunnels",
		"parameters": [
			{
				"in": "path",
				"name": "account_id",
				"required": true,
				"schema": {
					"description": "Identifier",
					"example": "023e105f4ecef8ad9ca31a8372d0c353",
					"maxLength": 32,
					"readOnly": true,
					"type": "string"
				}
			},
			{
				"description": "If true, the health check target in the response body will be presented using the new object format. Defaults to false.",
				"in": "header",
				"name": "x-magic-new-hc-target",
				"schema": {
					"type": "boolean"
				}
			}
		],
		"responses": {
			"200": {
				"content": {
					"application/json": {
						"schema": {
							"allOf": [
								{
									"allOf": [
										{
											"properties": {
												"errors": {
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												},
												"messages": {
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												},
												"result": {
													"anyOf": [
														{
															"type": "object"
														},
														{
															"items": {},
															"type": "array"
														},
														{
															"type": "string"
														}
													]
												},
												"success": {
													"description": "Whether the API call was successful",
													"enum": [
														true
													],
													"example": true,
													"type": "boolean"
												}
											},
											"required": [
												"success",
												"errors",
												"messages",
												"result"
											],
											"type": "object"
										},
										{
											"properties": {
												"result": {
													"anyOf": [
														{
															"nullable": true,
															"type": "object"
														},
														{
															"nullable": true,
															"type": "string"
														}
													]
												}
											}
										}
									],
									"type": "object"
								},
								{
									"properties": {
										"result": {
											"properties": {
												"ipsec_tunnels": {
													"items": {
														"properties": {
															"allow_null_cipher": {
																"description": "When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).",
																"example": true,
																"type": "boolean"
															},
															"automatic_return_routing": {
																"default": false,
																"description": "True if automatic stateful return routing should be enabled for a tunnel, false otherwise.",
																"example": true,
																"type": "boolean",
																"x-auditable": true
															},
															"bgp": {
																"properties": {
																	"customer_asn": {
																		"description": "ASN used on the customer end of the BGP session",
																		"format": "int32",
																		"minimum": 0,
																		"type": "integer"
																	},
																	"extra_prefixes": {
																		"description": "Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.",
																		"items": {
																			"format": "cidr",
																			"type": "string"
																		},
																		"type": "array"
																	},
																	"md5_key": {
																		"description": "MD5 key to use for session authentication.\n\nNote that *this is not a security measure*. MD5 is not a valid security mechanism, and the\nkey is not treated as a secret value. This is *only* supported for preventing\nmisconfiguration, not for defending against malicious attacks.\n\nThe MD5 key, if set, must be of non-zero length and consist only of the following types of\ncharacter:\n\n* ASCII alphanumerics: `[a-zA-Z0-9]`\n* Special characters in the set `'!@#$%^&*()+[]{}<>/.,;:_-~`= \\|`\n\nIn other words, MD5 keys may contain any printable ASCII character aside from newline (0x0A),\nquotation mark (`\"`), vertical tab (0x0B), carriage return (0x0D), tab (0x09), form feed\n(0x0C), and the question mark (`?`). Requests specifying an MD5 key with one or more of\nthese disallowed characters will be rejected.",
																		"type": "string"
																	}
																},
																"required": [
																	"customer_asn"
																],
																"type": "object"
															},
															"bgp_status": {
																"properties": {
																	"bgp_state": {
																		"type": "string"
																	},
																	"cf_speaker_ip": {
																		"format": "ipv4",
																		"type": "string"
																	},
																	"cf_speaker_port": {
																		"maximum": 65535,
																		"minimum": 1,
																		"type": "integer"
																	},
																	"customer_speaker_ip": {
																		"format": "ipv4",
																		"type": "string"
																	},
																	"customer_speaker_port": {
																		"maximum": 65535,
																		"minimum": 1,
																		"type": "integer"
																	},
																	"state": {
																		"enum": [
																			"BGP_DOWN",
																			"BGP_UP",
																			"BGP_ESTABLISHING"
																		],
																		"type": "string"
																	},
																	"tcp_established": {
																		"type": "boolean"
																	},
																	"updated_at": {
																		"format": "date-time",
																		"type": "string"
																	}
																},
																"required": [
																	"state",
																	"tcp_established",
																	"updated_at"
																],
																"type": "object"
															},
															"cloudflare_endpoint": {
																"description": "The IP address assigned to the Cloudflare side of the IPsec tunnel.",
																"example": "203.0.113.1",
																"type": "string"
															},
															"created_on": {
																"description": "The date and time the tunnel was created.",
																"example": "2017-06-14T00:00:00Z",
																"format": "date-time",
																"readOnly": true,
																"type": "string",
																"x-auditable": true
															},
															"custom_remote_identities": {
																"properties": {
																	"fqdn_id": {
																		"description": "A custom IKE ID of type FQDN that may be used to identity the IPsec tunnel. The\ngenerated IKE IDs can still be used even if this custom value is specified.\n\nMust be of the form `<custom label>.<account ID>.custom.ipsec.cloudflare.com`.\n\nThis custom ID does not need to be unique. Two IPsec tunnels may have the same custom \nfqdn_id. However, if another IPsec tunnel has the same value then the two tunnels \ncannot have the same cloudflare_endpoint.",
																		"type": "string"
																	}
																},
																"type": "object"
															},
															"customer_endpoint": {
																"description": "The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.",
																"example": "203.0.113.1",
																"type": "string"
															},
															"description": {
																"description": "An optional description forthe IPsec tunnel.",
																"example": "Tunnel for ISP X",
																"type": "string"
															},
															"health_check": {
																"allOf": [
																	{
																		"properties": {
																			"enabled": {
																				"default": true,
																				"description": "Determines whether to run healthchecks for a tunnel.",
																				"example": true,
																				"type": "boolean",
																				"x-auditable": true
																			},
																			"rate": {
																				"default": "mid",
																				"description": "How frequent the health check is run. The default value is `mid`.",
																				"enum": [
																					"low",
																					"mid",
																					"high"
																				],
																				"example": "low",
																				"type": "string",
																				"x-auditable": true
																			},
																			"target": {
																				"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.",
																				"oneOf": [
																					{
																						"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target.",
																						"properties": {
																							"effective": {
																								"description": "The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.",
																								"example": "203.0.113.1",
																								"readOnly": true,
																								"type": "string",
																								"x-auditable": true
																							},
																							"saved": {
																								"description": "The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.",
																								"example": "203.0.113.1",
																								"type": "string",
																								"x-auditable": true
																							}
																						},
																						"type": "object"
																					},
																					{
																						"type": "string"
																					}
																				]
																			},
																			"type": {
																				"default": "reply",
																				"description": "The type of healthcheck to run, reply or request. The default value is `reply`.",
																				"enum": [
																					"reply",
																					"request"
																				],
																				"example": "request",
																				"type": "string",
																				"x-auditable": true
																			}
																		},
																		"type": "object"
																	},
																	{
																		"properties": {
																			"direction": {
																				"default": "unidirectional",
																				"description": "The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.",
																				"enum": [
																					"unidirectional",
																					"bidirectional"
																				],
																				"example": "bidirectional",
																				"type": "string"
																			}
																		}
																	}
																]
															},
															"id": {
																"description": "Identifier",
																"example": "c4a7362d577a6c3019a474fd6f485821",
																"maxLength": 32,
																"readOnly": true,
																"type": "string",
																"x-auditable": true
															},
															"interface_address": {
																"description": "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.",
																"example": "192.0.2.0/31",
																"type": "string",
																"x-auditable": true
															},
															"interface_address6": {
																"description": "A 127 bit IPV6 prefix from within the virtual_subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual_subnet6. Eg if virtual_subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface_address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127",
																"example": "2606:54c1:7:0:a9fe:12d2:1:200/127",
																"type": "string",
																"x-auditable": true
															},
															"modified_on": {
																"description": "The date and time the tunnel was last modified.",
																"example": "2017-06-14T05:20:00Z",
																"format": "date-time",
																"readOnly": true,
																"type": "string",
																"x-auditable": true
															},
															"name": {
																"description": "The name of the IPsec tunnel. The name cannot share a name with other tunnels.",
																"example": "IPsec_1",
																"type": "string"
															},
															"psk_metadata": {
																"description": "The PSK metadata that includes when the PSK was generated.",
																"properties": {
																	"last_generated_on": {
																		"description": "The date and time the tunnel was last modified.",
																		"example": "2017-06-14T05:20:00Z",
																		"format": "date-time",
																		"readOnly": true,
																		"type": "string",
																		"x-auditable": true
																	}
																},
																"type": "object"
															},
															"replay_protection": {
																"default": false,
																"description": "If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.",
																"example": false,
																"type": "boolean"
															}
														},
														"required": [
															"id",
															"name",
															"cloudflare_endpoint",
															"interface_address"
														],
														"type": "object"
													},
													"type": "array"
												}
											}
										}
									}
								}
							]
						}
					}
				},
				"description": "List IPsec tunnels response"
			},
			"4XX": {
				"content": {
					"application/json": {
						"schema": {
							"allOf": [
								{
									"allOf": [
										{
											"allOf": [
												{
													"properties": {
														"errors": {
															"example": [],
															"items": {
																"properties": {
																	"code": {
																		"minimum": 1000,
																		"type": "integer"
																	},
																	"message": {
																		"type": "string"
																	}
																},
																"required": [
																	"code",
																	"message"
																],
																"type": "object",
																"uniqueItems": true
															},
															"type": "array"
														},
														"messages": {
															"example": [],
															"items": {
																"properties": {
																	"code": {
																		"minimum": 1000,
																		"type": "integer"
																	},
																	"message": {
																		"type": "string"
																	}
																},
																"required": [
																	"code",
																	"message"
																],
																"type": "object",
																"uniqueItems": true
															},
															"type": "array"
														},
														"result": {
															"anyOf": [
																{
																	"type": "object"
																},
																{
																	"items": {},
																	"type": "array"
																},
																{
																	"type": "string"
																}
															]
														},
														"success": {
															"description": "Whether the API call was successful",
															"enum": [
																true
															],
															"example": true,
															"type": "boolean"
														}
													},
													"required": [
														"success",
														"errors",
														"messages",
														"result"
													],
													"type": "object"
												},
												{
													"properties": {
														"result": {
															"anyOf": [
																{
																	"nullable": true,
																	"type": "object"
																},
																{
																	"nullable": true,
																	"type": "string"
																}
															]
														}
													}
												}
											],
											"type": "object"
										},
										{
											"properties": {
												"result": {
													"properties": {
														"ipsec_tunnels": {
															"items": {
																"properties": {
																	"allow_null_cipher": {
																		"description": "When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).",
																		"example": true,
																		"type": "boolean"
																	},
																	"automatic_return_routing": {
																		"default": false,
																		"description": "True if automatic stateful return routing should be enabled for a tunnel, false otherwise.",
																		"example": true,
																		"type": "boolean",
																		"x-auditable": true
																	},
																	"bgp": {
																		"properties": {
																			"customer_asn": {
																				"description": "ASN used on the customer end of the BGP session",
																				"format": "int32",
																				"minimum": 0,
																				"type": "integer"
																			},
																			"extra_prefixes": {
																				"description": "Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.",
																				"items": {
																					"format": "cidr",
																					"type": "string"
																				},
																				"type": "array"
																			},
																			"md5_key": {
																				"description": "MD5 key to use for session authentication.\n\nNote that *this is not a security measure*. MD5 is not a valid security mechanism, and the\nkey is not treated as a secret value. This is *only* supported for preventing\nmisconfiguration, not for defending against malicious attacks.\n\nThe MD5 key, if set, must be of non-zero length and consist only of the following types of\ncharacter:\n\n* ASCII alphanumerics: `[a-zA-Z0-9]`\n* Special characters in the set `'!@#$%^&*()+[]{}<>/.,;:_-~`= \\|`\n\nIn other words, MD5 keys may contain any printable ASCII character aside from newline (0x0A),\nquotation mark (`\"`), vertical tab (0x0B), carriage return (0x0D), tab (0x09), form feed\n(0x0C), and the question mark (`?`). Requests specifying an MD5 key with one or more of\nthese disallowed characters will be rejected.",
																				"type": "string"
																			}
																		},
																		"required": [
																			"customer_asn"
																		],
																		"type": "object"
																	},
																	"bgp_status": {
																		"properties": {
																			"bgp_state": {
																				"type": "string"
																			},
																			"cf_speaker_ip": {
																				"format": "ipv4",
																				"type": "string"
																			},
																			"cf_speaker_port": {
																				"maximum": 65535,
																				"minimum": 1,
																				"type": "integer"
																			},
																			"customer_speaker_ip": {
																				"format": "ipv4",
																				"type": "string"
																			},
																			"customer_speaker_port": {
																				"maximum": 65535,
																				"minimum": 1,
																				"type": "integer"
																			},
																			"state": {
																				"enum": [
																					"BGP_DOWN",
																					"BGP_UP",
																					"BGP_ESTABLISHING"
																				],
																				"type": "string"
																			},
																			"tcp_established": {
																				"type": "boolean"
																			},
																			"updated_at": {
																				"format": "date-time",
																				"type": "string"
																			}
																		},
																		"required": [
																			"state",
																			"tcp_established",
																			"updated_at"
																		],
																		"type": "object"
																	},
																	"cloudflare_endpoint": {
																		"description": "The IP address assigned to the Cloudflare side of the IPsec tunnel.",
																		"example": "203.0.113.1",
																		"type": "string"
																	},
																	"created_on": {
																		"description": "The date and time the tunnel was created.",
																		"example": "2017-06-14T00:00:00Z",
																		"format": "date-time",
																		"readOnly": true,
																		"type": "string",
																		"x-auditable": true
																	},
																	"custom_remote_identities": {
																		"properties": {
																			"fqdn_id": {
																				"description": "A custom IKE ID of type FQDN that may be used to identity the IPsec tunnel. The\ngenerated IKE IDs can still be used even if this custom value is specified.\n\nMust be of the form `<custom label>.<account ID>.custom.ipsec.cloudflare.com`.\n\nThis custom ID does not need to be unique. Two IPsec tunnels may have the same custom \nfqdn_id. However, if another IPsec tunnel has the same value then the two tunnels \ncannot have the same cloudflare_endpoint.",
																				"type": "string"
																			}
																		},
																		"type": "object"
																	},
																	"customer_endpoint": {
																		"description": "The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.",
																		"example": "203.0.113.1",
																		"type": "string"
																	},
																	"description": {
																		"description": "An optional description forthe IPsec tunnel.",
																		"example": "Tunnel for ISP X",
																		"type": "string"
																	},
																	"health_check": {
																		"allOf": [
																			{
																				"properties": {
																					"enabled": {
																						"default": true,
																						"description": "Determines whether to run healthchecks for a tunnel.",
																						"example": true,
																						"type": "boolean",
																						"x-auditable": true
																					},
																					"rate": {
																						"default": "mid",
																						"description": "How frequent the health check is run. The default value is `mid`.",
																						"enum": [
																							"low",
																							"mid",
																							"high"
																						],
																						"example": "low",
																						"type": "string",
																						"x-auditable": true
																					},
																					"target": {
																						"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.",
																						"oneOf": [
																							{
																								"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target.",
																								"properties": {
																									"effective": {
																										"description": "The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.",
																										"example": "203.0.113.1",
																										"readOnly": true,
																										"type": "string",
																										"x-auditable": true
																									},
																									"saved": {
																										"description": "The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.",
																										"example": "203.0.113.1",
																										"type": "string",
																										"x-auditable": true
																									}
																								},
																								"type": "object"
																							},
																							{
																								"type": "string"
																							}
																						]
																					},
																					"type": {
																						"default": "reply",
																						"description": "The type of healthcheck to run, reply or request. The default value is `reply`.",
																						"enum": [
																							"reply",
																							"request"
																						],
																						"example": "request",
																						"type": "string",
																						"x-auditable": true
																					}
																				},
																				"type": "object"
																			},
																			{
																				"properties": {
																					"direction": {
																						"default": "unidirectional",
																						"description": "The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.",
																						"enum": [
																							"unidirectional",
																							"bidirectional"
																						],
																						"example": "bidirectional",
																						"type": "string"
																					}
																				}
																			}
																		]
																	},
																	"id": {
																		"description": "Identifier",
																		"example": "c4a7362d577a6c3019a474fd6f485821",
																		"maxLength": 32,
																		"readOnly": true,
																		"type": "string",
																		"x-auditable": true
																	},
																	"interface_address": {
																		"description": "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.",
																		"example": "192.0.2.0/31",
																		"type": "string",
																		"x-auditable": true
																	},
																	"interface_address6": {
																		"description": "A 127 bit IPV6 prefix from within the virtual_subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual_subnet6. Eg if virtual_subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface_address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127",
																		"example": "2606:54c1:7:0:a9fe:12d2:1:200/127",
																		"type": "string",
																		"x-auditable": true
																	},
																	"modified_on": {
																		"description": "The date and time the tunnel was last modified.",
																		"example": "2017-06-14T05:20:00Z",
																		"format": "date-time",
																		"readOnly": true,
																		"type": "string",
																		"x-auditable": true
																	},
																	"name": {
																		"description": "The name of the IPsec tunnel. The name cannot share a name with other tunnels.",
																		"example": "IPsec_1",
																		"type": "string"
																	},
																	"psk_metadata": {
																		"description": "The PSK metadata that includes when the PSK was generated.",
																		"properties": {
																			"last_generated_on": {
																				"description": "The date and time the tunnel was last modified.",
																				"example": "2017-06-14T05:20:00Z",
																				"format": "date-time",
																				"readOnly": true,
																				"type": "string",
																				"x-auditable": true
																			}
																		},
																		"type": "object"
																	},
																	"replay_protection": {
																		"default": false,
																		"description": "If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.",
																		"example": false,
																		"type": "boolean"
																	}
																},
																"required": [
																	"id",
																	"name",
																	"cloudflare_endpoint",
																	"interface_address"
																],
																"type": "object"
															},
															"type": "array"
														}
													}
												}
											}
										}
									]
								},
								{
									"properties": {
										"errors": {
											"allOf": [
												{
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												}
											],
											"example": [
												{
													"code": 7003,
													"message": "No route for the URI"
												}
											],
											"minLength": 1
										},
										"messages": {
											"allOf": [
												{
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												}
											],
											"example": []
										},
										"result": {
											"enum": [
												null
											],
											"nullable": true,
											"type": "object"
										},
										"success": {
											"description": "Whether the API call was successful",
											"enum": [
												false
											],
											"example": false,
											"type": "boolean"
										}
									},
									"required": [
										"success",
										"errors",
										"messages",
										"result"
									],
									"type": "object"
								}
							]
						}
					}
				},
				"description": "List IPsec tunnels response failure"
			}
		},
		"security": [
			{
				"api_email": [],
				"api_key": [],
				"api_token": []
			}
		],
		"summary": "List IPsec tunnels",
		"tags": [
			"Magic IPsec tunnels"
		],
		"x-api-token-group": [
			"Magic WAN Write",
			"Magic WAN Read",
			"Magic Transit Read",
			"Magic Transit Write"
		],
		"x-cfPlanAvailability": {
			"business": false,
			"enterprise": true,
			"free": false,
			"pro": false
		}
	},
	"GET /accounts/{account_id}/magic/ipsec_tunnels/{ipsec_tunnel_id}": {
		"description": "Lists details for a specific IPsec tunnel.",
		"operationId": "magic-ipsec-tunnels-list-ipsec-tunnel-details",
		"parameters": [
			{
				"in": "path",
				"name": "ipsec_tunnel_id",
				"required": true,
				"schema": {
					"description": "Identifier",
					"example": "023e105f4ecef8ad9ca31a8372d0c353",
					"maxLength": 32,
					"readOnly": true,
					"type": "string"
				}
			},
			{
				"in": "path",
				"name": "account_id",
				"required": true,
				"schema": {
					"description": "Identifier",
					"example": "023e105f4ecef8ad9ca31a8372d0c353",
					"maxLength": 32,
					"readOnly": true,
					"type": "string"
				}
			},
			{
				"description": "If true, the health check target in the response body will be presented using the new object format. Defaults to false.",
				"in": "header",
				"name": "x-magic-new-hc-target",
				"schema": {
					"type": "boolean"
				}
			}
		],
		"responses": {
			"200": {
				"content": {
					"application/json": {
						"schema": {
							"allOf": [
								{
									"allOf": [
										{
											"properties": {
												"errors": {
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												},
												"messages": {
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												},
												"result": {
													"anyOf": [
														{
															"type": "object"
														},
														{
															"items": {},
															"type": "array"
														},
														{
															"type": "string"
														}
													]
												},
												"success": {
													"description": "Whether the API call was successful",
													"enum": [
														true
													],
													"example": true,
													"type": "boolean"
												}
											},
											"required": [
												"success",
												"errors",
												"messages",
												"result"
											],
											"type": "object"
										},
										{
											"properties": {
												"result": {
													"anyOf": [
														{
															"nullable": true,
															"type": "object"
														},
														{
															"nullable": true,
															"type": "string"
														}
													]
												}
											}
										}
									],
									"type": "object"
								},
								{
									"properties": {
										"result": {
											"properties": {
												"ipsec_tunnel": {
													"properties": {
														"allow_null_cipher": {
															"description": "When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).",
															"example": true,
															"type": "boolean"
														},
														"automatic_return_routing": {
															"default": false,
															"description": "True if automatic stateful return routing should be enabled for a tunnel, false otherwise.",
															"example": true,
															"type": "boolean",
															"x-auditable": true
														},
														"bgp": {
															"properties": {
																"customer_asn": {
																	"description": "ASN used on the customer end of the BGP session",
																	"format": "int32",
																	"minimum": 0,
																	"type": "integer"
																},
																"extra_prefixes": {
																	"description": "Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.",
																	"items": {
																		"format": "cidr",
																		"type": "string"
																	},
																	"type": "array"
																},
																"md5_key": {
																	"description": "MD5 key to use for session authentication.\n\nNote that *this is not a security measure*. MD5 is not a valid security mechanism, and the\nkey is not treated as a secret value. This is *only* supported for preventing\nmisconfiguration, not for defending against malicious attacks.\n\nThe MD5 key, if set, must be of non-zero length and consist only of the following types of\ncharacter:\n\n* ASCII alphanumerics: `[a-zA-Z0-9]`\n* Special characters in the set `'!@#$%^&*()+[]{}<>/.,;:_-~`= \\|`\n\nIn other words, MD5 keys may contain any printable ASCII character aside from newline (0x0A),\nquotation mark (`\"`), vertical tab (0x0B), carriage return (0x0D), tab (0x09), form feed\n(0x0C), and the question mark (`?`). Requests specifying an MD5 key with one or more of\nthese disallowed characters will be rejected.",
																	"type": "string"
																}
															},
															"required": [
																"customer_asn"
															],
															"type": "object"
														},
														"bgp_status": {
															"properties": {
																"bgp_state": {
																	"type": "string"
																},
																"cf_speaker_ip": {
																	"format": "ipv4",
																	"type": "string"
																},
																"cf_speaker_port": {
																	"maximum": 65535,
																	"minimum": 1,
																	"type": "integer"
																},
																"customer_speaker_ip": {
																	"format": "ipv4",
																	"type": "string"
																},
																"customer_speaker_port": {
																	"maximum": 65535,
																	"minimum": 1,
																	"type": "integer"
																},
																"state": {
																	"enum": [
																		"BGP_DOWN",
																		"BGP_UP",
																		"BGP_ESTABLISHING"
																	],
																	"type": "string"
																},
																"tcp_established": {
																	"type": "boolean"
																},
																"updated_at": {
																	"format": "date-time",
																	"type": "string"
																}
															},
															"required": [
																"state",
																"tcp_established",
																"updated_at"
															],
															"type": "object"
														},
														"cloudflare_endpoint": {
															"description": "The IP address assigned to the Cloudflare side of the IPsec tunnel.",
															"example": "203.0.113.1",
															"type": "string"
														},
														"created_on": {
															"description": "The date and time the tunnel was created.",
															"example": "2017-06-14T00:00:00Z",
															"format": "date-time",
															"readOnly": true,
															"type": "string",
															"x-auditable": true
														},
														"custom_remote_identities": {
															"properties": {
																"fqdn_id": {
																	"description": "A custom IKE ID of type FQDN that may be used to identity the IPsec tunnel. The\ngenerated IKE IDs can still be used even if this custom value is specified.\n\nMust be of the form `<custom label>.<account ID>.custom.ipsec.cloudflare.com`.\n\nThis custom ID does not need to be unique. Two IPsec tunnels may have the same custom \nfqdn_id. However, if another IPsec tunnel has the same value then the two tunnels \ncannot have the same cloudflare_endpoint.",
																	"type": "string"
																}
															},
															"type": "object"
														},
														"customer_endpoint": {
															"description": "The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.",
															"example": "203.0.113.1",
															"type": "string"
														},
														"description": {
															"description": "An optional description forthe IPsec tunnel.",
															"example": "Tunnel for ISP X",
															"type": "string"
														},
														"health_check": {
															"allOf": [
																{
																	"properties": {
																		"enabled": {
																			"default": true,
																			"description": "Determines whether to run healthchecks for a tunnel.",
																			"example": true,
																			"type": "boolean",
																			"x-auditable": true
																		},
																		"rate": {
																			"default": "mid",
																			"description": "How frequent the health check is run. The default value is `mid`.",
																			"enum": [
																				"low",
																				"mid",
																				"high"
																			],
																			"example": "low",
																			"type": "string",
																			"x-auditable": true
																		},
																		"target": {
																			"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.",
																			"oneOf": [
																				{
																					"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target.",
																					"properties": {
																						"effective": {
																							"description": "The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.",
																							"example": "203.0.113.1",
																							"readOnly": true,
																							"type": "string",
																							"x-auditable": true
																						},
																						"saved": {
																							"description": "The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.",
																							"example": "203.0.113.1",
																							"type": "string",
																							"x-auditable": true
																						}
																					},
																					"type": "object"
																				},
																				{
																					"type": "string"
																				}
																			]
																		},
																		"type": {
																			"default": "reply",
																			"description": "The type of healthcheck to run, reply or request. The default value is `reply`.",
																			"enum": [
																				"reply",
																				"request"
																			],
																			"example": "request",
																			"type": "string",
																			"x-auditable": true
																		}
																	},
																	"type": "object"
																},
																{
																	"properties": {
																		"direction": {
																			"default": "unidirectional",
																			"description": "The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.",
																			"enum": [
																				"unidirectional",
																				"bidirectional"
																			],
																			"example": "bidirectional",
																			"type": "string"
																		}
																	}
																}
															]
														},
														"id": {
															"description": "Identifier",
															"example": "c4a7362d577a6c3019a474fd6f485821",
															"maxLength": 32,
															"readOnly": true,
															"type": "string",
															"x-auditable": true
														},
														"interface_address": {
															"description": "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.",
															"example": "192.0.2.0/31",
															"type": "string",
															"x-auditable": true
														},
														"interface_address6": {
															"description": "A 127 bit IPV6 prefix from within the virtual_subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual_subnet6. Eg if virtual_subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface_address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127",
															"example": "2606:54c1:7:0:a9fe:12d2:1:200/127",
															"type": "string",
															"x-auditable": true
														},
														"modified_on": {
															"description": "The date and time the tunnel was last modified.",
															"example": "2017-06-14T05:20:00Z",
															"format": "date-time",
															"readOnly": true,
															"type": "string",
															"x-auditable": true
														},
														"name": {
															"description": "The name of the IPsec tunnel. The name cannot share a name with other tunnels.",
															"example": "IPsec_1",
															"type": "string"
														},
														"psk_metadata": {
															"description": "The PSK metadata that includes when the PSK was generated.",
															"properties": {
																"last_generated_on": {
																	"description": "The date and time the tunnel was last modified.",
																	"example": "2017-06-14T05:20:00Z",
																	"format": "date-time",
																	"readOnly": true,
																	"type": "string",
																	"x-auditable": true
																}
															},
															"type": "object"
														},
														"replay_protection": {
															"default": false,
															"description": "If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.",
															"example": false,
															"type": "boolean"
														}
													},
													"required": [
														"id",
														"name",
														"cloudflare_endpoint",
														"interface_address"
													],
													"type": "object"
												}
											},
											"type": "object"
										}
									}
								}
							]
						}
					}
				},
				"description": "List IPsec tunnel details response"
			},
			"4XX": {
				"content": {
					"application/json": {
						"schema": {
							"allOf": [
								{
									"allOf": [
										{
											"allOf": [
												{
													"properties": {
														"errors": {
															"example": [],
															"items": {
																"properties": {
																	"code": {
																		"minimum": 1000,
																		"type": "integer"
																	},
																	"message": {
																		"type": "string"
																	}
																},
																"required": [
																	"code",
																	"message"
																],
																"type": "object",
																"uniqueItems": true
															},
															"type": "array"
														},
														"messages": {
															"example": [],
															"items": {
																"properties": {
																	"code": {
																		"minimum": 1000,
																		"type": "integer"
																	},
																	"message": {
																		"type": "string"
																	}
																},
																"required": [
																	"code",
																	"message"
																],
																"type": "object",
																"uniqueItems": true
															},
															"type": "array"
														},
														"result": {
															"anyOf": [
																{
																	"type": "object"
																},
																{
																	"items": {},
																	"type": "array"
																},
																{
																	"type": "string"
																}
															]
														},
														"success": {
															"description": "Whether the API call was successful",
															"enum": [
																true
															],
															"example": true,
															"type": "boolean"
														}
													},
													"required": [
														"success",
														"errors",
														"messages",
														"result"
													],
													"type": "object"
												},
												{
													"properties": {
														"result": {
															"anyOf": [
																{
																	"nullable": true,
																	"type": "object"
																},
																{
																	"nullable": true,
																	"type": "string"
																}
															]
														}
													}
												}
											],
											"type": "object"
										},
										{
											"properties": {
												"result": {
													"properties": {
														"ipsec_tunnel": {
															"properties": {
																"allow_null_cipher": {
																	"description": "When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).",
																	"example": true,
																	"type": "boolean"
																},
																"automatic_return_routing": {
																	"default": false,
																	"description": "True if automatic stateful return routing should be enabled for a tunnel, false otherwise.",
																	"example": true,
																	"type": "boolean",
																	"x-auditable": true
																},
																"bgp": {
																	"properties": {
																		"customer_asn": {
																			"description": "ASN used on the customer end of the BGP session",
																			"format": "int32",
																			"minimum": 0,
																			"type": "integer"
																		},
																		"extra_prefixes": {
																			"description": "Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.",
																			"items": {
																				"format": "cidr",
																				"type": "string"
																			},
																			"type": "array"
																		},
																		"md5_key": {
																			"description": "MD5 key to use for session authentication.\n\nNote that *this is not a security measure*. MD5 is not a valid security mechanism, and the\nkey is not treated as a secret value. This is *only* supported for preventing\nmisconfiguration, not for defending against malicious attacks.\n\nThe MD5 key, if set, must be of non-zero length and consist only of the following types of\ncharacter:\n\n* ASCII alphanumerics: `[a-zA-Z0-9]`\n* Special characters in the set `'!@#$%^&*()+[]{}<>/.,;:_-~`= \\|`\n\nIn other words, MD5 keys may contain any printable ASCII character aside from newline (0x0A),\nquotation mark (`\"`), vertical tab (0x0B), carriage return (0x0D), tab (0x09), form feed\n(0x0C), and the question mark (`?`). Requests specifying an MD5 key with one or more of\nthese disallowed characters will be rejected.",
																			"type": "string"
																		}
																	},
																	"required": [
																		"customer_asn"
																	],
																	"type": "object"
																},
																"bgp_status": {
																	"properties": {
																		"bgp_state": {
																			"type": "string"
																		},
																		"cf_speaker_ip": {
																			"format": "ipv4",
																			"type": "string"
																		},
																		"cf_speaker_port": {
																			"maximum": 65535,
																			"minimum": 1,
																			"type": "integer"
																		},
																		"customer_speaker_ip": {
																			"format": "ipv4",
																			"type": "string"
																		},
																		"customer_speaker_port": {
																			"maximum": 65535,
																			"minimum": 1,
																			"type": "integer"
																		},
																		"state": {
																			"enum": [
																				"BGP_DOWN",
																				"BGP_UP",
																				"BGP_ESTABLISHING"
																			],
																			"type": "string"
																		},
																		"tcp_established": {
																			"type": "boolean"
																		},
																		"updated_at": {
																			"format": "date-time",
																			"type": "string"
																		}
																	},
																	"required": [
																		"state",
																		"tcp_established",
																		"updated_at"
																	],
																	"type": "object"
																},
																"cloudflare_endpoint": {
																	"description": "The IP address assigned to the Cloudflare side of the IPsec tunnel.",
																	"example": "203.0.113.1",
																	"type": "string"
																},
																"created_on": {
																	"description": "The date and time the tunnel was created.",
																	"example": "2017-06-14T00:00:00Z",
																	"format": "date-time",
																	"readOnly": true,
																	"type": "string",
																	"x-auditable": true
																},
																"custom_remote_identities": {
																	"properties": {
																		"fqdn_id": {
																			"description": "A custom IKE ID of type FQDN that may be used to identity the IPsec tunnel. The\ngenerated IKE IDs can still be used even if this custom value is specified.\n\nMust be of the form `<custom label>.<account ID>.custom.ipsec.cloudflare.com`.\n\nThis custom ID does not need to be unique. Two IPsec tunnels may have the same custom \nfqdn_id. However, if another IPsec tunnel has the same value then the two tunnels \ncannot have the same cloudflare_endpoint.",
																			"type": "string"
																		}
																	},
																	"type": "object"
																},
																"customer_endpoint": {
																	"description": "The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.",
																	"example": "203.0.113.1",
																	"type": "string"
																},
																"description": {
																	"description": "An optional description forthe IPsec tunnel.",
																	"example": "Tunnel for ISP X",
																	"type": "string"
																},
																"health_check": {
																	"allOf": [
																		{
																			"properties": {
																				"enabled": {
																					"default": true,
																					"description": "Determines whether to run healthchecks for a tunnel.",
																					"example": true,
																					"type": "boolean",
																					"x-auditable": true
																				},
																				"rate": {
																					"default": "mid",
																					"description": "How frequent the health check is run. The default value is `mid`.",
																					"enum": [
																						"low",
																						"mid",
																						"high"
																					],
																					"example": "low",
																					"type": "string",
																					"x-auditable": true
																				},
																				"target": {
																					"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.",
																					"oneOf": [
																						{
																							"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target.",
																							"properties": {
																								"effective": {
																									"description": "The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.",
																									"example": "203.0.113.1",
																									"readOnly": true,
																									"type": "string",
																									"x-auditable": true
																								},
																								"saved": {
																									"description": "The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.",
																									"example": "203.0.113.1",
																									"type": "string",
																									"x-auditable": true
																								}
																							},
																							"type": "object"
																						},
																						{
																							"type": "string"
																						}
																					]
																				},
																				"type": {
																					"default": "reply",
																					"description": "The type of healthcheck to run, reply or request. The default value is `reply`.",
																					"enum": [
																						"reply",
																						"request"
																					],
																					"example": "request",
																					"type": "string",
																					"x-auditable": true
																				}
																			},
																			"type": "object"
																		},
																		{
																			"properties": {
																				"direction": {
																					"default": "unidirectional",
																					"description": "The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.",
																					"enum": [
																						"unidirectional",
																						"bidirectional"
																					],
																					"example": "bidirectional",
																					"type": "string"
																				}
																			}
																		}
																	]
																},
																"id": {
																	"description": "Identifier",
																	"example": "c4a7362d577a6c3019a474fd6f485821",
																	"maxLength": 32,
																	"readOnly": true,
																	"type": "string",
																	"x-auditable": true
																},
																"interface_address": {
																	"description": "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.",
																	"example": "192.0.2.0/31",
																	"type": "string",
																	"x-auditable": true
																},
																"interface_address6": {
																	"description": "A 127 bit IPV6 prefix from within the virtual_subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual_subnet6. Eg if virtual_subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface_address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127",
																	"example": "2606:54c1:7:0:a9fe:12d2:1:200/127",
																	"type": "string",
																	"x-auditable": true
																},
																"modified_on": {
																	"description": "The date and time the tunnel was last modified.",
																	"example": "2017-06-14T05:20:00Z",
																	"format": "date-time",
																	"readOnly": true,
																	"type": "string",
																	"x-auditable": true
																},
																"name": {
																	"description": "The name of the IPsec tunnel. The name cannot share a name with other tunnels.",
																	"example": "IPsec_1",
																	"type": "string"
																},
																"psk_metadata": {
																	"description": "The PSK metadata that includes when the PSK was generated.",
																	"properties": {
																		"last_generated_on": {
																			"description": "The date and time the tunnel was last modified.",
																			"example": "2017-06-14T05:20:00Z",
																			"format": "date-time",
																			"readOnly": true,
																			"type": "string",
																			"x-auditable": true
																		}
																	},
																	"type": "object"
																},
																"replay_protection": {
																	"default": false,
																	"description": "If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.",
																	"example": false,
																	"type": "boolean"
																}
															},
															"required": [
																"id",
																"name",
																"cloudflare_endpoint",
																"interface_address"
															],
															"type": "object"
														}
													},
													"type": "object"
												}
											}
										}
									]
								},
								{
									"properties": {
										"errors": {
											"allOf": [
												{
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												}
											],
											"example": [
												{
													"code": 7003,
													"message": "No route for the URI"
												}
											],
											"minLength": 1
										},
										"messages": {
											"allOf": [
												{
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												}
											],
											"example": []
										},
										"result": {
											"enum": [
												null
											],
											"nullable": true,
											"type": "object"
										},
										"success": {
											"description": "Whether the API call was successful",
											"enum": [
												false
											],
											"example": false,
											"type": "boolean"
										}
									},
									"required": [
										"success",
										"errors",
										"messages",
										"result"
									],
									"type": "object"
								}
							]
						}
					}
				},
				"description": "List IPsec tunnel details response failure"
			}
		},
		"security": [
			{
				"api_email": [],
				"api_key": [],
				"api_token": []
			}
		],
		"summary": "List IPsec tunnel details",
		"tags": [
			"Magic IPsec tunnels"
		],
		"x-api-token-group": [
			"Magic WAN Write",
			"Magic WAN Read",
			"Magic Transit Read",
			"Magic Transit Write"
		],
		"x-cfPlanAvailability": {
			"business": false,
			"enterprise": true,
			"free": false,
			"pro": false
		}
	},
	"POST /accounts/{account_id}/magic/ipsec_tunnels": {
		"description": "Creates a new IPsec tunnel associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.",
		"operationId": "magic-ipsec-tunnels-create-ipsec-tunnels",
		"parameters": [
			{
				"in": "path",
				"name": "account_id",
				"required": true,
				"schema": {
					"description": "Identifier",
					"example": "023e105f4ecef8ad9ca31a8372d0c353",
					"maxLength": 32,
					"readOnly": true,
					"type": "string"
				}
			},
			{
				"description": "If true, the health check target in the request and response bodies will be presented using the new object format. Defaults to false.",
				"in": "header",
				"name": "x-magic-new-hc-target",
				"schema": {
					"type": "boolean"
				}
			}
		],
		"requestBody": {
			"content": {
				"application/json": {
					"schema": {
						"allOf": [
							{
								"properties": {
									"automatic_return_routing": {
										"default": false,
										"description": "True if automatic stateful return routing should be enabled for a tunnel, false otherwise.",
										"example": true,
										"type": "boolean",
										"x-auditable": true
									},
									"bgp": {
										"properties": {
											"customer_asn": {
												"description": "ASN used on the customer end of the BGP session",
												"format": "int32",
												"minimum": 0,
												"type": "integer"
											},
											"extra_prefixes": {
												"description": "Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.",
												"items": {
													"format": "cidr",
													"type": "string"
												},
												"type": "array"
											},
											"md5_key": {
												"description": "MD5 key to use for session authentication.\n\nNote that *this is not a security measure*. MD5 is not a valid security mechanism, and the\nkey is not treated as a secret value. This is *only* supported for preventing\nmisconfiguration, not for defending against malicious attacks.\n\nThe MD5 key, if set, must be of non-zero length and consist only of the following types of\ncharacter:\n\n* ASCII alphanumerics: `[a-zA-Z0-9]`\n* Special characters in the set `'!@#$%^&*()+[]{}<>/.,;:_-~`= \\|`\n\nIn other words, MD5 keys may contain any printable ASCII character aside from newline (0x0A),\nquotation mark (`\"`), vertical tab (0x0B), carriage return (0x0D), tab (0x09), form feed\n(0x0C), and the question mark (`?`). Requests specifying an MD5 key with one or more of\nthese disallowed characters will be rejected.",
												"type": "string"
											}
										},
										"required": [
											"customer_asn"
										],
										"type": "object"
									},
									"cloudflare_endpoint": {
										"description": "The IP address assigned to the Cloudflare side of the IPsec tunnel.",
										"example": "203.0.113.1",
										"type": "string"
									},
									"customer_endpoint": {
										"description": "The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.",
										"example": "203.0.113.1",
										"type": "string"
									},
									"description": {
										"description": "An optional description forthe IPsec tunnel.",
										"example": "Tunnel for ISP X",
										"type": "string"
									},
									"health_check": {
										"allOf": [
											{
												"properties": {
													"enabled": {
														"default": true,
														"description": "Determines whether to run healthchecks for a tunnel.",
														"example": true,
														"type": "boolean",
														"x-auditable": true
													},
													"rate": {
														"default": "mid",
														"description": "How frequent the health check is run. The default value is `mid`.",
														"enum": [
															"low",
															"mid",
															"high"
														],
														"example": "low",
														"type": "string",
														"x-auditable": true
													},
													"target": {
														"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.",
														"oneOf": [
															{
																"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target.",
																"properties": {
																	"effective": {
																		"description": "The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.",
																		"example": "203.0.113.1",
																		"readOnly": true,
																		"type": "string",
																		"x-auditable": true
																	},
																	"saved": {
																		"description": "The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.",
																		"example": "203.0.113.1",
																		"type": "string",
																		"x-auditable": true
																	}
																},
																"type": "object"
															},
															{
																"type": "string"
															}
														]
													},
													"type": {
														"default": "reply",
														"description": "The type of healthcheck to run, reply or request. The default value is `reply`.",
														"enum": [
															"reply",
															"request"
														],
														"example": "request",
														"type": "string",
														"x-auditable": true
													}
												},
												"type": "object"
											},
											{
												"properties": {
													"direction": {
														"default": "unidirectional",
														"description": "The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.",
														"enum": [
															"unidirectional",
															"bidirectional"
														],
														"example": "bidirectional",
														"type": "string"
													}
												}
											}
										]
									},
									"interface_address": {
										"description": "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.",
										"example": "192.0.2.0/31",
										"type": "string",
										"x-auditable": true
									},
									"interface_address6": {
										"description": "A 127 bit IPV6 prefix from within the virtual_subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual_subnet6. Eg if virtual_subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface_address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127",
										"example": "2606:54c1:7:0:a9fe:12d2:1:200/127",
										"type": "string",
										"x-auditable": true
									},
									"name": {
										"description": "The name of the IPsec tunnel. The name cannot share a name with other tunnels.",
										"example": "IPsec_1",
										"type": "string"
									},
									"psk": {
										"description": "A randomly generated or provided string for use in the IPsec tunnel.",
										"example": "O3bwKSjnaoCxDoUxjcq4Rk8ZKkezQUiy",
										"type": "string"
									},
									"replay_protection": {
										"default": false,
										"description": "If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.",
										"example": false,
										"type": "boolean"
									}
								},
								"required": [
									"name",
									"cloudflare_endpoint",
									"interface_address"
								],
								"type": "object"
							}
						]
					}
				}
			},
			"required": true
		},
		"responses": {
			"200": {
				"content": {
					"application/json": {
						"schema": {
							"allOf": [
								{
									"allOf": [
										{
											"properties": {
												"errors": {
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												},
												"messages": {
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												},
												"result": {
													"anyOf": [
														{
															"type": "object"
														},
														{
															"items": {},
															"type": "array"
														},
														{
															"type": "string"
														}
													]
												},
												"success": {
													"description": "Whether the API call was successful",
													"enum": [
														true
													],
													"example": true,
													"type": "boolean"
												}
											},
											"required": [
												"success",
												"errors",
												"messages",
												"result"
											],
											"type": "object"
										},
										{
											"properties": {
												"result": {
													"anyOf": [
														{
															"nullable": true,
															"type": "object"
														},
														{
															"nullable": true,
															"type": "string"
														}
													]
												}
											}
										}
									],
									"type": "object"
								},
								{
									"properties": {
										"result": {
											"properties": {
												"allow_null_cipher": {
													"description": "When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).",
													"example": true,
													"type": "boolean"
												},
												"automatic_return_routing": {
													"default": false,
													"description": "True if automatic stateful return routing should be enabled for a tunnel, false otherwise.",
													"example": true,
													"type": "boolean",
													"x-auditable": true
												},
												"bgp": {
													"properties": {
														"customer_asn": {
															"description": "ASN used on the customer end of the BGP session",
															"format": "int32",
															"minimum": 0,
															"type": "integer"
														},
														"extra_prefixes": {
															"description": "Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.",
															"items": {
																"format": "cidr",
																"type": "string"
															},
															"type": "array"
														},
														"md5_key": {
															"description": "MD5 key to use for session authentication.\n\nNote that *this is not a security measure*. MD5 is not a valid security mechanism, and the\nkey is not treated as a secret value. This is *only* supported for preventing\nmisconfiguration, not for defending against malicious attacks.\n\nThe MD5 key, if set, must be of non-zero length and consist only of the following types of\ncharacter:\n\n* ASCII alphanumerics: `[a-zA-Z0-9]`\n* Special characters in the set `'!@#$%^&*()+[]{}<>/.,;:_-~`= \\|`\n\nIn other words, MD5 keys may contain any printable ASCII character aside from newline (0x0A),\nquotation mark (`\"`), vertical tab (0x0B), carriage return (0x0D), tab (0x09), form feed\n(0x0C), and the question mark (`?`). Requests specifying an MD5 key with one or more of\nthese disallowed characters will be rejected.",
															"type": "string"
														}
													},
													"required": [
														"customer_asn"
													],
													"type": "object"
												},
												"bgp_status": {
													"properties": {
														"bgp_state": {
															"type": "string"
														},
														"cf_speaker_ip": {
															"format": "ipv4",
															"type": "string"
														},
														"cf_speaker_port": {
															"maximum": 65535,
															"minimum": 1,
															"type": "integer"
														},
														"customer_speaker_ip": {
															"format": "ipv4",
															"type": "string"
														},
														"customer_speaker_port": {
															"maximum": 65535,
															"minimum": 1,
															"type": "integer"
														},
														"state": {
															"enum": [
																"BGP_DOWN",
																"BGP_UP",
																"BGP_ESTABLISHING"
															],
															"type": "string"
														},
														"tcp_established": {
															"type": "boolean"
														},
														"updated_at": {
															"format": "date-time",
															"type": "string"
														}
													},
													"required": [
														"state",
														"tcp_established",
														"updated_at"
													],
													"type": "object"
												},
												"cloudflare_endpoint": {
													"description": "The IP address assigned to the Cloudflare side of the IPsec tunnel.",
													"example": "203.0.113.1",
													"type": "string"
												},
												"created_on": {
													"description": "The date and time the tunnel was created.",
													"example": "2017-06-14T00:00:00Z",
													"format": "date-time",
													"readOnly": true,
													"type": "string",
													"x-auditable": true
												},
												"custom_remote_identities": {
													"properties": {
														"fqdn_id": {
															"description": "A custom IKE ID of type FQDN that may be used to identity the IPsec tunnel. The\ngenerated IKE IDs can still be used even if this custom value is specified.\n\nMust be of the form `<custom label>.<account ID>.custom.ipsec.cloudflare.com`.\n\nThis custom ID does not need to be unique. Two IPsec tunnels may have the same custom \nfqdn_id. However, if another IPsec tunnel has the same value then the two tunnels \ncannot have the same cloudflare_endpoint.",
															"type": "string"
														}
													},
													"type": "object"
												},
												"customer_endpoint": {
													"description": "The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.",
													"example": "203.0.113.1",
													"type": "string"
												},
												"description": {
													"description": "An optional description forthe IPsec tunnel.",
													"example": "Tunnel for ISP X",
													"type": "string"
												},
												"health_check": {
													"allOf": [
														{
															"properties": {
																"enabled": {
																	"default": true,
																	"description": "Determines whether to run healthchecks for a tunnel.",
																	"example": true,
																	"type": "boolean",
																	"x-auditable": true
																},
																"rate": {
																	"default": "mid",
																	"description": "How frequent the health check is run. The default value is `mid`.",
																	"enum": [
																		"low",
																		"mid",
																		"high"
																	],
																	"example": "low",
																	"type": "string",
																	"x-auditable": true
																},
																"target": {
																	"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.",
																	"oneOf": [
																		{
																			"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target.",
																			"properties": {
																				"effective": {
																					"description": "The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.",
																					"example": "203.0.113.1",
																					"readOnly": true,
																					"type": "string",
																					"x-auditable": true
																				},
																				"saved": {
																					"description": "The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.",
																					"example": "203.0.113.1",
																					"type": "string",
																					"x-auditable": true
																				}
																			},
																			"type": "object"
																		},
																		{
																			"type": "string"
																		}
																	]
																},
																"type": {
																	"default": "reply",
																	"description": "The type of healthcheck to run, reply or request. The default value is `reply`.",
																	"enum": [
																		"reply",
																		"request"
																	],
																	"example": "request",
																	"type": "string",
																	"x-auditable": true
																}
															},
															"type": "object"
														},
														{
															"properties": {
																"direction": {
																	"default": "unidirectional",
																	"description": "The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.",
																	"enum": [
																		"unidirectional",
																		"bidirectional"
																	],
																	"example": "bidirectional",
																	"type": "string"
																}
															}
														}
													]
												},
												"id": {
													"description": "Identifier",
													"example": "c4a7362d577a6c3019a474fd6f485821",
													"maxLength": 32,
													"readOnly": true,
													"type": "string",
													"x-auditable": true
												},
												"interface_address": {
													"description": "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.",
													"example": "192.0.2.0/31",
													"type": "string",
													"x-auditable": true
												},
												"interface_address6": {
													"description": "A 127 bit IPV6 prefix from within the virtual_subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual_subnet6. Eg if virtual_subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface_address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127",
													"example": "2606:54c1:7:0:a9fe:12d2:1:200/127",
													"type": "string",
													"x-auditable": true
												},
												"modified_on": {
													"description": "The date and time the tunnel was last modified.",
													"example": "2017-06-14T05:20:00Z",
													"format": "date-time",
													"readOnly": true,
													"type": "string",
													"x-auditable": true
												},
												"name": {
													"description": "The name of the IPsec tunnel. The name cannot share a name with other tunnels.",
													"example": "IPsec_1",
													"type": "string"
												},
												"psk_metadata": {
													"description": "The PSK metadata that includes when the PSK was generated.",
													"properties": {
														"last_generated_on": {
															"description": "The date and time the tunnel was last modified.",
															"example": "2017-06-14T05:20:00Z",
															"format": "date-time",
															"readOnly": true,
															"type": "string",
															"x-auditable": true
														}
													},
													"type": "object"
												},
												"replay_protection": {
													"default": false,
													"description": "If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.",
													"example": false,
													"type": "boolean"
												}
											},
											"required": [
												"id",
												"name",
												"cloudflare_endpoint",
												"interface_address"
											],
											"type": "object"
										}
									}
								}
							]
						}
					}
				},
				"description": "Create IPsec tunnels response"
			},
			"4XX": {
				"content": {
					"application/json": {
						"schema": {
							"allOf": [
								{
									"allOf": [
										{
											"allOf": [
												{
													"properties": {
														"errors": {
															"example": [],
															"items": {
																"properties": {
																	"code": {
																		"minimum": 1000,
																		"type": "integer"
																	},
																	"message": {
																		"type": "string"
																	}
																},
																"required": [
																	"code",
																	"message"
																],
																"type": "object",
																"uniqueItems": true
															},
															"type": "array"
														},
														"messages": {
															"example": [],
															"items": {
																"properties": {
																	"code": {
																		"minimum": 1000,
																		"type": "integer"
																	},
																	"message": {
																		"type": "string"
																	}
																},
																"required": [
																	"code",
																	"message"
																],
																"type": "object",
																"uniqueItems": true
															},
															"type": "array"
														},
														"result": {
															"anyOf": [
																{
																	"type": "object"
																},
																{
																	"items": {},
																	"type": "array"
																},
																{
																	"type": "string"
																}
															]
														},
														"success": {
															"description": "Whether the API call was successful",
															"enum": [
																true
															],
															"example": true,
															"type": "boolean"
														}
													},
													"required": [
														"success",
														"errors",
														"messages",
														"result"
													],
													"type": "object"
												},
												{
													"properties": {
														"result": {
															"anyOf": [
																{
																	"nullable": true,
																	"type": "object"
																},
																{
																	"nullable": true,
																	"type": "string"
																}
															]
														}
													}
												}
											],
											"type": "object"
										},
										{
											"properties": {
												"result": {
													"properties": {
														"allow_null_cipher": {
															"description": "When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).",
															"example": true,
															"type": "boolean"
														},
														"automatic_return_routing": {
															"default": false,
															"description": "True if automatic stateful return routing should be enabled for a tunnel, false otherwise.",
															"example": true,
															"type": "boolean",
															"x-auditable": true
														},
														"bgp": {
															"properties": {
																"customer_asn": {
																	"description": "ASN used on the customer end of the BGP session",
																	"format": "int32",
																	"minimum": 0,
																	"type": "integer"
																},
																"extra_prefixes": {
																	"description": "Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.",
																	"items": {
																		"format": "cidr",
																		"type": "string"
																	},
																	"type": "array"
																},
																"md5_key": {
																	"description": "MD5 key to use for session authentication.\n\nNote that *this is not a security measure*. MD5 is not a valid security mechanism, and the\nkey is not treated as a secret value. This is *only* supported for preventing\nmisconfiguration, not for defending against malicious attacks.\n\nThe MD5 key, if set, must be of non-zero length and consist only of the following types of\ncharacter:\n\n* ASCII alphanumerics: `[a-zA-Z0-9]`\n* Special characters in the set `'!@#$%^&*()+[]{}<>/.,;:_-~`= \\|`\n\nIn other words, MD5 keys may contain any printable ASCII character aside from newline (0x0A),\nquotation mark (`\"`), vertical tab (0x0B), carriage return (0x0D), tab (0x09), form feed\n(0x0C), and the question mark (`?`). Requests specifying an MD5 key with one or more of\nthese disallowed characters will be rejected.",
																	"type": "string"
																}
															},
															"required": [
																"customer_asn"
															],
															"type": "object"
														},
														"bgp_status": {
															"properties": {
																"bgp_state": {
																	"type": "string"
																},
																"cf_speaker_ip": {
																	"format": "ipv4",
																	"type": "string"
																},
																"cf_speaker_port": {
																	"maximum": 65535,
																	"minimum": 1,
																	"type": "integer"
																},
																"customer_speaker_ip": {
																	"format": "ipv4",
																	"type": "string"
																},
																"customer_speaker_port": {
																	"maximum": 65535,
																	"minimum": 1,
																	"type": "integer"
																},
																"state": {
																	"enum": [
																		"BGP_DOWN",
																		"BGP_UP",
																		"BGP_ESTABLISHING"
																	],
																	"type": "string"
																},
																"tcp_established": {
																	"type": "boolean"
																},
																"updated_at": {
																	"format": "date-time",
																	"type": "string"
																}
															},
															"required": [
																"state",
																"tcp_established",
																"updated_at"
															],
															"type": "object"
														},
														"cloudflare_endpoint": {
															"description": "The IP address assigned to the Cloudflare side of the IPsec tunnel.",
															"example": "203.0.113.1",
															"type": "string"
														},
														"created_on": {
															"description": "The date and time the tunnel was created.",
															"example": "2017-06-14T00:00:00Z",
															"format": "date-time",
															"readOnly": true,
															"type": "string",
															"x-auditable": true
														},
														"custom_remote_identities": {
															"properties": {
																"fqdn_id": {
																	"description": "A custom IKE ID of type FQDN that may be used to identity the IPsec tunnel. The\ngenerated IKE IDs can still be used even if this custom value is specified.\n\nMust be of the form `<custom label>.<account ID>.custom.ipsec.cloudflare.com`.\n\nThis custom ID does not need to be unique. Two IPsec tunnels may have the same custom \nfqdn_id. However, if another IPsec tunnel has the same value then the two tunnels \ncannot have the same cloudflare_endpoint.",
																	"type": "string"
																}
															},
															"type": "object"
														},
														"customer_endpoint": {
															"description": "The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.",
															"example": "203.0.113.1",
															"type": "string"
														},
														"description": {
															"description": "An optional description forthe IPsec tunnel.",
															"example": "Tunnel for ISP X",
															"type": "string"
														},
														"health_check": {
															"allOf": [
																{
																	"properties": {
																		"enabled": {
																			"default": true,
																			"description": "Determines whether to run healthchecks for a tunnel.",
																			"example": true,
																			"type": "boolean",
																			"x-auditable": true
																		},
																		"rate": {
																			"default": "mid",
																			"description": "How frequent the health check is run. The default value is `mid`.",
																			"enum": [
																				"low",
																				"mid",
																				"high"
																			],
																			"example": "low",
																			"type": "string",
																			"x-auditable": true
																		},
																		"target": {
																			"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.",
																			"oneOf": [
																				{
																					"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target.",
																					"properties": {
																						"effective": {
																							"description": "The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.",
																							"example": "203.0.113.1",
																							"readOnly": true,
																							"type": "string",
																							"x-auditable": true
																						},
																						"saved": {
																							"description": "The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.",
																							"example": "203.0.113.1",
																							"type": "string",
																							"x-auditable": true
																						}
																					},
																					"type": "object"
																				},
																				{
																					"type": "string"
																				}
																			]
																		},
																		"type": {
																			"default": "reply",
																			"description": "The type of healthcheck to run, reply or request. The default value is `reply`.",
																			"enum": [
																				"reply",
																				"request"
																			],
																			"example": "request",
																			"type": "string",
																			"x-auditable": true
																		}
																	},
																	"type": "object"
																},
																{
																	"properties": {
																		"direction": {
																			"default": "unidirectional",
																			"description": "The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.",
																			"enum": [
																				"unidirectional",
																				"bidirectional"
																			],
																			"example": "bidirectional",
																			"type": "string"
																		}
																	}
																}
															]
														},
														"id": {
															"description": "Identifier",
															"example": "c4a7362d577a6c3019a474fd6f485821",
															"maxLength": 32,
															"readOnly": true,
															"type": "string",
															"x-auditable": true
														},
														"interface_address": {
															"description": "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.",
															"example": "192.0.2.0/31",
															"type": "string",
															"x-auditable": true
														},
														"interface_address6": {
															"description": "A 127 bit IPV6 prefix from within the virtual_subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual_subnet6. Eg if virtual_subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface_address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127",
															"example": "2606:54c1:7:0:a9fe:12d2:1:200/127",
															"type": "string",
															"x-auditable": true
														},
														"modified_on": {
															"description": "The date and time the tunnel was last modified.",
															"example": "2017-06-14T05:20:00Z",
															"format": "date-time",
															"readOnly": true,
															"type": "string",
															"x-auditable": true
														},
														"name": {
															"description": "The name of the IPsec tunnel. The name cannot share a name with other tunnels.",
															"example": "IPsec_1",
															"type": "string"
														},
														"psk_metadata": {
															"description": "The PSK metadata that includes when the PSK was generated.",
															"properties": {
																"last_generated_on": {
																	"description": "The date and time the tunnel was last modified.",
																	"example": "2017-06-14T05:20:00Z",
																	"format": "date-time",
																	"readOnly": true,
																	"type": "string",
																	"x-auditable": true
																}
															},
															"type": "object"
														},
														"replay_protection": {
															"default": false,
															"description": "If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.",
															"example": false,
															"type": "boolean"
														}
													},
													"required": [
														"id",
														"name",
														"cloudflare_endpoint",
														"interface_address"
													],
													"type": "object"
												}
											}
										}
									]
								},
								{
									"properties": {
										"errors": {
											"allOf": [
												{
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												}
											],
											"example": [
												{
													"code": 7003,
													"message": "No route for the URI"
												}
											],
											"minLength": 1
										},
										"messages": {
											"allOf": [
												{
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												}
											],
											"example": []
										},
										"result": {
											"enum": [
												null
											],
											"nullable": true,
											"type": "object"
										},
										"success": {
											"description": "Whether the API call was successful",
											"enum": [
												false
											],
											"example": false,
											"type": "boolean"
										}
									},
									"required": [
										"success",
										"errors",
										"messages",
										"result"
									],
									"type": "object"
								}
							]
						}
					}
				},
				"description": "Create IPsec tunnels response failure"
			}
		},
		"security": [
			{
				"api_email": [],
				"api_key": [],
				"api_token": []
			}
		],
		"summary": "Create an IPsec tunnel",
		"tags": [
			"Magic IPsec tunnels"
		],
		"x-api-token-group": [
			"Magic WAN Write",
			"Magic Transit Write"
		],
		"x-cfPlanAvailability": {
			"business": false,
			"enterprise": true,
			"free": false,
			"pro": false
		}
	},
	"POST /accounts/{account_id}/magic/ipsec_tunnels/{ipsec_tunnel_id}/psk_generate": {
		"description": "Generates a Pre Shared Key for a specific IPsec tunnel used in the IKE session. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes. After a PSK is generated, the PSK is immediately persisted to Cloudflare's edge and cannot be retrieved later. Note the PSK in a safe place.",
		"operationId": "magic-ipsec-tunnels-generate-pre-shared-key-(-psk)-for-ipsec-tunnels",
		"parameters": [
			{
				"in": "path",
				"name": "ipsec_tunnel_id",
				"required": true,
				"schema": {
					"description": "Identifier",
					"example": "023e105f4ecef8ad9ca31a8372d0c353",
					"maxLength": 32,
					"readOnly": true,
					"type": "string"
				}
			},
			{
				"in": "path",
				"name": "account_id",
				"required": true,
				"schema": {
					"description": "Identifier",
					"example": "023e105f4ecef8ad9ca31a8372d0c353",
					"maxLength": 32,
					"readOnly": true,
					"type": "string"
				}
			}
		],
		"requestBody": {
			"content": {
				"application/json": {}
			},
			"required": true
		},
		"responses": {
			"200": {
				"content": {
					"application/json": {
						"schema": {
							"allOf": [
								{
									"allOf": [
										{
											"properties": {
												"errors": {
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												},
												"messages": {
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												},
												"result": {
													"anyOf": [
														{
															"type": "object"
														},
														{
															"items": {},
															"type": "array"
														},
														{
															"type": "string"
														}
													]
												},
												"success": {
													"description": "Whether the API call was successful",
													"enum": [
														true
													],
													"example": true,
													"type": "boolean"
												}
											},
											"required": [
												"success",
												"errors",
												"messages",
												"result"
											],
											"type": "object"
										},
										{
											"properties": {
												"result": {
													"anyOf": [
														{
															"nullable": true,
															"type": "object"
														},
														{
															"nullable": true,
															"type": "string"
														}
													]
												}
											}
										}
									],
									"type": "object"
								},
								{
									"properties": {
										"result": {
											"properties": {
												"ipsec_tunnel_id": {
													"description": "Identifier",
													"example": "023e105f4ecef8ad9ca31a8372d0c353",
													"maxLength": 32,
													"readOnly": true,
													"type": "string"
												},
												"psk": {
													"description": "A randomly generated or provided string for use in the IPsec tunnel.",
													"example": "O3bwKSjnaoCxDoUxjcq4Rk8ZKkezQUiy",
													"type": "string"
												},
												"psk_metadata": {
													"description": "The PSK metadata that includes when the PSK was generated.",
													"properties": {
														"last_generated_on": {
															"description": "The date and time the tunnel was last modified.",
															"example": "2017-06-14T05:20:00Z",
															"format": "date-time",
															"readOnly": true,
															"type": "string",
															"x-auditable": true
														}
													},
													"type": "object"
												}
											}
										}
									}
								}
							]
						}
					}
				},
				"description": "Generate Pre Shared Key (PSK) for IPsec tunnels response"
			},
			"4XX": {
				"content": {
					"application/json": {
						"schema": {
							"allOf": [
								{
									"allOf": [
										{
											"allOf": [
												{
													"properties": {
														"errors": {
															"example": [],
															"items": {
																"properties": {
																	"code": {
																		"minimum": 1000,
																		"type": "integer"
																	},
																	"message": {
																		"type": "string"
																	}
																},
																"required": [
																	"code",
																	"message"
																],
																"type": "object",
																"uniqueItems": true
															},
															"type": "array"
														},
														"messages": {
															"example": [],
															"items": {
																"properties": {
																	"code": {
																		"minimum": 1000,
																		"type": "integer"
																	},
																	"message": {
																		"type": "string"
																	}
																},
																"required": [
																	"code",
																	"message"
																],
																"type": "object",
																"uniqueItems": true
															},
															"type": "array"
														},
														"result": {
															"anyOf": [
																{
																	"type": "object"
																},
																{
																	"items": {},
																	"type": "array"
																},
																{
																	"type": "string"
																}
															]
														},
														"success": {
															"description": "Whether the API call was successful",
															"enum": [
																true
															],
															"example": true,
															"type": "boolean"
														}
													},
													"required": [
														"success",
														"errors",
														"messages",
														"result"
													],
													"type": "object"
												},
												{
													"properties": {
														"result": {
															"anyOf": [
																{
																	"nullable": true,
																	"type": "object"
																},
																{
																	"nullable": true,
																	"type": "string"
																}
															]
														}
													}
												}
											],
											"type": "object"
										},
										{
											"properties": {
												"result": {
													"properties": {
														"ipsec_tunnel_id": {
															"description": "Identifier",
															"example": "023e105f4ecef8ad9ca31a8372d0c353",
															"maxLength": 32,
															"readOnly": true,
															"type": "string"
														},
														"psk": {
															"description": "A randomly generated or provided string for use in the IPsec tunnel.",
															"example": "O3bwKSjnaoCxDoUxjcq4Rk8ZKkezQUiy",
															"type": "string"
														},
														"psk_metadata": {
															"description": "The PSK metadata that includes when the PSK was generated.",
															"properties": {
																"last_generated_on": {
																	"description": "The date and time the tunnel was last modified.",
																	"example": "2017-06-14T05:20:00Z",
																	"format": "date-time",
																	"readOnly": true,
																	"type": "string",
																	"x-auditable": true
																}
															},
															"type": "object"
														}
													}
												}
											}
										}
									]
								},
								{
									"properties": {
										"errors": {
											"allOf": [
												{
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												}
											],
											"example": [
												{
													"code": 7003,
													"message": "No route for the URI"
												}
											],
											"minLength": 1
										},
										"messages": {
											"allOf": [
												{
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												}
											],
											"example": []
										},
										"result": {
											"enum": [
												null
											],
											"nullable": true,
											"type": "object"
										},
										"success": {
											"description": "Whether the API call was successful",
											"enum": [
												false
											],
											"example": false,
											"type": "boolean"
										}
									},
									"required": [
										"success",
										"errors",
										"messages",
										"result"
									],
									"type": "object"
								}
							]
						}
					}
				},
				"description": "Generate Pre Shared Key (PSK) for IPsec tunnels response failure"
			}
		},
		"security": [
			{
				"api_email": [],
				"api_key": [],
				"api_token": []
			}
		],
		"summary": "Generate Pre Shared Key (PSK) for IPsec tunnels",
		"tags": [
			"Magic IPsec tunnels"
		],
		"x-api-token-group": [
			"Magic WAN Write",
			"Magic Transit Write"
		],
		"x-cfPlanAvailability": {
			"business": false,
			"enterprise": true,
			"free": false,
			"pro": false
		}
	},
	"PUT /accounts/{account_id}/magic/ipsec_tunnels": {
		"description": "Update multiple IPsec tunnels associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.",
		"operationId": "magic-ipsec-tunnels-update-multiple-ipsec-tunnels",
		"parameters": [
			{
				"in": "path",
				"name": "account_id",
				"required": true,
				"schema": {
					"description": "Identifier",
					"example": "023e105f4ecef8ad9ca31a8372d0c353",
					"maxLength": 32,
					"readOnly": true,
					"type": "string"
				}
			},
			{
				"description": "If true, the health check target in the request and response bodies will be presented using the new object format. Defaults to false.",
				"in": "header",
				"name": "x-magic-new-hc-target",
				"schema": {
					"type": "boolean"
				}
			}
		],
		"requestBody": {
			"content": {
				"application/json": {
					"schema": {
						"required": [
							"id"
						]
					}
				}
			},
			"required": true
		},
		"responses": {
			"200": {
				"content": {
					"application/json": {
						"schema": {
							"allOf": [
								{
									"allOf": [
										{
											"properties": {
												"errors": {
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												},
												"messages": {
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												},
												"result": {
													"anyOf": [
														{
															"type": "object"
														},
														{
															"items": {},
															"type": "array"
														},
														{
															"type": "string"
														}
													]
												},
												"success": {
													"description": "Whether the API call was successful",
													"enum": [
														true
													],
													"example": true,
													"type": "boolean"
												}
											},
											"required": [
												"success",
												"errors",
												"messages",
												"result"
											],
											"type": "object"
										},
										{
											"properties": {
												"result": {
													"anyOf": [
														{
															"nullable": true,
															"type": "object"
														},
														{
															"nullable": true,
															"type": "string"
														}
													]
												}
											}
										}
									],
									"type": "object"
								},
								{
									"properties": {
										"result": {
											"properties": {
												"modified": {
													"example": true,
													"type": "boolean"
												},
												"modified_ipsec_tunnels": {
													"items": {
														"properties": {
															"allow_null_cipher": {
																"description": "When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).",
																"example": true,
																"type": "boolean"
															},
															"automatic_return_routing": {
																"default": false,
																"description": "True if automatic stateful return routing should be enabled for a tunnel, false otherwise.",
																"example": true,
																"type": "boolean",
																"x-auditable": true
															},
															"bgp": {
																"properties": {
																	"customer_asn": {
																		"description": "ASN used on the customer end of the BGP session",
																		"format": "int32",
																		"minimum": 0,
																		"type": "integer"
																	},
																	"extra_prefixes": {
																		"description": "Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.",
																		"items": {
																			"format": "cidr",
																			"type": "string"
																		},
																		"type": "array"
																	},
																	"md5_key": {
																		"description": "MD5 key to use for session authentication.\n\nNote that *this is not a security measure*. MD5 is not a valid security mechanism, and the\nkey is not treated as a secret value. This is *only* supported for preventing\nmisconfiguration, not for defending against malicious attacks.\n\nThe MD5 key, if set, must be of non-zero length and consist only of the following types of\ncharacter:\n\n* ASCII alphanumerics: `[a-zA-Z0-9]`\n* Special characters in the set `'!@#$%^&*()+[]{}<>/.,;:_-~`= \\|`\n\nIn other words, MD5 keys may contain any printable ASCII character aside from newline (0x0A),\nquotation mark (`\"`), vertical tab (0x0B), carriage return (0x0D), tab (0x09), form feed\n(0x0C), and the question mark (`?`). Requests specifying an MD5 key with one or more of\nthese disallowed characters will be rejected.",
																		"type": "string"
																	}
																},
																"required": [
																	"customer_asn"
																],
																"type": "object"
															},
															"bgp_status": {
																"properties": {
																	"bgp_state": {
																		"type": "string"
																	},
																	"cf_speaker_ip": {
																		"format": "ipv4",
																		"type": "string"
																	},
																	"cf_speaker_port": {
																		"maximum": 65535,
																		"minimum": 1,
																		"type": "integer"
																	},
																	"customer_speaker_ip": {
																		"format": "ipv4",
																		"type": "string"
																	},
																	"customer_speaker_port": {
																		"maximum": 65535,
																		"minimum": 1,
																		"type": "integer"
																	},
																	"state": {
																		"enum": [
																			"BGP_DOWN",
																			"BGP_UP",
																			"BGP_ESTABLISHING"
																		],
																		"type": "string"
																	},
																	"tcp_established": {
																		"type": "boolean"
																	},
																	"updated_at": {
																		"format": "date-time",
																		"type": "string"
																	}
																},
																"required": [
																	"state",
																	"tcp_established",
																	"updated_at"
																],
																"type": "object"
															},
															"cloudflare_endpoint": {
																"description": "The IP address assigned to the Cloudflare side of the IPsec tunnel.",
																"example": "203.0.113.1",
																"type": "string"
															},
															"created_on": {
																"description": "The date and time the tunnel was created.",
																"example": "2017-06-14T00:00:00Z",
																"format": "date-time",
																"readOnly": true,
																"type": "string",
																"x-auditable": true
															},
															"custom_remote_identities": {
																"properties": {
																	"fqdn_id": {
																		"description": "A custom IKE ID of type FQDN that may be used to identity the IPsec tunnel. The\ngenerated IKE IDs can still be used even if this custom value is specified.\n\nMust be of the form `<custom label>.<account ID>.custom.ipsec.cloudflare.com`.\n\nThis custom ID does not need to be unique. Two IPsec tunnels may have the same custom \nfqdn_id. However, if another IPsec tunnel has the same value then the two tunnels \ncannot have the same cloudflare_endpoint.",
																		"type": "string"
																	}
																},
																"type": "object"
															},
															"customer_endpoint": {
																"description": "The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.",
																"example": "203.0.113.1",
																"type": "string"
															},
															"description": {
																"description": "An optional description forthe IPsec tunnel.",
																"example": "Tunnel for ISP X",
																"type": "string"
															},
															"health_check": {
																"allOf": [
																	{
																		"properties": {
																			"enabled": {
																				"default": true,
																				"description": "Determines whether to run healthchecks for a tunnel.",
																				"example": true,
																				"type": "boolean",
																				"x-auditable": true
																			},
																			"rate": {
																				"default": "mid",
																				"description": "How frequent the health check is run. The default value is `mid`.",
																				"enum": [
																					"low",
																					"mid",
																					"high"
																				],
																				"example": "low",
																				"type": "string",
																				"x-auditable": true
																			},
																			"target": {
																				"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.",
																				"oneOf": [
																					{
																						"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target.",
																						"properties": {
																							"effective": {
																								"description": "The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.",
																								"example": "203.0.113.1",
																								"readOnly": true,
																								"type": "string",
																								"x-auditable": true
																							},
																							"saved": {
																								"description": "The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.",
																								"example": "203.0.113.1",
																								"type": "string",
																								"x-auditable": true
																							}
																						},
																						"type": "object"
																					},
																					{
																						"type": "string"
																					}
																				]
																			},
																			"type": {
																				"default": "reply",
																				"description": "The type of healthcheck to run, reply or request. The default value is `reply`.",
																				"enum": [
																					"reply",
																					"request"
																				],
																				"example": "request",
																				"type": "string",
																				"x-auditable": true
																			}
																		},
																		"type": "object"
																	},
																	{
																		"properties": {
																			"direction": {
																				"default": "unidirectional",
																				"description": "The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.",
																				"enum": [
																					"unidirectional",
																					"bidirectional"
																				],
																				"example": "bidirectional",
																				"type": "string"
																			}
																		}
																	}
																]
															},
															"id": {
																"description": "Identifier",
																"example": "c4a7362d577a6c3019a474fd6f485821",
																"maxLength": 32,
																"readOnly": true,
																"type": "string",
																"x-auditable": true
															},
															"interface_address": {
																"description": "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.",
																"example": "192.0.2.0/31",
																"type": "string",
																"x-auditable": true
															},
															"interface_address6": {
																"description": "A 127 bit IPV6 prefix from within the virtual_subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual_subnet6. Eg if virtual_subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface_address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127",
																"example": "2606:54c1:7:0:a9fe:12d2:1:200/127",
																"type": "string",
																"x-auditable": true
															},
															"modified_on": {
																"description": "The date and time the tunnel was last modified.",
																"example": "2017-06-14T05:20:00Z",
																"format": "date-time",
																"readOnly": true,
																"type": "string",
																"x-auditable": true
															},
															"name": {
																"description": "The name of the IPsec tunnel. The name cannot share a name with other tunnels.",
																"example": "IPsec_1",
																"type": "string"
															},
															"psk_metadata": {
																"description": "The PSK metadata that includes when the PSK was generated.",
																"properties": {
																	"last_generated_on": {
																		"description": "The date and time the tunnel was last modified.",
																		"example": "2017-06-14T05:20:00Z",
																		"format": "date-time",
																		"readOnly": true,
																		"type": "string",
																		"x-auditable": true
																	}
																},
																"type": "object"
															},
															"replay_protection": {
																"default": false,
																"description": "If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.",
																"example": false,
																"type": "boolean"
															}
														},
														"required": [
															"id",
															"name",
															"cloudflare_endpoint",
															"interface_address"
														],
														"type": "object"
													},
													"type": "array"
												}
											}
										}
									}
								}
							]
						}
					}
				},
				"description": "Update multiple IPsec tunnels response"
			},
			"4XX": {
				"content": {
					"application/json": {
						"schema": {
							"allOf": [
								{
									"allOf": [
										{
											"allOf": [
												{
													"properties": {
														"errors": {
															"example": [],
															"items": {
																"properties": {
																	"code": {
																		"minimum": 1000,
																		"type": "integer"
																	},
																	"message": {
																		"type": "string"
																	}
																},
																"required": [
																	"code",
																	"message"
																],
																"type": "object",
																"uniqueItems": true
															},
															"type": "array"
														},
														"messages": {
															"example": [],
															"items": {
																"properties": {
																	"code": {
																		"minimum": 1000,
																		"type": "integer"
																	},
																	"message": {
																		"type": "string"
																	}
																},
																"required": [
																	"code",
																	"message"
																],
																"type": "object",
																"uniqueItems": true
															},
															"type": "array"
														},
														"result": {
															"anyOf": [
																{
																	"type": "object"
																},
																{
																	"items": {},
																	"type": "array"
																},
																{
																	"type": "string"
																}
															]
														},
														"success": {
															"description": "Whether the API call was successful",
															"enum": [
																true
															],
															"example": true,
															"type": "boolean"
														}
													},
													"required": [
														"success",
														"errors",
														"messages",
														"result"
													],
													"type": "object"
												},
												{
													"properties": {
														"result": {
															"anyOf": [
																{
																	"nullable": true,
																	"type": "object"
																},
																{
																	"nullable": true,
																	"type": "string"
																}
															]
														}
													}
												}
											],
											"type": "object"
										},
										{
											"properties": {
												"result": {
													"properties": {
														"modified": {
															"example": true,
															"type": "boolean"
														},
														"modified_ipsec_tunnels": {
															"items": {
																"properties": {
																	"allow_null_cipher": {
																		"description": "When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).",
																		"example": true,
																		"type": "boolean"
																	},
																	"automatic_return_routing": {
																		"default": false,
																		"description": "True if automatic stateful return routing should be enabled for a tunnel, false otherwise.",
																		"example": true,
																		"type": "boolean",
																		"x-auditable": true
																	},
																	"bgp": {
																		"properties": {
																			"customer_asn": {
																				"description": "ASN used on the customer end of the BGP session",
																				"format": "int32",
																				"minimum": 0,
																				"type": "integer"
																			},
																			"extra_prefixes": {
																				"description": "Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.",
																				"items": {
																					"format": "cidr",
																					"type": "string"
																				},
																				"type": "array"
																			},
																			"md5_key": {
																				"description": "MD5 key to use for session authentication.\n\nNote that *this is not a security measure*. MD5 is not a valid security mechanism, and the\nkey is not treated as a secret value. This is *only* supported for preventing\nmisconfiguration, not for defending against malicious attacks.\n\nThe MD5 key, if set, must be of non-zero length and consist only of the following types of\ncharacter:\n\n* ASCII alphanumerics: `[a-zA-Z0-9]`\n* Special characters in the set `'!@#$%^&*()+[]{}<>/.,;:_-~`= \\|`\n\nIn other words, MD5 keys may contain any printable ASCII character aside from newline (0x0A),\nquotation mark (`\"`), vertical tab (0x0B), carriage return (0x0D), tab (0x09), form feed\n(0x0C), and the question mark (`?`). Requests specifying an MD5 key with one or more of\nthese disallowed characters will be rejected.",
																				"type": "string"
																			}
																		},
																		"required": [
																			"customer_asn"
																		],
																		"type": "object"
																	},
																	"bgp_status": {
																		"properties": {
																			"bgp_state": {
																				"type": "string"
																			},
																			"cf_speaker_ip": {
																				"format": "ipv4",
																				"type": "string"
																			},
																			"cf_speaker_port": {
																				"maximum": 65535,
																				"minimum": 1,
																				"type": "integer"
																			},
																			"customer_speaker_ip": {
																				"format": "ipv4",
																				"type": "string"
																			},
																			"customer_speaker_port": {
																				"maximum": 65535,
																				"minimum": 1,
																				"type": "integer"
																			},
																			"state": {
																				"enum": [
																					"BGP_DOWN",
																					"BGP_UP",
																					"BGP_ESTABLISHING"
																				],
																				"type": "string"
																			},
																			"tcp_established": {
																				"type": "boolean"
																			},
																			"updated_at": {
																				"format": "date-time",
																				"type": "string"
																			}
																		},
																		"required": [
																			"state",
																			"tcp_established",
																			"updated_at"
																		],
																		"type": "object"
																	},
																	"cloudflare_endpoint": {
																		"description": "The IP address assigned to the Cloudflare side of the IPsec tunnel.",
																		"example": "203.0.113.1",
																		"type": "string"
																	},
																	"created_on": {
																		"description": "The date and time the tunnel was created.",
																		"example": "2017-06-14T00:00:00Z",
																		"format": "date-time",
																		"readOnly": true,
																		"type": "string",
																		"x-auditable": true
																	},
																	"custom_remote_identities": {
																		"properties": {
																			"fqdn_id": {
																				"description": "A custom IKE ID of type FQDN that may be used to identity the IPsec tunnel. The\ngenerated IKE IDs can still be used even if this custom value is specified.\n\nMust be of the form `<custom label>.<account ID>.custom.ipsec.cloudflare.com`.\n\nThis custom ID does not need to be unique. Two IPsec tunnels may have the same custom \nfqdn_id. However, if another IPsec tunnel has the same value then the two tunnels \ncannot have the same cloudflare_endpoint.",
																				"type": "string"
																			}
																		},
																		"type": "object"
																	},
																	"customer_endpoint": {
																		"description": "The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.",
																		"example": "203.0.113.1",
																		"type": "string"
																	},
																	"description": {
																		"description": "An optional description forthe IPsec tunnel.",
																		"example": "Tunnel for ISP X",
																		"type": "string"
																	},
																	"health_check": {
																		"allOf": [
																			{
																				"properties": {
																					"enabled": {
																						"default": true,
																						"description": "Determines whether to run healthchecks for a tunnel.",
																						"example": true,
																						"type": "boolean",
																						"x-auditable": true
																					},
																					"rate": {
																						"default": "mid",
																						"description": "How frequent the health check is run. The default value is `mid`.",
																						"enum": [
																							"low",
																							"mid",
																							"high"
																						],
																						"example": "low",
																						"type": "string",
																						"x-auditable": true
																					},
																					"target": {
																						"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.",
																						"oneOf": [
																							{
																								"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target.",
																								"properties": {
																									"effective": {
																										"description": "The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.",
																										"example": "203.0.113.1",
																										"readOnly": true,
																										"type": "string",
																										"x-auditable": true
																									},
																									"saved": {
																										"description": "The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.",
																										"example": "203.0.113.1",
																										"type": "string",
																										"x-auditable": true
																									}
																								},
																								"type": "object"
																							},
																							{
																								"type": "string"
																							}
																						]
																					},
																					"type": {
																						"default": "reply",
																						"description": "The type of healthcheck to run, reply or request. The default value is `reply`.",
																						"enum": [
																							"reply",
																							"request"
																						],
																						"example": "request",
																						"type": "string",
																						"x-auditable": true
																					}
																				},
																				"type": "object"
																			},
																			{
																				"properties": {
																					"direction": {
																						"default": "unidirectional",
																						"description": "The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.",
																						"enum": [
																							"unidirectional",
																							"bidirectional"
																						],
																						"example": "bidirectional",
																						"type": "string"
																					}
																				}
																			}
																		]
																	},
																	"id": {
																		"description": "Identifier",
																		"example": "c4a7362d577a6c3019a474fd6f485821",
																		"maxLength": 32,
																		"readOnly": true,
																		"type": "string",
																		"x-auditable": true
																	},
																	"interface_address": {
																		"description": "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.",
																		"example": "192.0.2.0/31",
																		"type": "string",
																		"x-auditable": true
																	},
																	"interface_address6": {
																		"description": "A 127 bit IPV6 prefix from within the virtual_subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual_subnet6. Eg if virtual_subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface_address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127",
																		"example": "2606:54c1:7:0:a9fe:12d2:1:200/127",
																		"type": "string",
																		"x-auditable": true
																	},
																	"modified_on": {
																		"description": "The date and time the tunnel was last modified.",
																		"example": "2017-06-14T05:20:00Z",
																		"format": "date-time",
																		"readOnly": true,
																		"type": "string",
																		"x-auditable": true
																	},
																	"name": {
																		"description": "The name of the IPsec tunnel. The name cannot share a name with other tunnels.",
																		"example": "IPsec_1",
																		"type": "string"
																	},
																	"psk_metadata": {
																		"description": "The PSK metadata that includes when the PSK was generated.",
																		"properties": {
																			"last_generated_on": {
																				"description": "The date and time the tunnel was last modified.",
																				"example": "2017-06-14T05:20:00Z",
																				"format": "date-time",
																				"readOnly": true,
																				"type": "string",
																				"x-auditable": true
																			}
																		},
																		"type": "object"
																	},
																	"replay_protection": {
																		"default": false,
																		"description": "If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.",
																		"example": false,
																		"type": "boolean"
																	}
																},
																"required": [
																	"id",
																	"name",
																	"cloudflare_endpoint",
																	"interface_address"
																],
																"type": "object"
															},
															"type": "array"
														}
													}
												}
											}
										}
									]
								},
								{
									"properties": {
										"errors": {
											"allOf": [
												{
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												}
											],
											"example": [
												{
													"code": 7003,
													"message": "No route for the URI"
												}
											],
											"minLength": 1
										},
										"messages": {
											"allOf": [
												{
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												}
											],
											"example": []
										},
										"result": {
											"enum": [
												null
											],
											"nullable": true,
											"type": "object"
										},
										"success": {
											"description": "Whether the API call was successful",
											"enum": [
												false
											],
											"example": false,
											"type": "boolean"
										}
									},
									"required": [
										"success",
										"errors",
										"messages",
										"result"
									],
									"type": "object"
								}
							]
						}
					}
				},
				"description": "Update multiple IPsec tunnels response failure"
			}
		},
		"security": [
			{
				"api_email": [],
				"api_key": [],
				"api_token": []
			}
		],
		"summary": "Update multiple IPsec tunnels",
		"tags": [
			"Magic IPsec tunnels"
		],
		"x-api-token-group": [
			"Magic WAN Write",
			"Magic Transit Write"
		],
		"x-cfPlanAvailability": {
			"business": false,
			"enterprise": true,
			"free": false,
			"pro": false
		}
	},
	"PUT /accounts/{account_id}/magic/ipsec_tunnels/{ipsec_tunnel_id}": {
		"description": "Updates a specific IPsec tunnel associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.",
		"operationId": "magic-ipsec-tunnels-update-ipsec-tunnel",
		"parameters": [
			{
				"in": "path",
				"name": "ipsec_tunnel_id",
				"required": true,
				"schema": {
					"description": "Identifier",
					"example": "023e105f4ecef8ad9ca31a8372d0c353",
					"maxLength": 32,
					"readOnly": true,
					"type": "string"
				}
			},
			{
				"in": "path",
				"name": "account_id",
				"required": true,
				"schema": {
					"description": "Identifier",
					"example": "023e105f4ecef8ad9ca31a8372d0c353",
					"maxLength": 32,
					"readOnly": true,
					"type": "string"
				}
			},
			{
				"description": "If true, the health check target in the request and response bodies will be presented using the new object format. Defaults to false.",
				"in": "header",
				"name": "x-magic-new-hc-target",
				"schema": {
					"type": "boolean"
				}
			}
		],
		"requestBody": {
			"content": {
				"application/json": {
					"schema": {
						"properties": {
							"automatic_return_routing": {
								"default": false,
								"description": "True if automatic stateful return routing should be enabled for a tunnel, false otherwise.",
								"example": true,
								"type": "boolean",
								"x-auditable": true
							},
							"bgp": {
								"properties": {
									"customer_asn": {
										"description": "ASN used on the customer end of the BGP session",
										"format": "int32",
										"minimum": 0,
										"type": "integer"
									},
									"extra_prefixes": {
										"description": "Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.",
										"items": {
											"format": "cidr",
											"type": "string"
										},
										"type": "array"
									},
									"md5_key": {
										"description": "MD5 key to use for session authentication.\n\nNote that *this is not a security measure*. MD5 is not a valid security mechanism, and the\nkey is not treated as a secret value. This is *only* supported for preventing\nmisconfiguration, not for defending against malicious attacks.\n\nThe MD5 key, if set, must be of non-zero length and consist only of the following types of\ncharacter:\n\n* ASCII alphanumerics: `[a-zA-Z0-9]`\n* Special characters in the set `'!@#$%^&*()+[]{}<>/.,;:_-~`= \\|`\n\nIn other words, MD5 keys may contain any printable ASCII character aside from newline (0x0A),\nquotation mark (`\"`), vertical tab (0x0B), carriage return (0x0D), tab (0x09), form feed\n(0x0C), and the question mark (`?`). Requests specifying an MD5 key with one or more of\nthese disallowed characters will be rejected.",
										"type": "string"
									}
								},
								"required": [
									"customer_asn"
								],
								"type": "object"
							},
							"cloudflare_endpoint": {
								"description": "The IP address assigned to the Cloudflare side of the IPsec tunnel.",
								"example": "203.0.113.1",
								"type": "string"
							},
							"customer_endpoint": {
								"description": "The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.",
								"example": "203.0.113.1",
								"type": "string"
							},
							"description": {
								"description": "An optional description forthe IPsec tunnel.",
								"example": "Tunnel for ISP X",
								"type": "string"
							},
							"health_check": {
								"allOf": [
									{
										"properties": {
											"enabled": {
												"default": true,
												"description": "Determines whether to run healthchecks for a tunnel.",
												"example": true,
												"type": "boolean",
												"x-auditable": true
											},
											"rate": {
												"default": "mid",
												"description": "How frequent the health check is run. The default value is `mid`.",
												"enum": [
													"low",
													"mid",
													"high"
												],
												"example": "low",
												"type": "string",
												"x-auditable": true
											},
											"target": {
												"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.",
												"oneOf": [
													{
														"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target.",
														"properties": {
															"effective": {
																"description": "The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.",
																"example": "203.0.113.1",
																"readOnly": true,
																"type": "string",
																"x-auditable": true
															},
															"saved": {
																"description": "The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.",
																"example": "203.0.113.1",
																"type": "string",
																"x-auditable": true
															}
														},
														"type": "object"
													},
													{
														"type": "string"
													}
												]
											},
											"type": {
												"default": "reply",
												"description": "The type of healthcheck to run, reply or request. The default value is `reply`.",
												"enum": [
													"reply",
													"request"
												],
												"example": "request",
												"type": "string",
												"x-auditable": true
											}
										},
										"type": "object"
									},
									{
										"properties": {
											"direction": {
												"default": "unidirectional",
												"description": "The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.",
												"enum": [
													"unidirectional",
													"bidirectional"
												],
												"example": "bidirectional",
												"type": "string"
											}
										}
									}
								]
							},
							"interface_address": {
								"description": "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.",
								"example": "192.0.2.0/31",
								"type": "string",
								"x-auditable": true
							},
							"interface_address6": {
								"description": "A 127 bit IPV6 prefix from within the virtual_subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual_subnet6. Eg if virtual_subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface_address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127",
								"example": "2606:54c1:7:0:a9fe:12d2:1:200/127",
								"type": "string",
								"x-auditable": true
							},
							"name": {
								"description": "The name of the IPsec tunnel. The name cannot share a name with other tunnels.",
								"example": "IPsec_1",
								"type": "string"
							},
							"psk": {
								"description": "A randomly generated or provided string for use in the IPsec tunnel.",
								"example": "O3bwKSjnaoCxDoUxjcq4Rk8ZKkezQUiy",
								"type": "string"
							},
							"replay_protection": {
								"default": false,
								"description": "If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.",
								"example": false,
								"type": "boolean"
							}
						},
						"required": [
							"name",
							"cloudflare_endpoint",
							"interface_address"
						],
						"type": "object"
					}
				}
			},
			"required": true
		},
		"responses": {
			"200": {
				"content": {
					"application/json": {
						"schema": {
							"allOf": [
								{
									"allOf": [
										{
											"properties": {
												"errors": {
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												},
												"messages": {
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												},
												"result": {
													"anyOf": [
														{
															"type": "object"
														},
														{
															"items": {},
															"type": "array"
														},
														{
															"type": "string"
														}
													]
												},
												"success": {
													"description": "Whether the API call was successful",
													"enum": [
														true
													],
													"example": true,
													"type": "boolean"
												}
											},
											"required": [
												"success",
												"errors",
												"messages",
												"result"
											],
											"type": "object"
										},
										{
											"properties": {
												"result": {
													"anyOf": [
														{
															"nullable": true,
															"type": "object"
														},
														{
															"nullable": true,
															"type": "string"
														}
													]
												}
											}
										}
									],
									"type": "object"
								},
								{
									"properties": {
										"result": {
											"properties": {
												"modified": {
													"example": true,
													"type": "boolean"
												},
												"modified_ipsec_tunnel": {
													"properties": {
														"allow_null_cipher": {
															"description": "When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).",
															"example": true,
															"type": "boolean"
														},
														"automatic_return_routing": {
															"default": false,
															"description": "True if automatic stateful return routing should be enabled for a tunnel, false otherwise.",
															"example": true,
															"type": "boolean",
															"x-auditable": true
														},
														"bgp": {
															"properties": {
																"customer_asn": {
																	"description": "ASN used on the customer end of the BGP session",
																	"format": "int32",
																	"minimum": 0,
																	"type": "integer"
																},
																"extra_prefixes": {
																	"description": "Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.",
																	"items": {
																		"format": "cidr",
																		"type": "string"
																	},
																	"type": "array"
																},
																"md5_key": {
																	"description": "MD5 key to use for session authentication.\n\nNote that *this is not a security measure*. MD5 is not a valid security mechanism, and the\nkey is not treated as a secret value. This is *only* supported for preventing\nmisconfiguration, not for defending against malicious attacks.\n\nThe MD5 key, if set, must be of non-zero length and consist only of the following types of\ncharacter:\n\n* ASCII alphanumerics: `[a-zA-Z0-9]`\n* Special characters in the set `'!@#$%^&*()+[]{}<>/.,;:_-~`= \\|`\n\nIn other words, MD5 keys may contain any printable ASCII character aside from newline (0x0A),\nquotation mark (`\"`), vertical tab (0x0B), carriage return (0x0D), tab (0x09), form feed\n(0x0C), and the question mark (`?`). Requests specifying an MD5 key with one or more of\nthese disallowed characters will be rejected.",
																	"type": "string"
																}
															},
															"required": [
																"customer_asn"
															],
															"type": "object"
														},
														"bgp_status": {
															"properties": {
																"bgp_state": {
																	"type": "string"
																},
																"cf_speaker_ip": {
																	"format": "ipv4",
																	"type": "string"
																},
																"cf_speaker_port": {
																	"maximum": 65535,
																	"minimum": 1,
																	"type": "integer"
																},
																"customer_speaker_ip": {
																	"format": "ipv4",
																	"type": "string"
																},
																"customer_speaker_port": {
																	"maximum": 65535,
																	"minimum": 1,
																	"type": "integer"
																},
																"state": {
																	"enum": [
																		"BGP_DOWN",
																		"BGP_UP",
																		"BGP_ESTABLISHING"
																	],
																	"type": "string"
																},
																"tcp_established": {
																	"type": "boolean"
																},
																"updated_at": {
																	"format": "date-time",
																	"type": "string"
																}
															},
															"required": [
																"state",
																"tcp_established",
																"updated_at"
															],
															"type": "object"
														},
														"cloudflare_endpoint": {
															"description": "The IP address assigned to the Cloudflare side of the IPsec tunnel.",
															"example": "203.0.113.1",
															"type": "string"
														},
														"created_on": {
															"description": "The date and time the tunnel was created.",
															"example": "2017-06-14T00:00:00Z",
															"format": "date-time",
															"readOnly": true,
															"type": "string",
															"x-auditable": true
														},
														"custom_remote_identities": {
															"properties": {
																"fqdn_id": {
																	"description": "A custom IKE ID of type FQDN that may be used to identity the IPsec tunnel. The\ngenerated IKE IDs can still be used even if this custom value is specified.\n\nMust be of the form `<custom label>.<account ID>.custom.ipsec.cloudflare.com`.\n\nThis custom ID does not need to be unique. Two IPsec tunnels may have the same custom \nfqdn_id. However, if another IPsec tunnel has the same value then the two tunnels \ncannot have the same cloudflare_endpoint.",
																	"type": "string"
																}
															},
															"type": "object"
														},
														"customer_endpoint": {
															"description": "The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.",
															"example": "203.0.113.1",
															"type": "string"
														},
														"description": {
															"description": "An optional description forthe IPsec tunnel.",
															"example": "Tunnel for ISP X",
															"type": "string"
														},
														"health_check": {
															"allOf": [
																{
																	"properties": {
																		"enabled": {
																			"default": true,
																			"description": "Determines whether to run healthchecks for a tunnel.",
																			"example": true,
																			"type": "boolean",
																			"x-auditable": true
																		},
																		"rate": {
																			"default": "mid",
																			"description": "How frequent the health check is run. The default value is `mid`.",
																			"enum": [
																				"low",
																				"mid",
																				"high"
																			],
																			"example": "low",
																			"type": "string",
																			"x-auditable": true
																		},
																		"target": {
																			"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.",
																			"oneOf": [
																				{
																					"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target.",
																					"properties": {
																						"effective": {
																							"description": "The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.",
																							"example": "203.0.113.1",
																							"readOnly": true,
																							"type": "string",
																							"x-auditable": true
																						},
																						"saved": {
																							"description": "The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.",
																							"example": "203.0.113.1",
																							"type": "string",
																							"x-auditable": true
																						}
																					},
																					"type": "object"
																				},
																				{
																					"type": "string"
																				}
																			]
																		},
																		"type": {
																			"default": "reply",
																			"description": "The type of healthcheck to run, reply or request. The default value is `reply`.",
																			"enum": [
																				"reply",
																				"request"
																			],
																			"example": "request",
																			"type": "string",
																			"x-auditable": true
																		}
																	},
																	"type": "object"
																},
																{
																	"properties": {
																		"direction": {
																			"default": "unidirectional",
																			"description": "The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.",
																			"enum": [
																				"unidirectional",
																				"bidirectional"
																			],
																			"example": "bidirectional",
																			"type": "string"
																		}
																	}
																}
															]
														},
														"id": {
															"description": "Identifier",
															"example": "c4a7362d577a6c3019a474fd6f485821",
															"maxLength": 32,
															"readOnly": true,
															"type": "string",
															"x-auditable": true
														},
														"interface_address": {
															"description": "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.",
															"example": "192.0.2.0/31",
															"type": "string",
															"x-auditable": true
														},
														"interface_address6": {
															"description": "A 127 bit IPV6 prefix from within the virtual_subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual_subnet6. Eg if virtual_subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface_address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127",
															"example": "2606:54c1:7:0:a9fe:12d2:1:200/127",
															"type": "string",
															"x-auditable": true
														},
														"modified_on": {
															"description": "The date and time the tunnel was last modified.",
															"example": "2017-06-14T05:20:00Z",
															"format": "date-time",
															"readOnly": true,
															"type": "string",
															"x-auditable": true
														},
														"name": {
															"description": "The name of the IPsec tunnel. The name cannot share a name with other tunnels.",
															"example": "IPsec_1",
															"type": "string"
														},
														"psk_metadata": {
															"description": "The PSK metadata that includes when the PSK was generated.",
															"properties": {
																"last_generated_on": {
																	"description": "The date and time the tunnel was last modified.",
																	"example": "2017-06-14T05:20:00Z",
																	"format": "date-time",
																	"readOnly": true,
																	"type": "string",
																	"x-auditable": true
																}
															},
															"type": "object"
														},
														"replay_protection": {
															"default": false,
															"description": "If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.",
															"example": false,
															"type": "boolean"
														}
													},
													"required": [
														"id",
														"name",
														"cloudflare_endpoint",
														"interface_address"
													],
													"type": "object"
												}
											},
											"type": "object"
										}
									}
								}
							]
						}
					}
				},
				"description": "Update IPsec Tunnel response"
			},
			"4XX": {
				"content": {
					"application/json": {
						"schema": {
							"allOf": [
								{
									"allOf": [
										{
											"allOf": [
												{
													"properties": {
														"errors": {
															"example": [],
															"items": {
																"properties": {
																	"code": {
																		"minimum": 1000,
																		"type": "integer"
																	},
																	"message": {
																		"type": "string"
																	}
																},
																"required": [
																	"code",
																	"message"
																],
																"type": "object",
																"uniqueItems": true
															},
															"type": "array"
														},
														"messages": {
															"example": [],
															"items": {
																"properties": {
																	"code": {
																		"minimum": 1000,
																		"type": "integer"
																	},
																	"message": {
																		"type": "string"
																	}
																},
																"required": [
																	"code",
																	"message"
																],
																"type": "object",
																"uniqueItems": true
															},
															"type": "array"
														},
														"result": {
															"anyOf": [
																{
																	"type": "object"
																},
																{
																	"items": {},
																	"type": "array"
																},
																{
																	"type": "string"
																}
															]
														},
														"success": {
															"description": "Whether the API call was successful",
															"enum": [
																true
															],
															"example": true,
															"type": "boolean"
														}
													},
													"required": [
														"success",
														"errors",
														"messages",
														"result"
													],
													"type": "object"
												},
												{
													"properties": {
														"result": {
															"anyOf": [
																{
																	"nullable": true,
																	"type": "object"
																},
																{
																	"nullable": true,
																	"type": "string"
																}
															]
														}
													}
												}
											],
											"type": "object"
										},
										{
											"properties": {
												"result": {
													"properties": {
														"modified": {
															"example": true,
															"type": "boolean"
														},
														"modified_ipsec_tunnel": {
															"properties": {
																"allow_null_cipher": {
																	"description": "When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).",
																	"example": true,
																	"type": "boolean"
																},
																"automatic_return_routing": {
																	"default": false,
																	"description": "True if automatic stateful return routing should be enabled for a tunnel, false otherwise.",
																	"example": true,
																	"type": "boolean",
																	"x-auditable": true
																},
																"bgp": {
																	"properties": {
																		"customer_asn": {
																			"description": "ASN used on the customer end of the BGP session",
																			"format": "int32",
																			"minimum": 0,
																			"type": "integer"
																		},
																		"extra_prefixes": {
																			"description": "Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.",
																			"items": {
																				"format": "cidr",
																				"type": "string"
																			},
																			"type": "array"
																		},
																		"md5_key": {
																			"description": "MD5 key to use for session authentication.\n\nNote that *this is not a security measure*. MD5 is not a valid security mechanism, and the\nkey is not treated as a secret value. This is *only* supported for preventing\nmisconfiguration, not for defending against malicious attacks.\n\nThe MD5 key, if set, must be of non-zero length and consist only of the following types of\ncharacter:\n\n* ASCII alphanumerics: `[a-zA-Z0-9]`\n* Special characters in the set `'!@#$%^&*()+[]{}<>/.,;:_-~`= \\|`\n\nIn other words, MD5 keys may contain any printable ASCII character aside from newline (0x0A),\nquotation mark (`\"`), vertical tab (0x0B), carriage return (0x0D), tab (0x09), form feed\n(0x0C), and the question mark (`?`). Requests specifying an MD5 key with one or more of\nthese disallowed characters will be rejected.",
																			"type": "string"
																		}
																	},
																	"required": [
																		"customer_asn"
																	],
																	"type": "object"
																},
																"bgp_status": {
																	"properties": {
																		"bgp_state": {
																			"type": "string"
																		},
																		"cf_speaker_ip": {
																			"format": "ipv4",
																			"type": "string"
																		},
																		"cf_speaker_port": {
																			"maximum": 65535,
																			"minimum": 1,
																			"type": "integer"
																		},
																		"customer_speaker_ip": {
																			"format": "ipv4",
																			"type": "string"
																		},
																		"customer_speaker_port": {
																			"maximum": 65535,
																			"minimum": 1,
																			"type": "integer"
																		},
																		"state": {
																			"enum": [
																				"BGP_DOWN",
																				"BGP_UP",
																				"BGP_ESTABLISHING"
																			],
																			"type": "string"
																		},
																		"tcp_established": {
																			"type": "boolean"
																		},
																		"updated_at": {
																			"format": "date-time",
																			"type": "string"
																		}
																	},
																	"required": [
																		"state",
																		"tcp_established",
																		"updated_at"
																	],
																	"type": "object"
																},
																"cloudflare_endpoint": {
																	"description": "The IP address assigned to the Cloudflare side of the IPsec tunnel.",
																	"example": "203.0.113.1",
																	"type": "string"
																},
																"created_on": {
																	"description": "The date and time the tunnel was created.",
																	"example": "2017-06-14T00:00:00Z",
																	"format": "date-time",
																	"readOnly": true,
																	"type": "string",
																	"x-auditable": true
																},
																"custom_remote_identities": {
																	"properties": {
																		"fqdn_id": {
																			"description": "A custom IKE ID of type FQDN that may be used to identity the IPsec tunnel. The\ngenerated IKE IDs can still be used even if this custom value is specified.\n\nMust be of the form `<custom label>.<account ID>.custom.ipsec.cloudflare.com`.\n\nThis custom ID does not need to be unique. Two IPsec tunnels may have the same custom \nfqdn_id. However, if another IPsec tunnel has the same value then the two tunnels \ncannot have the same cloudflare_endpoint.",
																			"type": "string"
																		}
																	},
																	"type": "object"
																},
																"customer_endpoint": {
																	"description": "The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.",
																	"example": "203.0.113.1",
																	"type": "string"
																},
																"description": {
																	"description": "An optional description forthe IPsec tunnel.",
																	"example": "Tunnel for ISP X",
																	"type": "string"
																},
																"health_check": {
																	"allOf": [
																		{
																			"properties": {
																				"enabled": {
																					"default": true,
																					"description": "Determines whether to run healthchecks for a tunnel.",
																					"example": true,
																					"type": "boolean",
																					"x-auditable": true
																				},
																				"rate": {
																					"default": "mid",
																					"description": "How frequent the health check is run. The default value is `mid`.",
																					"enum": [
																						"low",
																						"mid",
																						"high"
																					],
																					"example": "low",
																					"type": "string",
																					"x-auditable": true
																				},
																				"target": {
																					"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.",
																					"oneOf": [
																						{
																							"description": "The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target.",
																							"properties": {
																								"effective": {
																									"description": "The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.",
																									"example": "203.0.113.1",
																									"readOnly": true,
																									"type": "string",
																									"x-auditable": true
																								},
																								"saved": {
																									"description": "The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.",
																									"example": "203.0.113.1",
																									"type": "string",
																									"x-auditable": true
																								}
																							},
																							"type": "object"
																						},
																						{
																							"type": "string"
																						}
																					]
																				},
																				"type": {
																					"default": "reply",
																					"description": "The type of healthcheck to run, reply or request. The default value is `reply`.",
																					"enum": [
																						"reply",
																						"request"
																					],
																					"example": "request",
																					"type": "string",
																					"x-auditable": true
																				}
																			},
																			"type": "object"
																		},
																		{
																			"properties": {
																				"direction": {
																					"default": "unidirectional",
																					"description": "The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.",
																					"enum": [
																						"unidirectional",
																						"bidirectional"
																					],
																					"example": "bidirectional",
																					"type": "string"
																				}
																			}
																		}
																	]
																},
																"id": {
																	"description": "Identifier",
																	"example": "c4a7362d577a6c3019a474fd6f485821",
																	"maxLength": 32,
																	"readOnly": true,
																	"type": "string",
																	"x-auditable": true
																},
																"interface_address": {
																	"description": "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.",
																	"example": "192.0.2.0/31",
																	"type": "string",
																	"x-auditable": true
																},
																"interface_address6": {
																	"description": "A 127 bit IPV6 prefix from within the virtual_subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual_subnet6. Eg if virtual_subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface_address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127",
																	"example": "2606:54c1:7:0:a9fe:12d2:1:200/127",
																	"type": "string",
																	"x-auditable": true
																},
																"modified_on": {
																	"description": "The date and time the tunnel was last modified.",
																	"example": "2017-06-14T05:20:00Z",
																	"format": "date-time",
																	"readOnly": true,
																	"type": "string",
																	"x-auditable": true
																},
																"name": {
																	"description": "The name of the IPsec tunnel. The name cannot share a name with other tunnels.",
																	"example": "IPsec_1",
																	"type": "string"
																},
																"psk_metadata": {
																	"description": "The PSK metadata that includes when the PSK was generated.",
																	"properties": {
																		"last_generated_on": {
																			"description": "The date and time the tunnel was last modified.",
																			"example": "2017-06-14T05:20:00Z",
																			"format": "date-time",
																			"readOnly": true,
																			"type": "string",
																			"x-auditable": true
																		}
																	},
																	"type": "object"
																},
																"replay_protection": {
																	"default": false,
																	"description": "If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.",
																	"example": false,
																	"type": "boolean"
																}
															},
															"required": [
																"id",
																"name",
																"cloudflare_endpoint",
																"interface_address"
															],
															"type": "object"
														}
													},
													"type": "object"
												}
											}
										}
									]
								},
								{
									"properties": {
										"errors": {
											"allOf": [
												{
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												}
											],
											"example": [
												{
													"code": 7003,
													"message": "No route for the URI"
												}
											],
											"minLength": 1
										},
										"messages": {
											"allOf": [
												{
													"example": [],
													"items": {
														"properties": {
															"code": {
																"minimum": 1000,
																"type": "integer"
															},
															"message": {
																"type": "string"
															}
														},
														"required": [
															"code",
															"message"
														],
														"type": "object",
														"uniqueItems": true
													},
													"type": "array"
												}
											],
											"example": []
										},
										"result": {
											"enum": [
												null
											],
											"nullable": true,
											"type": "object"
										},
										"success": {
											"description": "Whether the API call was successful",
											"enum": [
												false
											],
											"example": false,
											"type": "boolean"
										}
									},
									"required": [
										"success",
										"errors",
										"messages",
										"result"
									],
									"type": "object"
								}
							]
						}
					}
				},
				"description": "Update IPsec Tunnel response failure"
			}
		},
		"security": [
			{
				"api_email": [],
				"api_key": [],
				"api_token": []
			}
		],
		"summary": "Update IPsec Tunnel",
		"tags": [
			"Magic IPsec tunnels"
		],
		"x-api-token-group": [
			"Magic WAN Write",
			"Magic Transit Write"
		],
		"x-cfPlanAvailability": {
			"business": false,
			"enterprise": true,
			"free": false,
			"pro": false
		}
	}
}